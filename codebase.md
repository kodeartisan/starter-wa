# assets/icon.png

This is a binary file of the type: Image

# package.json

```json
{ "name": "starter-wa", "displayName": "Starter wa", "version": "0.0.1", "description": "A basic Plasmo extension.", "author": "Plasmo Corp. <foss@plasmo.com>", "scripts": { "dev": "plasmo dev --no-cs-reload", "build": "plasmo build", "package": "plasmo package" }, "dependencies": { "@haverstack/axios-fetch-adapter": "^0.12.0", "@lemonsqueezy/lemonsqueezy.js": "^4.0.0", "@mantine/core": "^8.2.2", "@mantine/dates": "^8.2.2", "@mantine/dropzone": "^8.2.2", "@mantine/form": "^8.2.2", "@mantine/hooks": "^8.2.2", "@plasmohq/messaging": "0.7.1", "@plasmohq/storage": "^1.15.0", "@tabler/icons-react": "^3.34.1", "@wppconnect/wa-js": "^3.18.0", "axios": "^1.11.0", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dayjs": "^1.11.13", "dexie": "^4.0.11", "dexie-react-hooks": "^1.1.7", "emoji-picker-react": "^4.13.2", "file-saver": "^2.0.5", "html2canvas": "^1.4.1", "jquery": "^3.7.1", "jspdf": "^3.0.1", "jszip": "^3.10.1", "lodash": "^4.17.21", "mantine-datatable": "^8.2.0", "plasmo": "0.90.5", "react": "18.2.0", "react-dom": "18.2.0", "react-if": "^4.1.6", "webextension-polyfill": "^0.12.0", "xlsx": "^0.18.5", "zustand": "^5.0.7" }, "devDependencies": { "@ianvs/prettier-plugin-sort-imports": "4.1.1", "@iconify/react": "^6.0.0", "@types/chrome": "0.0.258", "@types/file-saver": "^2.0.7", "@types/jquery": "^3.5.32", "@types/lodash": "^4.17.20", "@types/node": "20.11.5", "@types/react": "18.2.48", "@types/react-dom": "18.2.18", "@types/webextension-polyfill": "^0.12.3", "postcss": "^8.5.6", "postcss-preset-mantine": "1.17.0", "postcss-simple-vars": "^7.0.1", "prettier": "3.2.4", "typescript": "5.3.3" }, "manifest": { "host_permissions": [ "https://web.whatsapp.com/*", "https://api.lemonsqueezy.com/*" ], "permissions": [] } }
```

# postcss.config.cjs

```cjs
module.exports = { plugins: { 'postcss-preset-mantine': {}, 'postcss-simple-vars': { variables: { 'mantine-breakpoint-xs': '36em', 'mantine-breakpoint-sm': '48em', 'mantine-breakpoint-md': '62em', 'mantine-breakpoint-lg': '75em', 'mantine-breakpoint-xl': '88em', }, }, }, }
```

# README.md

```md
This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo). ## Getting Started First, run the development server: \`\`\`bash pnpm dev # or npm run dev \`\`\` Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`. You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser. For further guidance, [visit our Documentation](https://docs.plasmo.com/) ## Making production build Run the following: \`\`\`bash pnpm build # or npm run build \`\`\` This should create a production bundle for your extension, ready to be zipped and published to the stores. ## Submit to the webstores The easiest way to deploy your Plasmo extension is to use the built-in [bpp](https://bpp.browser.market) GitHub action. Prior to using this action however, make sure to build your extension and upload the first version to the store to establish the basic credentials. Then, simply follow [this setup instruction](https://docs.plasmo.com/framework/workflows/submit) and you should be on your way for automated submission!
```

# src/background/index.ts

```ts
import { Action, Setting } from '@/constants' import { storage } from '@/libs/storage' import { getTabByUrl, openWa } from '@/utils/ext' import { sendToContentScript } from '@plasmohq/messaging' import browser from 'webextension-polyfill' browser.runtime.onInstalled.addListener(async (details) => { if (details.reason === 'install') { await storage.set(Setting.LICENSE_KEY, null) await storage.set(Setting.IS_FIRST_TIME, true) await storage.set(Setting.NEED_TO_OPEN, true) await storage.set(Setting.BLUR_PROFILE_PICTURES, false) await storage.set(Setting.BLUR_MESSAGES, false) await storage.set(Setting.BLUR_USER_GROUP_NAMES, false) await storage.set(Setting.BLUR_RECENT_MESSAGES, false) await openWa() } }) browser.action.onClicked.addListener(async () => { const waTab = await getTabByUrl('https://web.whatsapp.com/') if (waTab?.active) { sendToContentScript({ name: Action.Window.SHOW_MODAL_MAIN, }) return } await storage.set(Setting.NEED_TO_OPEN, true) await openWa() })
```

# src/background/messages/http.ts

```ts
import http from '@/libs/http' import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { url, method, data, config } = req.body const httpInstance = { POST: () => { return http.post(url, data, config) }, GET: () => { return http.get(url, config) }, } const result = await httpInstance[method]?.() return res.send(result.data) } export default handler
```

# src/background/messages/landing-page.ts

```ts
import type { PlasmoMessaging } from '@plasmohq/messaging' import browser from 'webextension-polyfill' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const url = browser.runtime.getURL('tabs/landing-page.html') await browser.tabs.create({ url }) return res.send({}) } export default handler
```

# src/background/messages/lemonsqueezy.ts

```ts
import lemonSqueezy from '@/libs/ls' import type { PlasmoMessaging } from '@plasmohq/messaging' import pkg from '../../../package.json' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body try { let response switch (action) { case 'validateLicense': response = await lemonSqueezy.validateLicense(body.licenseKey) break case 'activateLicense': response = await lemonSqueezy.activateLicense(body.licenseKey, pkg.name) break case 'deactivateLicense': response = await lemonSqueezy.deactivateLicense( body.licenseKey, body.instanceId, ) break case 'getCustomer': response = await lemonSqueezy.getCustomer(body.customerId) break default: return res.send({ error: 'Invalid Lemon Squeezy action' }) } res.send(response) } catch (error) { // Tangani error yang mungkin dilempar oleh SDK Lemon Squeezy res.send({ error: true, message: error.message || 'An unknown error occurred.', }) } } export default handler
```

# src/components/AppMenu.module.css

```css
.tab { &:hover, &[data-active] { background-color: var(--mantine-primary-color-filled-hover); } }
```

# src/components/AppMenu.tsx

```tsx
import { Action, Page, Setting } from '@/constants' import PageChatBackup from '@/features/tools/backup-chat/PageChatBackup' import useLicense from '@/hooks/useLicense' import useRuntimeMessage from '@/hooks/useRuntimeMessage' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Box, Stack, Tabs, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' import classes from './AppMenu.module.css' import Modal from './Modal/Modal' import ModalActivation from './Modal/ModalActivation' import ModalFaq from './Modal/ModalFaq' import ModalProfile from './Modal/ModalProfile' const AppMenu: React.FC = () => { const { setIsReady, setActiveChat } = useAppStore() const license = useLicense() const [showModalMain, modalMain] = useDisclosure(true) const [showModalUpgrade, modalUpgrade] = useDisclosure(false) const [showModalActivation, modalActivation] = useDisclosure(false) const [showModalFaq, modalFaq] = useDisclosure(false) const [showModalProfile, modalProfile] = useDisclosure(false) const [needToOpen, setNeedToOpen] = useStorage(Setting.NEED_TO_OPEN, false) const [activeTab, setActiveTab] = useState<string | null>(Page.CHAT_BACKUP) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.ACTIVE_CHAT: setActiveChat(body) break case Action.Window.GO_TO_PAGE: setActiveTab(body) break case Action.Window.SHOW_MODAL_UPGRADE: modalUpgrade.toggle() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break case Action.Window.SHOW_MODAL_FAQ: modalFaq.toggle() break case Action.Window.SHOW_MODAL_PROFILE: modalProfile.toggle() break default: break } }) useRuntimeMessage((message, sender, sendResponse) => { switch (message.name) { case Action.Window.SHOW_MODAL_MAIN: modalMain.toggle() sendResponse() break default: break } // Return true to keep the message channel open for async responses return true }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { if (needToOpen) { modalMain.open() setNeedToOpen(false).then().catch(console.error) } }, [needToOpen]) const handleChangeTab = (value: string | null) => { if (Page.UPGRADE === value) { modalUpgrade.toggle() return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } if (Page.FAQ === value) { modalFaq.toggle() return } if (Page.PROFILE === value) { modalProfile.toggle() return } setActiveTab(value) } const renderTabList = () => { return ( <Tabs.List style={{ gap: 10, background: 'var(--mantine-primary-color-filled)', }} > <Stack justify="space-between" gap={0} style={{ height: '100%' }}> <Box> <Tabs.Tab value={Page.CHAT_BACKUP} className={classes.tab}> <Tooltip label="Backup" position="left"> <Icon icon="tabler:database-export" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> </Box> <Box> <Tabs.Tab value={Page.FAQ} className={classes.tab}> <Tooltip label="Faqs"> <Icon icon="tabler:world-question" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.UPGRADE} className={classes.tab}> <Tooltip label="Upgrade"> <Icon icon="tabler:crown" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab}> <Tooltip label="Activate"> <Icon icon="tabler:key" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PROFILE} className={classes.tab}> <Tooltip label="Profile"> <Icon icon="tabler:user-square-rounded" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> </Stack> </Tabs.List> ) } const renderTabPanel = () => { return ( <> <Tabs.Panel value={Page.CHAT_BACKUP}> <PageChatBackup /> </Tabs.Panel> </> ) } return ( <> <Modal opened={showModalMain} onClose={modalMain.close} p={0}> <Tabs value={activeTab} onChange={handleChangeTab} variant="pills" orientation="vertical" radius={0} keepMounted={false} > {renderTabList()} {renderTabPanel()} </Tabs> </Modal> <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <ModalFaq opened={showModalFaq} onClose={modalFaq.close} /> <ModalProfile opened={showModalProfile} onClose={modalProfile.close} /> </> ) } export default AppMenu
```

# src/components/Layout/LayoutPage.module.css

```css
.header { border-bottom: 1px solid var(--mantine-color-gray-3); } .footer { border-top: 2px solid var(--mantine-color-gray-3); }
```

# src/components/Layout/LayoutPage.tsx

```tsx
// src/components/Layout/LayoutPage.tsx import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import { useAppStore } from '@/stores/app' import env from '@/utils/env' import { goToLandingPage, showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Loader, Menu, ScrollArea, Stack, Text, Title, type MantineSpacing, type StyleProp, } from '@mantine/core' import icon from 'data-base64:../../../assets/icon.png' import { When } from 'react-if' import packageJson from '../../../package.json' import classes from './LayoutPage.module.css' interface Props { width?: StyleProp<React.CSSProperties['width']> | null height?: StyleProp<React.CSSProperties['height']> | null p?: StyleProp<MantineSpacing> title?: string | null children: React.ReactNode } const LayoutPage: React.FC<Props> = ({ width = 900, height = 620, p = 'xl', children, title = null, }: Props) => { const wa = useWa() const license = useLicense() const renderBody = () => { return ( <Stack p={'xl'} w={width}> {children} </Stack> ) } return ( <> <Stack w={width} gap={0}> <Group justify="space-between" px={'lg'} py={'xs'} className={classes.header} > <Group gap={6}> <img width={32} height={32} src={icon} style={{ borderRadius: 10, }} /> <Title order={4} ml={2}> {title ? title : packageJson.displayName} </Title> <When condition={license.isPro() && env.isProduction()}> <Button radius={'lg'} size="compact-sm" variant="outline" px={'sm'} > <Text fw={500}>Pro</Text> </Button> </When> </Group> {/* MODIFIED: Changed button text to be more benefit-focused. */} <When condition={license.isFree()}> <Button variant="filled" color="yellow" size="xs" radius="md" leftSection={<Icon icon="tabler:crown" fontSize={16} />} onClick={goToLandingPage} > Go Pro </Button> </When> </Group> {wa.isReady ? ( <ScrollArea h={height}>{renderBody()}</ScrollArea> ) : ( <Center h={height}> <Loader /> </Center> )} </Stack> </> ) } export default LayoutPage
```

# src/components/Modal/Modal.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Card, Paper, type MantineSpacing, type StyleProp, } from '@mantine/core' import React, { type CSSProperties } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void height?: string | number width?: string | number style?: CSSProperties withCloseButton?: boolean | false h?: StyleProp<React.CSSProperties['height']> w?: StyleProp<React.CSSProperties['width']> p?: StyleProp<MantineSpacing> children: React.ReactNode } const Modal: React.FC<Props> = ({ opened, onClose, style = {}, withCloseButton = false, p = 'lg', h, w, children, ...rest }: Props) => { if (!opened) return null return ( <> <div style={{ position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, zIndex: 399, width: '100%', height: '100%', backgroundColor: 'black', opacity: '0.15', }} onClick={onClose} ></div> <Box style={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 1050, ...style, }} {...rest} > <Card shadow={'xs'} p={p} w={w} h={h} radius={'md'}> <When condition={withCloseButton}> <ActionIcon onClick={onClose} color="red" variant="transparent" style={{ position: 'absolute', right: 3, top: 1, }} > <Icon icon="tabler:x" fontSize={16} /> </ActionIcon> <Box mb={'md'} /> </When> {children} </Card> </Box> </> ) } export default Modal
```

# src/components/Modal/ModalActivation.tsx

```tsx
// src/components/Modal/ModalActivation.tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, rem, Stack, Text, TextInput, ThemeIcon, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalActivation: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const form = useForm({ initialValues: defaultValues, validate: { license: (value) => _.isEmpty(value) ? 'A license key is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) const handleOnClose = () => { form.reset() onClose() } const handleSubmit = async () => { const { hasErrors } = form.validate() if (hasErrors) { return } setLoading(true) form.clearErrors() try { const response = await license.activate(form.values.license) if (response.data.error) { form.setFieldError('license', response.data.error.replace(/_/g, ' ')) setLoading(false) return } if (response.data.meta.store_id.toString() !== getStoreId()) { form.setFieldError( 'license', 'This license key is not valid for this product.', ) setLoading(false) return } toast.success('Successfully activated! ðŸŽ‰') handleOnClose() } catch (err) { console.error('Activation error:', err) form.setFieldError( 'license', 'An unexpected error occurred. Please try again.', ) } finally { setLoading(false) } } return ( <Modal opened={opened} onClose={handleOnClose} w={500} p="xl" withCloseButton > <Stack gap="lg"> <Stack align="center" gap="xs"> <ThemeIcon color="teal" size={rem(60)} radius="xl"> <Icon icon="tabler:key" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> {' '} License Activation{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Enter your license key below to unlock all Pro features.{' '} </Text> </Stack> <Stack> <TextInput label="License Key" placeholder="xxxx-xxxx-xxxx-xxxx" required leftSection={<Icon icon="tabler:key" fontSize={18} />} {...form.getInputProps('license')} /> {/* MODIFIED: Replaced text with more reassuring microcopy. */} <Text size="xs" c="dimmed"> {' '} Your license key validates your purchase, ensuring you receive lifetime access and all future updates.{' '} </Text> </Stack> <Button loading={loading} onClick={handleSubmit} fullWidth size="md" mt="md" leftSection={<Icon icon="tabler:circle-check" fontSize={20} />} > {' '} Activate License{' '} </Button> </Stack> </Modal> ) } export default ModalActivation
```

# src/components/Modal/ModalFaq.tsx

```tsx
// src/components/Modal/ModalFaq.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Accordion, Anchor, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const faqData = [ { icon: 'tabler:rocket', question: 'What are the main benefits of upgrading to Pro?', answer: "With Pro, you get **Total Protection** by backing up all messages and media without limitsâ€”no more risk of losing important data or precious memories. You'll unlock **Exclusive Features** like custom date ranges, Excel/CSV exports, and upcoming premium tools. Plus, you receive **Priority Support**, ensuring our team assists you first whenever you need help.", }, { icon: 'tabler:key', question: 'Where can I find my license key?', answer: 'You will receive an email from Lemon Squeezy after making a purchase. This email usually contains your purchase details and your license key.', }, { icon: 'tabler:shield-lock', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our priority. This extension does not collect, store, or share any personal data from your WhatsApp account. All processes occur locally on your device.', }, { icon: 'tabler:mail-question', question: 'How can I get more help and support?', answer: 'If you have other questions or need assistance, please feel free to email us at extdotninja@gmail.com. Our team will be happy to help you.', }, ] const ModalFaq: React.FC<Props> = ({ opened, onClose }: Props) => { const handleOnClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleOnClose} withCloseButton w={700}> <Stack> <Stack align="center" gap={4} mb={'xl'}> <Icon icon="tabler:world-question" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> Frequently Asked Questions </Title> </Stack> {/* Accordion */} <Accordion variant="separated" radius="md"> {faqData.map((item) => ( <Accordion.Item key={item.question} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > {/* MODIFIED: Changed the answer to markdown-like bolding for emphasis. */} <Text fw={500} dangerouslySetInnerHTML={{ __html: item.question.replace( /\*\*(.*?)\*\*/g, '<b>$1</b>', ), }} ></Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} ></Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> {/* Contact Support */} <Paper withBorder p="md" shadow="none" radius="md" mt="xl"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still have questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us via email. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Paper> </Stack> </Modal> ) } export default ModalFaq
```

# src/components/Modal/ModalProfile.tsx

```tsx
// src/features/profile/PageProfile.tsx import { Setting } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import { showModalActivation, showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' import packageJson from '../../../package.json' import Modal from './Modal' interface Props { opened: boolean onClose: () => void } const ModalProfile: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const { profile, license: licenseData } = useAppStore() const [licenseKey] = useStorage(Setting.LICENSE_KEY) const handleDeactivate = async () => { if ( confirm( 'Are you sure you want to deactivate your license on this device?', ) ) { await license.deactivate() } } const handleUpgrade = () => { showModalUpgrade() } const handleActivate = () => { showModalActivation() } const maskLicenseKey = (key: string | undefined | null) => { if (!key) return 'N/A' const keyParts = key.split('-') if (keyParts.length > 1) { return `****-****-****-${keyParts[keyParts.length - 1]}` } return '****' + key.slice(-4) } const InfoItem = ({ icon, label, value, }: { icon: string label: string value: React.ReactNode }) => ( <Group wrap="nowrap" gap="lg"> <ThemeIcon variant="light" size={36} radius="md"> <Icon icon={icon} fontSize={20} /> </ThemeIcon> <div> <Text size="xs" c="dimmed"> {label} </Text> <Text size="sm" fw={500}> {value || '-'} </Text> </div> </Group> ) return ( <Modal opened={opened} onClose={onClose} withCloseButton w={700}> <Stack> {/* Account Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Title order={5}>Account Details</Title> <Divider /> <InfoItem icon="tabler:info-circle" label="App Version" value={packageJson.version} /> </Stack> </Card> {/* License Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>License Status</Title> <Badge color={license.isPro() ? 'teal' : 'gray'} size="lg" variant="filled" > {license.isPro() ? 'Pro' : 'Free'} </Badge> </Group> <Divider /> <When condition={license.isPro()}> <Stack my="xs" gap="sm"> <InfoItem icon="tabler:user" label="Licensed To" value={licenseData?.meta.customer_name} /> <InfoItem icon="tabler:mail" label="Email" value={licenseData?.meta.customer_email} /> <InfoItem icon="tabler:key" label="License Key" value={maskLicenseKey(licenseKey)} /> <InfoItem icon="tabler:calendar-event" label="Expires On" value={ licenseData?.license_key.expires_at ? dayjs(licenseData.license_key.expires_at).format( 'DD MMMM YYYY', ) : 'Lifetime' } /> </Stack> </When> <Text size="sm" c="dimmed"> {license.isPro() ? 'Thank you for being a Pro user! You have access to all features.' : 'Upgrade to Pro to unlock all features.'} </Text> <Group justify="flex-end" mt="md"> <When condition={license.isFree()}> <Button onClick={handleUpgrade} color="teal" leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Pro </Button> <Button onClick={handleActivate} variant="outline" leftSection={<Icon icon="tabler:key" fontSize={18} />} > Activate License </Button> </When> <When condition={license.isPro()}> <Button onClick={license.goToMyOrders} variant="outline" leftSection={<Icon icon="tabler:credit-card" fontSize={18} />} > Manage Subscription </Button> <Button onClick={handleDeactivate} color="red" variant="light" leftSection={<Icon icon="tabler:key-off" fontSize={18} />} > Deactivate License </Button> </When> </Group> </Stack> </Card> <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>Data Privacy Guarantee</Title> <ThemeIcon variant="light" color="teal"> <Icon icon="tabler:shield-check" fontSize={20} /> </ThemeIcon> </Group> <Divider /> <Text size="sm" c="dimmed"> All your data is stored only on your computer and is never sent to our servers. You have 100% control over your data. </Text> </Stack> </Card> </Stack> </Modal> ) } export default ModalProfile
```

# src/components/Toast/Toast.module.css

```css
@keyframes fadeIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .toast { animation: fadeIn 0.3s ease-out forwards; }
```

# src/components/Toast/Toast.tsx

```tsx
import { type Toast } from '@/stores/toast' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Text, ThemeIcon } from '@mantine/core' import { useEffect } from 'react' import classes from './Toast.module.css' interface ToastProps extends Toast { onClose: () => void } const ToastComponent: React.FC<ToastProps> = ({ id, type, title, message, duration = 2000, onClose, }) => { useEffect(() => { const timer = setTimeout(() => { onClose() }, duration) return () => clearTimeout(timer) }, [id, duration, onClose]) const toastConfig = { success: { icon: 'tabler:check', color: 'teal' }, error: { icon: 'tabler:x', color: 'red' }, info: { icon: 'tabler:info-circle', color: 'blue' }, // ADDED: Configuration for the new 'warning' type. warning: { icon: 'tabler:alert-triangle', color: 'orange' }, } const { icon, color } = toastConfig[type] return ( <Paper shadow="lg" p="sm" radius="md" withBorder className={classes.toast} style={{ minWidth: 350, maxWidth: 400 }} > <Group align="flex-start" wrap="nowrap"> <ThemeIcon color={color} size={36} radius="xl" mt={4}> <Icon icon={icon} fontSize={22} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Text fw={600} size="md"> {title} </Text> <Text size="sm" c="dimmed"> {message} </Text> </Stack> <ActionIcon variant="transparent" color="gray" onClick={onClose}> <Icon icon="tabler:x" /> </ActionIcon> </Group> </Paper> ) } export default ToastComponent
```

# src/components/Toast/ToastProvider.tsx

```tsx
import { useToastStore } from '@/stores/toast' import { Box } from '@mantine/core' import React from 'react' import ToastComponent from './Toast' const ToastProvider: React.FC = () => { const { toasts, removeToast } = useToastStore() return ( <Box style={{ position: 'fixed', top: 20, right: 20, zIndex: 2000, display: 'flex', flexDirection: 'column', gap: '10px', }} > {toasts.map((toast) => ( <ToastComponent key={toast.id} id={toast.id} type={toast.type} title={toast.title} message={toast.message} duration={toast.duration} onClose={() => removeToast(toast.id)} /> ))} </Box> ) } export default ToastProvider
```

# src/config/plans.ts

```ts
// src/config/plans.ts // Define a more structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // Centralized list of features for easy management and comparison export const features: PlanFeature[] = [ { feature: 'Backup Message Limit', free: 'First 10 per chat', pro: true, // Using 'true' represents "Unlimited" or "Included" }, { feature: 'Backup Media (Images, Videos, Docs)', free: false, // Using 'false' represents "Not Included" pro: true, }, { feature: 'Advanced Date Range Filtering', free: 'Last 7 Days Only', pro: true, }, { feature: 'Keyword Filtering', free: true, pro: true, }, { feature: 'Export to HTML, TXT, JSON', free: true, pro: true, }, { feature: 'Export to PDF, CSV, Excel (XLSX)', free: false, pro: true, }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, { feature: 'Future Pro Updates', free: false, pro: true, }, { feature: 'Pricing Model', free: 'Completely Free', pro: 'One-Time Payment', }, ] // Simplified plan definitions const plans = [ { name: 'Free', description: 'For starters and hobbyists.', price: 'Free', isFree: true, placeholderPrice: null, link: '#', // This feature list is for the pricing card display features: [ 'Backup first 10 messages per chat', 'Basic export formats (HTML, TXT)', 'Standard support', ], }, { name: 'Lifetime', description: 'Pay once, access forever.', placeholderPrice: '$59', price: '$39', isFree: false, link: 'https://extdotninja.lemonsqueezy.com/buy/554f3fc2-a924-496d-9b4e-57e21e55a59a?media=0&logo=0&desc=0&discount=0', // This feature list is for the pricing card display features: [ 'Unlimited chat & media backups', 'All export formats (PDF, CSV, Excel)', 'Priority customer support', 'All future Pro updates', 'No subscriptions. Ever.', ], }, ] export default plans
```

# src/constants/action.ts

```ts
export const App = { HTTP: 'App.HTPP', AI: 'App.AI', } export const Blocklist = { ALL: 'Blocklist.ALL', BLOCK_CONTACT: 'Blocklist.BLOCK_CONTACT', IS_BLOCKED: 'Blocklist.IS_BLOCKED', UNBLOCK_CONTACT: 'Blocklist.UNBLOCK_CONTACT', } export const Cart = { ADD: 'Cart.ADD', CLEAR: 'Cart.CLEAR', GET: 'Cart.GET', GET_THUMB_FROM_CART: 'Cart.GET_THUMB_FROM_CART', REMOVE: 'Cart.REMOVE', SUBMIT: 'Cart.SUBMIT', UPDATE: 'Cart.UPDATE', } export const Catalog = { ADD_PRODUCT_IMAGE: 'Catalog.ADD_PRODUCT_IMAGE', CHANGE_PRODUCT_IMAGE: 'Catalog.CHANGE_PRODUCT_IMAGE', CREATE_COLLECTION: 'Catalog.CREATE_COLLECTION', CREATE_PRODUCT: 'Catalog.CREATE_PRODUCT', DELETE_COLLECTION: 'Catalog.DELETE_COLLECTION', DELETE_PRODUCT: 'Catalog.DELETE_PRODUCT', EDIT_COLLECTION: 'Catalog.EDIT_COLLECTION', EDIT_PRODUCT: 'Catalog.EDIT_PRODUCT', GET_COLLECTIONS: 'Catalog.GET_COLLECTIONS', GET_MY_CATALOG: 'Catalog.GET_MY_CATALOG', GET_PRODUCT_BY_ID: 'Catalog.GET_PRODUCT_BY_ID', GET_PRODUCTS: 'Catalog.GET_PRODUCTS', REMOVE_PRODUCT_IMAGE: 'Catalog.REMOVE_PRODUCT_IMAGE', SET_PRODUCT_VISIBILITY: 'Catalog.SET_PRODUCT_VISIBILITY', UPDAGE_CART_ENABLED: 'Catalog.UPDAGE_CART_ENABLED', } export const Community = { ADD_SUB_GROUPS: 'Community.ADD_SUB_GROUPS', } export const Chat = { ARCHIVE: 'Chat.ARCHIVE', CAN_MARK_PLAYED: 'Chat.CAN_MARK_PLAYED', CAN_MUTE: 'Chat.CAN_MUTE', CAN_REPLY: 'Chat.CAN_REPLY', CLEAR: 'Chat.CLEAR', CLOSE_CHAT: 'Chat.CLOSE_CHAT', DELETE: 'Chat.DELETE', DELETE_MESSAGE: 'Chat.DELETE_MESSAGE', DOWNLOAD_MEDIA: 'Chat.DOWNLOAD_MEDIA', // ++ ADDED FIND: 'Chat.FIND', FORWARD_MESSAGE: 'Chat.FORWARD_MESSAGE', GET: 'Chat.GET', GET_ACTIVE_CHAT: 'Chat.GET_ACTIVE_CHAT', GET_LAST_SEEN: 'Chat.GET_LAST_SEEN', GET_MESSAGE_ACK: 'Chat.GET_MESSAGE_ACK', GET_MESSAGES: 'Chat.GET_MESSAGES', GET_NOTES: 'Chat.GET_NOTES', GET_PLATFORM_MESSAGE: 'Chat.GET_PLATFORM_MESSAGE', MARK_IS_COMPOSING: 'Chat.MARK_IS_COMPOSING', MARK_IS_PAUSED: 'Chat.MARK_IS_PAUSED', MARK_IS_READ: 'Chat.MARK_IS_READ', MARK_IS_RECORDING: 'Chat.MARK_IS_RECORDING', MARK_IS_UNREAD: 'Chat.MARK_IS_UNREAD', MARK_PLAYED: 'Chat.MARK_PLAYED', MUTE: 'Chat.MUTE', OPEN_CHAT_AT: 'Chat.OPEN_CHAT_AT', OPEN_CHAT_BOTTOM: 'Chat.OPEN_CHAT_BOTTOM', OPEN_CHAT_FROM_UNREAD: 'Chat.OPEN_CHAT_FROM_UNREAD', PIN_MSG: 'Chat.PIN_MSG', LIST: 'Chat.LIST', SET_CHAT_LIST: 'Chat.SET_CHAT_LIST', SET_INPUT_TEXT: 'Chat.SET_INPUT_TEXT', SET_NOTES: 'Chat.SET_NOTES', } export const Contact = { GET: 'Contact.GET', GET_BUSINESS_PROFILE: 'Contact.GET_BUSINESS_PROFILE', GET_COMMON_GROUPS: 'Contact.GET_COMMON_GROUPS', GET_PROFILE_PICTURE_URL: 'Contact.GET_PROFILE_PICTURE_URL', GET_STATUS: 'Contact.GET_STATUS', LIST: 'Contact.LIST', LIST_CONTACT_BY_COUNTRY: 'Contact.LIST_CONTACT_BY_COUNTRY', IS_EXIST: 'Contact.IS_EXIST', REMOVE: 'Contact.REMOVE', } export const Conn = { GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER: 'Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER', GET_AUTH_CODE: 'Conn.GET_AUTH_CODE', GET_PROFILE: 'Conn.GET_PROFILE', GET_MY_USER_ID: 'Conn.GET_MY_USER_ID', } export const Group = { ADD_PARTICIPANTS: 'Group.ADD_PARTICIPANTS', APPROVE: 'Group.APPROVE', LIST: 'Group.LIST', CAN_ADD: 'Group.CAN_ADD', CAN_DEMOTE: 'Group.CAN_DEMOTE', CAN_PROMOTE: 'Group.CAN_PROMOTE', CAN_REMOVE: 'Group.CAN_REMOVE', CREATE: 'Group.CREATE', DEMOTE_PARTICIPANTS: 'Group.DEMOTE_PARTICIPANTS', GET_GROUP_INFO_FROM_INVITE_CODE: 'Group.GET_GROUP_INFO_FROM_INVITE_CODE', GET_GROUP_SIZE_LIMIT: 'Group.GET_GROUP_SIZE_LIMIT', GET_INVITE_LINK: 'Group.GET_INVITE_LINK', GET_MEMBERSHIP_REQUESTS: 'Group.GET_MEMBERSHIP_REQUESTS', GET_PARTICIPANTS: 'Group.GET_PARTICIPANTS', IAM_ADMIN: 'Group.IAM_ADMIN', IAM_MEMBER: 'Group.IAM_MEMBER', IAM_RESTRICTED_MEMBER: 'Group.IAM_RESTRICTED_MEMBER', IAM_SUPER_ADMIN: 'Group.IAM_SUPER_ADMIN', JOIN: 'Group.JOIN', LEAVE: 'Group.LEAVE', PROMOTE_PARTICIPANTS: 'Group.PROMOTE_PARTICIPANTS', REJECT: 'Group.REJECT', REMOVE_ICON: 'Group.REMOVE_ICON', REMOVE_PARTICIPANTS: 'Group.REMOVE_PARTICIPANTS', REVOKE_INVITE_CODE: 'Group.REVOKE_INVITE_CODE', SET_DESCRIPTION: 'Group.SET_DESCRIPTION', SET_ICON: 'Group.SET_ICON', SET_PROPERTY: 'Group.SET_PROPERTY', SET_SUBJECT: 'Group.SET_SUBJECT', } export const Newsletter = { CREATE: 'Newsletter.CREATE', DESTROY: 'Newsletter.DESTROY', EDIT: 'Newsletter.EDIT', GET_SUBSCRIBERS: 'Newsletter.GET_SUBSCRIBERS', MUTE: 'Newsletter.MUTE', } export const Send = { TEXT: 'Send.TEXT', IMAGE: 'Send.IMAGE', LOCATION: 'Send.LOCATION', DOCUMENT: 'Send.DOCUMENT', FILE: 'Send.FILE', POLL: 'Send.POLL', VCARD: 'Send.VCARD', } export const Status = { GET: 'Status.GET', GET_MY_STATUS: 'Status.GET_MY_STATUS', REMOVE: 'Status.REMOVE', SEND_IMAGE_STATUS: 'Status.SEND_IMAGE_STATUS', SEND_READ_STATUS: 'Status.SEND_READ_STATUS', SEND_TEXT_STATUS: 'Status.SEND_TEXT_STATUS', SEND_VIDEO_STATUS: 'Status.SEND_VIDEO_STATUS', UPDATE_PARTICIPANTS: 'Status.UPDATE_PARTICIPANTS', } export const Profile = { EDIT_BUSINESS_PROFILE: 'Profile.EDIT_BUSINESS_PROFILE', GET_MY_PROFILE_NAME: 'Profile.GET_MY_PROFILE_NAME', GET_MY_PROFILE_PICTURE: 'Profile.GET_MY_PROFILE_PICTURE', GET_MY_STATUS: 'Profile.GET_MY_STATUS', IS_BUSINESS: 'Profile.IS_BUSINESS', REMOVE_MY_PROFILE_PICTURE: 'Profile.REMOVE_MY_PROFILE_PICTURE', SET_MY_PROFILE_NAME: 'Profile.SET_MY_PROFILE_NAME', SET_MY_PROFILE_PICTURE: 'Profile.SET_MY_PROFILE_PICTURE', SET_MY_STATUS: 'Profile.SET_MY_STATUS', } export const AI = { REWRITE_MESSAGE: 'AI.REWRITE_MESSAGE', } export const Window = { READY: 'Window.READY', ACTIVE_CHAT: 'Window.ACTIVE_CHAT', GO_TO_PAGE: 'Window.GO_TO_PAGE', CLOSE_PAGE: 'Window.CLOSE_PAGE', SHOW_MODAL_MAIN: 'Window.SHOW_MODAL_MAIN', SHOW_MODAL_UPGRADE: 'Window.SHOW_MODAL_UPGRADE', SHOW_MODAL_ACTIVATION: 'Window.SHOW_MODAL_ACTIVATION', SHOW_MODAL_PROFILE: 'Window.SHOW_MODAL_PROFILE', SHOW_MODAL_FAQ: 'Window.SHOW_MODAL_FAQ', SEND_BROADCAST: 'Window.SEND_BROADCAST', }
```

# src/constants/index.ts

```ts
// src/constants/index.ts export * as Action from './action' export * as Setting from './setting' export const Status = { SUCCESS: 'SUCCESS', IDLE: 'IDLE', PENDING: 'PENDING', FAILED: 'FAILED', RUNNING: 'RUNNING', SCHEDULER: 'SCHEDULER', CANCELLED: 'CANCELLED', PAUSED: 'PAUSED', DRAFT: 'DRAFT', POSTED: 'POSTED', } export const Page = { HOME: 'Page.HOME', BROADCAST: 'Page.BROADCAST', TOOLS: 'Page.TOOLS', NUMBER_VALIDATOR: 'Page.NUMBER_VALIDATOR', DIRECT_CHAT: 'Page.DIRECT_CHAT', PRIVACY: 'Page.PRIVACY', EXPORT: 'Page.EXPORT', FAQ: 'Page.FAQ', UPGRADE: 'Page.UPGRADE', ACTIVATE: 'Page.ACTIVATE', PROFILE: 'Page.PROFILE', QUICK_REPLY: 'Page.QUICK_REPLY', WA_ME_GENERATOR: 'Page.WA_ME_GENERATOR', LABEL: 'Page.LABEL', GROUP_LINK_GENERATOR: 'Page.GROUP_LINK_GENERATOR', CHAT_BACKUP: 'Page.CHAT_BACKUP', // ++ ADDED } export const Account = { BUSINESS: 'BUSINESS', PERSONAL: 'PERSONAL', } export const Message = { TEXT: 'TEXT', MEDIA: 'MEDIA', IMAGE: 'IMAGE', VIDEO: 'VIDEO', AUDIO: 'AUDIO', FILE: 'FILE', LOCATION: 'LOCATION', VCARD: 'VCARD', BUTTON: 'BUTTON', LIST: 'LIST', POLL: 'POLL', } export const Media = { BROADCAST: 'BROADCAST', BROADCAST_TEMPLATE: 'BROADCAST_TEMPLATE', STATUS_CONTENT: 'STATUS_CONTENT', QUICK_REPLY: 'QUICK_REPLY', } export const ContactType = { ALL: 'CONTACT_TYPE_ALL', SAVED_CONTACTS: 'CONTACT_TYPE_SAVED_CONTACTS', UNSAVED_CONTACTS: 'CONTACT_TYPE_UNSAVED_CONTACTS', } export const AccountType = { ALL: 'ACCOUNT_TYPE_ALL', PERSONAL: 'ACCOUNT_TYPE_PERSONAL', BUSINESS: 'ACCOUNT_TYPE_BUSINESS', } export const MessageType = { ALL: 'MESSAGE_TYPE_ALL', HAVE_UNREAD_MESSAGES: 'MESSAGE_TYPE_HAVE_UNREAD_MESSAGES', NO_UNREAD_MESSAGES: 'MESSAGE_TYPE_NO_UNREAD_MESSAGES', } export const SaveAs = { CSV: 'SAVE_AS_CSV', EXCEL: 'SAVE_AS_EXCEL', PDF: 'SAVE_AS_PDF', JSON: 'SAVE_AS_JSON', MARKDOWN: 'SAVE_AS_MARKDOWN', HTML: 'SAVE_AS_HTML', VCARD: 'SAVE_AS_VCARD', }
```

# src/constants/setting.ts

```ts
export const LICENSE_KEY = 'SETTING_LICENSE_KEY' export const LICENSE_INSTANCE_ID = 'SETTING_LICENSE_INSTANCE_ID' export const LICENSE_DATA_CACHE = 'SETTING_LICENSE_DATA_CACHE' export const IS_FIRST_TIME = 'SETTING_IS_FIRST_TIME' export const NEED_TO_OPEN = 'SETTING_NEED_TO_OPEN' export const HAS_ACKNOWLEDGED_BROADCAST_WARNING = 'SETTING.HAS_ACKNOWLEDGED_BROADCAST_WARNING' export const BLUR_PROFILE_PICTURES = 'SETTING.BLUR_PROFILE_PICTURES' export const BLUR_MESSAGES = 'SETTING.BLUR_MESSAGES' export const BLUR_USER_GROUP_NAMES = 'SETTING.BLUR_USER_GROUP_NAMES' export const BLUR_RECENT_MESSAGES = 'SETTING.BLUR_RECENT_MESSAGES' export const EXPORT_COLUMNS = 'SETTING_EXPORT_COLUMNS'
```

# src/contents/inject-script.ts

```ts
import { Action } from '@/constants' import wa from '@/libs/wa' import { initInjectScriptRelays } from '@/relays' import { postMessage } from '@/utils/util' import type { PlasmoCSConfig } from 'plasmo' export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], world: 'MAIN', } initInjectScriptRelays() wa.on.ready(() => { setTimeout(() => { onReady() }, 2000) }) const onReady = () => { setTimeout(() => { window.postMessage({ action: Action.Window.READY, body: {}, }) WPP.on('chat.active_chat', (chat) => { const body = { name: chat.contact?.__x_pushname || chat.contact?.__x_verifiedName || chat.name || chat.formattedTitle, number: chat.id.user, formattedNumber: chat.id._serialized, isUser: chat.id._serialized.includes('@c.us'), isGroup: chat.id._serialized.includes('@g.us'), isBusiness: chat.contact?.__x_isBusiness, } postMessage(Action.Window.ACTIVE_CHAT, body) }) }, 1000) }
```

# src/contents/main.tsx

```tsx
import AppMenu from '@/components/AppMenu' import ToastProvider from '@/components/Toast/ToastProvider' import theme from '@/libs/theme' import style from '@/utils/style' import { MantineProvider } from '@mantine/core' import type { PlasmoCSConfig, PlasmoGetShadowHostId } from 'plasmo' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-main` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Main = () => { return ( <> <MantineProvider theme={theme} //@ts-ignore cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-main') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <AppMenu /> <ToastProvider /> </MantineProvider> </> ) } export default Main
```

# src/features/tools/backup-chat/components/BackupOptions.tsx

```tsx
// src/features/tools/backup-chat/components/BackupOptions.tsx import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import { getContactName, showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Avatar, Badge, Button, Checkbox, Group, Radio, Select, Stack, TagsInput, Text, } from '@mantine/core' import { DatePickerInput } from '@mantine/dates' import React, { useEffect, useState } from 'react' import type { useChatBackup } from '../hooks/useChatBackup' interface Props { // Pass the entire hook's return object for cleaner prop management. backupHook: ReturnType<typeof useChatBackup> onStart: () => void } const BackupOptions: React.FC<Props> = ({ backupHook, onStart }) => { // Destructure properties from the hook const { form, SUPPORTED_MESSAGE_TYPES } = backupHook const license = useLicense() const wa = useWa() const [chatOptions, setChatOptions] = useState<{ label: string; value: string; avatar: string }[]>() const datePresets = [ { value: 'today', label: 'Today', pro: false }, { value: 'yesterday', label: 'Yesterday', pro: false }, { value: 'last7', label: 'Last 7 Days', pro: false }, { value: 'last30', label: 'Last 30 Days', pro: true }, { value: 'thisMonth', label: 'This Month', pro: true }, { value: 'lastMonth', label: 'Last Month', pro: true }, { value: 'all', label: 'All Time', pro: true }, { value: 'custom', label: 'Custom Range...', pro: true }, ] // MODIFIED: Added CSV and XLSX export formats. const exportFormats = [ { value: 'html', label: 'HTML (.zip)' }, { value: 'pdf', label: 'PDF' }, { value: 'csv', label: 'CSV' }, { value: 'xlsx', label: 'Excel' }, { value: 'txt', label: 'TXT' }, { value: 'json', label: 'JSON' }, { value: 'md', label: 'Markdown' }, ] useEffect(() => { if (!wa.isReady) return wa.chat.list({ onlyUsers: true }).then((chats) => { const labelValueChats = chats.map((chat: any) => ({ label: getContactName(chat.contact), value: chat.id, avatar: chat.contact.avatar, })) setChatOptions(labelValueChats) }) }, [wa.isReady]) const handleDatePresetChange = (value: string | null) => { if (!value) return const option = datePresets.find((p) => p.value === value) if (license.isFree() && option?.pro) { showModalUpgrade() return } form.setFieldValue('datePreset', value) } const renderSelectOption = ({ option, }: { option: { value: string; label: string; avatar: string } }) => ( <Group> <Avatar src={option.avatar} size="md" radius="xl" /> <div> <Text size="sm">{option.label}</Text> </div> </Group> ) return ( <Stack> <Select label="Select chat" data={chatOptions ?? []} searchable clearable required renderOption={renderSelectOption} {...form.getInputProps('chatId')} /> <TagsInput label="Filter by Keywords (Optional)" placeholder="Add keywords and press Enter" description="Only export messages containing any of these keywords. Case-insensitive." value={form.values.keywords} onChange={(newKeywords) => { form.setFieldValue('keywords', newKeywords) }} error={form.errors.keywords} clearable /> <Select label="Date Range" data={datePresets} value={form.values.datePreset} onChange={handleDatePresetChange} renderOption={({ option }) => { const preset = datePresets.find((p) => p.value === option.value) return ( <Group justify="space-between"> <Text>{option.label}</Text> {license.isFree() && preset?.pro && ( <Badge size="sm" variant="light" color="teal"> {' '} PRO{' '} </Badge> )} </Group> ) }} /> {form.values.datePreset === 'custom' && ( <DatePickerInput type="range" label="Custom Date Range" placeholder="Pick a start and end date" {...form.getInputProps('dateRange')} required /> )} <Checkbox.Group label="Include Message Types" description="Select the types of messages to include in the backup." value={form.values.messageTypes} onChange={(values) => { form.setFieldValue('messageTypes', values) }} > <Group mt="xs"> {SUPPORTED_MESSAGE_TYPES.map((type) => ( <Group key={type} gap="xs"> <Checkbox key={type} value={type} label={type.charAt(0).toUpperCase() + type.slice(1)} /> </Group> ))} </Group> </Checkbox.Group> <Radio.Group label="Format" value={form.values.exportFormat} onChange={(value) => { form.setFieldValue('exportFormat', value) }} > <Group mt="xs"> {exportFormats.map((format) => ( <Group key={format.value} gap="xs"> <Radio size="sm" value={format.value} label={format.label} /> </Group> ))} </Group> </Radio.Group> <Group justify="flex-end" mt={'xl'}> <Button leftSection={<Icon icon="tabler:download" />} onClick={onStart} disabled={!form.values.chatId} > Start Backup </Button> </Group> </Stack> ) } export default BackupOptions
```

# src/features/tools/backup-chat/components/BackupProgress.tsx

```tsx
// src/features/tools/chat-backup/components/BackupProgress.tsx import { Button, Center, Group, Progress, Stack, Text } from '@mantine/core' import React from 'react' interface Props { progress: { value: number label: string } onCancel: () => void } const BackupProgress: React.FC<Props> = ({ progress, onCancel }) => { return ( <Center h={250}> <Stack w="100%" align="center"> <Text size="lg" fw={500}> Backup in Progress... </Text> <Progress value={progress.value} animated size="lg" w="100%" /> <Text c="dimmed" size="sm"> {progress.label} </Text> <Button mt="lg" variant="outline" color="red" onClick={onCancel}> Cancel </Button> </Stack> </Center> ) } export default BackupProgress
```

# src/features/tools/backup-chat/components/BackupResult.tsx

```tsx
// src/features/tools/backup-chat/components/BackupResult.tsx import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Card, Center, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' import { When } from 'react-if' interface Props { result: { messagesExported: number messagesOmitted: number mediaOmitted: number isLimitApplied: boolean } onDone: () => void } const BackupResult: React.FC<Props> = ({ result, onDone }) => { const { messagesExported, messagesOmitted, mediaOmitted, isLimitApplied } = result return ( <Center> <Stack align="center" gap="lg"> <ThemeIcon color="teal" size={80} radius="xl"> <Icon icon="tabler:circle-check" fontSize={48} /> </ThemeIcon> <Title order={3}>Backup Complete!</Title> <Text c="dimmed" size="sm" ta="center" maw={400}> Successfully exported {messagesExported} messages. You can find the file in your downloads folder. </Text> <When condition={isLimitApplied}> {/* MODIFIED: The entire warning card has been updated for better psychological impact. */} <Card withBorder p="lg" shadow="none" radius="md" mt="md" style={{ width: '100%', borderColor: 'var(--mantine-color-orange-4)', backgroundColor: 'var(--mantine-color-orange-0)', }} > <Stack align="center" gap="sm"> <Group gap="xs"> <Icon icon="tabler:alert-triangle" color="var(--mantine-color-orange-7)" fontSize={24} /> {/* MODIFIED: Changed title to be more alarming and personal. */} <Title order={5} c="orange.9"> Warning: Some Memories Are At Risk! </Title> </Group> {/* MODIFIED: Changed text to emphasize the risk of permanent data loss. */} <Text ta="center" size="sm" c="dimmed"> <b>{messagesOmitted.toLocaleString()} messages</b> and{' '} <b>{mediaOmitted.toLocaleString()} media files</b> were NOT SAVED and could be lost forever. Upgrade now to protect all your data. </Text> <Button mt="sm" color="teal" onClick={showModalUpgrade} leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Protect Everything </Button> </Stack> </Card> </When> <Button variant="outline" mt="xl" onClick={onDone}> Start Another Backup </Button> </Stack> </Center> ) } export default BackupResult
```

# src/features/tools/backup-chat/helpers/backupProcessor.ts

```ts
// src/features/tools/backup-chat/helpers/backupProcessor.ts import wa from '@/libs/wa' import { getContactName } from '@/utils/util' import { endOfDay, endOfMonth, isWithinInterval, startOfDay, startOfMonth, subDays, subMonths, } from 'date-fns' import _ from 'lodash' import { exportToHtml, exportToJson, exportToMarkdown, exportToPdf, exportToTxt, } from './exportUtils' // Interface for backup parameters. interface BackupParams { chatId: string exportFormat: string messageTypes: string[] keywords: string[] datePreset: string dateRange: [Date | null, Date | null] enableEncryption: boolean password?: string setProgress: (progress: { value: number; label: string }) => void validationRef?: React.MutableRefObject<boolean> } /** * @description The core logic for running a chat backup. * It's a standalone function that can be called from UI hooks or background listeners. * @param params The backup configuration. * @returns A promise that resolves to true on success/cancellation, and false on failure. */ export const runBackupProcess = async (params: Partial<BackupParams>) => { const { chatId, exportFormat = 'html', messageTypes = [], keywords = [], datePreset = 'all', dateRange = [null, null], enableEncryption = false, password, setProgress = () => {}, validationRef = { current: true }, } = params if (!chatId) { throw new Error('Chat ID is required to start a backup.') } setProgress({ value: 5, label: 'Fetching messages...' }) // Date range filtering logic. let effectiveDateRange: [Date | null, Date | null] = [null, null] if (datePreset === 'custom') { effectiveDateRange = dateRange } else if (datePreset !== 'all') { const now = new Date() let start: Date | null = null let end: Date | null = null switch (datePreset) { case 'today': start = startOfDay(now) end = endOfDay(now) break // ... other date presets } effectiveDateRange = [start, end] } const allMessages = await wa.chat.getMessages(chatId, { count: -1 }) const [startDate, endDate] = effectiveDateRange const lowercasedKeywords = keywords .map((k) => k.toLowerCase().trim()) .filter(Boolean) const filteredMessages = allMessages.filter((msg) => { const dateMatch = !startDate || !endDate || isWithinInterval(new Date(msg.timestamp), { start: startDate, end: endDate, }) const keywordMatch = lowercasedKeywords.length === 0 || lowercasedKeywords.some( (k) => (msg.body && msg.body.toLowerCase().includes(k)) || (msg.caption && msg.caption.toLowerCase().includes(k)), ) const typeMatch = messageTypes.includes(msg.type) return dateMatch && keywordMatch && typeMatch }) if (filteredMessages.length === 0) { throw new Error('No messages found matching your criteria to export.') } const chat = await wa.chat.find(chatId) const filename = `backup_chat_${_.snakeCase( getContactName(chat.data.contact), )}_${new Date().toISOString().slice(0, 10)}` const exporterParams = { messages: filteredMessages, chat, filename, includeMediaTypes: messageTypes, setProgress, validationRef, password: enableEncryption ? password : undefined, } switch (exportFormat) { case 'pdf': await exportToPdf(exporterParams) break case 'txt': await exportToTxt(exporterParams) break case 'json': await exportToJson(exporterParams) break case 'md': await exportToMarkdown(exporterParams) break case 'html': default: await exportToHtml(exporterParams) break } return validationRef.current }
```

# src/features/tools/backup-chat/helpers/exportUtils.ts

```ts
// src/features/tools/backup-chat/helpers/exportUtils.ts import wa from '@/libs/wa' import { generateVideoThumbnail, getContactName } from '@/utils/util' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import jsPDF from 'jspdf' import JSZip from 'jszip' import _ from 'lodash' // ADDED: Import xlsx library for CSV and Excel export. import * as XLSX from 'xlsx' interface ExporterParams { messages: any[] // Messages now include an `isRedacted` property chat: any filename: string includeMediaTypes: string[] setProgress: (progress: { value: number; label: string }) => void validationRef: React.MutableRefObject<boolean> isLimitApplied?: boolean password?: string } const REDACTED_PLACEHOLDER = '********' // ... (existing functions: renderQuotedMessage, getRedactedMediaHtml, etc. remain unchanged) const renderQuotedMessage = (quotedMsg: any): string => { if (!quotedMsg) return '' const quotedSenderName = quotedMsg.sender.isMe ? 'You' : getContactName(quotedMsg.sender) let quotedContent = '' switch (quotedMsg.type) { case 'chat': quotedContent = _.escape(quotedMsg.body) break case 'image': quotedContent = 'ðŸ“· Photo' break case 'video': quotedContent = 'ðŸŽ¥ Video' break case 'document': quotedContent = `ðŸ“„ ${_.escape(quotedMsg.filename) || 'Document'}` break case 'ptt': quotedContent = 'ðŸŽ¤ Voice Message' break default: quotedContent = `[Unsupported message type: ${quotedMsg.type}]` } return ` <a href="#message-${quotedMsg.id}" class="quoted-message-link"> <div class="quoted-message"> <div class="quoted-sender">${_.escape(quotedSenderName)}</div> <div class="quoted-content">${quotedContent}</div> </div> </a> ` } const getRedactedMediaHtml = (type: string): string => { const iconMap: { [key: string]: string } = { image: 'ðŸ–¼ï¸', video: 'ðŸŽ¬', document: 'ðŸ“„', ptt: 'ðŸŽµ', } const icon = iconMap[type] || 'ðŸ”’' return ` <div class="redacted-media-container"> <div class="redacted-bg">${icon}</div> <div class="redacted-overlay"> <div class="lock-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect> <path d="M7 11V7a5 5 0 0 1 10 0v4"></path> </svg> </div> <div class="redacted-text">Upgrade to Pro to view</div> </div> </div> ` } const getRedactedTextHtml = (): string => { return `<div class="redacted-text-placeholder">${REDACTED_PLACEHOLDER}</div>` } const generateHtmlBody = async ({ messages, chat, includeMediaTypes, setProgress, validationRef, isForPdf = false, isLimitApplied = false, // Keep receiving this to know if redaction happened. }: ExporterParams & { isForPdf?: boolean }): Promise<{ htmlBody: string mediaMap: Map<string, Blob> }> => { const headerHtml = ` <div class="export-header"> <p><b>Chat With:</b> ${_.escape(getContactName(chat.data.contact))}</p> <p><b>Export Date:</b> ${new Date().toLocaleString()}</p> <p><b>Total Messages Exported:</b> ${messages.length}</p> ${ isLimitApplied ? '<p style="color: #d9534f;"><b>Notice:</b>Upgrade to Pro to save all messages and media.</p>' : '' } </div> ` let messagesHtml = '' const mediaMap = new Map<string, Blob>() for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] if ( !['chat', 'image', 'video', 'document', 'ptt', 'location'].includes( msg.type, ) ) continue const progressValue = ((i + 1) / messages.length) * 90 // Reserve last 10% setProgress({ value: progressValue, label: `Processing message ${i + 1} of ${messages.length}...`, }) const direction = msg.contact.isMe ? 'out' : 'in' const senderName = !msg.fromMe && chat.data.isGroup ? msg.contact?.pushname || msg.contact?.formattedName || 'Unknown' : '' let mediaHtml = '' const isMediaMessage = ['image', 'video', 'document', 'ptt'].includes( msg.type, ) const shouldIncludeThisMedia = includeMediaTypes.includes(msg.type) if ( isMediaMessage && shouldIncludeThisMedia && !mediaMap.has(msg.id) && !msg.isRedacted ) { setProgress({ value: progressValue, label: `Downloading media for message ${i + 1}... (${ msg.filename || msg.type })`, }) const blob = await wa.chat.downloadMedia(msg.id) if (blob) { mediaMap.set(msg.id, blob) const mediaType = msg.type as 'image' | 'video' | 'document' | 'ptt' const extension = blob.type.split('/')[1] || 'bin' const mediaFilename = `${msg.id}.${extension}` const folderName = mediaType === 'ptt' ? 'audio' : `${mediaType}s` const filePath = `./${folderName}/${mediaFilename}` const blobUrl = URL.createObjectURL(blob) switch (msg.type) { case 'image': mediaHtml = `<img src="${ isForPdf ? blobUrl : filePath }" alt="Image" />` break case 'video': if (isForPdf) { //@ts-ignore const thumb = await generateVideoThumbnail(blob) mediaHtml = `<div class="video-thumb-container"><img src="${thumb}" alt="Video Thumbnail" /><div class="play-button">â–¶</div></div>` } else { mediaHtml = `<video controls src="${filePath}"></video>` } break case 'ptt': if (isForPdf) { const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) mediaHtml = `<div class="media-placeholder">ðŸŽ¤ Voice Message (${duration})</div>` } else { mediaHtml = `<audio controls src="${filePath}"></audio>` } break case 'document': if (isForPdf) { mediaHtml = `<div class="media-placeholder">ðŸ“„ ${ _.escape(msg.filename) || 'Document' }</div>` } else { mediaHtml = `<a href="${filePath}" target="_blank">Download: ${ _.escape(msg.filename) || 'Document' }</a>` } break } } } else if (isMediaMessage) { if (msg.isRedacted) { mediaHtml = getRedactedMediaHtml(msg.type) } else { const mediaType = msg.type === 'ptt' ? 'Audio' : msg.type let placeholderText = `[${ mediaType.charAt(0).toUpperCase() + mediaType.slice(1) } not included]` mediaHtml = `<div class="media-placeholder">${placeholderText}</div>` } } const messageBodyHtml = msg.isRedacted ? getRedactedTextHtml() : `<span>${ _.escape(msg.type === 'chat' ? msg.body : msg.caption) ?? '' }</span>` const quotedHtml = renderQuotedMessage(msg.quotedMsg) messagesHtml += ` <div class="message-cluster message-${direction}" id="message-${msg.id}"> <div class="message"> <div class="message-bubble"> ${ senderName ? `<div class="sender-name">${_.escape(senderName)}</div>` : '' } <div class="message-content"> ${quotedHtml} ${mediaHtml} ${messageBodyHtml} <span class="timestamp">${new Date( msg.timestamp, ).toLocaleTimeString([], { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', })}</span> </div> </div> </div> </div> ` } return { htmlBody: headerHtml + messagesHtml, mediaMap } } const getFullHtmlDocument = (bodyContent: string, chat: any) => { const styles = ` <style> body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; margin: 0; background-color: #E5DDD5; } .chat-container { max-width: 800px; margin: auto; padding: 20px; } .export-header { background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #dee2e6; font-size: 0.9em; } .export-header p { margin: 2px 0; color: #333; } .export-header b { color: #111; } .limit-notice { background-color: #fffbe6; border: 1px solid #ffe58f; border-radius: 4px; padding: 10px; margin-top: 10px; font-size: 0.85em; text-align: center; color: #856404; } .message-cluster { display: flex; flex-direction: column; margin-bottom: 2px; padding: 0 9%; scroll-margin-top: 20px; } .message-cluster.message-out { align-items: flex-end; } .message-cluster.message-in { align-items: flex-start; } .message { max-width: 65%; word-wrap: break-word; margin-bottom: 10px; } .message-bubble { padding: 6px 9px; border-radius: 7.5px; box-shadow: 0 1px 0.5px rgba(11,20,26,.13); position: relative; } .message-out .message-bubble { background-color: #d9fdd3; color: #0f1010; } .message-in .message-bubble { background-color: #fff; color: #111b21; } .sender-name { font-size: 0.8rem; font-weight: 500; color: #028a76; margin-bottom: 4px; } .message-content img, .message-content video { width: 100%; max-width: 300px; border-radius: 6px; margin-top: 5px; display: block; } .message-content a { color: #0088cc; } .timestamp { font-size: 0.7rem; color: #667781; display: flex; justify-content: flex-end; padding-top: 4px; } .media-placeholder { padding: 10px; background-color: #f0f0f0; border: 1px dashed #ccc; border-radius: 6px; color: #888; font-style: italic; font-size: 0.9em; margin-top: 5px; text-align: center; } .quoted-message-link { text-decoration: none; color: inherit; } .quoted-message { background-color: #f0f2f5; border-left: 4px solid #4CAF50; padding: 8px 10px; margin-bottom: 5px; border-radius: 4px; opacity: 0.85; } .quoted-sender { font-weight: bold; font-size: 0.85em; color: #4CAF50; } .quoted-content { font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; } .video-thumb-container { position: relative; display: inline-block; } .video-thumb-container img { display: block; width: 100%; max-width: 300px; border-radius: 6px; } .video-thumb-container .play-button { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: white; background-color: rgba(0, 0, 0, 0.5); border-radius: 50%; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; text-shadow: 1px 1px 2px black;} .redacted-media-container { position: relative; width: 100%; max-width: 300px; height: 200px; background-color: #e9ecef; border-radius: 6px; margin-top: 5px; overflow: hidden; display: flex; align-items: center; justify-content: center; } .redacted-bg { font-size: 50px; filter: blur(8px); opacity: 0.3; user-select: none; } .redacted-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; } .lock-icon svg { width: 32px; height: 32px; } .redacted-text { font-size: 0.9em; font-weight: 500; margin-top: 8px; } .redacted-text-placeholder { padding: 10px; background-color: #f8f9fa; border: 1px dashed #dee2e6; border-radius: 6px; color: #6c757d; font-style: italic; font-size: 0.9em; margin-top: 5px; text-align: center; } </style> ` return ` <html> <head> <meta charset="UTF-8"> <title>Chat with ${_.escape(getContactName(chat.data.contact))}</title> ${styles} </head> <body><div class="chat-container">${bodyContent}</div></body> </html> ` } // ... (existing exportToHtml, exportToPdf, etc. functions remain unchanged) export const exportToHtml = async (params: ExporterParams) => { const { filename, setProgress, password } = params const { htmlBody, mediaMap } = await generateHtmlBody(params) const fullHtml = getFullHtmlDocument(htmlBody, params.chat) mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) { URL.revokeObjectURL(url) } }) if (mediaMap.size > 0 && params.includeMediaTypes.length > 0) { const zip = new JSZip() const mediaFolders: { [key: string]: JSZip | null } = { image: zip.folder('images'), video: zip.folder('videos'), document: zip.folder('documents'), ptt: zip.folder('audio'), } for (const [msgId, blob] of mediaMap.entries()) { const msg = params.messages.find((m) => m.id === msgId) if (msg && msg.type !== 'chat') { const mediaType = msg.type as 'image' | 'video' | 'document' | 'ptt' const folder = mediaFolders[mediaType] const extension = blob.type.split('/')[1] || 'bin' const mediaFilename = `${msg.id}.${extension}` folder?.file(mediaFilename, blob) } } zip.file(`${filename}.html`, fullHtml) setProgress({ value: 98, label: 'Compressing files...' }) const zipOptions: any = { type: 'blob' } if (password) { zipOptions.password = password } const zipBlob = await zip.generateAsync(zipOptions) //@ts-ignore FileSaver.saveAs(zipBlob, `${filename}.zip`) } else { const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' }) FileSaver.saveAs(blob, `${filename}.html`) } } export const exportToPdf = async (params: ExporterParams) => { const { filename, setProgress, validationRef } = params const { htmlBody, mediaMap } = await generateHtmlBody({ ...params, includeMediaTypes: ['image', 'video'], isForPdf: true, }) const fullHtml = getFullHtmlDocument(htmlBody, params.chat) if (!validationRef.current) { mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) return } setProgress({ value: 92, label: 'Generating PDF document...' }) const container = document.createElement('div') container.style.position = 'absolute' container.style.left = '-9999px' container.style.width = '800px' document.body.appendChild(container) container.innerHTML = fullHtml try { const canvas = await html2canvas(container, { useCORS: true, scale: 2 }) document.body.removeChild(container) mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) if (!validationRef.current) return setProgress({ value: 95, label: 'Formatting PDF pages...' }) const imgData = canvas.toDataURL('image/png') const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4', }) const pdfWidth = pdf.internal.pageSize.getWidth() const pdfHeight = pdf.internal.pageSize.getHeight() const canvasWidth = canvas.width const canvasHeight = canvas.height const ratio = canvasWidth / pdfWidth const canvasHeightInPdf = canvasHeight / ratio let heightLeft = canvasHeightInPdf let position = 0 pdf.addImage( imgData, 'PNG', 0, position, pdfWidth, canvasHeightInPdf, undefined, 'FAST', ) heightLeft -= pdfHeight while (heightLeft > 0) { position = heightLeft - canvasHeightInPdf pdf.addPage() pdf.addImage( imgData, 'PNG', 0, position, pdfWidth, canvasHeightInPdf, undefined, 'FAST', ) heightLeft -= pdfHeight } setProgress({ value: 98, label: 'Saving PDF file...' }) pdf.save(`${filename}.pdf`) } catch (error) { console.error('Error generating PDF:', error) if (document.body.contains(container)) { document.body.removeChild(container) } mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) throw new Error('Failed to generate PDF from chat content.') } } export const exportToTxt = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef } = params let textContent = `Chat With: ${getContactName(chat.data.contact)}\r\n` textContent += `Export Date: ${new Date().toLocaleString()}\r\n` textContent += `Total Messages Exported: ${messages.length}\r\n\r\n` for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const sender = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toLocaleString() let content = '' if (msg.isRedacted) { content = REDACTED_PLACEHOLDER } else { switch (msg.type) { case 'chat': content = msg.body break case 'image': content = `[Image: ${msg.filename || 'image.jpg'}]` if (msg.caption) content += `\r\n${msg.caption}` break case 'video': content = `[Video: ${msg.filename || 'video.mp4'}]` if (msg.caption) content += `\r\n${msg.caption}` break case 'document': content = `[Document: ${msg.filename || 'file'}]` if (msg.caption) content += `\r\n${msg.caption}` break case 'ptt': const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) content = `[Voice Message: ${duration}]` break default: content = `[${msg.type}]` break } } if (msg.quotedMsg && !msg.isRedacted) { const quotedSender = msg.quotedMsg.sender.isMe ? 'You' : getContactName(msg.quotedMsg.sender) const quotedContent = _.truncate( msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, { length: 40 }, ) content = `[Quoting ${quotedSender}: "${quotedContent}"]\r\n${content}` } textContent += `[${timestamp}] ${sender}: ${content}\r\n\r\n` } if (validationRef.current) { const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' }) FileSaver.saveAs(blob, `${filename}.txt`) } } export const exportToJson = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef } = params const messageList: object[] = [] for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) let bodyContent: string | null = msg.body || null if (msg.isRedacted) { bodyContent = REDACTED_PLACEHOLDER } else if (msg.type !== 'chat') { let placeholder = `[${msg.type}]` if (msg.filename) { placeholder = `[${msg.type}: ${msg.filename}]` } else if (msg.type === 'ptt' && msg.duration) { const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) placeholder = `[Voice Message: ${duration}]` } bodyContent = placeholder } messageList.push({ id: msg.id, timestamp: new Date(msg.timestamp).toISOString(), sender: { name: msg.contact.isMe ? 'You' : getContactName(msg.contact), id: msg.from, isMe: msg.contact.isMe, }, type: msg.type, body: bodyContent, caption: msg.isRedacted ? null : msg.caption || null, filename: msg.isRedacted ? null : msg.filename || null, quotedMessage: msg.quotedMsg && !msg.isRedacted ? { id: msg.quotedMsg.id, sender: getContactName(msg.quotedMsg.sender), body: msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, } : null, }) } if (validationRef.current) { const finalJson = { metadata: { chatWith: getContactName(chat.data.contact), chatId: chat.data.id, exportDate: new Date().toISOString(), totalMessages: messages.length, }, messages: messageList, } const jsonString = JSON.stringify(finalJson, null, 2) const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8', }) FileSaver.saveAs(blob, `${filename}.json`) } } export const exportToMarkdown = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef } = params let mdContent = `# Chat with: ${getContactName(chat.data.contact)}\n\n` mdContent += `**Export Date:** ${new Date().toLocaleString()}\n` mdContent += `**Total Messages:** ${messages.length}\n\n---\n\n` for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const senderName = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toLocaleString() mdContent += `**${_.escape(senderName)}** (*${timestamp}*)\n\n` if (msg.quotedMsg && !msg.isRedacted) { const quotedSenderName = msg.quotedMsg.sender.isMe ? 'You' : getContactName(msg.quotedMsg.sender) const quotedBody = _.truncate( msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, { length: 80 }, ) mdContent += `> > **${_.escape(quotedSenderName)}**: ${_.escape( quotedBody, )}\n\n` } let mdMessageContent = '' switch (msg.type) { case 'chat': mdMessageContent = msg.isRedacted ? `*${REDACTED_PLACEHOLDER}*` : msg.body.replace(/\n/g, ' \n') // Markdown line breaks break case 'image': mdMessageContent = msg.isRedacted ? `*${REDACTED_PLACEHOLDER}*` : `*Image: \`${_.escape(msg.filename)}\`*` if (msg.caption && !msg.isRedacted) mdMessageContent += `\n> ${_.escape(msg.caption)}` break case 'video': mdMessageContent = msg.isRedacted ? `*${REDACTED_PLACEHOLDER}*` : `*Video: \`${_.escape(msg.filename)}\`*` if (msg.caption && !msg.isRedacted) mdMessageContent += `\n> ${_.escape(msg.caption)}` break case 'document': mdMessageContent = msg.isRedacted ? `*${REDACTED_PLACEHOLDER}*` : `*Document: \`${_.escape(msg.filename)}\`*` if (msg.caption && !msg.isRedacted) mdMessageContent += `\n> ${_.escape(msg.caption)}` break case 'ptt': const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) mdMessageContent = msg.isRedacted ? `*${REDACTED_PLACEHOLDER}*` : `*Voice Message (${duration})*` break default: mdMessageContent = `*[Unsupported message type: ${msg.type}]*` } mdContent += `${mdMessageContent}\n\n---\n` } if (validationRef.current) { const blob = new Blob([mdContent], { type: 'text/markdown;charset=utf-8', }) FileSaver.saveAs(blob, `${filename}.md`) } } // ADDED: A shared helper to prepare data for CSV/XLSX to avoid code duplication. const prepareSheetData = (params: ExporterParams): any[] => { const { messages, setProgress, validationRef } = params const sheetData: any[] = [] // Define headers sheetData.push([ 'Message ID', 'Timestamp', 'Sender Name', 'Sender Number', 'Message Type', 'Content', 'Quoted Message ID', ]) for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const senderName = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toISOString() let content = '' if (msg.isRedacted) { content = REDACTED_PLACEHOLDER } else { switch (msg.type) { case 'chat': content = msg.body break case 'image': case 'video': case 'document': content = `[${msg.type.toUpperCase()}] ${msg.caption || ''}`.trim() break case 'ptt': const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) content = `[VOICE MESSAGE] Duration: ${duration}` break default: content = `[${msg.type.toUpperCase()}]` break } } sheetData.push([ msg.id, timestamp, senderName, msg.from, msg.type, content, msg.quotedMsg?.id || '', ]) } return sheetData } // ADDED: Export function for CSV format. export const exportToCsv = async (params: ExporterParams) => { const { filename, validationRef } = params const sheetData = prepareSheetData(params) if (validationRef.current) { const worksheet = XLSX.utils.aoa_to_sheet(sheetData) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } } // ADDED: Export function for XLSX format. export const exportToXlsx = async (params: ExporterParams) => { const { filename, validationRef } = params const sheetData = prepareSheetData(params) if (validationRef.current) { const worksheet = XLSX.utils.aoa_to_sheet(sheetData) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Chat Backup') XLSX.writeFile(workbook, `${filename}.xlsx`) } }
```

# src/features/tools/backup-chat/hooks/useChatBackup.ts

```ts
// src/features/tools/backup-chat/hooks/useChatBackup.ts import useLicense from '@/hooks/useLicense' import wa from '@/libs/wa' import toast from '@/utils/toast' import { getContactName } from '@/utils/util' import { useForm } from '@mantine/form' import { endOfDay, endOfMonth, isWithinInterval, startOfDay, startOfMonth, subDays, subMonths, } from 'date-fns' import _ from 'lodash' import { useRef, useState } from 'react' // MODIFIED: Import new CSV and XLSX exporters. import { exportToCsv, exportToHtml, exportToJson, exportToMarkdown, exportToPdf, exportToTxt, exportToXlsx, } from '../helpers/exportUtils' const SUPPORTED_MESSAGE_TYPES = ['chat', 'image', 'video', 'document', 'ptt'] export interface BackupResultStats { messagesExported: number messagesOmitted: number mediaOmitted: number isLimitApplied: boolean } export const useChatBackup = () => { const license = useLicense() const [isBackingUp, setIsBackingUp] = useState(false) const [progress, setProgress] = useState({ value: 0, label: 'Initializing...', }) const validationRef = useRef(true) const [backupResult, setBackupResult] = useState<BackupResultStats | null>( null, ) const form = useForm({ initialValues: { chatId: '', exportFormat: 'html', messageTypes: SUPPORTED_MESSAGE_TYPES, keywords: [] as string[], datePreset: 'today', dateRange: [null, null] as [Date | null, Date | null], }, validate: { chatId: (value) => (value ? null : 'A chat must be selected.'), dateRange: (value, values) => { if (values.datePreset === 'custom' && (!value[0] || !value[1])) { return 'A start and end date are required for a custom range.' } return null }, }, validateInputOnChange: ['keywords'], }) const cancelBackup = () => { validationRef.current = false } const clearBackupResult = () => { setBackupResult(null) form.reset() } const startBackup = async () => { if (form.validate().hasErrors) return setIsBackingUp(true) validationRef.current = true setProgress({ value: 5, label: 'Fetching and filtering messages...' }) let resultStats: BackupResultStats = { messagesExported: 0, messagesOmitted: 0, mediaOmitted: 0, isLimitApplied: false, } try { const { chatId, dateRange, keywords, messageTypes, datePreset } = form.values let effectiveDateRange: [Date | null, Date | null] = [null, null] if (datePreset === 'custom') { effectiveDateRange = dateRange } else if (datePreset !== 'all') { const now = new Date() let start: Date | null = null let end: Date | null = null switch (datePreset) { case 'today': start = startOfDay(now) end = endOfDay(now) break case 'yesterday': const yesterday = subDays(now, 1) start = startOfDay(yesterday) end = endOfDay(yesterday) break case 'last7': start = startOfDay(subDays(now, 6)) end = endOfDay(now) break case 'last30': start = startOfDay(subDays(now, 29)) end = endOfDay(now) break case 'thisMonth': start = startOfMonth(now) end = endOfMonth(now) break case 'lastMonth': const lastMonthDate = subMonths(now, 1) start = startOfMonth(lastMonthDate) end = endOfMonth(lastMonthDate) break } effectiveDateRange = [start, end] } const allMessages = await wa.chat.getMessages(chatId, { count: -1 }) let [startDate, endDate] = effectiveDateRange if (license.isFree()) { const sevenDaysAgo = startOfDay(subDays(new Date(), 7)) if (!startDate || startDate < sevenDaysAgo) { startDate = sevenDaysAgo } } const lowercasedKeywords = keywords .map((k) => k.toLowerCase().trim()) .filter(Boolean) const filteredMessages = allMessages.filter((msg) => { const dateMatch = !startDate || !endDate || isWithinInterval(new Date(msg.timestamp), { start: startDate, end: endDate, }) const keywordMatch = lowercasedKeywords.length === 0 || lowercasedKeywords.some( (k) => (msg.body && msg.body.toLowerCase().includes(k)) || (msg.caption && msg.caption.toLowerCase().includes(k)), ) const typeMatch = messageTypes.includes(msg.type) return dateMatch && keywordMatch && typeMatch }) if (filteredMessages.length === 0) { toast.info('No messages found matching your criteria to export.') setIsBackingUp(false) return } const isLimitApplied = license.isFree() && filteredMessages.length > 10 const messagesToExport = filteredMessages.map((msg, index) => ({ ...msg, isRedacted: isLimitApplied && index >= 10, })) const messagesOmittedCount = isLimitApplied ? filteredMessages.length - 10 : 0 const mediaOmittedCount = isLimitApplied ? filteredMessages .slice(10) .filter((msg) => ['image', 'video', 'document', 'ptt'].includes(msg.type), ).length : 0 resultStats = { messagesExported: filteredMessages.length - messagesOmittedCount, messagesOmitted: messagesOmittedCount, mediaOmitted: mediaOmittedCount, isLimitApplied: isLimitApplied, } const chat = await wa.chat.find(form.values.chatId) // @ts-ignore const filename = `backup_chat_${_.snakeCase( getContactName(chat.data.contact), )}_${new Date().toISOString().slice(0, 10)}` const exporterParams = { messages: messagesToExport, chat, filename, includeMediaTypes: form.values.messageTypes, setProgress, validationRef, isLimitApplied, } // MODIFIED: Added cases for 'csv' and 'xlsx' export formats. switch (form.values.exportFormat) { case 'pdf': await exportToPdf(exporterParams) break case 'txt': await exportToTxt(exporterParams) break case 'json': await exportToJson(exporterParams) break case 'md': await exportToMarkdown(exporterParams) break case 'csv': await exportToCsv(exporterParams) break case 'xlsx': await exportToXlsx(exporterParams) break case 'html': default: await exportToHtml(exporterParams) break } if (validationRef.current) { // MODIFIED: Implement smart toast notification. Show a warning for limited backups. if (isLimitApplied) { toast.warning( 'Backup Limited', 'Only the first 10 messages were saved. Upgrade to Pro for unlimited backups.', ) } else { toast.success('Backup completed successfully!') } setBackupResult(resultStats) } else { toast.info('Backup cancelled by user.') } } catch (error: any) { console.error('Backup failed:', error) toast.error(error.message || 'An unknown error occurred during backup.') setBackupResult(null) } finally { setIsBackingUp(false) } } return { form, isBackingUp, progress, startBackup, cancelBackup, SUPPORTED_MESSAGE_TYPES, backupResult, clearBackupResult, } }
```

# src/features/tools/backup-chat/PageChatBackup.tsx

```tsx
// src/features/tools/backup-chat/PageChatBackup.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Icon } from '@iconify/react' import { Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' import BackupOptions from './components/BackupOptions' import BackupProgress from './components/BackupProgress' import BackupResult from './components/BackupResult' import { useChatBackup } from './hooks/useChatBackup' const PageChatBackup: React.FC = () => { const backup = useChatBackup() const renderContent = () => { if (backup.isBackingUp) { return ( <BackupProgress progress={backup.progress} onCancel={backup.cancelBackup} /> ) } if (backup.backupResult) { return ( <BackupResult result={backup.backupResult} onDone={backup.clearBackupResult} /> ) } return <BackupOptions backupHook={backup} onStart={backup.startBackup} /> } return ( <LayoutPage width={700}> <Stack>{renderContent()}</Stack> </LayoutPage> ) } export default PageChatBackup
```

# src/hooks/useAi.ts

```ts
// src/hooks/useAi.ts import { AI } from '@/constants/action' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' const useAi = () => { const rewriteMessage = async ( prompt: string, message: string, system: | string | null = 'You are an expert copywriter. Your task is to rewrite the user message based on their instruction.', ): Promise<Response<string>> => { // Send the request to the background relay defined in `ai.relay.ts` return await sendToBackgroundViaRelay({ //@ts-ignore name: 'ai', body: { prompt, message, system }, }) } return { rewriteMessage, } } export default useAi
```

# src/hooks/useDataQuery.ts

```ts
import type { EntityTable } from 'dexie' import { useLiveQuery } from 'dexie-react-hooks' import { useMemo, useState } from 'react' type SortDirection = 'asc' | 'desc' interface Sort { field: string direction: SortDirection } type SortState = Sort | null type FilterOperator = | 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'between' interface Filter { field: string operator: FilterOperator value: any secondValue?: any } interface useDataQueryOptions<T> { //@ts-ignore table: EntityTable<T, 'id'> initialPageSize?: number searchField?: string initialSort?: Sort initialFilters?: Filter[] } export const useDataQuery = <T>(options: useDataQueryOptions<T>) => { const { table, initialPageSize = 10, searchField = 'name', initialSort = { field: 'id', direction: 'desc' }, initialFilters = [], } = options const [page, setPage] = useState(1) const [pageSize, setPageSize] = useState(initialPageSize) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<T[]>([]) const [sort, setSort] = useState<SortState>(initialSort) const [filters, setFilters] = useState<Filter[]>(initialFilters) const applyFilter = (query: any, filter: Filter) => { const { field, operator, value, secondValue } = filter switch (operator) { case 'equals': return query.filter((item: any) => item[field] === value) case 'contains': return query.filter((item: any) => String(item[field]) .toLowerCase() .includes(String(value).toLowerCase()), ) case 'startsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .startsWith(String(value).toLowerCase()), ) case 'endsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .endsWith(String(value).toLowerCase()), ) case 'greaterThan': return query.filter((item: any) => item[field] > value) case 'lessThan': return query.filter((item: any) => item[field] < value) case 'between': return query.filter( (item: any) => item[field] >= value && item[field] <= (secondValue ?? value), ) default: return query } } const data = useLiveQuery(async () => { if (pageSize <= 0) return { data: [], totalItems: 0, hasMore: false } const startIndex = (page - 1) * pageSize let query = search ? table.where(searchField).startsWithIgnoreCase(search) : table.toCollection() let results = await query.toArray() filters.forEach((filter) => { results = applyFilter(results, filter) }) if (sort) { results.sort((a: any, b: any) => { const aValue = a[sort.field] const bValue = b[sort.field] if (aValue === bValue) return 0 const comparison = aValue > bValue ? 1 : -1 return sort.direction === 'asc' ? comparison : -comparison }) } const paginatedResults = results.slice(startIndex, startIndex + pageSize) return { data: paginatedResults, totalItems: results.length, hasMore: startIndex + paginatedResults.length < results.length, } }, [page, pageSize, search, sort, filters]) const _delete = async (id: any) => { if (confirm('Are you sure?')) { await table.delete(id) } } const toggleSort = (field: string) => { setSort((currentSort) => { // Case 1: No current sort, or a new column is clicked. Start with 'asc'. if (!currentSort || currentSort.field !== field) { return { field, direction: 'asc' } } // Case 2: Currently sorted 'asc'. Switch to 'desc'. if (currentSort.direction === 'asc') { return { field, direction: 'desc' } } // Case 3: Currently sorted 'desc'. Switch to null to remove sorting. if (currentSort.direction === 'desc') { return null } // Fallback, should not be reached. return currentSort }) } const addFilter = (filter: Filter) => { setFilters((prev) => [...prev, filter]) setPage(1) } const removeFilter = (index: number) => { setFilters((prev) => prev.filter((_, i) => i !== index)) setPage(1) } const updateFilter = (index: number, filter: Filter) => { setFilters((prev) => prev.map((f, i) => (i === index ? filter : f))) setPage(1) } const clearFilters = () => { setFilters([]) setPage(1) } const derivedData = useMemo( () => ({ data: data?.data ?? [], totalRecords: data?.totalItems ?? 0, hasMore: data?.hasMore ?? false, }), [data], ) return { ...derivedData, selectedRecords, page, pageSize, search, sort, filters, setPage, setPageSize, setSelectedRecords, setSearch, toggleSort, addFilter, removeFilter, updateFilter, clearFilters, _delete, searchField, } } export default useDataQuery
```

# src/hooks/useFile.ts

```ts
// src/utils/file.ts import { SaveAs, Setting } from '@/constants' import { storage } from '@/libs/storage' import FileSaver from 'file-saver' import _ from 'lodash' import * as XLSX from 'xlsx' import useLicense from './useLicense' const useFile = () => { const license = useLicense() const getSelectedColumns = async () => { return ( (await storage.get<Record<string, boolean>>(Setting.EXPORT_COLUMNS)) || { phoneNumber: true, publicName: true, savedName: true, isBlocked: true, isBusiness: true, isMyContact: true, } ) } const serializeData = async (data: any[]) => { const selectedColumns = await getSelectedColumns() let filteredData = data.map((item: any) => _.pickBy(item, (_, key) => selectedColumns[key] === true), ) if (license.isFree() && filteredData.length > 10) { filteredData = filteredData.map((item, index) => index >= 10 ? _.mapValues(item, () => '********') : item, ) } return filteredData } const defaultFilename = () => { return `export_${new Date().toISOString().slice(0, 10)}` } const saveAsCSV = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } const saveAsExcel = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet 1') XLSX.writeFile(workbook, `${filename}.xlsx`) } const saveAsJson = (data: any[], filename: string) => { const json = JSON.stringify(data, null, 2) const blob = new Blob([json], { type: 'application/json' }) FileSaver.saveAs(blob, `${filename}.json`) } const saveAsVCard = (data: any[]) => { const vcardContent = data .map((contact) => { const name = contact.savedName || contact.publicName || 'Unknown' const phone = contact.phoneNumber ? `+${contact.phoneNumber}` : '' return `BEGIN:VCARD\nVERSION:3.0\nFN:${name}\nTEL;TYPE=CELL:${phone}\nEND:VCARD` }) .join('\n') const blob = new Blob([vcardContent], { type: 'text/vcard' }) FileSaver.saveAs(blob, `${defaultFilename()}.vcf`) } /** * Main function to save data in various formats. * @param fileType The format to save as (e.g., 'csv', 'xlsx'). * @param data The array of data objects to save. * @param filename (Optional) The base name for the file, without extension. */ const saveAs = async (fileType: string, data: any[], filename?: string) => { const processedData = await serializeData(data) const finalFilename = filename || defaultFilename() switch (fileType) { case SaveAs.CSV: saveAsCSV(processedData, finalFilename) break case SaveAs.EXCEL: saveAsExcel(processedData, finalFilename) break case SaveAs.JSON: saveAsJson(processedData, finalFilename) break case SaveAs.VCARD: saveAsVCard(processedData) // VCard has its own filename logic break // Other formats like Markdown and HTML can be added here. default: console.error(`Unsupported file type: ${fileType}`) break } } return { saveAs } } export default useFile
```

# src/hooks/useLicense.ts

```ts
// src/hooks/useLicense.ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import type { License } from '@/types' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { sendToBackground } from '@plasmohq/messaging' import { isPast } from 'date-fns' const useLicense = () => { const { license, setLicense } = useAppStore() const callLemonSqueezyApi = async (action: string, body: any) => { return await sendToBackground({ name: 'lemonsqueezy', body: { action, body, }, }) } const init = async () => { // First, check for a cached, valid license to avoid unnecessary API calls. const cachedLicense = await storage.get<License | null>( Setting.LICENSE_DATA_CACHE, ) if (cachedLicense?.license_key?.status === 'active') { setLicense(cachedLicense) return } // If no valid cache, proceed with the standard validation flow. const licenseKey = await storage.get<string | null>(Setting.LICENSE_KEY) if (!licenseKey) { setLicense(null) await storage.remove(Setting.LICENSE_DATA_CACHE) return } const response = await callLemonSqueezyApi('validateLicense', { licenseKey, }) if (response.error) { // Validation failed, clear all license-related storage. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is invalid or has been deactivated. You have been switched to the Free plan.', 'License Invalid', ) return } if (response.data.meta.store_id.toString() !== getStoreId()) { await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is for a different product. You have been switched to the Free plan.', 'License Error', ) return } // Validation successful, update app state and cache the license data if active. setLicense(response.data) if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } if ( response.data.license_key.expires_at && isPast(new Date(response.data.license_key.expires_at)) ) { toast.info( 'Your license has expired. You have been switched to the Free plan.', 'License Expired', ) await storage.remove(Setting.LICENSE_DATA_CACHE) } } const isFree = (): boolean => { if (!license) { return true } return license.license_key.status !== 'active' } const isPro = () => { if (!license) { return false } return license.license_key.status === 'active' } const isExpired = () => { // For lifetime licenses, 'expires_at' might be null. // The most reliable check is the status. If no expiration date exists, it's not expired. if (!license || !license.license_key.expires_at) { return false } return isPast(new Date(license.license_key.expires_at)) } const getLicense = () => { return license } const activate = async (licenseKey: string) => { const response = await callLemonSqueezyApi('activateLicense', { licenseKey, }) if (!response.error) { setLicense(response.data) await storage.set(Setting.LICENSE_KEY, licenseKey) await storage.set(Setting.LICENSE_INSTANCE_ID, response.data.instance.id) // Cache the license data immediately on successful activation. if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } } return response } const deactivate = async () => { const licenseKey = await storage.get(Setting.LICENSE_KEY) const instanceId = await storage.get(Setting.LICENSE_INSTANCE_ID) try { const response = await callLemonSqueezyApi('deactivateLicense', { licenseKey, instanceId, }) if (response.data.deactivated) { // Clear all license-related data from storage on deactivation. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.success('Your license has been deactivated from this device.') } else { toast.error('Failed to deactivate the license. Please contact support.') } } catch (e) { toast.error('An error occurred during deactivation.') } } const goToMyOrders = async () => { if (!license?.meta?.customer_id) { toast.error('Could not find customer information.') return } try { const response = await callLemonSqueezyApi('getCustomer', { customerId: license.meta.customer_id, }) if (response.error) { toast.error('Could not retrieve customer portal link.') return } window.open( response.data.data.attributes.urls.customer_portal, '_blank', 'noopener,noreferrer', ) } catch (e) { toast.error('An error occurred while fetching your subscription details.') } } return { init, isFree, isPro, isExpired, activate, getLicense, goToMyOrders, deactivate, } } export default useLicense
```

# src/hooks/useRuntimeMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = ( message: T, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void, ) => void | boolean /** * A React hook for handling Chrome runtime messages * @param listener The callback function to handle incoming messages * @returns void * * @example * useRuntimeMessage((message, sender, sendResponse) => { * if (message.type === 'getData') { * sendResponse({ data: 'example' }) * } * // Return true to keep the message channel open for async responses * return true * }) */ const useRuntimeMessage = <T = any>(listener: MessageListener<T>): void => { const memoizedHandler = useCallback<MessageListener<T>>( (message, sender, sendResponse) => { return listener(message, sender, sendResponse) }, [listener], ) useEffect(() => { chrome.runtime.onMessage.addListener(memoizedHandler) return () => { chrome.runtime.onMessage.removeListener(memoizedHandler) } }, [memoizedHandler]) } export default useRuntimeMessage
```

# src/hooks/useWa.ts

```ts
import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' const useWa = () => { const { isReady, activeChat } = useAppStore() return { isReady, activeChat, ...wa, } } export default useWa
```

# src/hooks/useWindowMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = (event: MessageEvent<T>) => void const useWindowMessage = <T = any>(listener: MessageListener<T>): void => { const handleMessage = useCallback<MessageListener<T>>( (event) => { listener(event) }, [listener], ) useEffect(() => { window.addEventListener('message', handleMessage) return () => window.removeEventListener('message', handleMessage) }, [handleMessage]) } export default useWindowMessage
```

# src/libs/db.ts

```ts
// src/libs/db.ts import Dexie, { type EntityTable } from 'dexie' import packageJson from '../../package.json' export interface Media { id: number parentId: number type: string name: string file: File ext: string } export interface Broadcast { id: number name?: string | null type: string message: any isTyping: number isScheduler: number status: string delayMin?: number delayMax?: number pauseEnabled?: number pauseAfter?: number pauseDuration?: number pausedUntil?: Date | null } export interface BroadcastContact { id: number broadcastId: number number: string name?: string | null status: string error?: string | null scheduledAt?: Date | null sendAt?: Date | null } export interface BroadcastTemplate { id: number name: string type: string message: any } export interface BroadcastRecipient { id: number name: string recipients: { name: string; number: string; source: string }[] createdAt: Date } export interface Label { id: number label: string value: string show: number custom: number numbers?: any[] color?: string group?: string isPinned?: number } export interface DirectChatTemplate { id: number name: string message: string } export interface QuickReply { id: number name: string type: string message: any isPinned?: number createdAt?: Date } const db = new Dexie(packageJson.name) as Dexie & { media: EntityTable<Media, 'id'> broadcasts: EntityTable<Broadcast, 'id'> broadcastContacts: EntityTable<BroadcastContact, 'id'> broadcastTemplates: EntityTable<BroadcastTemplate, 'id'> broadcastRecipients: EntityTable<BroadcastRecipient, 'id'> labels: EntityTable<Label, 'id'> directChatTemplates: EntityTable<DirectChatTemplate, 'id'> quickReplies: EntityTable<QuickReply, 'id'> } // NOTE: Dexie cannot index boolean values. Fields intended for use in `where()` clauses // have been changed from `boolean` to `number` (0 for false, 1 for true). db.version(1).stores({ media: '++id, parentId, type, name, file, ext', broadcasts: '++id, name, type, message, isTyping, isScheduler, status, delayMin, delayMax, pauseEnabled, pauseAfter, pauseDuration, pausedUntil', broadcastContacts: '++id, broadcastId, number, name, status, error, scheduledAt, sendAt, [broadcastId+status]', broadcastTemplates: '++id, name, type, message', broadcastRecipients: '++id, name, createdAt', labels: '++id, label, value, show, custom, color, group, isPinned, *numbers', directChatTemplates: '++id, name', quickReplies: '++id, name, type, isPinned, createdAt', }) export default db
```

# src/libs/http.ts

```ts
import fetchAdapter from '@haverstack/axios-fetch-adapter' import axios from 'axios' const http = axios.create({ adapter: fetchAdapter, }) export default http
```

# src/libs/ls.ts

```ts
import * as lemon from '@lemonsqueezy/lemonsqueezy.js' lemon.lemonSqueezySetup({}) const lemonSqueezy = lemon export default lemonSqueezy
```

# src/libs/storage.ts

```ts
import { Storage } from '@plasmohq/storage' export const storage = new Storage({})
```

# src/libs/theme.ts

```ts
import { Button, createTheme, FileInput, Menu, Modal, MultiSelect, NumberInput, Popover, Radio, Select, Switch, TagsInput, Text, Textarea, TextInput, Tooltip, } from '@mantine/core' const theme = createTheme({ colors: { emerald: [ '#effbf3', '#ddf4e5', '#b6eac7', '#8cdfa7', '#6bd68c', '#56d07b', '#4acd72', '#3bb560', '#31a154', '#145229', ], }, primaryColor: 'teal', cursorType: 'pointer', components: { Button: Button.extend({ defaultProps: { size: 'sm', }, }), FileInput: FileInput.extend({ defaultProps: { size: 'md', }, }), Menu: Menu.extend({ defaultProps: { withinPortal: false } }), Modal: Modal.extend({ defaultProps: { size: 'xl', withCloseButton: false, withOverlay: false, withinPortal: false, }, }), NumberInput: NumberInput.extend({ defaultProps: { size: 'md' } }), MultiSelect: MultiSelect.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Popover: Popover.extend({ defaultProps: { withinPortal: false, }, }), Radio: Radio.extend({ defaultProps: { size: 'md', }, }), Select: Select.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Switch: Switch.extend({ defaultProps: { size: 'md', }, }), TagsInput: TagsInput.extend({ defaultProps: { size: 'md', }, }), Text: Text.extend({ defaultProps: { size: 'md', }, }), Textarea: Textarea.extend({ defaultProps: { size: 'md', }, }), TextInput: TextInput.extend({ defaultProps: { size: 'md', }, }), Tooltip: Tooltip.extend({ defaultProps: { position: 'left', withinPortal: false, withArrow: true, }, }), }, }) export default theme
```

# src/libs/wa/blocklist.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' export const all = async (): Promise<Wid[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.ALL, body: {}, }) } export const blockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.BLOCK_CONTACT, body: chatId, }) } export const isBlocked = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.IS_BLOCKED, body: chatId, }) } export const unblockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.UNBLOCK_CONTACT, body: chatId, }) }
```

# src/libs/wa/cart.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { SendMessageOptions } from '@wppconnect/wa-js/dist/chat' /** * Add product in cart * * @example * \`\`\`javascript * const cart = wa.cart.add('[number]@c.us', [ * { id: 'productId', qnt: 2 }, * ]); * \`\`\` */ export const add = async ( chatId: string, products: { id: string qnt: number }[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.ADD, body: { chatId, products }, }) } /** * Clear all items of cart * */ export const clear = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.CLEAR, body: wid, }) } /** * Get products in cart chat * * @example * \`\`\`javascript * const cart = wa.cart.get('[number]@c.us'); * \`\`\` */ export const get = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET, body: wid, }) } /** * Get thumb of a cart * * @example * \`\`\`javascript * const cart = wa.cart.getThumbFromCart('[number]@c.us'); * \`\`\` */ export const getThumbFromCart = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET_THUMB_FROM_CART, body: wid, }) } /** * Remove a product in cart * * @example * \`\`\`javascript * const cart = wa.cart.remove('[number]@c.us', '6987301181294productId'); * \`\`\` */ export const remove = async ( chatId: string, productId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.REMOVE, body: { chatId, productId }, }) } /** * Send a request order to business chat * * @example * \`\`\`javascript * const cart = wa.cart.submit('[number]@c.us'); * \`\`\` * * @example * \`\`\`javascript * // Send cart with a custom message * const cart = wa.cart.submit('[number]@c.us', 'Custom message here'); * \`\`\` */ export const submit = async ( wid: string, msg?: string, options?: SendMessageOptions, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.SUBMIT, body: { wid, msg, options }, }) } /** * Update product in cart * * @example * \`\`\`javascript * const cart = wa.cart.update('[number]@c.us', '6987301181294productId', { quantity: 12 }); * \`\`\` */ export const update = async ( chatId: string, productId: string, options: { quantity: number }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.UPDATE, body: { chatId, productId, options }, }) }
```

# src/libs/wa/catalog.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { createProductParams } from '@wppconnect/wa-js/dist/catalog/functions/createProduct' import type { editProductParams } from '@wppconnect/wa-js/dist/catalog/functions/editProduct' /** * Add image on product * This function include additional images on product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.addProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const addProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.ADD_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Add image on product * This function change main image of product * for change additional images use @addProductImage * * @example * \`\`\`javascript * await wa.catalog.changeProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const changeProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CHANGE_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Create new collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.createCollection('Collection Name', ['565656589898']); * \`\`\` */ export const createCollection = async ( collectionName: string, productsId: string[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_COLLECTION, body: { collectionName, productsId }, }) } /** * Create new product * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.addProduct( { name: 'Product name', image: 'base64 image string', description: 'product description', price: '89.90', isHidden: false, url: 'https://wppconnect.io', retailerId: 'AKA001', } ); * \`\`\` */ export const createProduct = async ( params: createProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_PRODUCT, body: params, }) } /** * Delete a collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.deleteCollection("377095767832354"); * \`\`\` * * @return Return sucess or error */ export const deleteCollection = async (collectionId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_COLLECTION, body: collectionId, }) } /** * @example * \`\`\`javascript * * // Delete various products * const myCatalog = await wa.catalog.delProducts(['6104203702939361', '6104289702939361']); * \`\`\` */ export const deleteProduct = async (productsIds: string[]): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_PRODUCT, body: productsIds, }) } /** * @example * \`\`\`javascript * const myCatalog = await wa.catalog.EditCollection('565656589898', { collectionName: 'New Name for collection', productsToAdd: ['5656523223'], productsToRemove: ['5656523232']}); * \`\`\` */ interface paramsEditCollection { name?: string productsToAdd?: string[] productsToRemove?: string[] } export const editCollection = async ( collectionId: string, params: paramsEditCollection, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_COLLECTION, body: { collectionId, params }, }) } /** * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = wa.catalog.editProduct('5498255476885590', {name: 'Plano 01', price: '89990', description: 'Insert description for your product', isHidden: true, url: 'http://www.wppconnect.io', retailerId: 'AKA001'}); * \`\`\` */ export const editProduct = async ( productId: string, params: editProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_PRODUCT, body: { productId, params }, }) } /** * Get collections of catalog * * @example * \`\`\`javascript * // Retrieve 20 collections of chat * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20'); * * // Retrieve 20 collections of chat and products arrays limit with 10 products * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20', '10'); * \`\`\` */ export const getCollections = async ( chatId: string, qnt?: number, productsCount?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_COLLECTIONS, body: { chatId, qnt, productsCount }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ export const getMyCatalog = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_MY_CATALOG, body: {}, }) } /** * Retrieves product by id * * @example * \`\`\`javascript * // Retrieve data of product * await wa.catalog.getProductById('5521985565656@c.us', '68685985868923'); * \`\`\` */ export const getProductById = async ( chatId: string, productId: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCT_BY_ID, body: { chatId, productId }, }) } /** * Retrieves product by contact id * * @example * Get products of catalogs * \`\`\`javascript * await wa.catalog.getProducts('5521985625689@c.us', 10); * \`\`\` */ export const getProducts = async (chatId: string, qnt: number): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCTS, body: { chatId, qnt }, }) } /** * Remove image on product * This function remove additional images of product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.removeProductImage('68685985868923', '0'); * \`\`\` */ export const removeProductImage = async ( productId: string, index: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.REMOVE_PRODUCT_IMAGE, body: { productId, index }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` */ export const setProductVisibility = async ( productId: any, isHidden: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.SET_PRODUCT_VISIBILITY, body: { productId, isHidden }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` * * @return Return sucess of product visibility set */ export const updateCartEnabled = async (enabled: boolean): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.UPDAGE_CART_ENABLED, body: enabled, }) }
```

# src/libs/wa/chat.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions, DeleteMessageReturn, ForwardMessagesOptions, GetMessagesOptions, RawMessage, } from '@wppconnect/wa-js/dist/chat' import type { ParticipantStatusACK } from '@wppconnect/wa-js/dist/chat/functions/getMessageACK' import type { Stringable } from '@wppconnect/wa-js/dist/types' import type { MsgKey, MsgModel, Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { ACK } from '@wppconnect/wa-js/dist/whatsapp/enums' /** * Archive a chat * * @example * // Archive a chat * wa.chat.archive('[number]@c.us'); * * // Unarchive a chat * wa.chat.archive('[number]@c.us', false); * \`\`\` */ export const archive = async ( chatId: string | Wid, archive = true, ): Promise<{ wid: Wid archive: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.ARCHIVE, body: { chatId, archive }, }) } /** * Get if message can played * * @example * \`\`\`javascript * wa.chat.canMarkPlayed('[message_id]'); * \`\`\` */ export const canMarkPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MARK_PLAYED, body: messageId, }) } /** * Check if is possible to mute this chat * * @example * \`\`\`javascript * const canMute = wa.chat.canMute('[number]@c.us'); * \`\`\` */ export const canMute = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MUTE, body: chatId, }) } /** * Get if message can reply * * @example * \`\`\`javascript * wa.chat.canReply('[message_id]'); * \`\`\` */ export const canReply = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_REPLY, body: messageId, }) } /** * Clear a chat message * */ export const clear = async ( chatId: string | Wid, keepStarred = true, ): Promise<{ wid: Wid status: number keepStarred: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLEAR, body: { chatId, keepStarred }, }) } /** * Close the chat tab * * @example * \`\`\`javascript * await wa.chat.closeChat(); * \`\`\` * */ export const closeChat = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLOSE_CHAT, body: {}, }) } /** * Delete a chat * */ export const _delete = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE, body: chatId, }) } /** * Delete a message * * @example * \`\`\`javascript * // Delete a message * wa.chat.deleteMessage('[number]@c.us', 'msgid'); * // Delete a list of messages * wa.chat.deleteMessage('[number]@c.us', ['msgid1', 'msgid2]); * // Delete a message and delete media * wa.chat.deleteMessage('[number]@c.us', 'msgid', true); * // Revoke a message * wa.chat.deleteMessage('[number]@c.us', 'msgid', true, true); * \`\`\` * */ export const deleteMessage = async ( chatId: string | Wid, ids: string | string[], deleteMediaInDevice = false, revoke = false, ): Promise<DeleteMessageReturn | DeleteMessageReturn[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE_MESSAGE, body: { chatId, ids, deleteMediaInDevice, revoke }, }) } /** * Downloads media from a message * * @example * \`\`\`javascript * await wa.chat.downloadMedia('messageId'); * \`\`\` */ export const downloadMedia = async ( messageId: string | MsgKey, ): Promise<Blob | null> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DOWNLOAD_MEDIA, body: messageId, }) } export const find = async (chatId: string | Wid): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FIND, body: chatId, }) } /** * Forward messages to a chat * * @example * \`\`\`javascript * // Forward messages * wa.chat.forwardMessage('[number]@c.us', 'true_[number]@c.us_ABCDEF'); * \`\`\` */ export const forwardMessage = async ( toChatId: string | Wid, msgId: string | MsgKey, options: ForwardMessagesOptions = {}, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FORWARD_MESSAGE, body: { toChatId, msgId, options }, }) } /** * Find a chat by id * */ export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET, body: chatId, }) } export const getActiveChat = async () => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_ACTIVE_CHAT, body: {}, }) } /** * Get timestamp of last seen * @example * \`\`\`javascript * wa.chat.getLastSeen('[number]@c.us'); * \`\`\` */ export const getLastSeen = async ( chatId: string | Wid, ): Promise<number | boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_LAST_SEEN, body: chatId, }) } /** * Get message ACK from a message * * @example * \`\`\`javascript * // Get message ACK * const ackInfo = await WPP.chat.getMessageACK('true_[number]@c.us_ABCDEF'); * * console.log(ackInfo.deliveryRemaining); // Delivery Remaining * console.log(ackInfo.readRemaining); // Read Remaining * console.log(ackInfo.playedRemaining); // PlayedRemaining, for audio(ptt) only * * console.log(ackInfo.participants[0].deliveredAt); // Delivered At, in timestamp format * console.log(ackInfo.participants[0].readAt); // Read At, in timestamp format * console.log(ackInfo.participants[0].playedAt); // Played At, in timestamp format, for audio(ptt) only * * //To get only how was received * const received = ackInfo.participants.filter(p => p.deliveredAt || p.readAt || p.playedAt); * * //To get only how was read * const read = ackInfo.participants.filter(p => p.readAt || p.playedAt); * * //To get only how was played * const played = ackInfo.participants.filter(p => p.playedAt); * \`\`\` */ export const getMessageACK = async ( msgId: string | MsgKey, ): Promise<{ ack: ACK fromMe: boolean deliveryRemaining: number readRemaining: number playedRemaining: number participants: ParticipantStatusACK[] }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGE_ACK, body: msgId, }) } /** * Fetch messages from a chat * * @example * \`\`\`javascript * // Some messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * }); * * // All messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * }); * * // Last 20 unread messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * onlyUnread: true, * }); * * // All unread messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * onlyUnread: true, * }); * * // 20 messages before specific message * wa.chat.getMessages('[number]@c.us', { * count: 20, * direction: 'before', * id: '<full message id>' * }); * * // Only media messages (url, document and links) * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'all', * }); * * // Only image messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'image', * }); * * // Only document messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'document', * }); * * // Only link (url) messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'url', * }); * \`\`\` */ export const getMessages = async ( chatId: string | Wid, options: GetMessagesOptions = {}, ): Promise<any[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGES, body: { chatId, options }, }) } /** * Get notes from a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.getNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const getNotes = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_NOTES, body: chatId, }) } /** * Get the platform message from message ID * * The platform can be: * * android * * iphone * * web * * unknown * * @example * \`\`\`javascript * // to get platform from a message * const platform = wa.chat.getPlatformFromMessage('[message_id]'); * \`\`\` */ export const getPlatformFromMessage = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<'android' | 'iphone' | 'web' | 'unknown'> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_PLATFORM_MESSAGE, body: messageId, }) } /** * Return a list of chats * * @example * \`\`\`javascript * // All chats * const chats = await wa.chat.list(); * * // Some chats * const chats = wa.chat.list({count: 20}); * * // 20 chats before specific chat * const chats = wa.chat.list({count: 20, direction: 'before', id: '[number]@c.us'}); * * // Only users chats * const chats = await wa.chat.list({onlyUsers: true}); * * // Only groups chats * const chats = await wa.chat.list({onlyGroups: true}); * * // Only communities chats * const chats = await wa.chat.list({onlyCommunities: true}); * * // Only Newsletter * const chats = await wa.chat.list({onlyNewsletter: true}); * * // Only with label Text * const chats = await wa.chat.list({withLabels: ['Test']}); * * // Only with label id * const chats = await wa.chat.list({withLabels: ['1']}); * * // Only with label with one of text or id * const chats = await wa.chat.list({withLabels: ['Alfa','5']}); * \`\`\` * */ export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.LIST, body: options, }) } /** * Mark a chat to composing state * and keep sending "is writting a message" * * @example * \`\`\`javascript * // Mark is composing * wa.chat.markIsComposing('[number]@c.us'); * * // Mark is composing for 5 seconds * wa.chat.markIsComposing('[number]@c.us', 5000); * \`\`\` */ export const markIsComposing = async ( chatId: string | Wid, duration?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_COMPOSING, body: { chatId, duration }, }) } /** * Mark a chat is paused state * * @example * \`\`\`javascript * // Mark as recording * wa.chat.markIsPaused('[number]@c.us'); * \`\`\` */ export const markIsPaused = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_PAUSED, body: chatId, }) } /** * Mark a chat as read and send SEEN event * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsRead('[number]@c.us'); * \`\`\` */ export const markIsRead = async ( chatId: string, ): Promise<{ wid: Wid unreadCount: number }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_READ, body: chatId, }) } /** * Mark a chat to recording state * and keep sending "is recording" * * @example * \`\`\`javascript * // Mark is recording * wa.chat.markIsRecording('[number]@c.us'); * * // Mark is recording for 5 seconds * wa.chat.markIsRecording('[number]@c.us', 5000); * \`\`\` */ export const markIsRecording = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_RECORDING, body: chatId, }) } /** * Mark a chat as unread * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsUnread('[number]@c.us'); * \`\`\` */ export const markIsUnread = async ( chatId: string | Wid, ): Promise<{ wid: Wid }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_UNREAD, body: chatId, }) } /** * Mark message as played * * @example * \`\`\`javascript * wa.chat.markPlayed('[message_id]'); * \`\`\` */ export const markPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_PLAYED, body: messageId, }) } /** * Mute a chat, you can use duration or expiration * For expiration, use unix timestamp (seconds only) * For duration, use seconds * * @example * \`\`\`javascript * // Mute for 60 seconds * wa.chat.mute('[number]@c.us', {duration: 60}); * * // Mute util 2021-01-01 * wa.chat.mute('[number]@c.us', {expiration: 1641006000}); * * // or using date * const expiration = new Date('2022-01-01 00:00:00'); * wa.chat.mute('[number]@c.us', {expiration: expiration}); * \`\`\` * */ export const mute = async ( chatId: string | Wid, time: { expiration: number | Date } | { duration: number }, ): Promise<{ wid: Wid expiration: number isMuted: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MUTE, body: { chatId, time }, }) } /** * Open the chat in the WhatsApp interface in a specific message * * @example * \`\`\`javascript * await wa.chat.openChatAt('[number]@c.us', <message_id>); * \`\`\` * */ export const openChatAt = async ( chatId: string | Wid, messageId: string, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_AT, body: { chatId, messageId }, }) } /** * Open the chat in the WhatsApp interface in bottom position * * @example * \`\`\`javascript * await wa.chat.openChatBottom('[number]@c.us'); * \`\`\` * */ export const openChatBottom = async ( chatId: string, ): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_BOTTOM, body: chatId, }) } /** * Open the chat in the WhatsApp interface from first unread message * * @example * \`\`\`javascript * await wa.chat.openChatFromUnread('[number]@c.us'); * \`\`\` * */ export const openChatFromUnread = async ( chatId: string | Wid, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_FROM_UNREAD, body: chatId, }) } /** * Pin a message in chat * * @example * \`\`\`javascript * // Pin a message in chat * wa.chat.pinMsg('true_[number]@c.us_ABCDEF'); * * // Pin a message in chat for 30 days * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', 2592000); * * // Unpin a message * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', false); * \`\`\` */ export const pinMsg = async ( msgId: string | MsgKey, pin = true, seconds = 604800, // default 7 days ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN_MSG, body: { msgId, pin, seconds }, }) } /** * Set custom Chat list in panel of whatsapp * * @example * \`\`\`javascript * // Your custom list * wa.chat.setChatList('custom', ['number@c.us', 'number2@c.us']); * * // List only with unread chats * wa.chat.setChatList('unread'); * * // List only with favorites chats * wa.chat.setChatList('favorites'); * * // List only with groups chats * wa.chat.setChatList('group'); * * // List only labels chat * wa.chat.setChatList('labels', '454545_labelId'); * \`\`\` */ export const setChatList = async (type: string, ids?: string | string[]) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_CHAT_LIST, body: { type, ids }, }) } export const setInputText = async (text: string, chatId?: string | Wid) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_INPUT_TEXT, body: { text, chatId }, }) } /** * Set notes for a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.setNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const setNotes = async ( chatId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_NOTES, body: { chatId, content }, }) }
```

# src/libs/wa/conn.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Alternative login method using code * Get the Link Device Code for Authentication using the phone number * * @example * \`\`\`javascript * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]'); * * // Disable push notification * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]', false); * \`\`\` */ export const genLinkDeviceCodeForPhoneNumber = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }) } /** * Return the current auth code * * @example * \`\`\`javascript * const authCode = await wa.conn.getAuthCode(); * console.log(authCode.fullCode); // Output: a long string to generate a QRCode * \`\`\` */ export const getAuthCode = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_AUTH_CODE, }) } export const getMyUserId = async (): Promise<Wid | undefined> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_MY_USER_ID, }) }
```

# src/libs/wa/contact.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ContactListOptions } from '@wppconnect/wa-js/dist/contact' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Get a contact by id * * @example * \`\`\`javascript * await wa.contact.get('[number]@c.us'); * \`\`\` * */ export const get = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET, body: contactId, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getBusinessProfile('[number]@c.us'); * \`\`\` * */ export const getBusinessProfile = async ( contactId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_BUSINESS_PROFILE, body: contactId, }) } /** * Get all commons groups for the contact * * @example * \`\`\`javascript * const groups_ids = await wa.contact.getCommonGroups('[number]@c.us'); * \`\`\` * */ export const getCommonGroups = async (wid: Wid | string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_COMMON_GROUPS, body: wid, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getProfilePictureUrl('[number]@c.us'); * \`\`\` * */ export const getProfilePictureUrl = async ( contactId: string | Wid, full = true, ): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_PROFILE_PICTURE_URL, body: { contactId, full }, }) } /** * Get the current text status * * @example * \`\`\`javascript * await wa.contact.getStatus('[number]@c.us'); * \`\`\` */ export const getStatus = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_STATUS, body: contactId, }) } export const list = async (options: ContactListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.LIST, body: options, }) } export const isExist = async (contactId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.IS_EXIST, body: contactId, }) }
```

# src/libs/wa/group.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions } from '@wppconnect/wa-js/dist/chat' import type { GroupProperty } from '@wppconnect/wa-js/dist/group' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Add one or more participants to a group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.addParticipants('[group@g.us]', [number@c.us]); * * // Get participant result: * console.log(result['123@c.us'].code); * console.log(result['123@c.us'].invite_code); * console.log(result['123@c.us'].invite_code_exp); * console.log(result['123@c.us'].message); * console.log(result['123@c.us'].wid); * * const memberResult = result['123@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['123@c.us'].invite_code; * console.log(link); * \`\`\` */ export const addParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.ADD_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Approve a membership request to group * * @example * \`\`\`javascript * await wa.group.approve(12345645@g.us, 5554999999999@c.us); * \`\`\` * */ export const approve = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.APPROVE, body: { groupId, membershipIds }, }) } /** * Check if your account is allowed to add new participants * * @example * \`\`\`javascript * const result = await wa.group.canAdd('group@g.us'); * console.log(result); * \`\`\` */ export const canAdd = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_ADD, body: groupId, }) } /** * Check if your account is allowed to demote participants * * @example * \`\`\`javascript * await wa.group.canDemote('group@g.us'); * console.log(result); * \`\`\` */ export const canDemote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_DEMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to promote participants * * @example * \`\`\`javascript * await WPP.group.canPromote('group@g.us'); * console.log(result); * \`\`\` * */ export const canPromote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_PROMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to remove participants * * @example * \`\`\`javascript * const result = await wa.group.canRemove('group@g.us'); * console.log(result); * \`\`\` */ export const canRemove = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_REMOVE, body: { groupId, participantsIds }, }) } /** * Create a new group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.create('Test Group', ['number@c.us']); * * console.log(result.gid.toString()); // Get the group ID * * // Get participant result: * console.log(result['number@c.us'].code); * console.log(result['number@c.us'].invite_code); * console.log(result['number@c.us'].invite_code_exp); * console.log(result['number@c.us'].message); * console.log(result['number@c.us'].wid); * * const memberResult = result['number@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['number@c.us'].invite_code; * console.log(link); * * // Create a Subgroup for a community * const result = await wa.group.create('Test Group', ['number@c.us'], 'communit@g.us'); * \`\`\` */ export const create = async ( groupName: string, participantsIds: (string | Wid) | (string | Wid)[], parentGroup: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CREATE, body: { groupName, participantsIds, parentGroup }, }) } /** * @example * \`\`\`javascript * // One member * await wa.group.demoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.demoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const demoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.DEMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Get group info from an inviteCode * * @example * \`\`\`javascript * await wa.group.getGroupInfoFromInviteCode('<inviteCode>'); * \`\`\` */ export const getGroupInfoFromInviteCode = async ( inviteCode: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, body: inviteCode, }) } /** * Get the max number of participants for a group * * @example * \`\`\`javascript * const limit = await wa.group.getGroupSizeLimit(); * console.log(limit); * \`\`\` */ export const getGroupSizeLimit = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_SIZE_LIMIT, body: {}, }) } export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LIST, }) } /** * @description Sends a request to the background script to get a group's invite link. * @param groupId The ID of the group (e.g., '1234567890@g.us'). * @returns A promise that resolves with the invite link string. */ export const getInviteLink = async (groupId: string): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_INVITE_LINK, body: { groupId }, }) } /** * Retrieve a lista of a membership approval requests * * @example * \`\`\`javascript * await wa.group.getMembershipRequests(12345645@g.us); * \`\`\` */ export const getMembershipRequests = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_MEMBERSHIP_REQUESTS, body: groupId, }) } /** * Get an array of participants of a group * * @example * \`\`\`javascript * wa.group.getParticipants('[group-id]@g.us'); * \`\`\` */ export const getParticipants = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_PARTICIPANTS, body: groupId, }) } export const iAmAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_ADMIN, body: groupId, }) } export const iAmMember = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_MEMBER, body: groupId, }) } export const iAmRestrictedMember = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_RESTRICTED_MEMBER, body: groupId, }) } export const iAmSuperAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_SUPER_ADMIN, body: groupId, }) } /** * Join in a group from an invite code. * * @example * \`\`\`javascript * await wa.group.join('abcde....'); * \`\`\` */ export const join = async (inviteCode: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.JOIN, body: inviteCode, }) } /** * Leave from a group. * * @example * \`\`\`javascript * await wa.group.leave('[number]@g.us'); * \`\`\` */ export const leave = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LEAVE, body: groupId, }) } /** * Promote group member to admin * * @example * \`\`\`javascript * // One member * await wa.group.promoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.promoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` * * @category Group */ export const promoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.PROMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Reject a membership request to group * * @example * \`\`\`javascript * await wa.group.reject(12345645@g.us, 5554999999999@c.us); * \`\`\` */ export const reject = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REJECT, body: { groupId, membershipIds }, }) } /** * Remove the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.removeIcon('[group@g.us]'); * \`\`\` */ export const removeIcon = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_ICON, body: groupId, }) } /** * Remove participants of a group * * @example * \`\`\`javascript * // One member * await wa.group.removeParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.removeParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const removeParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Revoke the current invite code and generate new one. * * @example * \`\`\`javascript * const code = WPP.group.revokeInviteCode('[group-id]@g.us'); * const link = 'https://chat.whatsapp.com/' + code; * \`\`\` */ export const revokeInviteCode = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REVOKE_INVITE_CODE, body: groupId, }) } /** * Define the group description * * @example * \`\`\`javascript * await wa.group.setDescription('[group-id]@g.us', 'new group description'); * \`\`\` */ export const setDescription = async ( groupId: string | Wid, description: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_DESCRIPTION, body: { groupId, description }, }) } /** * Set the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.setIcon('[group@g.us]', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const setIcon = async ( groupId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_ICON, body: { groupId, content }, }) } /** * Set the group property * * @example * \`\`\`javascript * // Only admins can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', true); * * // All can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', false); * * // Disatble temporary messages * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 0); * * // Enable temporary messages for 24 hours * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 86400); * * // Enable temporary messages for 7 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 604800); * * // Enable temporary messages for 90 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 7776000); * * // Only admins can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', true); * * // All can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', false); * \`\`\` */ export const setProperty = async ( groupId: string | Wid, property: GroupProperty, value: 0 | 1 | 86400 | 604800 | 7776000 | boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_PROPERTY, body: { groupId, property, value }, }) } /** * Define the group subject * * @example * \`\`\`javascript * await wa.group.setSubject('[group-id]@g.us', 'new group subject'); * \`\`\` */ export const setSubject = async ( groupId: string | Wid, subject: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_SUBJECT, body: { groupId, subject }, }) }
```

# src/libs/wa/index.ts

```ts
import * as chat from './chat' import * as conn from './conn' import * as contact from './contact' import * as group from './group' import * as on from './on' import * as send from './send' export default { on, conn, send, contact, chat, group, }
```

# src/libs/wa/newsletter.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' /** * Create a newsletter * * @example * \`\`\`javascript * // To edit name * wa.newsletter.create('Name for your newsletter', { * description: 'Description for that', * picture: '<base64_string', * }); * \`\`\` */ export const create = async ( name: string, opts: { description?: string; picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.CREATE, body: { name, opts }, }) } /** * Delete a newsletter * * @example * \`\`\`javascript * const code = wa.newsletter.destroy('[newsletter-id]@newsletter'); * \`\`\` */ export const destroy = async (id: string): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.DESTROY, body: id, }) } /** * Edit the newsletter data * * @example * \`\`\`javascript * // To edit name * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * name: 'New Name' * }); * * // To edit description * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * description: 'New description' * }); * * // To change picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: '<base64_image>' * }); * * // To remove picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: null * }); * \`\`\` */ export const edit = async ( newsletterId: string, opts: { name?: string description?: string picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.EDIT, body: { newsletterId, opts }, }) } /** * Get subscribers of a newsletters * * @example * \`\`\`javascript * const code = wa.newsletter.getSubscribers('[newsletter-id]@newsletter'); * \`\`\` */ export const getSubscribers = async (id: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.GET_SUBSCRIBERS, body: id, }) } /** * Mute and unmute a newsletter * * @example * // Mute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', true); * \`\`\` * * // Unmute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', false); * \`\`\` */ export const mute = async ( newsletterId: string, value?: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.MUTE, body: { newsletterId, value }, }) }
```

# src/libs/wa/on.ts

```ts
export const ready = (callback = () => {}) => { const targetSelector = '#side' // WhatsApp left-panel root const node = document.querySelector(targetSelector) if (node) { require('@wppconnect/wa-js/dist/wppconnect-wa') callback() return } // Wait for the node to appear only once const observer = new MutationObserver(() => { const el = document.querySelector(targetSelector) if (el) { console.log('âœ…âœ…âœ…âœ…âœ…') observer.disconnect() // stop watching require('@wppconnect/wa-js/dist/wppconnect-wa') callback() } }) observer.observe(document.body, { childList: true, subtree: true, }) }
```

# src/libs/wa/profile.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { BusinessProfileModel } from '@wppconnect/wa-js/dist/whatsapp' /** * Update your business profile * * @example * \`\`\`javascript * await wa.profile.editBusinessProfile({description: 'New description for profile'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({categories: { id: "133436743388217", localized_display_name: "Artes e entretenimento", not_a_biz: false, }}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({email: 'test@test.com.br'}); * \`\`\` * * Change website of profile (max 2 sites) * \`\`\`javascript * await wa.profile.editBusinessProfile({website: [ "https://www.wppconnect.io", "https://www.teste2.com.br", ]}); * \`\`\` * * Change businessHours for Specific Hours * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { * { tue: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, wed: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, thu: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, fri: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sat: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sun: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, } }, timezone: "America/Sao_Paulo" }); * * Change businessHours for Always Opened * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "open_24h", }, tue: { mode: "open_24h", }, wed: { mode: "open_24h", }, thu: { mode: "open_24h", }, fri: { mode: "open_24h", }, sat: { mode: "open_24h", }, sun: { mode: "open_24h", }, } timezone: "America/Sao_Paulo" }); * * Change businessHours for Appointment Only * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "appointment_only", }, tue: { mode: "appointment_only", }, wed: { mode: "appointment_only", }, thu: { mode: "appointment_only", }, fri: { mode: "appointment_only", }, sat: { mode: "appointment_only", }, sun: { mode: "appointment_only", }, } timezone: "America/Sao_Paulo" }); * * */ export const editBusinessProfile = async ( params: BusinessProfileModel, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.EDIT_BUSINESS_PROFILE, body: params, }) } /** * Get your current profile name * * @example * \`\`\`javascript * const myProfileName = wa.profile.getMyProfileName(); * \`\`\` */ export const getMyProfileName = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_NAME, body: {}, }) } /** * Get your current profile picture * * @example * \`\`\`javascript * await wa.profile.getMyProfilePicture(); * \`\`\` */ export const getMyProfilePicture = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_PICTURE, body: {}, }) } /** * Get your current text status * * @example * \`\`\`javascript * await wa.profile.getMyStatus(); * \`\`\` */ export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_STATUS, body: {}, }) } /** * Return the current logged user is Bussiness or not * * @example * \`\`\`javascript * wa.profile.isBusiness(); * \`\`\` */ export const isBusiness = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.IS_BUSINESS, body: {}, }) } /** * Remove your profile picture * * @example * \`\`\`javascript * await wa.profile.removeMyProfilePicture(); * \`\`\` */ export const removeMyProfilePicture = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.REMOVE_MY_PROFILE_PICTURE, body: {}, }) } /** * Update your current profile name * * @example * \`\`\`javascript * await wa.profile.setMyProfileName('My new name'); * \`\`\` */ export const setMyProfileName = async (name: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_NAME, body: {}, }) } /** * Update your profile picture * * @example * \`\`\`javascript * await wa.profile.setMyProfilePicture('data:image/jpeg;base64,.....'); * \`\`\` */ export const setMyProfilePicture = async (content: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_PICTURE, body: content, }) } /** * Update your current text status * * @example * \`\`\`javascript * await wa.profile.setMyStatus('Example text'); * \`\`\` */ export const setMyStatus = async (statusText: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_STATUS, body: statusText, }) }
```

# src/libs/wa/send.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { AudioMessageOptions, AutoDetectMessageOptions, DocumentMessageOptions, ImageMessageOptions, LocationMessageOptions, PoolMessageOptions, SendMessageOptions, StickerMessageOptions, TextMessageOptions, VCardContact, VideoMessageOptions, } from '@wppconnect/wa-js/dist/chat' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { SendMsgResult } from '@wppconnect/wa-js/dist/whatsapp/enums' export const text = async ( chatId: any, content: any, options: TextMessageOptions = {}, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.TEXT, body: { chatId, content, options, }, }) } export const file = async ( chatId: string | Wid, content: string | Blob | File, options: | AutoDetectMessageOptions | AudioMessageOptions | DocumentMessageOptions | ImageMessageOptions | VideoMessageOptions | StickerMessageOptions | TextMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.FILE, body: { chatId, content, options, }, }) } export const location = async ( chatId: string | Wid, options: LocationMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.LOCATION, body: { chatId, options, }, }) } export const poll = async ( chatId: any, name: string, choices: string[], options?: PoolMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.POLL, body: { chatId, name, choices, options, }, }) } export const vcard = async ( chatId: string | Wid, contacts: string | Wid | VCardContact | (string | Wid | VCardContact)[], options?: SendMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.VCARD, body: { chatId, contacts, options, }, }) }
```

# src/libs/wa/status.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ImageStatusOptions, TextStatusOptions, VideoStatusOptions, } from '@wppconnect/wa-js/dist/status' import type { MsgKey, Wid } from '@wppconnect/wa-js/dist/whatsapp' export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET, body: chatId, }) } export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET_MY_STATUS, body: {}, }) } export const remove = async (msgId: string | MsgKey): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.REMOVE, body: msgId, }) } /** * Send a image message to status stories * * @example * \`\`\`javascript * wa.status.sendImageStatus('data:image/jpeg;base64,<a long base64 file...>'); * \`\`\` */ export const sendImageStatus = async ( content: any, options: ImageStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_IMAGE_STATUS, body: { content, options }, }) } /** * Mark status as read/seen * * @example * \`\`\`javascript * wa.status.sendReadStatus('[phone_number]@c.us', 'false_status@broadcast_3A169E0FD4BC6E92212F_5521526232927@c.us'); * \`\`\` */ export const sendReadStatus = async ( chatId: string | Wid, statusId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_READ_STATUS, body: { chatId, statusId }, }) } /** * Send a text message to status stories * * @example * \`\`\`javascript * wa.status.sendTextStatus(`Bootstrap primary color: #0275d8`, { backgroundColor: '#0275d8', font: 2}); * \`\`\` */ export const sendTextStatus = async ( content: any, options: TextStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_TEXT_STATUS, body: { content, options }, }) } /** * Send a video message to status stories * * @example * \`\`\`javascript * wa.status.sendVideoStatus('data:video/mp4;base64,<a long base64 file...>'); * \`\`\` */ export const sendVideoStatus = async ( content: any, options: VideoStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_VIDEO_STATUS, body: { content, options }, }) } /** * Define a custom list of participants to send the status message * * @example * \`\`\`javascript * // Use a custom list * await wa.status.updateParticipants(['123@c.us', '456@c.us']); * // Use the contacts by default * await wa.status.updateParticipants(null); * \`\`\` */ export const updateParticipants = async ( ids?: (string | Wid)[] | null, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.UPDATE_PARTICIPANTS, body: ids, }) }
```

# src/relays/blocklist.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const blockContact = () => { relay( { name: Action.Blocklist.BLOCK_CONTACT, }, async ({ body }) => { return await WPP.blocklist.blockContact(body) }, ) } const isBlocked = () => { relay( { name: Action.Blocklist.IS_BLOCKED, }, async ({ body }) => { return WPP.blocklist.isBlocked(body) }, ) } const unblockContact = () => { relay( { name: Action.Blocklist.UNBLOCK_CONTACT, }, async ({ body }) => { return WPP.blocklist.unblockContact(body) }, ) } const initBlocklistRelays = () => { all() blockContact() isBlocked() unblockContact() } export default initBlocklistRelays
```

# src/relays/cart.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const add = () => { relay( { name: Action.Cart.ADD, }, async ({ body }) => { const { chatId, products } = body return await WPP.cart.add(chatId, products) }, ) } const clear = () => { relay( { name: Action.Cart.CLEAR, }, async ({ body }) => { return await WPP.cart.clear(body) }, ) } const get = () => { relay( { name: Action.Cart.GET, }, async ({ body }) => { return WPP.cart.get(body) }, ) } const getThumbFromCart = () => { relay( { name: Action.Cart.GET_THUMB_FROM_CART, }, async ({ body }) => { return await WPP.cart.getThumbFromCart(body) }, ) } const remove = () => { relay( { name: Action.Cart.REMOVE, }, async ({ body }) => { const { chatId, productId } = body return WPP.cart.remove(chatId, productId) }, ) } const submit = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { wid, msg, options } = body return WPP.cart.submit(wid, msg, options) }, ) } const update = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { chatId, productId, options } = body return WPP.cart.update(chatId, productId, options) }, ) } const initCartRelays = () => { add() clear() get() getThumbFromCart() remove() submit() update() } export default initCartRelays
```

# src/relays/catalog.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const addProductImage = () => { relay( { name: Action.Catalog.ADD_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.addProductImage(productId, content) }, ) } const changeProductImage = () => { relay( { name: Action.Catalog.CHANGE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.changeProductImage(productId, content) }, ) } const createCollection = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { const { collectionName, productsId } = body return await WPP.catalog.createCollection(collectionName, productsId) }, ) } const createProduct = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.createProduct(body) }, ) } const deleteCollection = () => { relay( { name: Action.Catalog.DELETE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.deleteCollection(body) }, ) } const deleteProduct = () => { relay( { name: Action.Catalog.DELETE_PRODUCT, }, async ({ body }) => { return await WPP.catalog.delProducts(body) }, ) } const editCollection = () => { relay( { name: Action.Catalog.EDIT_COLLECTION, }, async ({ body }) => { const { collectionId, params } = body return await WPP.catalog.editCollection(collectionId, params) }, ) } const editProduct = () => { relay( { name: Action.Catalog.EDIT_PRODUCT, }, async ({ body }) => { const { productId, params } = body return await WPP.catalog.editProduct(productId, params) }, ) } const getCollections = () => { relay( { name: Action.Catalog.GET_COLLECTIONS, }, async ({ body }) => { const { chatId, qnt, productsCount } = body return await WPP.catalog.getCollections(chatId, qnt, productsCount) }, ) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ const getMyCatalog = () => { relay( { name: Action.Catalog.GET_MY_CATALOG, }, async ({ body }) => { return await WPP.catalog.getMyCatalog() }, ) } const getProductById = () => { relay( { name: Action.Catalog.GET_PRODUCT_BY_ID, }, async ({ body }) => { const { chatId, productId } = body return await WPP.catalog.getProductById(chatId, productId) }, ) } const getProducts = () => { relay( { name: Action.Catalog.GET_PRODUCTS, }, async ({ body }) => { const { chatId, qnt } = body return await WPP.catalog.getProducts(chatId, qnt) }, ) } const removeProductImage = () => { relay( { name: Action.Catalog.REMOVE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, index } = body return await WPP.catalog.removeProductImage(productId, index) }, ) } const setProductVisibility = () => { relay( { name: Action.Catalog.SET_PRODUCT_VISIBILITY, }, async ({ body }) => { const { productId, isHidden } = body return await WPP.catalog.setProductVisibility(productId, isHidden) }, ) } const updateCartEnabled = () => { relay( { name: Action.Catalog.UPDAGE_CART_ENABLED, }, async ({ body }) => { return await WPP.catalog.updateCartEnabled(body) }, ) } const initCatalogRelays = () => { addProductImage() changeProductImage() createCollection() createProduct() deleteCollection() deleteProduct() editCollection() editProduct() getCollections() getMyCatalog() getProductById() getProducts() removeProductImage() setProductVisibility() updateCartEnabled() } export default initCatalogRelays
```

# src/relays/chat.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const archive = () => { relay( { name: Action.Chat.ARCHIVE, }, async ({ body }) => { return await WPP.chat.archive(body) }, ) } const canMarkPlayed = () => { relay( { name: Action.Chat.CAN_MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.canMarkPlayed(body) }, ) } const canMute = () => { relay( { name: Action.Chat.CAN_MUTE, }, async ({ body }) => { return WPP.chat.canMute(body) }, ) } const canReply = () => { relay( { name: Action.Chat.CAN_REPLY, }, async ({ body }) => { return await WPP.chat.canReply(body) }, ) } const clear = () => { relay( { name: Action.Chat.CLEAR, }, async ({ body }) => { return await WPP.chat.clear(body) }, ) } const closeChat = () => { relay( { name: Action.Chat.CLOSE_CHAT, }, async ({ body }) => { return await WPP.chat.closeChat() }, ) } const _delete = () => { relay( { name: Action.Chat.DELETE, }, async ({ body }) => { return await WPP.chat.delete(body) }, ) } const deleteMessage = () => { relay( { name: Action.Chat.DELETE_MESSAGE, }, async ({ body }) => { const { chatId, ids, deleteMediaInDevice, revoke } = body return await WPP.chat.deleteMessage( chatId, ids, deleteMediaInDevice, revoke, ) }, ) } const list = () => { relay( { name: Action.Chat.LIST, }, async ({ body }) => { console.log('body', body) return (await WPP.chat.list(body)).map(serialize.chat) }, ) } const find = () => { relay( { name: Action.Chat.FIND, }, async (req) => { try { const chatId = req.body const chat = await WPP.chat.find(chatId) return response.success(serialize.chat(chat)) } catch (error) { return response.error(error.message) } }, ) } const forwardMessage = () => { relay( { name: Action.Chat.FORWARD_MESSAGE, }, async ({ body }) => { const { toChatId, msgId, options } = body return await WPP.chat.forwardMessage(toChatId, msgId, options) }, ) } const get = () => { relay( { name: Action.Chat.GET, }, async ({ body }) => { try { const chat = WPP.chat.get(body) return serialize.chat(chat) } catch (error) {} }, ) } const getActiveChat = () => { relay( { name: Action.Chat.GET_ACTIVE_CHAT, }, async (req) => { try { const chat = WPP.chat.getActiveChat() if (!chat) { return null } return serialize.chat(chat) } catch (error) { return null } }, ) } const getLastSeen = () => { relay( { name: Action.Chat.GET_LAST_SEEN, }, async ({ body }) => { return await WPP.chat.getLastSeen(body) }, ) } const getMessageACK = () => { relay( { name: Action.Chat.GET_MESSAGE_ACK, }, async ({ body }) => { return await WPP.chat.getMessageACK(body) }, ) } const getMessages = () => { relay( { name: Action.Chat.GET_MESSAGES, }, async ({ body }) => { const { chatId, options } = body const messages = await WPP.chat.getMessages(chatId, options) return messages.map(serialize.message) }, ) } const getNotes = () => { relay( { name: Action.Chat.GET_NOTES, }, async ({ body }) => { return await WPP.chat.getNotes(body) }, ) } const getPlatformFromMessage = () => { relay( { name: Action.Chat.GET_PLATFORM_MESSAGE, }, async ({ body }) => { return WPP.chat.getPlatformFromMessage(body) }, ) } const markIsComposing = () => { relay( { name: Action.Chat.MARK_IS_COMPOSING, }, async ({ body }) => { const { chatId, duration } = body return WPP.chat.markIsComposing(chatId, duration) }, ) } const markIsPaused = () => { relay( { name: Action.Chat.MARK_IS_PAUSED, }, async ({ body }) => { return await WPP.chat.markIsPaused(body) }, ) } const markIsRead = () => { relay( { name: Action.Chat.MARK_IS_READ, }, async ({ body }) => { return await WPP.chat.markIsRead(body) }, ) } const markIsRecording = () => { relay( { name: Action.Chat.MARK_IS_RECORDING, }, async ({ body }) => { return await WPP.chat.markIsRecording(body) }, ) } const markIsUnread = () => { relay( { name: Action.Chat.MARK_IS_UNREAD, }, async ({ body }) => { return await WPP.chat.markIsUnread(body) }, ) } const markPlayed = () => { relay( { name: Action.Chat.MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.markPlayed(body) }, ) } const mute = () => { relay( { name: Action.Chat.MUTE, }, async ({ body }) => { const { chatId, time } = body return await WPP.chat.mute(chatId, time) }, ) } const openChatAt = () => { relay( { name: Action.Chat.OPEN_CHAT_AT, }, async ({ body }) => { const { chatId, messageId } = body return await WPP.chat.openChatAt(chatId, messageId) }, ) } const openChatFromUnread = () => { relay( { name: Action.Chat.OPEN_CHAT_FROM_UNREAD, }, async ({ body }) => { return await WPP.chat.openChatFromUnread(body) }, ) } const pinMsg = () => { relay( { name: Action.Chat.PIN_MSG, }, async ({ body }) => { const { msgId, pin, seconds } = body return await WPP.chat.pinMsg(msgId, pin, seconds) }, ) } const openChatBottom = () => { relay( { name: Action.Chat.OPEN_CHAT_BOTTOM, }, async (req) => { try { const chatId = req.body return await WPP.chat.openChatBottom(chatId) } catch (error) { return false } }, ) } const setChatList = () => { relay( { name: Action.Chat.SET_CHAT_LIST, }, async (req) => { try { const { type, ids } = req.body await WPP.chat.setChatList(type, ids) } catch (error) { console.error(`setChatList: ${error}`) } }, ) } const setInputText = () => { relay( { name: Action.Chat.SET_INPUT_TEXT, }, async ({ body }) => { const { text, chatId } = body return await WPP.chat.setInputText(text, chatId) }, ) } const setNotes = () => { relay( { name: Action.Chat.SET_NOTES, }, async ({ body }) => { const { chatId, content } = body return await WPP.chat.setNotes(chatId, content) }, ) } const downloadMedia = () => { relay( { name: Action.Chat.DOWNLOAD_MEDIA, }, async ({ body: messageId }) => { try { const media = await Promise.race([ WPP.chat.downloadMedia(messageId), new Promise((_, reject) => setTimeout(() => reject(new Error('Error download media')), 3000), ), ]) return media } catch (error) { return null } }, ) } const initChatRelay = () => { archive() canMarkPlayed() canMute() canReply() clear() closeChat() _delete() deleteMessage() downloadMedia() find() forwardMessage() get() getActiveChat() getLastSeen() getMessageACK() getMessages() getNotes() getPlatformFromMessage() markIsComposing() markIsPaused() markIsRead() markIsRecording() markIsUnread() markPlayed() mute() list() openChatBottom() openChatAt() openChatFromUnread() pinMsg() setChatList() setInputText() setNotes() } export default initChatRelay
```

# src/relays/community.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const initCommunityRelays = () => { all() } export default initCommunityRelays
```

# src/relays/conn.relay.ts

```ts
import { Account, Action } from '@/constants' import country from '@/utils/country' import { delay } from '@/utils/util' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const genLinkDeviceCodeForPhoneNumber = () => { relay( { name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }, async ({ body }) => { const { phone, sendPushNotification } = body return await WPP.conn.genLinkDeviceCodeForPhoneNumber( phone, sendPushNotification, ) }, ) } const getAuthCode = () => { relay( { name: Action.Conn.GET_AUTH_CODE, }, async ({ body }) => { return await WPP.conn.getAuthCode() }, ) } const getMyUserId = () => { relay( { name: Action.Conn.GET_MY_USER_ID, }, async (req) => { return WPP.conn.getMyUserId() }, ) } const getProfile = () => { relay( { name: Action.Conn.GET_PROFILE, }, async (req) => { await delay(1000) const { user: number } = WPP.conn.getMyUserId() const contact = await WPP.contact.get(`${number}@c.us`) const countryCode = await WPP.whatsapp.functions.getCountryShortcodeByPhone(contact.id.user) const selectedCountry = country.getCountryByCode(countryCode) return { name: contact.pushname || contact.formattedName || contact.name || contact.verifiedName, number, type: contact.isBusiness ? Account.BUSINESS : Account.PERSONAL, country: selectedCountry.label, } }, ) } const initConnRelays = () => { genLinkDeviceCodeForPhoneNumber() getAuthCode() getMyUserId() getProfile() } export default initConnRelays
```

# src/relays/contact.relay.ts

```ts
import { Action } from '@/constants' import filterBy from '@/utils/filterBy' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Contact.GET, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getBusinessProfile = () => { relay( { name: Action.Contact.GET_BUSINESS_PROFILE, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getCommonGroups = () => { relay( { name: Action.Contact.GET_COMMON_GROUPS, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getProfilePictureUrl = () => { relay( { name: Action.Contact.GET_PROFILE_PICTURE_URL, }, async ({ body }) => { const { contactId, full } = body return await WPP.contact.getProfilePictureUrl(contactId, full) }, ) } const getStatus = () => { relay( { name: Action.Contact.GET_STATUS, }, async ({ body }) => { return await WPP.contact.getStatus(body) }, ) } const list = () => { relay( { name: Action.Contact.LIST, }, async (req) => { const options = req.body const contacts = ((await WPP.contact.list(options)) ?? []) .filter(filterBy.dontIncludeLid) .map(serialize.contact) return contacts }, ) } const isExist = () => { relay( { name: Action.Contact.IS_EXIST, }, async (req) => { try { const contactId = req.body const result = await WPP.contact.queryExists(contactId) return !!result } catch (error) { return false } }, ) } const initContactRelay = () => { get() getBusinessProfile() getCommonGroups() getProfilePictureUrl() getStatus() isExist() list() } export default initContactRelay
```

# src/relays/group.relay.ts

```ts
import { Action } from '@/constants' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const addParticipants = () => { relay( { name: Action.Group.ADD_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.addParticipants(groupId, participantsIds) }, ) } const approve = () => { relay( { name: Action.Group.APPROVE, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.approve(groupId, membershipIds) }, ) } const canAdd = () => { relay( { name: Action.Group.CAN_ADD, }, async ({ body }) => { return await WPP.group.canAdd(body) }, ) } const canDemote = () => { relay( { name: Action.Group.CAN_DEMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canDemote(groupId, participantsIds) }, ) } const canPromote = () => { relay( { name: Action.Group.CAN_PROMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canPromote(groupId, participantsIds) }, ) } const canRemove = () => { relay( { name: Action.Group.CAN_REMOVE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canRemove(groupId, participantsIds) }, ) } const create = () => { relay( { name: Action.Group.CREATE, }, async ({ body }) => { const { groupName, participantsIds, parentGroup } = body return await WPP.group.create(groupName, participantsIds, parentGroup) }, ) } const demoteParticipants = () => { relay( { name: Action.Group.DEMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.demoteParticipants(groupId, participantsIds) }, ) } const getGroupInfoFromInviteCode = () => { relay( { name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, }, async ({ body }) => { return await WPP.group.getGroupInfoFromInviteCode(body) }, ) } const getGroupSizeLimit = () => { relay( { name: Action.Group.GET_GROUP_SIZE_LIMIT, }, async ({ body }) => { return await WPP.group.getGroupSizeLimit() }, ) } const list = () => { relay( { name: Action.Group.LIST, }, async ({ body }) => { const list = await WPP.chat.list(body) if (!list) { return [] } return list.map(serialize.chat) }, ) } const getInviteLink = () => { relay( { name: Action.Group.GET_INVITE_LINK, }, async (req) => { try { const { groupId } = req.body const link = await WPP.group.getInviteCode(groupId) return `https://chat.whatsapp.com/${link}` } catch (error) { console.error(`getInviteLink relay error: ${error}`) return null } }, ) } const getMembershipRequests = () => { relay( { name: Action.Group.GET_MEMBERSHIP_REQUESTS, }, async ({ body }) => { return await WPP.group.getMembershipRequests(body) }, ) } const getParticipants = () => { relay( { name: Action.Group.GET_PARTICIPANTS, }, async ({ body }) => { try { const participants = await WPP.group.getParticipants(body) return participants.map(serialize.participant) } catch (error) { return [] } }, ) } const iAmAdmin = () => { relay( { name: Action.Group.IAM_ADMIN, }, async ({ body }) => { return await WPP.group.iAmAdmin(body) }, ) } const iAmMember = () => { relay( { name: Action.Group.IAM_MEMBER, }, async ({ body }) => { return await WPP.group.iAmMember(body) }, ) } const iAmRestrictedMember = () => { relay( { name: Action.Group.IAM_RESTRICTED_MEMBER, }, async ({ body }) => { return await WPP.group.iAmRestrictedMember(body) }, ) } const iAmSuperAdmin = () => { relay( { name: Action.Group.IAM_SUPER_ADMIN, }, async ({ body }) => { return await WPP.group.iAmSuperAdmin(body) }, ) } const join = () => { relay( { name: Action.Group.JOIN, }, async ({ body }) => { return await WPP.group.join(body) }, ) } const leave = () => { relay( { name: Action.Group.LEAVE, }, async ({ body }) => { return await WPP.group.leave(body) }, ) } const promoteParticipants = () => { relay( { name: Action.Group.PROMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.promoteParticipants(groupId, participantsIds) }, ) } const reject = () => { relay( { name: Action.Group.REJECT, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.reject(groupId, membershipIds) }, ) } const removeIcon = () => { relay( { name: Action.Group.REMOVE_ICON, }, async ({ body }) => { return await WPP.group.removeIcon(body) }, ) } const removeParticipants = () => { relay( { name: Action.Group.REMOVE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.removeParticipants(groupId, participantsIds) }, ) } const revokeInviteCode = () => { relay( { name: Action.Group.REVOKE_INVITE_CODE, }, async ({ body }) => { return await WPP.group.revokeInviteCode(body) }, ) } const setDescription = () => { relay( { name: Action.Group.SET_DESCRIPTION, }, async ({ body }) => { const { groupId, description } = body return await WPP.group.setDescription(groupId, description) }, ) } const setIcon = () => { relay( { name: Action.Group.SET_ICON, }, async ({ body }) => { const { groupId, content } = body return await WPP.group.setIcon(groupId, content) }, ) } const setProperty = () => { relay( { name: Action.Group.SET_PROPERTY, }, async ({ body }) => { const { groupId, property, value } = body return await WPP.group.setProperty(groupId, property, value) }, ) } const setSubject = () => { relay( { name: Action.Group.SET_SUBJECT, }, async ({ body }) => { const { groupId, subject } = body return await WPP.group.setSubject(groupId, subject) }, ) } const initGroupRelay = () => { addParticipants() approve() canAdd() canDemote() canPromote() canRemove() create() demoteParticipants() getInviteLink() getGroupInfoFromInviteCode() getGroupSizeLimit() getMembershipRequests() getParticipants() list() iAmAdmin() iAmMember() iAmRestrictedMember() iAmSuperAdmin() join() leave() promoteParticipants() reject() removeIcon() removeParticipants() revokeInviteCode() setDescription() setIcon() setProperty() setSubject() } export default initGroupRelay
```

# src/relays/index.ts

```ts
import initBlocklistRelays from './blocklist.relay' import initCartRelays from './cart.relay' import initChatRelay from './chat.relay' import initConnRelays from './conn.relay' import initContactRelay from './contact.relay' import initGroupRelay from './group.relay' import initSendRelay from './send.relay' import initStatusRelay from './status.relay' export const initInjectScriptRelays = () => { initBlocklistRelays() initCartRelays() initChatRelay() initConnRelays() initContactRelay() initGroupRelay() initSendRelay() initStatusRelay() }
```

# src/relays/newsletter.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const create = () => { relay( { name: Action.Newsletter.CREATE, }, async ({ body }) => { const { name, opts } = body return await WPP.newsletter.create(name, opts) }, ) } const destroy = () => { relay( { name: Action.Newsletter.DESTROY, }, async ({ body }) => { return await WPP.newsletter.destroy(body) }, ) } const edit = () => { relay( { name: Action.Newsletter.EDIT, }, async ({ body }) => { const { newsletterId, opts } = body return await WPP.newsletter.edit(newsletterId, opts) }, ) } const getSubscribers = () => { relay( { name: Action.Newsletter.GET_SUBSCRIBERS, }, async ({ body }) => { return await WPP.newsletter.getSubscribers(body) }, ) } const mute = () => { relay( { name: Action.Newsletter.MUTE, }, async ({ body }) => { const { newsletterId, value } = body return await WPP.newsletter.mute(newsletterId, value) }, ) } const initNewsletterRelay = () => { create() destroy() edit() getSubscribers() mute() } export default initNewsletterRelay
```

# src/relays/profile.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Profile.EDIT_BUSINESS_PROFILE, }, async ({ body }) => { return WPP.status.get(body) }, ) } const initProfileRelays = () => { get() } export default initProfileRelays
```

# src/relays/send.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const sendText = () => { relay( { name: Action.Send.TEXT, }, async (req) => { try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendTextMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendFile = () => { relay( { name: Action.Send.FILE, }, async (req) => { console.log('req', req) try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendFileMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendLocation = () => { relay( { name: Action.Send.LOCATION, }, async (req) => { try { const { chatId, options } = req.body const { sendMsgResult } = await WPP.chat.sendLocationMessage( chatId, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendPoll = () => { relay( { name: Action.Send.POLL, }, async (req) => { try { const { chatId, name, choices, options } = req.body const { sendMsgResult } = await WPP.chat.sendCreatePollMessage( chatId, name, choices, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendVCard = () => { relay( { name: Action.Send.VCARD, }, async (req) => { try { const { chatId, contacts, options } = req.body const { sendMsgResult } = await WPP.chat.sendVCardContactMessage( chatId, contacts, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const initSendRelay = () => { sendText() sendFile() sendLocation() sendPoll() sendVCard() } export default initSendRelay
```

# src/relays/status.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Status.GET, }, async ({ body }) => { return WPP.status.get(body) }, ) } const getMyStatus = () => { relay( { name: Action.Status.GET_MY_STATUS, }, async ({ body }) => { return await WPP.status.getMyStatus() }, ) } const remove = () => { relay( { name: Action.Status.REMOVE, }, async ({ body }) => { return await WPP.status.remove(body) }, ) } const sendImageStatus = () => { relay( { name: Action.Status.SEND_IMAGE_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendImageStatus(content, options) }, ) } const sendReadStatus = () => { relay( { name: Action.Status.SEND_READ_STATUS, }, async ({ body }) => { const { chatId, statusId } = body return await WPP.status.sendReadStatus(chatId, statusId) }, ) } const sendTextStatus = () => { relay( { name: Action.Status.SEND_TEXT_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendTextStatus(content, options) }, ) } const sendVideoStatus = () => { relay( { name: Action.Status.SEND_VIDEO_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendVideoStatus(content, options) }, ) } const updateParticipants = () => { relay( { name: Action.Status.UPDATE_PARTICIPANTS, }, async ({ body }) => { return await WPP.status.updateParticipants(body) }, ) } const initStatusRelay = () => { get() getMyStatus() remove() sendImageStatus() sendReadStatus() sendTextStatus() sendVideoStatus() updateParticipants() } export default initStatusRelay
```

# src/stores/app.ts

```ts
import type { License } from '@/types' import { create } from 'zustand' interface AppState { isReady: boolean setIsReady: (isReady: boolean) => void profile: any setProfile: (profile: any) => void license?: License | null setLicense: (license: any) => void groups: any[] setGroups: (groups: []) => void isLoading: boolean setIsLoading: (state: boolean) => void activeChat: any setActiveChat: (chat: any) => void } export const useAppStore = create<AppState>((set) => ({ isReady: false, setIsReady: (isReady: boolean) => set({ isReady }), license: null, setLicense: (license: any) => set({ license: license }), groups: [], setGroups: (groups: []) => set({ groups }), profile: {}, setProfile: (profile: any) => set({ profile }), isLoading: false, setIsLoading: (state: any) => set({ isLoading: state }), activeChat: {}, setActiveChat: (chat: any) => set({ activeChat: chat }), }))
```

# src/stores/toast.ts

```ts
import { create } from 'zustand' export interface Toast { id: number type: 'success' | 'error' | 'info' | 'warning' title: string message: string duration?: number } interface ToastState { toasts: Toast[] addToast: (toast: Omit<Toast, 'id'>) => void removeToast: (id: number) => void } export const useToastStore = create<ToastState>((set) => ({ toasts: [], addToast: (toast) => set((state) => ({ toasts: [...state.toasts, { ...toast, id: Date.now() }], })), removeToast: (id) => set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id), })), }))
```

# src/styles/globals.css

```css
div.plasmo-csui-container { margin: 0; color-scheme: var(--mantine-color-scheme); font-family: var(--mantine-font-family); font-size: var(--mantine-font-size-md); line-height: var(--mantine-line-height); background-color: var(--mantine-color-body); color: var(--mantine-color-text); -webkit-font-smoothing: var(--mantine-webkit-font-smoothing); -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing); right: 0px; left: auto !important; } .root { position: fixed; top: '30%'; left: '50%'; transform: 'translate(-50%, -50%)'; z-index: 1001; background-color: red; } #plasmo-inline { background: transparent; }
```

# src/tabs/landing-page.tsx

```tsx
// src/tabs/landing-page.tsx import plans, { features as comparisonFeatures } from '@/config/plans' import theme from '@/libs/theme' import { Accordion, Avatar, Badge, Box, Button, Card, Center, Container, Divider, Grid, Group, MantineProvider, Paper, Stack, Table, Text, ThemeIcon, Title, } from '@mantine/core' import '@mantine/core/styles.css' import { IconArrowRight, IconCertificate, IconCheck, IconCircleCheck, IconCrown, IconHelpOctagon, IconKey, IconLock, IconMessageCircle, IconRocket, IconShieldCheck, IconSparkles, IconThumbUp, IconUser, IconWorldQuestion, IconX, } from '@tabler/icons-react' import { When } from 'react-if' // Helper component for checkmark icons const CheckIcon = () => ( <IconCheck size={20} stroke={2.5} color="var(--mantine-color-teal-6)" /> ) const CrossIcon = () => ( <IconX size={20} stroke={2.5} color="var(--mantine-color-red-6)" /> ) // --- Section Components --- // 1. Hero Section: Headline and Sub-headline const HeroSection = () => ( <Center p="xl"> <Stack align="center" gap="md" ta="center" maw={700}> <Badge variant="light" color="teal" size="lg" leftSection={<IconSparkles size={16} />} > Unlock The Full Power </Badge> <Title order={1} fz={{ base: 36, sm: 48 }}> Never Lose a WhatsApp Memory Again </Title> <Text c="dimmed" fz="lg"> Upgrade to Pro to get unlimited backups of all your chats and media. Secure your conversations, export in any format, and enjoy peace of mind with a simple one-time payment. </Text> </Stack> </Center> ) // 2. Pricing Section const PricingSection = () => ( <Group justify="center" align="stretch" mt="xl"> {plans.map((plan, index) => ( <Card key={index} withBorder w={{ base: '100%', sm: 380 }} radius={'lg'} p="lg" style={{ border: !plan.isFree ? '2px solid var(--mantine-color-teal-6)' : undefined, boxShadow: !plan.isFree ? 'var(--mantine-shadow-lg)' : 'var(--mantine-shadow-sm)', }} > <Stack justify="space-between" style={{ height: '100%' }}> {/* Card Header */} <Box> <Group justify="space-between"> <Title order={3}>{plan.name}</Title> {!plan.isFree && ( <Badge color="yellow" variant="filled" size="lg"> Most Popular </Badge> )} </Group> <Text c="dimmed" mt={4}> {plan.description} </Text> </Box> {/* Price */} <Box my="lg"> <Group gap={8} align={'flex-end'}> {plan.placeholderPrice && ( <Title order={3} c={'dimmed'} style={{ textDecorationLine: 'line-through' }} > {plan.placeholderPrice} </Title> )} <Title order={1} fz={48}> {plan.price} </Title> {!plan.isFree && ( <Text c="dimmed" mb={8}> / Lifetime </Text> )} </Group> {!plan.isFree && ( <Text c="orange.7" fw={500} size="sm"> Limited Time Offer! Price will increase soon. </Text> )} </Box> {/* Features List */} <Stack gap="sm" mb="lg"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="sm" wrap="nowrap" align="flex-start"> <IconCircleCheck color={'var(--mantine-color-teal-6)'} size={20} style={{ minWidth: 20, marginTop: 3 }} /> <Text size="sm">{feature}</Text> </Group> ))} </Stack> {/* Action Button */} <Box mt="auto"> {plan.isFree ? ( <Button size="md" variant="default" fullWidth disabled> Your Current Plan </Button> ) : ( <Stack gap="xs"> <Button size="md" component="a" href={plan.link} target="_blank" fullWidth leftSection={<IconCrown size={18} />} > Upgrade to Pro </Button> <Group justify="center" gap={6}> <IconLock size={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> Secure Transaction via Lemon Squeezy </Text> </Group> </Stack> )} </Box> </Stack> </Card> ))} </Group> ) // 3. Feature Comparison Table const FeatureComparisonTable = () => ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> Feature Comparison: Free vs. Pro </Title> </Center> <Card withBorder radius="lg" p={0}> <Table striped highlightOnHover verticalSpacing="md" fz="sm"> <Table.Thead> <Table.Tr> <Table.Th w="40%">Feature</Table.Th> <Table.Th ta="center">Free</Table.Th> <Table.Th ta="center">Pro</Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {comparisonFeatures.map((item) => ( <Table.Tr key={item.feature}> <Table.Td fw={500}>{item.feature}</Table.Td> <Table.Td ta="center"> {typeof item.free === 'boolean' ? ( item.free ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Text size="sm">{item.free}</Text> )} </Table.Td> <Table.Td ta="center"> {typeof item.pro === 'boolean' ? ( item.pro ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Badge color="teal" variant="light"> {item.pro} </Badge> )} </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </Card> </Box> ) // 4. Testimonials Section const testimonialsData = [ { name: 'Sarah L.', role: 'Small Business Owner', avatar: 'https://i.pravatar.cc/150?u=a042581f4e29026704d', quote: 'This tool is a lifesaver! I was terrified of losing years of client conversations. The Pro version let me back up everything in minutes. The peace of mind is priceless.', }, { name: 'Mike P.', role: 'Freelancer', avatar: 'https://i.pravatar.cc/150?u=a04258114e29026702d', quote: 'I needed to export a long chat history for a project report. The Excel export feature in Pro saved me hours of manual copy-pasting. A fantastic one-time purchase, no annoying subscriptions!', }, { name: 'Jessica T.', role: 'University Student', avatar: 'https://i.pravatar.cc/150?u=a042581f4e29026706d', quote: "I accidentally deleted a whole chat with important study notes. Thanks to my backup, I recovered everything. I recommend the Lifetime plan to all my friends. It's a must-have.", }, ] const TestimonialsSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Trusted by Users Like You</Title> <Text c="dimmed"> See what our happy customers are saying about the Pro version. </Text> </Stack> </Center> <Grid mt="xl"> {testimonialsData.map((testimonial) => ( <Grid.Col span={{ base: 12, md: 4 }} key={testimonial.name}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack> <Text c="dimmed">"{testimonial.quote}"</Text> <Group mt="md"> <Avatar src={testimonial.avatar} alt={testimonial.name} radius="xl" /> <div> <Text fw={500}>{testimonial.name}</Text> <Text size="xs" c="dimmed"> {testimonial.role} </Text> </div> </Group> </Stack> </Card> </Grid.Col> ))} </Grid> </Box> ) // 5. Guarantee Section const GuaranteeSection = () => ( <Paper bg="teal.0" radius="lg" p="xl" mt={80}> <Group justify="center" align="center"> <ThemeIcon variant="light" color="teal" size={60} radius="xl"> <IconCertificate size={32} /> </ThemeIcon> <Stack gap={0} ta={{ base: 'center', sm: 'left' }}> <Title order={3}>30-Day Money-Back Guarantee</Title> <Text c="dimmed" maw={500}> We're confident you'll love the Pro features. If you're not 100% satisfied for any reason, contact us within 30 days of your purchase for a full, no-questions-asked refund. </Text> </Stack> </Group> </Paper> ) // 6. FAQ Section const faqData = [ { icon: IconRocket, question: 'What are the main benefits of upgrading to Pro?', answer: "With Pro, you get **Total Protection** by backing up all messages and media without limits. You'll unlock **Exclusive Features** like PDF/Excel exports and advanced filtering. Plus, you receive **Priority Support**, ensuring our team assists you first.", }, { icon: IconKey, question: 'Is this a one-time payment or a subscription?', answer: 'It is a **one-time payment**. You pay once and get lifetime access to all current and future Pro features. No monthly fees, no subscriptions, ever.', }, { icon: IconShieldCheck, question: 'Is my data secure?', answer: 'Absolutely. Your data security is our top priority. The extension processes everything **locally on your computer**. No chat data is ever sent to our servers. You have 100% control.', }, { icon: IconHelpOctagon, question: 'How do I get my license key after purchase?', answer: 'Immediately after your purchase, you will receive an email from our payment partner, **Lemon Squeezy**, containing your license key and instructions to activate it.', }, ] const FaqSection = () => ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> Frequently Asked Questions </Title> </Center> <Accordion variant="separated" radius="lg"> {faqData.map((item, index) => ( <Accordion.Item key={index} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <item.icon size={22} /> </ThemeIcon> } > <Text fw={500}>{item.question}</Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} /> </Accordion.Panel> </Accordion.Item> ))} </Accordion> </Box> ) // 7. Data Privacy Section const PrivacySection = () => ( <Card withBorder radius="lg" p="xl" mt={80} shadow="sm"> <Group wrap="nowrap" gap="xl"> <ThemeIcon color="teal" size={60} radius="xl" variant="light"> <IconShieldCheck size={32} /> </ThemeIcon> <div> <Title order={3}>Your Privacy is Guaranteed</Title> <Text mt={4} c="dimmed"> We take your privacy seriously. All your data, including chats and media, is processed and stored exclusively on your own computer. Nothing is ever uploaded to our servers. You maintain 100% control and ownership of your data at all times. </Text> </div> </Group> </Card> ) // 8. After Purchase Section const AfterPurchaseSection = () => { const steps = [ { icon: IconLock, title: '1. Secure Payment', description: 'Complete your purchase through our secure payment partner, Lemon Squeezy.', }, { icon: IconKey, title: '2. Get Your Key', description: 'Check your email for your unique lifetime license key, delivered instantly.', }, { icon: IconRocket, title: '3. Activate & Enjoy', description: 'Open the extension, enter your key, and immediately unlock all Pro features!', }, ] return ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> What Happens After You Buy? </Title> </Center> <Grid> {steps.map((step, index) => ( <Grid.Col span={{ base: 12, sm: 4 }} key={step.title}> <Stack align="center" ta="center"> <ThemeIcon size={50} radius="xl" variant="light"> <step.icon size={24} /> </ThemeIcon> <Text fw={700} fz="lg"> {step.title} </Text> <Text c="dimmed" size="sm"> {step.description} </Text> </Stack> </Grid.Col> ))} </Grid> </Box> ) } // --- Main Page Component --- const LandingPage = () => { return ( <MantineProvider theme={theme}> <Container size="md" py="xl"> <Stack gap={80}> <HeroSection /> <PricingSection /> <FeatureComparisonTable /> <TestimonialsSection /> <GuaranteeSection /> <FaqSection /> <PrivacySection /> <AfterPurchaseSection /> {/* Final CTA */} <Center mt={40}> <Stack align="center" gap="lg"> <Title order={2}>Ready to Secure Your Chats?</Title> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<IconCrown size={20} />} > Get Lifetime Access Now </Button> </Stack> </Center> </Stack> </Container> </MantineProvider> ) } export default LandingPage
```

# src/types/globals.d.ts

```ts
import type * as wajs from '@wppconnect/wa-js' declare global { interface Window { WPP: typeof wajs } const WPP: typeof wajs }
```

# src/types/index.d.ts

```ts
import type { Status } from '@/constants' export interface Response<T> { status: keyof typeof Status | string data?: T | null error?: string | null } interface LicenseInstance { createt_at: Date id: string name: string } interface LicenseKey { activation_limit: number activation_usage: number create_at: Date expires_at: Date id: number status: string test_mode: boolean } interface LicenseMeta { customer_email: string customer_id: number customer_name: string order_id: number order_item_id: number product_id: number store_id: number variant_id: number variant_name: string } export interface License { activated?: boolean | null valid?: boolean | null instance?: LicenseInstance | null license_key: LicenseKey meta: LicenseMeta }
```

# src/utils/country.ts

```ts
const countries = { AD: { label: 'ðŸ‡¦ðŸ‡© Andorra', phone: '376' }, AE: { label: 'ðŸ‡¦ðŸ‡ª United Arab Emirates', phone: '971' }, AF: { label: 'ðŸ‡¦ðŸ‡« Afghanistan', phone: '93' }, AG: { label: 'ðŸ‡¦ðŸ‡¬ Antigua and Barbuda', phone: '1-268' }, AI: { label: 'ðŸ‡¦ðŸ‡® Anguilla', phone: '1-264' }, AL: { label: 'ðŸ‡¦ðŸ‡± Albania', phone: '355' }, AM: { label: 'ðŸ‡¦ðŸ‡² Armenia', phone: '374' }, AO: { label: 'ðŸ‡¦ðŸ‡´ Angola', phone: '244' }, AQ: { label: 'ðŸ‡¦ðŸ‡¶ Antarctica', phone: '672' }, AR: { label: 'ðŸ‡¦ðŸ‡· Argentina', phone: '54' }, AS: { label: 'ðŸ‡¦ðŸ‡¸ American Samoa', phone: '1-684' }, AT: { label: 'ðŸ‡¦ðŸ‡¹ Austria', phone: '43' }, AU: { label: 'ðŸ‡¦ðŸ‡º Australia', phone: '61' }, AW: { label: 'ðŸ‡¦ðŸ‡¼ Aruba', phone: '297' }, AX: { label: 'ðŸ‡¦ðŸ‡½ Alland Islands', phone: '358' }, AZ: { label: 'ðŸ‡¦ðŸ‡¿ Azerbaijan', phone: '994' }, BA: { label: 'ðŸ‡§ðŸ‡¦ Bosnia and Herzegovina', phone: '387' }, BB: { label: 'ðŸ‡§ðŸ‡§ Barbados', phone: '1-246' }, BD: { label: 'ðŸ‡§ðŸ‡© Bangladesh', phone: '880' }, BE: { label: 'ðŸ‡§ðŸ‡ª Belgium', phone: '32' }, BF: { label: 'ðŸ‡§ðŸ‡« Burkina Faso', phone: '226' }, BG: { label: 'ðŸ‡§ðŸ‡¬ Bulgaria', phone: '359' }, BH: { label: 'ðŸ‡§ðŸ‡­ Bahrain', phone: '973' }, BI: { label: 'ðŸ‡§ðŸ‡® Burundi', phone: '257' }, BJ: { label: 'ðŸ‡§ðŸ‡¯ Benin', phone: '229' }, BL: { label: 'ðŸ‡§ðŸ‡± Saint Barthelemy', phone: '590' }, BM: { label: 'ðŸ‡§ðŸ‡² Bermuda', phone: '1-441' }, BN: { label: 'ðŸ‡§ðŸ‡³ Brunei Darussalam', phone: '673' }, BO: { label: 'ðŸ‡§ðŸ‡´ Bolivia', phone: '591' }, BR: { label: 'ðŸ‡§ðŸ‡· Brazil', phone: '55' }, BS: { label: 'ðŸ‡§ðŸ‡¸ Bahamas', phone: '1-242' }, BT: { label: 'ðŸ‡§ðŸ‡¹ Bhutan', phone: '975' }, BV: { label: 'ðŸ‡§ðŸ‡» Bouvet Island', phone: '47' }, BW: { label: 'ðŸ‡§ðŸ‡¼ Botswana', phone: '267' }, BY: { label: 'ðŸ‡§ðŸ‡¾ Belarus', phone: '375' }, BZ: { label: 'ðŸ‡§ðŸ‡¿ Belize', phone: '501' }, CA: { label: 'ðŸ‡¨ðŸ‡¦ Canada', phone: '1' }, CC: { label: 'ðŸ‡¨ðŸ‡¨ Cocos (Keeling) Islands', phone: '61' }, CD: { label: 'ðŸ‡¨ðŸ‡© Congo, Democratic Republic of the', phone: '243' }, CF: { label: 'ðŸ‡¨ðŸ‡« Central African Republic', phone: '236' }, CG: { label: 'ðŸ‡¨ðŸ‡¬ Congo, Republic of the', phone: '242' }, CH: { label: 'ðŸ‡¨ðŸ‡­ Switzerland', phone: '41' }, CI: { label: "ðŸ‡¨ðŸ‡® Cote d'Ivoire", phone: '225' }, CK: { label: 'ðŸ‡¨ðŸ‡° Cook Islands', phone: '682' }, CL: { label: 'ðŸ‡¨ðŸ‡± Chile', phone: '56' }, CM: { label: 'ðŸ‡¨ðŸ‡² Cameroon', phone: '237' }, CN: { label: 'ðŸ‡¨ðŸ‡³ China', phone: '86' }, CO: { label: 'ðŸ‡¨ðŸ‡´ Colombia', phone: '57' }, CR: { label: 'ðŸ‡¨ðŸ‡· Costa Rica', phone: '506' }, CU: { label: 'ðŸ‡¨ðŸ‡º Cuba', phone: '53' }, CV: { label: 'ðŸ‡¨ðŸ‡» Cape Verde', phone: '238' }, CW: { label: 'ðŸ‡¨ðŸ‡¼ Curacao', phone: '599' }, CX: { label: 'ðŸ‡¨ðŸ‡½ Christmas Island', phone: '61' }, CY: { label: 'ðŸ‡¨ðŸ‡¾ Cyprus', phone: '357' }, CZ: { label: 'ðŸ‡¨ðŸ‡¿ Czech Republic', phone: '420' }, DE: { label: 'ðŸ‡©ðŸ‡ª Germany', phone: '49' }, DJ: { label: 'ðŸ‡©ðŸ‡¯ Djibouti', phone: '253' }, DK: { label: 'ðŸ‡©ðŸ‡° Denmark', phone: '45' }, DM: { label: 'ðŸ‡©ðŸ‡² Dominica', phone: '1-767' }, DO: { label: 'ðŸ‡©ðŸ‡´ Dominican Republic', phone: '1-809' }, DZ: { label: 'ðŸ‡©ðŸ‡¿ Algeria', phone: '213' }, EC: { label: 'ðŸ‡ªðŸ‡¨ Ecuador', phone: '593' }, EE: { label: 'ðŸ‡ªðŸ‡ª Estonia', phone: '372' }, EG: { label: 'ðŸ‡ªðŸ‡¬ Egypt', phone: '20' }, EH: { label: 'ðŸ‡ªðŸ‡­ Western Sahara', phone: '212' }, ER: { label: 'ðŸ‡ªðŸ‡· Eritrea', phone: '291' }, ES: { label: 'ðŸ‡ªðŸ‡¸ Spain', phone: '34' }, ET: { label: 'ðŸ‡ªðŸ‡¹ Ethiopia', phone: '251' }, FI: { label: 'ðŸ‡«ðŸ‡® Finland', phone: '358' }, FJ: { label: 'ðŸ‡«ðŸ‡¯ Fiji', phone: '679' }, FK: { label: 'ðŸ‡«ðŸ‡° Falkland Islands (Malvinas)', phone: '500' }, FM: { label: 'ðŸ‡«ðŸ‡² Micronesia, Federated States of', phone: '691' }, FO: { label: 'ðŸ‡«ðŸ‡´ Faroe Islands', phone: '298' }, FR: { label: 'ðŸ‡«ðŸ‡· France', phone: '33' }, GA: { label: 'ðŸ‡¬ðŸ‡¦ Gabon', phone: '241' }, GB: { label: 'ðŸ‡¬ðŸ‡§ United Kingdom', phone: '44' }, GD: { label: 'ðŸ‡¬ðŸ‡© Grenada', phone: '1-473' }, GE: { label: 'ðŸ‡¬ðŸ‡ª Georgia', phone: '995' }, GF: { label: 'ðŸ‡¬ðŸ‡« French Guiana', phone: '594' }, GG: { label: 'ðŸ‡¬ðŸ‡¬ Guernsey', phone: '44' }, GH: { label: 'ðŸ‡¬ðŸ‡­ Ghana', phone: '233' }, GI: { label: 'ðŸ‡¬ðŸ‡® Gibraltar', phone: '350' }, GL: { label: 'ðŸ‡¬ðŸ‡± Greenland', phone: '299' }, GM: { label: 'ðŸ‡¬ðŸ‡² Gambia', phone: '220' }, GN: { label: 'ðŸ‡¬ðŸ‡³ Guinea', phone: '224' }, GP: { label: 'ðŸ‡¬ðŸ‡µ Guadeloupe', phone: '590' }, GQ: { label: 'ðŸ‡¬ðŸ‡¶ Equatorial Guinea', phone: '240' }, GR: { label: 'ðŸ‡¬ðŸ‡· Greece', phone: '30' }, GS: { label: 'ðŸ‡¬ðŸ‡¸ South Georgia and the South Sandwich Islands', phone: '500', }, GT: { label: 'ðŸ‡¬ðŸ‡¹ Guatemala', phone: '502' }, GU: { label: 'ðŸ‡¬ðŸ‡º Guam', phone: '1-671' }, GW: { label: 'ðŸ‡¬ðŸ‡¼ Guinea-Bissau', phone: '245' }, GY: { label: 'ðŸ‡¬ðŸ‡¾ Guyana', phone: '592' }, HK: { label: 'ðŸ‡­ðŸ‡° Hong Kong', phone: '852' }, HM: { label: 'ðŸ‡­ðŸ‡² Heard Island and McDonald Islands', phone: '672' }, HN: { label: 'ðŸ‡­ðŸ‡³ Honduras', phone: '504' }, HR: { label: 'ðŸ‡­ðŸ‡· Croatia', phone: '385' }, HT: { label: 'ðŸ‡­ðŸ‡¹ Haiti', phone: '509' }, HU: { label: 'ðŸ‡­ðŸ‡º Hungary', phone: '36' }, ID: { label: 'ðŸ‡®ðŸ‡© Indonesia', phone: '62' }, IE: { label: 'ðŸ‡®ðŸ‡ª Ireland', phone: '353' }, IL: { label: 'ðŸ‡®ðŸ‡± Israel', phone: '972' }, IM: { label: 'ðŸ‡®ðŸ‡² Isle of Man', phone: '44' }, IN: { label: 'ðŸ‡®ðŸ‡³ India', phone: '91' }, IO: { label: 'ðŸ‡®ðŸ‡´ British Indian Ocean Territory', phone: '246' }, IQ: { label: 'ðŸ‡®ðŸ‡¶ Iraq', phone: '964' }, IR: { label: 'ðŸ‡®ðŸ‡· Iran, Islamic Republic of', phone: '98' }, IS: { label: 'ðŸ‡®ðŸ‡¸ Iceland', phone: '354' }, IT: { label: 'ðŸ‡®ðŸ‡¹ Italy', phone: '39' }, JE: { label: 'ðŸ‡¯ðŸ‡ª Jersey', phone: '44' }, JM: { label: 'ðŸ‡¯ðŸ‡² Jamaica', phone: '1-876' }, JO: { label: 'ðŸ‡¯ðŸ‡´ Jordan', phone: '962' }, JP: { label: 'ðŸ‡¯ðŸ‡µ Japan', phone: '81' }, KE: { label: 'ðŸ‡°ðŸ‡ª Kenya', phone: '254' }, KG: { label: 'ðŸ‡°ðŸ‡¬ Kyrgyzstan', phone: '996' }, KH: { label: 'ðŸ‡°ðŸ‡­ Cambodia', phone: '855' }, KI: { label: 'ðŸ‡°ðŸ‡® Kiribati', phone: '686' }, KM: { label: 'ðŸ‡°ðŸ‡² Comoros', phone: '269' }, KN: { label: 'ðŸ‡°ðŸ‡³ Saint Kitts and Nevis', phone: '1-869' }, KP: { label: "ðŸ‡°ðŸ‡µ Korea, Democratic People's Republic of", phone: '850' }, KR: { label: 'ðŸ‡°ðŸ‡· Korea, Republic of', phone: '82' }, KW: { label: 'ðŸ‡°ðŸ‡¼ Kuwait', phone: '965' }, KY: { label: 'ðŸ‡°ðŸ‡¾ Cayman Islands', phone: '1-345' }, KZ: { label: 'ðŸ‡°ðŸ‡¿ Kazakhstan', phone: '7' }, LA: { label: "ðŸ‡±ðŸ‡¦ Lao People's Democratic Republic", phone: '856' }, LB: { label: 'ðŸ‡±ðŸ‡§ Lebanon', phone: '961' }, LC: { label: 'ðŸ‡±ðŸ‡¨ Saint Lucia', phone: '1-758' }, LI: { label: 'ðŸ‡±ðŸ‡® Liechtenstein', phone: '423' }, LK: { label: 'ðŸ‡±ðŸ‡° Sri Lanka', phone: '94' }, LR: { label: 'ðŸ‡±ðŸ‡· Liberia', phone: '231' }, LS: { label: 'ðŸ‡±ðŸ‡¸ Lesotho', phone: '266' }, LT: { label: 'ðŸ‡±ðŸ‡¹ Lithuania', phone: '370' }, LU: { label: 'ðŸ‡±ðŸ‡º Luxembourg', phone: '352' }, LV: { label: 'ðŸ‡±ðŸ‡» Latvia', phone: '371' }, LY: { label: 'ðŸ‡±ðŸ‡¾ Libya', phone: '218' }, MA: { label: 'ðŸ‡²ðŸ‡¦ Morocco', phone: '212' }, MC: { label: 'ðŸ‡²ðŸ‡¨ Monaco', phone: '377' }, MD: { label: 'ðŸ‡²ðŸ‡© Moldova, Republic of', phone: '373' }, ME: { label: 'ðŸ‡²ðŸ‡ª Montenegro', phone: '382' }, MF: { label: 'ðŸ‡²ðŸ‡« Saint Martin (French part)', phone: '590' }, MG: { label: 'ðŸ‡²ðŸ‡¬ Madagascar', phone: '261' }, MH: { label: 'ðŸ‡²ðŸ‡­ Marshall Islands', phone: '692' }, MK: { label: 'ðŸ‡²ðŸ‡° Macedonia, the Former Yugoslav Republic of', phone: '389' }, ML: { label: 'ðŸ‡²ðŸ‡± Mali', phone: '223' }, MM: { label: 'ðŸ‡²ðŸ‡² Myanmar', phone: '95' }, MN: { label: 'ðŸ‡²ðŸ‡³ Mongolia', phone: '976' }, MO: { label: 'ðŸ‡²ðŸ‡´ Macao', phone: '853' }, MP: { label: 'ðŸ‡²ðŸ‡µ Northern Mariana Islands', phone: '1-670' }, MQ: { label: 'ðŸ‡²ðŸ‡¶ Martinique', phone: '596' }, MR: { label: 'ðŸ‡²ðŸ‡· Mauritania', phone: '222' }, MS: { label: 'ðŸ‡²ðŸ‡¸ Montserrat', phone: '1-664' }, MT: { label: 'ðŸ‡²ðŸ‡¹ Malta', phone: '356' }, MU: { label: 'ðŸ‡²ðŸ‡º Mauritius', phone: '230' }, MV: { label: 'ðŸ‡²ðŸ‡» Maldives', phone: '960' }, MW: { label: 'ðŸ‡²ðŸ‡¼ Malawi', phone: '265' }, MX: { label: 'ðŸ‡²ðŸ‡½ Mexico', phone: '52' }, MY: { label: 'ðŸ‡²ðŸ‡¾ Malaysia', phone: '60' }, MZ: { label: 'ðŸ‡²ðŸ‡¿ Mozambique', phone: '258' }, NA: { label: 'ðŸ‡³ðŸ‡¦ Namibia', phone: '264' }, NC: { label: 'ðŸ‡³ðŸ‡¨ New Caledonia', phone: '687' }, NE: { label: 'ðŸ‡³ðŸ‡ª Niger', phone: '227' }, NF: { label: 'ðŸ‡³ðŸ‡« Norfolk Island', phone: '672' }, NG: { label: 'ðŸ‡³ðŸ‡¬ Nigeria', phone: '234' }, NI: { label: 'ðŸ‡³ðŸ‡® Nicaragua', phone: '505' }, NL: { label: 'ðŸ‡³ðŸ‡± Netherlands', phone: '31' }, NO: { label: 'ðŸ‡³ðŸ‡´ Norway', phone: '47' }, NP: { label: 'ðŸ‡³ðŸ‡µ Nepal', phone: '977' }, NR: { label: 'ðŸ‡³ðŸ‡· Nauru', phone: '674' }, NU: { label: 'ðŸ‡³ðŸ‡º Niue', phone: '683' }, NZ: { label: 'ðŸ‡³ðŸ‡¿ New Zealand', phone: '64' }, OM: { label: 'ðŸ‡´ðŸ‡² Oman', phone: '968' }, PA: { label: 'ðŸ‡µðŸ‡¦ Panama', phone: '507' }, PE: { label: 'ðŸ‡µðŸ‡ª Peru', phone: '51' }, PF: { label: 'ðŸ‡µðŸ‡« French Polynesia', phone: '689' }, PG: { label: 'ðŸ‡µðŸ‡¬ Papua New Guinea', phone: '675' }, PH: { label: 'ðŸ‡µðŸ‡­ Philippines', phone: '63' }, PK: { label: 'ðŸ‡µðŸ‡° Pakistan', phone: '92' }, PL: { label: 'ðŸ‡µðŸ‡± Poland', phone: '48' }, PM: { label: 'ðŸ‡µðŸ‡² Saint Pierre and Miquelon', phone: '508' }, PN: { label: 'ðŸ‡µðŸ‡³ Pitcairn', phone: '870' }, PR: { label: 'ðŸ‡µðŸ‡· Puerto Rico', phone: '1' }, PS: { label: 'ðŸ‡µðŸ‡¸ Palestine, State of', phone: '970' }, PT: { label: 'ðŸ‡µðŸ‡¹ Portugal', phone: '351' }, PW: { label: 'ðŸ‡µðŸ‡¼ Palau', phone: '680' }, PY: { label: 'ðŸ‡µðŸ‡¾ Paraguay', phone: '595' }, QA: { label: 'ðŸ‡¶ðŸ‡¦ Qatar', phone: '974' }, RE: { label: 'ðŸ‡·ðŸ‡ª Reunion', phone: '262' }, RO: { label: 'ðŸ‡·ðŸ‡´ Romania', phone: '40' }, RS: { label: 'ðŸ‡·ðŸ‡¸ Serbia', phone: '381' }, RU: { label: 'ðŸ‡·ðŸ‡º Russian Federation', phone: '7' }, RW: { label: 'ðŸ‡·ðŸ‡¼ Rwanda', phone: '250' }, SA: { label: 'ðŸ‡¸ðŸ‡¦ Saudi Arabia', phone: '966' }, SB: { label: 'ðŸ‡¸ðŸ‡§ Solomon Islands', phone: '677' }, SC: { label: 'ðŸ‡¸ðŸ‡¨ Seychelles', phone: '248' }, SD: { label: 'ðŸ‡¸ðŸ‡© Sudan', phone: '249' }, SE: { label: 'ðŸ‡¸ðŸ‡ª Sweden', phone: '46' }, SG: { label: 'ðŸ‡¸ðŸ‡¬ Singapore', phone: '65' }, SH: { label: 'ðŸ‡¸ðŸ‡­ Saint Helena', phone: '290' }, SI: { label: 'ðŸ‡¸ðŸ‡® Slovenia', phone: '386' }, SJ: { label: 'ðŸ‡¸ðŸ‡¯ Svalbard and Jan Mayen', phone: '47' }, SK: { label: 'ðŸ‡¸ðŸ‡° Slovakia', phone: '421' }, SL: { label: 'ðŸ‡¸ðŸ‡± Sierra Leone', phone: '232' }, SM: { label: 'ðŸ‡¸ðŸ‡² San Marino', phone: '378' }, SN: { label: 'ðŸ‡¸ðŸ‡³ Senegal', phone: '221' }, SO: { label: 'ðŸ‡¸ðŸ‡´ Somalia', phone: '252' }, SR: { label: 'ðŸ‡¸ðŸ‡· Suriname', phone: '597' }, SS: { label: 'ðŸ‡¸ðŸ‡¸ South Sudan', phone: '211' }, ST: { label: 'ðŸ‡¸ðŸ‡¹ Sao Tome and Principe', phone: '239' }, SV: { label: 'ðŸ‡¸ðŸ‡» El Salvador', phone: '503' }, SX: { label: 'ðŸ‡¸ðŸ‡½ Sint Maarten (Dutch part)', phone: '1-721' }, SY: { label: 'ðŸ‡¸ðŸ‡¾ Syrian Arab Republic', phone: '963' }, SZ: { label: 'ðŸ‡¸ðŸ‡¿ Swaziland', phone: '268' }, TC: { label: 'ðŸ‡¹ðŸ‡¨ Turks and Caicos Islands', phone: '1-649' }, TD: { label: 'ðŸ‡¹ðŸ‡© Chad', phone: '235' }, TF: { label: 'ðŸ‡¹ðŸ‡« French Southern Territories', phone: '262' }, TG: { label: 'ðŸ‡¹ðŸ‡¬ Togo', phone: '228' }, TH: { label: 'ðŸ‡¹ðŸ‡­ Thailand', phone: '66' }, TJ: { label: 'ðŸ‡¹ðŸ‡¯ Tajikistan', phone: '992' }, TK: { label: 'ðŸ‡¹ðŸ‡° Tokelau', phone: '690' }, TL: { label: 'ðŸ‡¹ðŸ‡± Timor-Leste', phone: '670' }, TM: { label: 'ðŸ‡¹ðŸ‡² Turkmenistan', phone: '993' }, TN: { label: 'ðŸ‡¹ðŸ‡³ Tunisia', phone: '216' }, TO: { label: 'ðŸ‡¹ðŸ‡´ Tonga', phone: '676' }, TR: { label: 'ðŸ‡¹ðŸ‡· Turkey', phone: '90' }, TT: { label: 'ðŸ‡¹ðŸ‡¹ Trinidad and Tobago', phone: '1-868' }, TV: { label: 'ðŸ‡¹ðŸ‡» Tuvalu', phone: '688' }, TW: { label: 'ðŸ‡¹ðŸ‡¼ Taiwan, Province of China', phone: '886' }, TZ: { label: 'ðŸ‡¹ðŸ‡¿ United Republic of Tanzania', phone: '255' }, UA: { label: 'ðŸ‡ºðŸ‡¦ Ukraine', phone: '380' }, UG: { label: 'ðŸ‡ºðŸ‡¬ Uganda', phone: '256' }, US: { label: 'ðŸ‡ºðŸ‡¸ United States', phone: '1' }, UY: { label: 'ðŸ‡ºðŸ‡¾ Uruguay', phone: '598' }, UZ: { label: 'ðŸ‡ºðŸ‡¿ Uzbekistan', phone: '998' }, VA: { label: 'ðŸ‡»ðŸ‡¦ Holy See (Vatican City State)', phone: '379' }, VC: { label: 'ðŸ‡»ðŸ‡¨ Saint Vincent and the Grenadines', phone: '1-784' }, VE: { label: 'ðŸ‡»ðŸ‡ª Venezuela', phone: '58' }, VG: { label: 'ðŸ‡»ðŸ‡¬ British Virgin Islands', phone: '1-284' }, VI: { label: 'ðŸ‡»ðŸ‡® US Virgin Islands', phone: '1-340' }, VN: { label: 'ðŸ‡»ðŸ‡³ Vietnam', phone: '84' }, VU: { label: 'ðŸ‡»ðŸ‡º Vanuatu', phone: '678' }, WF: { label: 'ðŸ‡¼ðŸ‡« Wallis and Futuna', phone: '681' }, WS: { label: 'ðŸ‡¼ðŸ‡¸ Samoa', phone: '685' }, XK: { label: 'ðŸ‡½ðŸ‡° Kosovo', phone: '383' }, YE: { label: 'ðŸ‡¾ðŸ‡ª Yemen', phone: '967' }, YT: { label: 'ðŸ‡¾ðŸ‡¹ Mayotte', phone: '262' }, ZA: { label: 'ðŸ‡¿ðŸ‡¦ South Africa', phone: '27' }, ZM: { label: 'ðŸ‡¿ðŸ‡² Zambia', phone: '260' }, ZW: { label: 'ðŸ‡¿ðŸ‡¼ Zimbabwe', phone: '263' }, } const getCountryByCode = (code: string) => { return countries[code] ?? { label: '-', phone: '-' } } export default { getCountryByCode, countries, }
```

# src/utils/env.ts

```ts
const isProduction = () => { return process.env.NODE_ENV === 'production' } const isDevelopment = () => { return process.env.NODE_ENV === 'development' } export const isStaging = () => { return process.env.PLASMO_PUBLIC_STAGING === 'true' } export default { isProduction, isDevelopment, isStaging, }
```

# src/utils/ext.ts

```ts
import type { Tabs } from 'webextension-polyfill' import browser from 'webextension-polyfill' export async function getCurrentTab(): Promise<Tabs.Tab> { const queryOptions = { active: true, currentWindow: true } const [tab] = await browser.tabs.query(queryOptions) return tab } export async function getTabs(): Promise<Tabs.Tab[]> { return new Promise(async (resolve, reject) => { try { const tabs = await browser.tabs.query({ currentWindow: true }) const filteredTabs = tabs.filter( (tab) => !tab.url?.startsWith('chrome://'), ) return resolve(filteredTabs) } catch (error) { reject(error) } }) } export async function getTabByUrl(url: string): Promise<Tabs.Tab | null> { const queryOptions = { url: url } const tabs = await browser.tabs.query(queryOptions) return tabs.length > 0 ? tabs[0] : null } export const openWa = async () => { await browser.tabs.create({ url: 'https://web.whatsapp.com' }) } export const isWaTabActive = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return result?.active } export const isWaTabAvailable = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return !!result }
```

# src/utils/filterBy.ts

```ts
import { AccountType, ContactType, MessageType } from '@/constants' import type { ContactModel } from '@wppconnect/wa-js/dist/whatsapp' const dontIncludeLid = (contact: ContactModel) => contact.id.server !== 'lid' const dontIncludeMe = (contact: any, number: any) => contact.phoneNumber !== number const accountType = (contact: any, type: string) => { switch (type) { case AccountType.ALL: return true case AccountType.PERSONAL: return contact.isBusiness === false case AccountType.BUSINESS: return contact.isBusiness === true default: return true } } const contactType = (contact: any, type: string): boolean => { switch (type) { case ContactType.ALL: return true case ContactType.SAVED_CONTACTS: return contact.isMyContact === true case ContactType.UNSAVED_CONTACTS: return contact.isMyContact === false default: return true } } const includeAdmin = (data: any, isIncludeAdmin: boolean) => { if (isIncludeAdmin) { if (data.isAdmin) { return true } } else { if (data.isAdmin) return false } return true } const onlyMyContact = (data: any, onlyMyContact: boolean) => { if (onlyMyContact) { return data.isMyContact === true } else { return data.isMyContact !== true } } const messageType = (contact: any, type: string): boolean => { switch (type) { case MessageType.ALL: return true case MessageType.HAVE_UNREAD_MESSAGES: return contact.hasUnread === true case MessageType.NO_UNREAD_MESSAGES: return contact.hasUnread === false default: return true } } const country = (contact: any, country: string) => { const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) return countryCode === country } export default { dontIncludeLid, dontIncludeMe, accountType, includeAdmin, onlyMyContact, contactType, messageType, country, }
```

# src/utils/page.ts

```ts
import { Action } from '@/constants' import { postMessage } from './util' const goTo = (page: string) => { postMessage(Action.Window.GO_TO_PAGE, page) } export default { goTo, }
```

# src/utils/response.ts

```ts
import { Status } from '@/constants' import type { Response } from '@/types' const success = <T = any>(data?: T | null): Response<T | undefined | null> => { return { status: Status.SUCCESS, data: data, } } const error = (error: string | undefined | null): Response<null> => { return { status: Status.FAILED, error: error, } } export const response = { success, error, }
```

# src/utils/serialize.ts

```ts
import type { ChatModel, ContactModel, GroupMetadataModel, MediaDataModel, MsgModel, ParticipantModel, } from '@wppconnect/wa-js/dist/whatsapp' import _ from 'lodash' import country from './country' const button = (buttons: any[]) => { return buttons .map(({ type, label, value }) => { switch (type) { case 'text': return { text: value } case 'url': return { text: label, url: value } case 'phoneNumber': return { text: label, phoneNumber: value } default: break } }) .filter((button) => !!button) } const list = (rows: any[]) => { return rows.filter((row) => row.title !== '') } const contact = (contact: ContactModel) => { if (!contact) return {} const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) const hasUnread = WPP.chat.get(contact.id._serialized)?.hasUnread ?? false const selectedCountry = country.getCountryByCode(countryCode) return { id: contact.id._serialized, avatar: contact.getProfilePicThumb().__x_eurl, country: selectedCountry.label, name: contact.name, pushname: contact.pushname, shortname: contact.shortName, notifyName: contact.notifyName, formattedName: contact.formattedName, formattedPhone: contact.formattedPhone, formattedShortName: contact.formattedShortName, formattedShortNameWithNonBreakingSpaces: contact.formattedShortNameWithNonBreakingSpaces, formattedUser: contact.formattedUser, isBusiness: contact.isBusiness, isContactBlocked: contact.isContactBlocked, //@ts-ignore isFavorite: contact.isFavorite, isGroup: contact.isGroup, isMe: contact.isMe, isMyContact: contact.isMyContact, isUser: contact.isUser, isWaContact: contact.isWAContact, labels: contact.labels, hasUnread, } } const mediaData = (data?: MediaDataModel) => { if (!data) return {} return { mimeType: data?.mimetype, size: data?.size, base64: data?.preview?.base64, height: data?.fullHeight, width: data?.fullWidth, } } const message = (msgModel: MsgModel) => { return { id: msgModel.id._serialized, ack: msgModel.ack, body: msgModel.body, from: msgModel.from, isViewOnce: msgModel.isViewOnce, timestamp: msgModel.t * 1000, to: msgModel.to, type: msgModel.type, mimetype: msgModel.mimetype, size: msgModel.size, filename: msgModel.filename, caption: msgModel.caption, duration: msgModel.duration, height: msgModel.height, width: msgModel.width, quotedMessage: msgModel.quotedMsg, contact: contact(msgModel.senderObj), } } const groupMetadata = (data: GroupMetadataModel) => { return { id: data?.id?._serialized, description: data?.desc, size: data?.size, subject: data?.subject, creation: data?.creation * 1000, participants: data?.participants?.getModelsArray().map(participant), } } const chat = (chat: ChatModel) => { return { id: chat.id._serialized, name: chat.name, messages: chat.msgs.getModelsArray().map(message), contact: contact(chat.contact), groupMetadata: groupMetadata(chat.groupMetadata), } } const participant = (participant: ParticipantModel) => { return { id: participant.id, isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, contact: contact(participant.contact), } } export default { button, list, contact, chat, participant, message, }
```

# src/utils/style.ts

```ts
import appMenuStyle from 'data-text:@/components/AppMenu.module.css' import layoutStyle from 'data-text:@/components/Layout/LayoutPage.module.css' import toastStyle from 'data-text:@/components/Toast/Toast.module.css' import globalsStyle from 'data-text:@/styles/globals.css' import coreStyle from 'data-text:@mantine/core/styles.css' import dateStyle from 'data-text:@mantine/dates/styles.css' import dropzoneStyle from 'data-text:@mantine/dropzone/styles.css' import tableStyle from 'data-text:mantine-datatable/styles.layer.css' const styles = [ coreStyle, dateStyle, dropzoneStyle, tableStyle, toastStyle, globalsStyle, layoutStyle, appMenuStyle, ] const generate = () => { return styles.join('') } export default { generate }
```

# src/utils/throwError.ts

```ts
const broadcastNotFound = () => { throw new Error('Broadcast not found') } const mediaNotFound = () => { throw new Error('Media not found') } const contactNotExist = () => { throw new Error('Contact not exist') } export default { broadcastNotFound, mediaNotFound, contactNotExist, }
```

# src/utils/toast.ts

```ts
import { useToastStore } from '@/stores/toast' const showSuccess = (message: string, title: string = 'Success') => { useToastStore.getState().addToast({ type: 'success', title, message }) } const showError = (message: string, title: string = 'Error') => { useToastStore.getState().addToast({ type: 'error', title, message }) } const showInfo = (message: string, title: string = 'Information') => { useToastStore.getState().addToast({ type: 'info', title, message }) } const showWarning = (message: string, title: string = 'Warning') => { useToastStore.getState().addToast({ type: 'warning', title, message }) } export default { success: showSuccess, error: showError, info: showInfo, // ADDED: Export the new 'warning' function. warning: showWarning, }
```

# src/utils/util.ts

```ts
// src/utils/util.ts import { Action, Message } from '@/constants' import type { UseFormReturnType } from '@mantine/form' import { sendToBackground } from '@plasmohq/messaging' import _ from 'lodash' export async function delay(timeoutMs = 1000) { await new Promise((resolve) => setTimeout(resolve, timeoutMs)) } export const generateRandomDelay = (min: number, max: number) => { // Calculate the range of multiples of 1000 const minThousand = Math.ceil(min / 1000) const maxThousand = Math.floor(max / 1000) // Generate a random integer in that range and multiply by 1000 const randomThousand = Math.floor(Math.random() * (maxThousand - minThousand + 1)) + minThousand return randomThousand * 1000 } export const truncate = (data: string, length: number = 30) => { return _.chain(data) .thru((str) => (str.length > length ? `${str.slice(0, length)}...` : str)) .value() } export const postMessage = (action: string, body: any = null) => { window.postMessage({ action, body }) } export const showModalUpgrade = () => { postMessage(Action.Window.SHOW_MODAL_UPGRADE) } export const showModalMain = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } export const showModalActivation = () => { postMessage(Action.Window.SHOW_MODAL_ACTIVATION) } export const showModalProfile = () => { postMessage(Action.Window.SHOW_MODAL_PROFILE) } export const showModalFaq = () => { postMessage(Action.Window.SHOW_MODAL_FAQ) } export const goToLandingPage = async () => { await sendToBackground({ name: 'landing-page', body: {}, }) } export const getStoreId = () => { return process.env.PLASMO_PUBLIC_STORE_ID } export const isTypeMessageMedia = (type: string) => { return [Message.MEDIA, Message.IMAGE, Message.VIDEO, Message.FILE].includes( type, ) } export const formHasErrors = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ): boolean => { let hasError = false if (form1.validate().hasErrors) { hasError = true } if (form2.validate().hasErrors) { hasError = true } return hasError } export const resetForms = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ) => { form1.reset() form2.reset() } /** * @description Generates a thumbnail from a video file. * @param {File} file The video file. * @returns {Promise<string>} A promise that resolves with a base64 data URL of the thumbnail. */ export const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve, reject) => { try { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.muted = true video.playsInline = true video.onloadeddata = () => { canvas.width = video.videoWidth canvas.height = video.videoHeight video.currentTime = 1 // Seek to 1 second to get a good frame video.onseeked = () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up memory resolve(thumbnailUrl) } else { reject(new Error('Could not get canvas context.')) } } } video.onerror = () => { URL.revokeObjectURL(video.src) reject(new Error('Failed to load video file for thumbnail.')) } video.src = URL.createObjectURL(file) } catch (error) { reject(error) } }) } export const getContactName = (contact: any) => { return ( contact.name || contact.pushname || contact.notifyName || contact.formattedName || '-' ) }
```

# tsconfig.json

```json
{ "extends": "plasmo/templates/tsconfig.base", "exclude": ["node_modules"], "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"], "compilerOptions": { "paths": { "@/*": ["src/*"] }, "baseUrl": "." } }
```

