# assets/icon.png

This is a binary file of the type: Image

# package.json

```json
{ "name": "whats-backup", "displayName": "WhatsBackup - WA Chats Backup & Exporter for WhatsApp", "version": "1.0.0", "description": "Save your WhatsApp chat and export to PDF, Excel, or CSV.", "author": "Extninja", "scripts": { "dev": "plasmo dev --no-cs-reload", "build": "plasmo build", "package": "plasmo package" }, "dependencies": { "@haverstack/axios-fetch-adapter": "^0.12.0", "@lemonsqueezy/lemonsqueezy.js": "^4.0.0", "@mantine/core": "^8.2.2", "@mantine/dates": "^8.2.2", "@mantine/dropzone": "^8.2.2", "@mantine/form": "^8.2.2", "@mantine/hooks": "^8.2.2", "@plasmohq/messaging": "0.7.1", "@plasmohq/storage": "^1.15.0", "@wppconnect/wa-js": "^3.18.0", "axios": "^1.11.0", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dayjs": "^1.11.13", "dexie": "^4.0.11", "dexie-react-hooks": "^1.1.7", "emoji-picker-react": "^4.13.2", "file-saver": "^2.0.5", "html2canvas": "^1.4.1", "jquery": "^3.7.1", "jspdf": "^3.0.1", "jszip": "^3.10.1", "lodash": "^4.17.21", "mantine-datatable": "^8.2.0", "plasmo": "0.90.5", "react": "18.2.0", "react-dom": "18.2.0", "react-if": "^4.1.6", "webextension-polyfill": "^0.12.0", "xlsx": "^0.18.5", "zustand": "^5.0.7" }, "devDependencies": { "@ianvs/prettier-plugin-sort-imports": "4.1.1", "@iconify/react": "^6.0.0", "@types/chrome": "0.0.258", "@types/file-saver": "^2.0.7", "@types/jquery": "^3.5.32", "@types/lodash": "^4.17.20", "@types/node": "20.11.5", "@types/react": "18.2.48", "@types/react-dom": "18.2.18", "@types/webextension-polyfill": "^0.12.3", "postcss": "^8.5.6", "postcss-preset-mantine": "1.17.0", "postcss-simple-vars": "^7.0.1", "prettier": "3.2.4", "typescript": "5.3.3" }, "manifest": { "host_permissions": [ "https://web.whatsapp.com/*", "https://api.lemonsqueezy.com/*" ], "permissions": [] } }
```

# postcss.config.cjs

```cjs
module.exports = { plugins: { 'postcss-preset-mantine': {}, 'postcss-simple-vars': { variables: { 'mantine-breakpoint-xs': '36em', 'mantine-breakpoint-sm': '48em', 'mantine-breakpoint-md': '62em', 'mantine-breakpoint-lg': '75em', 'mantine-breakpoint-xl': '88em', }, }, }, }
```

# README.md

```md
This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo). ## Getting Started First, run the development server: \`\`\`bash pnpm dev # or npm run dev \`\`\` Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`. You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser. For further guidance, [visit our Documentation](https://docs.plasmo.com/) ## Making production build Run the following: \`\`\`bash pnpm build # or npm run build \`\`\` This should create a production bundle for your extension, ready to be zipped and published to the stores. ## Submit to the webstores The easiest way to deploy your Plasmo extension is to use the built-in [bpp](https://bpp.browser.market) GitHub action. Prior to using this action however, make sure to build your extension and upload the first version to the store to establish the basic credentials. Then, simply follow [this setup instruction](https://docs.plasmo.com/framework/workflows/submit) and you should be on your way for automated submission!
```

# src/background/index.ts

```ts
import { Action, Setting } from '@/constants' import { storage } from '@/libs/storage' import { getTabByUrl, openWa } from '@/utils/ext' import { sendToContentScript } from '@plasmohq/messaging' import browser from 'webextension-polyfill' browser.runtime.onInstalled.addListener(async (details) => { if (details.reason === 'install') { await storage.set(Setting.LICENSE_KEY, null) await storage.set(Setting.IS_FIRST_TIME, true) await storage.set(Setting.NEED_TO_OPEN, true) await storage.set(Setting.BLUR_PROFILE_PICTURES, false) await storage.set(Setting.BLUR_MESSAGES, false) await storage.set(Setting.BLUR_USER_GROUP_NAMES, false) await storage.set(Setting.BLUR_RECENT_MESSAGES, false) await openWa() } }) browser.action.onClicked.addListener(async () => { const waTab = await getTabByUrl('https://web.whatsapp.com/') if (waTab?.active) { sendToContentScript({ name: Action.Window.SHOW_MODAL_MAIN, }) return } await storage.set(Setting.NEED_TO_OPEN, true) await openWa() })
```

# src/background/messages/http.ts

```ts
import http from '@/libs/http' import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { url, method, data, config } = req.body const httpInstance = { POST: () => { return http.post(url, data, config) }, GET: () => { return http.get(url, config) }, } const result = await httpInstance[method]?.() return res.send(result.data) } export default handler
```

# src/background/messages/landing-page.ts

```ts
import type { PlasmoMessaging } from '@plasmohq/messaging' import browser from 'webextension-polyfill' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const url = browser.runtime.getURL('tabs/landing-page.html') await browser.tabs.create({ url }) return res.send({}) } export default handler
```

# src/background/messages/lemonsqueezy.ts

```ts
import lemonSqueezy from '@/libs/ls' import type { PlasmoMessaging } from '@plasmohq/messaging' import pkg from '../../../package.json' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body try { let response switch (action) { case 'validateLicense': response = await lemonSqueezy.validateLicense(body.licenseKey) break case 'activateLicense': response = await lemonSqueezy.activateLicense(body.licenseKey, pkg.name) break case 'deactivateLicense': response = await lemonSqueezy.deactivateLicense( body.licenseKey, body.instanceId, ) break case 'getCustomer': response = await lemonSqueezy.getCustomer(body.customerId) break default: return res.send({ error: 'Invalid Lemon Squeezy action' }) } res.send(response) } catch (error) { // Tangani error yang mungkin dilempar oleh SDK Lemon Squeezy res.send({ error: true, message: error.message || 'An unknown error occurred.', }) } } export default handler
```

# src/components/AppMenu.module.css

```css
.tab { &:hover, &[data-active] { background-color: var(--mantine-primary-color-filled-hover); } }
```

# src/components/AppMenu.tsx

```tsx
import { Action, Page, Setting } from '@/constants' import PageChatBackup from '@/features/tools/backup-chat/PageChatBackup' import useLicense from '@/hooks/useLicense' import useRuntimeMessage from '@/hooks/useRuntimeMessage' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import { goToLandingPage } from '@/utils/util' import { Icon } from '@iconify/react' import { Box, Stack, Tabs, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' import classes from './AppMenu.module.css' import Modal from './Modal/Modal' import ModalActivation from './Modal/ModalActivation' import ModalFaq from './Modal/ModalFaq' import ModalProfile from './Modal/ModalProfile' const AppMenu: React.FC = () => { const { setIsReady, setActiveChat } = useAppStore() const license = useLicense() const [showModalMain, modalMain] = useDisclosure(true) const [showModalActivation, modalActivation] = useDisclosure(false) const [showModalFaq, modalFaq] = useDisclosure(false) const [showModalProfile, modalProfile] = useDisclosure(false) const [needToOpen, setNeedToOpen] = useStorage(Setting.NEED_TO_OPEN, false) const [activeTab, setActiveTab] = useState<string | null>(Page.CHAT_BACKUP) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.ACTIVE_CHAT: setActiveChat(body) break case Action.Window.GO_TO_PAGE: setActiveTab(body) break case Action.Window.SHOW_MODAL_UPGRADE: goToLandingPage() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break case Action.Window.SHOW_MODAL_FAQ: modalFaq.toggle() break case Action.Window.SHOW_MODAL_PROFILE: modalProfile.toggle() break default: break } }) useRuntimeMessage((message, sender, sendResponse) => { switch (message.name) { case Action.Window.SHOW_MODAL_MAIN: modalMain.toggle() sendResponse() break default: break } // Return true to keep the message channel open for async responses return true }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { if (needToOpen) { modalMain.open() setNeedToOpen(false).then().catch(console.error) } }, [needToOpen]) const handleChangeTab = (value: string | null) => { if (Page.UPGRADE === value) { goToLandingPage() return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } if (Page.FAQ === value) { modalFaq.toggle() return } if (Page.PROFILE === value) { modalProfile.toggle() return } setActiveTab(value) } const renderTabList = () => { return ( <Tabs.List style={{ gap: 10, background: 'var(--mantine-primary-color-filled)', }} > <Stack justify="space-between" gap={0} style={{ height: '100%' }}> <Box> <Tabs.Tab value={Page.CHAT_BACKUP} className={classes.tab}> <Tooltip label="Backup" position="left"> <Icon icon="tabler:database-export" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> </Box> <Box> <Tabs.Tab value={Page.FAQ} className={classes.tab}> <Tooltip label="Faqs"> <Icon icon="tabler:world-question" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.UPGRADE} className={classes.tab}> <Tooltip label="Upgrade"> <Icon icon="tabler:crown" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab}> <Tooltip label="Activate"> <Icon icon="tabler:key" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PROFILE} className={classes.tab}> <Tooltip label="Profile"> <Icon icon="tabler:user-square-rounded" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> </Stack> </Tabs.List> ) } const renderTabPanel = () => { return ( <> <Tabs.Panel value={Page.CHAT_BACKUP}> <PageChatBackup /> </Tabs.Panel> </> ) } return ( <> <Modal opened={showModalMain} onClose={modalMain.close} p={0}> <Tabs value={activeTab} onChange={handleChangeTab} variant="pills" orientation="vertical" radius={0} keepMounted={false} > {renderTabList()} {renderTabPanel()} </Tabs> </Modal> <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <ModalFaq opened={showModalFaq} onClose={modalFaq.close} /> <ModalProfile opened={showModalProfile} onClose={modalProfile.close} /> </> ) } export default AppMenu
```

# src/components/Layout/LayoutPage.module.css

```css
.header { border-bottom: 1px solid var(--mantine-color-gray-3); } .footer { border-top: 2px solid var(--mantine-color-gray-3); }
```

# src/components/Layout/LayoutPage.tsx

```tsx
// src/components/Layout/LayoutPage.tsx import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import env from '@/utils/env' import { goToLandingPage } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Loader, Menu, ScrollArea, Stack, Text, Title, type MantineSpacing, type StyleProp, } from '@mantine/core' import icon from 'data-base64:../../../assets/icon.png' import { When } from 'react-if' import packageJson from '../../../package.json' import classes from './LayoutPage.module.css' interface Props { width?: StyleProp<React.CSSProperties['width']> | null height?: StyleProp<React.CSSProperties['height']> | null p?: StyleProp<MantineSpacing> title?: string | null children: React.ReactNode } const LayoutPage: React.FC<Props> = ({ width = 900, height = 620, p = 'xl', children, title = null, }: Props) => { const wa = useWa() const license = useLicense() const renderBody = () => { return ( <Stack p={'xl'} w={width}> {children} </Stack> ) } return ( <> <Stack w={width} gap={0}> <Group justify="space-between" px={'lg'} py={'xs'} className={classes.header} > <Group gap={6}> <img width={32} height={32} src={icon} style={{ borderRadius: 10, }} /> <Title order={4} ml={2}> {title ? title : packageJson.displayName} </Title> <When condition={license.isPro() && env.isProduction()}> <Button radius={'lg'} size="compact-sm" variant="outline" px={'sm'} > <Text fw={500}>Pro</Text> </Button> </When> </Group> {/* MODIFIED: Changed button text to be more benefit-focused. */} <When condition={license.isFree()}> <Button variant="filled" color="yellow" size="xs" radius="md" leftSection={<Icon icon="tabler:crown" fontSize={16} />} onClick={goToLandingPage} > Go Pro </Button> </When> </Group> {wa.isReady ? ( <ScrollArea h={height}>{renderBody()}</ScrollArea> ) : ( <Center h={height}> <Loader /> </Center> )} </Stack> </> ) } export default LayoutPage
```

# src/components/Modal/Modal.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Card, Paper, type MantineSpacing, type StyleProp, } from '@mantine/core' import React, { type CSSProperties } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void height?: string | number width?: string | number style?: CSSProperties withCloseButton?: boolean | false h?: StyleProp<React.CSSProperties['height']> w?: StyleProp<React.CSSProperties['width']> p?: StyleProp<MantineSpacing> children: React.ReactNode } const Modal: React.FC<Props> = ({ opened, onClose, style = {}, withCloseButton = false, p = 'lg', h, w, children, ...rest }: Props) => { if (!opened) return null return ( <> <div style={{ position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, zIndex: 399, width: '100%', height: '100%', backgroundColor: 'black', opacity: '0.15', }} onClick={onClose} ></div> <Box style={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 1050, ...style, }} {...rest} > <Card shadow={'xs'} p={p} w={w} h={h} radius={'md'}> <When condition={withCloseButton}> <ActionIcon onClick={onClose} color="red" variant="transparent" style={{ position: 'absolute', right: 3, top: 1, }} > <Icon icon="tabler:x" fontSize={16} /> </ActionIcon> <Box mb={'md'} /> </When> {children} </Card> </Box> </> ) } export default Modal
```

# src/components/Modal/ModalActivation.tsx

```tsx
// src/components/Modal/ModalActivation.tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, rem, Stack, Text, TextInput, ThemeIcon, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalActivation: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const form = useForm({ initialValues: defaultValues, validate: { license: (value) => _.isEmpty(value) ? 'A license key is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) const handleOnClose = () => { form.reset() onClose() } const handleSubmit = async () => { const { hasErrors } = form.validate() if (hasErrors) { return } setLoading(true) form.clearErrors() try { const response = await license.activate(form.values.license) if (response.data.error) { form.setFieldError('license', response.data.error.replace(/_/g, ' ')) setLoading(false) return } if (response.data.meta.store_id.toString() !== getStoreId()) { form.setFieldError( 'license', 'This license key is not valid for this product.', ) setLoading(false) return } toast.success('Successfully activated! ðŸŽ‰') handleOnClose() } catch (err) { console.error('Activation error:', err) form.setFieldError( 'license', 'An unexpected error occurred. Please try again.', ) } finally { setLoading(false) } } return ( <Modal opened={opened} onClose={handleOnClose} w={500} p="xl" withCloseButton > <Stack gap="lg"> <Stack align="center" gap="xs"> <ThemeIcon color="teal" size={rem(60)} radius="xl"> <Icon icon="tabler:key" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> {' '} License Activation{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Enter your license key below to unlock all Pro features.{' '} </Text> </Stack> <Stack> <TextInput label="License Key" placeholder="xxxx-xxxx-xxxx-xxxx" required leftSection={<Icon icon="tabler:key" fontSize={18} />} {...form.getInputProps('license')} /> {/* MODIFIED: Replaced text with more reassuring microcopy. */} <Text size="xs" c="dimmed"> {' '} Your license key validates your purchase, ensuring you receive lifetime access and all future updates.{' '} </Text> </Stack> <Button loading={loading} onClick={handleSubmit} fullWidth size="md" mt="md" leftSection={<Icon icon="tabler:circle-check" fontSize={20} />} > {' '} Activate License{' '} </Button> </Stack> </Modal> ) } export default ModalActivation
```

# src/components/Modal/ModalFaq.tsx

```tsx
// src/components/Modal/ModalFaq.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Accordion, Anchor, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const faqData = [ { icon: 'tabler:rocket', question: 'What are the main benefits of upgrading to Pro?', answer: "With Pro, you get **Total Protection** by backing up all messages and media without limitsâ€”no more risk of losing important data or precious memories. You'll unlock **Exclusive Features** like custom date ranges, Excel/CSV exports, and upcoming premium tools. Plus, you receive **Priority Support**, ensuring our team assists you first whenever you need help.", }, { icon: 'tabler:key', question: 'Where can I find my license key?', answer: 'You will receive an email from Lemon Squeezy after making a purchase. This email usually contains your purchase details and your license key.', }, { icon: 'tabler:shield-lock', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our priority. This extension does not collect, store, or share any personal data from your WhatsApp account. All processes occur locally on your device.', }, { icon: 'tabler:mail-question', question: 'How can I get more help and support?', answer: 'If you have other questions or need assistance, please feel free to email us at extdotninja@gmail.com. Our team will be happy to help you.', }, ] const ModalFaq: React.FC<Props> = ({ opened, onClose }: Props) => { const handleOnClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleOnClose} withCloseButton w={700}> <Stack> <Stack align="center" gap={4} mb={'xl'}> <Icon icon="tabler:world-question" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> Frequently Asked Questions </Title> </Stack> {/* Accordion */} <Accordion variant="separated" radius="md"> {faqData.map((item) => ( <Accordion.Item key={item.question} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > {/* MODIFIED: Changed the answer to markdown-like bolding for emphasis. */} <Text fw={500} dangerouslySetInnerHTML={{ __html: item.question.replace( /\*\*(.*?)\*\*/g, '<b>$1</b>', ), }} ></Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} ></Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> {/* Contact Support */} <Paper withBorder p="md" shadow="none" radius="md" mt="xl"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still have questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us via email. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Paper> </Stack> </Modal> ) } export default ModalFaq
```

# src/components/Modal/ModalProfile.tsx

```tsx
// src/features/profile/PageProfile.tsx import { Setting } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import { goToLandingPage, showModalActivation } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' import packageJson from '../../../package.json' import Modal from './Modal' interface Props { opened: boolean onClose: () => void } const ModalProfile: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const { profile, license: licenseData } = useAppStore() const [licenseKey] = useStorage(Setting.LICENSE_KEY) const handleDeactivate = async () => { if ( confirm( 'Are you sure you want to deactivate your license on this device?', ) ) { await license.deactivate() } } const handleUpgrade = () => { goToLandingPage() } const handleActivate = () => { showModalActivation() } const maskLicenseKey = (key: string | undefined | null) => { if (!key) return 'N/A' const keyParts = key.split('-') if (keyParts.length > 1) { return `****-****-****-${keyParts[keyParts.length - 1]}` } return '****' + key.slice(-4) } const InfoItem = ({ icon, label, value, }: { icon: string label: string value: React.ReactNode }) => ( <Group wrap="nowrap" gap="lg"> <ThemeIcon variant="light" size={36} radius="md"> <Icon icon={icon} fontSize={20} /> </ThemeIcon> <div> <Text size="xs" c="dimmed"> {label} </Text> <Text size="sm" fw={500}> {value || '-'} </Text> </div> </Group> ) return ( <Modal opened={opened} onClose={onClose} withCloseButton w={700}> <Stack> {/* Account Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Title order={5}>Account Details</Title> <Divider /> <InfoItem icon="tabler:info-circle" label="App Version" value={packageJson.version} /> </Stack> </Card> {/* License Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>License Status</Title> <Badge color={license.isPro() ? 'teal' : 'gray'} size="lg" variant="filled" > {license.isPro() ? 'Pro' : 'Free'} </Badge> </Group> <Divider /> <When condition={license.isPro()}> <Stack my="xs" gap="sm"> <InfoItem icon="tabler:user" label="Licensed To" value={licenseData?.meta.customer_name} /> <InfoItem icon="tabler:mail" label="Email" value={licenseData?.meta.customer_email} /> <InfoItem icon="tabler:key" label="License Key" value={maskLicenseKey(licenseKey)} /> <InfoItem icon="tabler:calendar-event" label="Expires On" value={ licenseData?.license_key.expires_at ? dayjs(licenseData.license_key.expires_at).format( 'DD MMMM YYYY', ) : 'Lifetime' } /> </Stack> </When> <Text size="sm" c="dimmed"> {license.isPro() ? 'Thank you for being a Pro user! You have access to all features.' : 'Upgrade to Pro to unlock all features.'} </Text> <Group justify="flex-end" mt="md"> <When condition={license.isFree()}> <Button onClick={handleUpgrade} color="teal" leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Pro </Button> <Button onClick={handleActivate} variant="outline" leftSection={<Icon icon="tabler:key" fontSize={18} />} > Activate License </Button> </When> <When condition={license.isPro()}> <Button onClick={license.goToMyOrders} variant="outline" leftSection={<Icon icon="tabler:credit-card" fontSize={18} />} > Manage Subscription </Button> <Button onClick={handleDeactivate} color="red" variant="light" leftSection={<Icon icon="tabler:key-off" fontSize={18} />} > Deactivate License </Button> </When> </Group> </Stack> </Card> <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>Data Privacy Guarantee</Title> <ThemeIcon variant="light" color="teal"> <Icon icon="tabler:shield-check" fontSize={20} /> </ThemeIcon> </Group> <Divider /> <Text size="sm" c="dimmed"> All your data is stored only on your computer and is never sent to our servers. You have 100% control over your data. </Text> </Stack> </Card> </Stack> </Modal> ) } export default ModalProfile
```

# src/components/Modal/ModalUpgrade.tsx

```tsx
// src/components/Modal/ModalUpgrade.tsx import Modal from '@/components/Modal/Modal' import { goToLandingPage } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Group, rem, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void featureName: string featureBenefit: string } /** * English: A modal to inform free users about a Pro feature they've tried to access. * It provides context about the feature's benefits and offers a clear path to upgrade. */ const ModalUpgrade: React.FC<Props> = ({ opened, onClose, featureName, featureBenefit, }) => { const handleUpgrade = () => { goToLandingPage() onClose() } return ( <Modal opened={opened} onClose={onClose} w={500} p="xl" withCloseButton> <Stack gap="lg" align="center"> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} size={rem(60)} radius="xl" > <Icon icon="tabler:rocket" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> Unlock: {featureName} </Title> <Text c="dimmed" size="sm" ta="center"> {featureBenefit} </Text> <Text size="sm" ta="center" fw={500}> Upgrade to Pro to unlock this feature and many more! </Text> {/* MODIFIED: Wrapped CTA button and added trust signals. */} <Stack align="center" gap="xs" mt="md" w="100%"> <Group justify="center" style={{ width: '100%' }}> <Button variant="outline" onClick={onClose}> Maybe Later </Button> <Button onClick={handleUpgrade} leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > Upgrade Now </Button> </Group> {/* English: Add trust signals below the CTA to increase user confidence. */} <Group justify="center" gap={6} mt="xs"> <Icon icon="tabler:lock" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> Secure Payment & 30-Day Money-Back Guarantee </Text> </Group> </Stack> </Stack> </Modal> ) } export default ModalUpgrade
```

# src/components/Promo/PromoIcon.tsx

```tsx
// English: A simple, professional icon wrapper for branding. // This component is reusable for generating different icon sizes and types. import { Icon } from '@iconify/react' import { ThemeIcon } from '@mantine/core' import React from 'react' interface Props { size: number icon: string } const PromoIcon: React.FC<Props> = ({ size, icon }) => { return ( <ThemeIcon size={size} radius="lg" variant="gradient" gradient={{ from: 'teal', to: 'lime', deg: 105 }} > {/* Use the Icon component for dynamic icon rendering */} <Icon icon={icon} style={{ width: '70%', height: '70%', color: 'white' }} /> </ThemeIcon> ) } export default PromoIcon
```

# src/components/Promo/ScreenshotWrapper.tsx

```tsx
// src/components/Promo/ScreenshotWrapper.tsx // English: A reusable wrapper to handle screenshot generation and download logic. // It takes a title, a child component to render, and a filename. import { Icon } from '@iconify/react' import { Button, Card, Group, Stack, Text, Title } from '@mantine/core' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import React, { useRef, useState } from 'react' interface Props { title: string filename: string children: React.ReactNode } const ScreenshotWrapper: React.FC<Props> = ({ title, filename, children }) => { const screenshotRef = useRef<HTMLDivElement>(null) const [isLoading, setIsLoading] = useState(false) const handleDownload = async () => { if (!screenshotRef.current) return setIsLoading(true) try { const canvas = await html2canvas(screenshotRef.current, { scale: 2, // Higher scale for better resolution useCORS: true, // Use component's own background and handle transparency correctly. backgroundColor: null, }) canvas.toBlob((blob) => { if (blob) { FileSaver.saveAs(blob, filename) } }) } catch (error) { console.error('Failed to generate screenshot:', error) } finally { setIsLoading(false) } } return ( <Card withBorder radius="md"> <Stack> <Group justify="space-between"> <Title order={4}>{title}</Title> <Button size="xs" variant="light" onClick={handleDownload} loading={isLoading} leftSection={<Icon icon="tabler:download" fontSize={16} />} > Download </Button> </Group> <div ref={screenshotRef} style={{ alignSelf: 'flex-start', }} > {children} </div> </Stack> </Card> ) } export default ScreenshotWrapper
```

# src/components/Toast/Toast.module.css

```css
@keyframes fadeIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .toast { animation: fadeIn 0.3s ease-out forwards; }
```

# src/components/Toast/Toast.tsx

```tsx
import { type Toast } from '@/stores/toast' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Text, ThemeIcon } from '@mantine/core' import { useEffect } from 'react' import classes from './Toast.module.css' interface ToastProps extends Toast { onClose: () => void } const ToastComponent: React.FC<ToastProps> = ({ id, type, title, message, duration = 2000, onClose, }) => { useEffect(() => { const timer = setTimeout(() => { onClose() }, duration) return () => clearTimeout(timer) }, [id, duration, onClose]) const toastConfig = { success: { icon: 'tabler:check', color: 'teal' }, error: { icon: 'tabler:x', color: 'red' }, info: { icon: 'tabler:info-circle', color: 'blue' }, // ADDED: Configuration for the new 'warning' type. warning: { icon: 'tabler:alert-triangle', color: 'orange' }, } const { icon, color } = toastConfig[type] return ( <Paper shadow="lg" p="sm" radius="md" withBorder className={classes.toast} style={{ minWidth: 350, maxWidth: 400 }} > <Group align="flex-start" wrap="nowrap"> <ThemeIcon color={color} size={36} radius="xl" mt={4}> <Icon icon={icon} fontSize={22} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Text fw={600} size="md"> {title} </Text> <Text size="sm" c="dimmed"> {message} </Text> </Stack> <ActionIcon variant="transparent" color="gray" onClick={onClose}> <Icon icon="tabler:x" /> </ActionIcon> </Group> </Paper> ) } export default ToastComponent
```

# src/components/Toast/ToastProvider.tsx

```tsx
import { useToastStore } from '@/stores/toast' import { Box } from '@mantine/core' import React from 'react' import ToastComponent from './Toast' const ToastProvider: React.FC = () => { const { toasts, removeToast } = useToastStore() return ( <Box style={{ position: 'fixed', top: 20, right: 20, zIndex: 2000, display: 'flex', flexDirection: 'column', gap: '10px', }} > {toasts.map((toast) => ( <ToastComponent key={toast.id} id={toast.id} type={toast.type} title={toast.title} message={toast.message} duration={toast.duration} onClose={() => removeToast(toast.id)} /> ))} </Box> ) } export default ToastProvider
```

# src/config/plans.ts

```ts
// src/config/plans.ts // English: Define a structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // English: Centralized list of features for easy management and comparison export const features: PlanFeature[] = [ { feature: 'Message Backups', free: 'Up to 10 messages', pro: 'Unlimited', }, { feature: 'Backup Media (Images, Videos, Docs)', free: false, pro: true, }, { feature: 'Advanced Date Range Filtering', free: 'Last 7 days only', pro: true, }, { feature: 'Multiple Keyword Filtering', free: '1 keyword', // MODIFIED: Changed from `false` to specify the limit. pro: 'Unlimited', // MODIFIED: Changed from `true` to be more descriptive. }, { feature: 'Export to Multiple Formats', free: 'HTML only', pro: 'PDF, CSV, Excel, JSON, TXT', }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, ] // English: Define plan objects for the pricing cards. // This array structure allows for easy side-by-side comparison in the UI. const plans = [ { name: 'Free', isFree: true, description: 'For basic chat backup needs.', price: '$0', placeholderPrice: null, link: '#', features: [ 'Backup up to 10 messages per chat', 'Text-only backups', 'Export to HTML format', 'Limited to the last 7 days', ], }, { name: 'Pro Lifetime', isFree: false, description: 'Pay once, access all features forever.', placeholderPrice: '$89', price: '$39', link: 'https://extdotninja.lemonsqueezy.com/buy/554f3fc2-a924-496d-9b4e-57e21e55a59a?media=0&logo=0&desc=0&discount=0', features: [ 'Unlimited Message Backups', 'Backup All Media Types', 'Advanced Date & Keyword Filters', 'Multiple Export Formats', 'Priority Customer Support', 'All Future Updates Included', ], }, ] export default plans
```

# src/constants/action.ts

```ts
export const App = { HTTP: 'App.HTPP', AI: 'App.AI', } export const Blocklist = { ALL: 'Blocklist.ALL', BLOCK_CONTACT: 'Blocklist.BLOCK_CONTACT', IS_BLOCKED: 'Blocklist.IS_BLOCKED', UNBLOCK_CONTACT: 'Blocklist.UNBLOCK_CONTACT', } export const Cart = { ADD: 'Cart.ADD', CLEAR: 'Cart.CLEAR', GET: 'Cart.GET', GET_THUMB_FROM_CART: 'Cart.GET_THUMB_FROM_CART', REMOVE: 'Cart.REMOVE', SUBMIT: 'Cart.SUBMIT', UPDATE: 'Cart.UPDATE', } export const Catalog = { ADD_PRODUCT_IMAGE: 'Catalog.ADD_PRODUCT_IMAGE', CHANGE_PRODUCT_IMAGE: 'Catalog.CHANGE_PRODUCT_IMAGE', CREATE_COLLECTION: 'Catalog.CREATE_COLLECTION', CREATE_PRODUCT: 'Catalog.CREATE_PRODUCT', DELETE_COLLECTION: 'Catalog.DELETE_COLLECTION', DELETE_PRODUCT: 'Catalog.DELETE_PRODUCT', EDIT_COLLECTION: 'Catalog.EDIT_COLLECTION', EDIT_PRODUCT: 'Catalog.EDIT_PRODUCT', GET_COLLECTIONS: 'Catalog.GET_COLLECTIONS', GET_MY_CATALOG: 'Catalog.GET_MY_CATALOG', GET_PRODUCT_BY_ID: 'Catalog.GET_PRODUCT_BY_ID', GET_PRODUCTS: 'Catalog.GET_PRODUCTS', REMOVE_PRODUCT_IMAGE: 'Catalog.REMOVE_PRODUCT_IMAGE', SET_PRODUCT_VISIBILITY: 'Catalog.SET_PRODUCT_VISIBILITY', UPDAGE_CART_ENABLED: 'Catalog.UPDAGE_CART_ENABLED', } export const Community = { ADD_SUB_GROUPS: 'Community.ADD_SUB_GROUPS', } export const Chat = { ARCHIVE: 'Chat.ARCHIVE', CAN_MARK_PLAYED: 'Chat.CAN_MARK_PLAYED', CAN_MUTE: 'Chat.CAN_MUTE', CAN_REPLY: 'Chat.CAN_REPLY', CLEAR: 'Chat.CLEAR', CLOSE_CHAT: 'Chat.CLOSE_CHAT', DELETE: 'Chat.DELETE', DELETE_MESSAGE: 'Chat.DELETE_MESSAGE', DOWNLOAD_MEDIA: 'Chat.DOWNLOAD_MEDIA', // ++ ADDED FIND: 'Chat.FIND', FORWARD_MESSAGE: 'Chat.FORWARD_MESSAGE', GET: 'Chat.GET', GET_ACTIVE_CHAT: 'Chat.GET_ACTIVE_CHAT', GET_LAST_SEEN: 'Chat.GET_LAST_SEEN', GET_MESSAGE_ACK: 'Chat.GET_MESSAGE_ACK', GET_MESSAGES: 'Chat.GET_MESSAGES', GET_NOTES: 'Chat.GET_NOTES', GET_PLATFORM_MESSAGE: 'Chat.GET_PLATFORM_MESSAGE', MARK_IS_COMPOSING: 'Chat.MARK_IS_COMPOSING', MARK_IS_PAUSED: 'Chat.MARK_IS_PAUSED', MARK_IS_READ: 'Chat.MARK_IS_READ', MARK_IS_RECORDING: 'Chat.MARK_IS_RECORDING', MARK_IS_UNREAD: 'Chat.MARK_IS_UNREAD', MARK_PLAYED: 'Chat.MARK_PLAYED', MUTE: 'Chat.MUTE', OPEN_CHAT_AT: 'Chat.OPEN_CHAT_AT', OPEN_CHAT_BOTTOM: 'Chat.OPEN_CHAT_BOTTOM', OPEN_CHAT_FROM_UNREAD: 'Chat.OPEN_CHAT_FROM_UNREAD', PIN_MSG: 'Chat.PIN_MSG', LIST: 'Chat.LIST', SET_CHAT_LIST: 'Chat.SET_CHAT_LIST', SET_INPUT_TEXT: 'Chat.SET_INPUT_TEXT', SET_NOTES: 'Chat.SET_NOTES', } export const Contact = { GET: 'Contact.GET', GET_BUSINESS_PROFILE: 'Contact.GET_BUSINESS_PROFILE', GET_COMMON_GROUPS: 'Contact.GET_COMMON_GROUPS', GET_PROFILE_PICTURE_URL: 'Contact.GET_PROFILE_PICTURE_URL', GET_STATUS: 'Contact.GET_STATUS', LIST: 'Contact.LIST', LIST_CONTACT_BY_COUNTRY: 'Contact.LIST_CONTACT_BY_COUNTRY', IS_EXIST: 'Contact.IS_EXIST', REMOVE: 'Contact.REMOVE', } export const Conn = { GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER: 'Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER', GET_AUTH_CODE: 'Conn.GET_AUTH_CODE', GET_PROFILE: 'Conn.GET_PROFILE', GET_MY_USER_ID: 'Conn.GET_MY_USER_ID', } export const Group = { ADD_PARTICIPANTS: 'Group.ADD_PARTICIPANTS', APPROVE: 'Group.APPROVE', LIST: 'Group.LIST', CAN_ADD: 'Group.CAN_ADD', CAN_DEMOTE: 'Group.CAN_DEMOTE', CAN_PROMOTE: 'Group.CAN_PROMOTE', CAN_REMOVE: 'Group.CAN_REMOVE', CREATE: 'Group.CREATE', DEMOTE_PARTICIPANTS: 'Group.DEMOTE_PARTICIPANTS', GET_GROUP_INFO_FROM_INVITE_CODE: 'Group.GET_GROUP_INFO_FROM_INVITE_CODE', GET_GROUP_SIZE_LIMIT: 'Group.GET_GROUP_SIZE_LIMIT', GET_INVITE_LINK: 'Group.GET_INVITE_LINK', GET_MEMBERSHIP_REQUESTS: 'Group.GET_MEMBERSHIP_REQUESTS', GET_PARTICIPANTS: 'Group.GET_PARTICIPANTS', IAM_ADMIN: 'Group.IAM_ADMIN', IAM_MEMBER: 'Group.IAM_MEMBER', IAM_RESTRICTED_MEMBER: 'Group.IAM_RESTRICTED_MEMBER', IAM_SUPER_ADMIN: 'Group.IAM_SUPER_ADMIN', JOIN: 'Group.JOIN', LEAVE: 'Group.LEAVE', PROMOTE_PARTICIPANTS: 'Group.PROMOTE_PARTICIPANTS', REJECT: 'Group.REJECT', REMOVE_ICON: 'Group.REMOVE_ICON', REMOVE_PARTICIPANTS: 'Group.REMOVE_PARTICIPANTS', REVOKE_INVITE_CODE: 'Group.REVOKE_INVITE_CODE', SET_DESCRIPTION: 'Group.SET_DESCRIPTION', SET_ICON: 'Group.SET_ICON', SET_PROPERTY: 'Group.SET_PROPERTY', SET_SUBJECT: 'Group.SET_SUBJECT', } export const Newsletter = { CREATE: 'Newsletter.CREATE', DESTROY: 'Newsletter.DESTROY', EDIT: 'Newsletter.EDIT', GET_SUBSCRIBERS: 'Newsletter.GET_SUBSCRIBERS', MUTE: 'Newsletter.MUTE', } export const Send = { TEXT: 'Send.TEXT', IMAGE: 'Send.IMAGE', LOCATION: 'Send.LOCATION', DOCUMENT: 'Send.DOCUMENT', FILE: 'Send.FILE', POLL: 'Send.POLL', VCARD: 'Send.VCARD', } export const Status = { GET: 'Status.GET', GET_MY_STATUS: 'Status.GET_MY_STATUS', REMOVE: 'Status.REMOVE', SEND_IMAGE_STATUS: 'Status.SEND_IMAGE_STATUS', SEND_READ_STATUS: 'Status.SEND_READ_STATUS', SEND_TEXT_STATUS: 'Status.SEND_TEXT_STATUS', SEND_VIDEO_STATUS: 'Status.SEND_VIDEO_STATUS', UPDATE_PARTICIPANTS: 'Status.UPDATE_PARTICIPANTS', } export const Profile = { EDIT_BUSINESS_PROFILE: 'Profile.EDIT_BUSINESS_PROFILE', GET_MY_PROFILE_NAME: 'Profile.GET_MY_PROFILE_NAME', GET_MY_PROFILE_PICTURE: 'Profile.GET_MY_PROFILE_PICTURE', GET_MY_STATUS: 'Profile.GET_MY_STATUS', IS_BUSINESS: 'Profile.IS_BUSINESS', REMOVE_MY_PROFILE_PICTURE: 'Profile.REMOVE_MY_PROFILE_PICTURE', SET_MY_PROFILE_NAME: 'Profile.SET_MY_PROFILE_NAME', SET_MY_PROFILE_PICTURE: 'Profile.SET_MY_PROFILE_PICTURE', SET_MY_STATUS: 'Profile.SET_MY_STATUS', } export const AI = { REWRITE_MESSAGE: 'AI.REWRITE_MESSAGE', } export const Window = { READY: 'Window.READY', ACTIVE_CHAT: 'Window.ACTIVE_CHAT', GO_TO_PAGE: 'Window.GO_TO_PAGE', CLOSE_PAGE: 'Window.CLOSE_PAGE', SHOW_MODAL_MAIN: 'Window.SHOW_MODAL_MAIN', SHOW_MODAL_UPGRADE: 'Window.SHOW_MODAL_UPGRADE', SHOW_MODAL_ACTIVATION: 'Window.SHOW_MODAL_ACTIVATION', SHOW_MODAL_PROFILE: 'Window.SHOW_MODAL_PROFILE', SHOW_MODAL_FAQ: 'Window.SHOW_MODAL_FAQ', SEND_BROADCAST: 'Window.SEND_BROADCAST', }
```

# src/constants/index.ts

```ts
// src/constants/index.ts export * as Action from './action' export * as Setting from './setting' export const Status = { SUCCESS: 'SUCCESS', IDLE: 'IDLE', PENDING: 'PENDING', FAILED: 'FAILED', RUNNING: 'RUNNING', SCHEDULER: 'SCHEDULER', CANCELLED: 'CANCELLED', PAUSED: 'PAUSED', DRAFT: 'DRAFT', POSTED: 'POSTED', } export const Page = { HOME: 'Page.HOME', BROADCAST: 'Page.BROADCAST', TOOLS: 'Page.TOOLS', NUMBER_VALIDATOR: 'Page.NUMBER_VALIDATOR', DIRECT_CHAT: 'Page.DIRECT_CHAT', PRIVACY: 'Page.PRIVACY', EXPORT: 'Page.EXPORT', FAQ: 'Page.FAQ', UPGRADE: 'Page.UPGRADE', ACTIVATE: 'Page.ACTIVATE', PROFILE: 'Page.PROFILE', QUICK_REPLY: 'Page.QUICK_REPLY', WA_ME_GENERATOR: 'Page.WA_ME_GENERATOR', LABEL: 'Page.LABEL', GROUP_LINK_GENERATOR: 'Page.GROUP_LINK_GENERATOR', CHAT_BACKUP: 'Page.CHAT_BACKUP', // ++ ADDED } export const Account = { BUSINESS: 'BUSINESS', PERSONAL: 'PERSONAL', } export const Message = { TEXT: 'TEXT', MEDIA: 'MEDIA', IMAGE: 'IMAGE', VIDEO: 'VIDEO', AUDIO: 'AUDIO', FILE: 'FILE', LOCATION: 'LOCATION', VCARD: 'VCARD', BUTTON: 'BUTTON', LIST: 'LIST', POLL: 'POLL', } export const Media = { BROADCAST: 'BROADCAST', BROADCAST_TEMPLATE: 'BROADCAST_TEMPLATE', STATUS_CONTENT: 'STATUS_CONTENT', QUICK_REPLY: 'QUICK_REPLY', } export const ContactType = { ALL: 'CONTACT_TYPE_ALL', SAVED_CONTACTS: 'CONTACT_TYPE_SAVED_CONTACTS', UNSAVED_CONTACTS: 'CONTACT_TYPE_UNSAVED_CONTACTS', } export const AccountType = { ALL: 'ACCOUNT_TYPE_ALL', PERSONAL: 'ACCOUNT_TYPE_PERSONAL', BUSINESS: 'ACCOUNT_TYPE_BUSINESS', } export const MessageType = { ALL: 'MESSAGE_TYPE_ALL', HAVE_UNREAD_MESSAGES: 'MESSAGE_TYPE_HAVE_UNREAD_MESSAGES', NO_UNREAD_MESSAGES: 'MESSAGE_TYPE_NO_UNREAD_MESSAGES', } export const SaveAs = { CSV: 'SAVE_AS_CSV', EXCEL: 'SAVE_AS_EXCEL', PDF: 'SAVE_AS_PDF', JSON: 'SAVE_AS_JSON', MARKDOWN: 'SAVE_AS_MARKDOWN', HTML: 'SAVE_AS_HTML', VCARD: 'SAVE_AS_VCARD', }
```

# src/constants/setting.ts

```ts
export const LICENSE_KEY = 'SETTING_LICENSE_KEY' export const LICENSE_INSTANCE_ID = 'SETTING_LICENSE_INSTANCE_ID' export const LICENSE_DATA_CACHE = 'SETTING_LICENSE_DATA_CACHE' export const IS_FIRST_TIME = 'SETTING_IS_FIRST_TIME' export const NEED_TO_OPEN = 'SETTING_NEED_TO_OPEN' export const HAS_ACKNOWLEDGED_BROADCAST_WARNING = 'SETTING.HAS_ACKNOWLEDGED_BROADCAST_WARNING' export const BLUR_PROFILE_PICTURES = 'SETTING.BLUR_PROFILE_PICTURES' export const BLUR_MESSAGES = 'SETTING.BLUR_MESSAGES' export const BLUR_USER_GROUP_NAMES = 'SETTING.BLUR_USER_GROUP_NAMES' export const BLUR_RECENT_MESSAGES = 'SETTING.BLUR_RECENT_MESSAGES' export const EXPORT_COLUMNS = 'SETTING_EXPORT_COLUMNS'
```

# src/contents/inject-script.ts

```ts
import { Action } from '@/constants' import wa from '@/libs/wa' import { initInjectScriptRelays } from '@/relays' import { postMessage } from '@/utils/util' import type { PlasmoCSConfig } from 'plasmo' export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], world: 'MAIN', } initInjectScriptRelays() wa.on.ready(() => { setTimeout(() => { onReady() }, 2000) }) const onReady = () => { setTimeout(() => { window.postMessage({ action: Action.Window.READY, body: {}, }) WPP.on('chat.active_chat', (chat) => { const body = { name: chat.contact?.__x_pushname || chat.contact?.__x_verifiedName || chat.name || chat.formattedTitle, number: chat.id.user, formattedNumber: chat.id._serialized, isUser: chat.id._serialized.includes('@c.us'), isGroup: chat.id._serialized.includes('@g.us'), isBusiness: chat.contact?.__x_isBusiness, } postMessage(Action.Window.ACTIVE_CHAT, body) }) }, 1000) }
```

# src/contents/main.tsx

```tsx
import AppMenu from '@/components/AppMenu' import ToastProvider from '@/components/Toast/ToastProvider' import theme from '@/libs/theme' import style from '@/utils/style' import { MantineProvider } from '@mantine/core' import type { PlasmoCSConfig, PlasmoGetShadowHostId } from 'plasmo' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-main` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Main = () => { return ( <> <MantineProvider theme={theme} //@ts-ignore cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-main') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <AppMenu /> <ToastProvider /> </MantineProvider> </> ) } export default Main
```

# src/features/tools/backup-chat/components/BackupOptions.tsx

```tsx
// src/features/tools/backup-chat/components/BackupOptions.tsx import ModalUpgrade from '@/components/Modal/ModalUpgrade' import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import { getContactName } from '@/utils/util' import { Icon } from '@iconify/react' import { Avatar, Badge, Button, Checkbox, Group, Radio, Select, Stack, TagsInput, Text, Tooltip, } from '@mantine/core' import { DatePickerInput } from '@mantine/dates' import { useDisclosure } from '@mantine/hooks' import React, { useEffect, useState } from 'react' import type { useChatBackup } from '../hooks/useChatBackup' interface Props { // Pass the entire hook's return object for cleaner prop management. backupHook: ReturnType<typeof useChatBackup> onStart: () => void } // English: Define which message types are considered media for easier checking. const MEDIA_MESSAGE_TYPES = ['image', 'video', 'document', 'ptt'] // English: Define a type for the feature details to display in the upgrade modal. interface ProFeatureInfo { name: string benefit: string } const BackupOptions: React.FC<Props> = ({ backupHook, onStart }) => { // Destructure properties from the hook const { form, SUPPORTED_MESSAGE_TYPES } = backupHook const license = useLicense() const wa = useWa() const [chatOptions, setChatOptions] = useState<{ label: string; value: string; avatar: string }[]>() // MODIFIED: Added state management for the new upgrade modal. const [ isUpgradeModalOpen, { open: openUpgradeModal, close: closeUpgradeModal }, ] = useDisclosure(false) const [selectedFeature, setSelectedFeature] = useState<ProFeatureInfo>({ name: '', benefit: '', }) // English: A helper function to set feature details and open the upgrade modal. const triggerUpgradeModal = (name: string, benefit: string) => { setSelectedFeature({ name, benefit }) openUpgradeModal() } const datePresets = [ { value: 'today', label: 'Today', pro: false }, { value: 'yesterday', label: 'Yesterday', pro: false }, { value: 'last7', label: 'Last 7 Days', pro: false }, { value: 'last30', label: 'Last 30 Days', pro: true }, { value: 'thisMonth', label: 'This Month', pro: true }, { value: 'lastMonth', label: 'Last Month', pro: true }, { value: 'all', label: 'All Time', pro: true }, { value: 'custom', label: 'Custom Range...', pro: true }, ] const exportFormats = [ { value: 'html', label: 'HTML (.zip)', pro: false }, { value: 'txt', label: 'TXT', pro: true }, { value: 'json', label: 'JSON', pro: true }, { value: 'pdf', label: 'PDF', pro: true }, { value: 'csv', label: 'CSV', pro: true }, { value: 'xlsx', label: 'Excel', pro: true }, ] useEffect(() => { if (!wa.isReady) return wa.chat.list({ onlyUsers: true }).then((chats) => { const labelValueChats = chats.map((chat: any) => ({ label: getContactName(chat.contact), value: chat.id, avatar: chat.contact.avatar, })) setChatOptions(labelValueChats) }) }, [wa.isReady]) // MODIFIED: Instead of redirecting, this now shows a contextual modal. const handleDatePresetChange = (value: string | null) => { if (!value) return const option = datePresets.find((p) => p.value === value) if (license.isFree() && option?.pro) { triggerUpgradeModal( `"${option.label}" Date Range`, 'Gain the flexibility to back up your chats from any period, not just the last 7 days. Perfect for archiving older conversations.', ) return // English: Prevent setting the form value for the Pro feature. } form.setFieldValue('datePreset', value) } // MODIFIED: Instead of redirecting, this now shows a contextual modal. const handleExportFormatChange = (value: string) => { const format = exportFormats.find((f) => f.value === value) if (license.isFree() && format?.pro) { triggerUpgradeModal( `${format.label} Export`, `Exporting as ${ format.label.split(' ')[0] } allows for professional, easily shareable, or data-friendly archives of your chats.`, ) return // English: Prevent setting the form value for the Pro feature. } form.setFieldValue('exportFormat', value) } // MODIFIED: Instead of redirecting, this now shows a contextual modal for media types. const handleMessageTypeChange = (values: string[]) => { // Find if a new type was just added to the values array. const newType = values.find((v) => !form.values.messageTypes.includes(v)) // If a new type was selected, and it's a media type, and the user is on the Free plan, redirect. if (license.isFree() && newType && MEDIA_MESSAGE_TYPES.includes(newType)) { triggerUpgradeModal( 'Media Backups', 'Save not just the text, but also the photos, videos, documents, and voice notes that make your conversations complete.', ) return // English: Prevent setting the form value for the Pro feature. } form.setFieldValue('messageTypes', values) } const renderSelectOption = ({ option, }: { option: { value: string; label: string; avatar: string } }) => ( <Group> <Avatar src={option.avatar} size="md" radius="xl" /> <div> <Text size="sm">{option.label}</Text> </div> </Group> ) return ( <> {/* ADDED: Render the new upgrade modal, controlled by component state. */} <ModalUpgrade opened={isUpgradeModalOpen} onClose={closeUpgradeModal} featureName={selectedFeature.name} featureBenefit={selectedFeature.benefit} /> <Stack> <Select label="Select chat" data={chatOptions ?? []} searchable clearable required renderOption={renderSelectOption} {...form.getInputProps('chatId')} /> <Group justify="space-between" align="flex-end" wrap="nowrap"> <TagsInput label="Filter by Keywords (Optional)" placeholder={'Add keyword and press Enter'} description="Only export messages containing any of these keywords." value={form.values.keywords} onChange={(newKeywords) => { console.log(newKeywords) if (license.isFree() && newKeywords.length > 1) { triggerUpgradeModal( 'Multiple Keyword Filtering', 'Search your backups with unlimited keywords to find exactly what you need, instantly.', ) form.setFieldValue('keywords', [newKeywords[0]]) return } form.setFieldValue('keywords', newKeywords) }} error={form.errors.keywords} clearable style={{ flexGrow: 1 }} /> </Group> <Select label="Date Range" data={datePresets} value={form.values.datePreset} onChange={handleDatePresetChange} renderOption={({ option }) => { const preset = datePresets.find((p) => p.value === option.value) return ( <Group justify="space-between"> <Text>{option.label}</Text> </Group> ) }} /> {form.values.datePreset === 'custom' && ( <DatePickerInput type="range" label="Custom Date Range" placeholder="Pick a start and end date" {...form.getInputProps('dateRange')} required /> )} <Checkbox.Group label="Include Message Types" description="Select the types of messages to include in the backup." value={form.values.messageTypes} onChange={handleMessageTypeChange} > <Group mt="xs"> {SUPPORTED_MESSAGE_TYPES.map((type) => ( <Group key={type} gap="xs" align="center"> <Checkbox key={type} value={type} label={type.charAt(0).toUpperCase() + type.slice(1)} /> </Group> ))} </Group> </Checkbox.Group> <Radio.Group label="Format" value={form.values.exportFormat} onChange={handleExportFormatChange} > <Group mt="xs"> {exportFormats.map((format) => ( <Group key={format.value} gap="xs" align="center"> <Radio size="sm" value={format.value} label={format.label} /> </Group> ))} </Group> </Radio.Group> <Group justify="flex-end" mt={'xl'}> <Button leftSection={<Icon icon="tabler:download" />} onClick={onStart} disabled={!form.values.chatId} > Start Backup </Button> </Group> </Stack> </> ) } export default BackupOptions
```

# src/features/tools/backup-chat/components/BackupProgress.tsx

```tsx
// src/features/tools/chat-backup/components/BackupProgress.tsx import { Button, Center, Group, Progress, Stack, Text } from '@mantine/core' import React from 'react' interface Props { progress: { value: number label: string } onCancel: () => void } const BackupProgress: React.FC<Props> = ({ progress, onCancel }) => { return ( <Center h={250}> <Stack w="100%" align="center"> <Text size="lg" fw={500}> Backup in Progress... </Text> <Progress value={progress.value} animated size="lg" w="100%" /> <Text c="dimmed" size="sm"> {progress.label} </Text> <Button mt="lg" variant="outline" color="red" onClick={onCancel}> Cancel </Button> </Stack> </Center> ) } export default BackupProgress
```

# src/features/tools/backup-chat/components/BackupResult.tsx

```tsx
// src/features/tools/backup-chat/components/BackupResult.tsx import { goToLandingPage, showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Card, Center, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' import { When } from 'react-if' interface Props { result: { messagesExported: number messagesOmitted: number mediaOmitted: number isLimitApplied: boolean } onDone: () => void } const BackupResult: React.FC<Props> = ({ result, onDone }) => { const { messagesExported, messagesOmitted, mediaOmitted, isLimitApplied } = result return ( <Center> <Stack align="center" gap="lg"> <ThemeIcon color="teal" size={80} radius="xl"> <Icon icon="tabler:circle-check" fontSize={48} /> </ThemeIcon> <Title order={3}>Backup Complete!</Title> <Text c="dimmed" size="sm" ta="center" maw={400}> Successfully exported {messagesExported} messages. You can find the file in your downloads folder. </Text> <When condition={isLimitApplied}> {/* MODIFIED: The entire warning card has been updated for better psychological impact. */} <Card withBorder p="lg" shadow="none" radius="md" mt="md" style={{ width: '100%', borderColor: 'var(--mantine-color-orange-4)', backgroundColor: 'var(--mantine-color-orange-0)', }} > <Stack align="center" gap="sm"> <Group gap="xs"> <Icon icon="tabler:alert-triangle" color="var(--mantine-color-orange-7)" fontSize={24} /> {/* MODIFIED: Changed title to be more alarming and personal. */} <Title order={5} c="orange.9"> Warning: Some Memories Are At Risk! </Title> </Group> {/* MODIFIED: Changed text to emphasize the risk of permanent data loss. */} <Text ta="center" size="sm" c="dimmed"> <b>{messagesOmitted.toLocaleString()} messages</b> and{' '} <b>{mediaOmitted.toLocaleString()} media files</b> were NOT SAVED and could be lost forever. Upgrade now to protect all your data. </Text> <Button mt="sm" color="teal" onClick={goToLandingPage} leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Protect Everything </Button> </Stack> </Card> </When> <Button variant="outline" mt="xl" onClick={onDone}> Start Another Backup </Button> </Stack> </Center> ) } export default BackupResult
```

# src/features/tools/backup-chat/helpers/backupProcessor.ts

```ts
// src/features/tools/backup-chat/helpers/backupProcessor.ts import wa from '@/libs/wa' import { getContactName } from '@/utils/util' import { endOfDay, endOfMonth, isWithinInterval, startOfDay, startOfMonth, subDays, subMonths, } from 'date-fns' import _ from 'lodash' import { exportToHtml, exportToJson, exportToMarkdown, exportToPdf, exportToTxt, } from './exportUtils' // Interface for backup parameters. interface BackupParams { chatId: string exportFormat: string messageTypes: string[] keywords: string[] datePreset: string dateRange: [Date | null, Date | null] enableEncryption: boolean password?: string setProgress: (progress: { value: number; label: string }) => void validationRef?: React.MutableRefObject<boolean> } /** * @description The core logic for running a chat backup. * It's a standalone function that can be called from UI hooks or background listeners. * @param params The backup configuration. * @returns A promise that resolves to true on success/cancellation, and false on failure. */ export const runBackupProcess = async (params: Partial<BackupParams>) => { const { chatId, exportFormat = 'html', messageTypes = [], keywords = [], datePreset = 'all', dateRange = [null, null], enableEncryption = false, password, setProgress = () => {}, validationRef = { current: true }, } = params if (!chatId) { throw new Error('Chat ID is required to start a backup.') } setProgress({ value: 5, label: 'Fetching messages...' }) // Date range filtering logic. let effectiveDateRange: [Date | null, Date | null] = [null, null] if (datePreset === 'custom') { effectiveDateRange = dateRange } else if (datePreset !== 'all') { const now = new Date() let start: Date | null = null let end: Date | null = null switch (datePreset) { case 'today': start = startOfDay(now) end = endOfDay(now) break // ... other date presets } effectiveDateRange = [start, end] } const allMessages = await wa.chat.getMessages(chatId, { count: -1 }) const [startDate, endDate] = effectiveDateRange const lowercasedKeywords = keywords .map((k) => k.toLowerCase().trim()) .filter(Boolean) const filteredMessages = allMessages.filter((msg) => { const dateMatch = !startDate || !endDate || isWithinInterval(new Date(msg.timestamp), { start: startDate, end: endDate, }) const keywordMatch = lowercasedKeywords.length === 0 || lowercasedKeywords.some( (k) => (msg.body && msg.body.toLowerCase().includes(k)) || (msg.caption && msg.caption.toLowerCase().includes(k)), ) const typeMatch = messageTypes.includes(msg.type) return dateMatch && keywordMatch && typeMatch }) if (filteredMessages.length === 0) { throw new Error('No messages found matching your criteria to export.') } const chat = await wa.chat.find(chatId) const filename = `backup_chat_${_.snakeCase( getContactName(chat.data.contact), )}_${new Date().toISOString().slice(0, 10)}` const exporterParams = { messages: filteredMessages, chat, filename, includeMediaTypes: messageTypes, setProgress, validationRef, password: enableEncryption ? password : undefined, } switch (exportFormat) { case 'pdf': await exportToPdf(exporterParams) break case 'txt': await exportToTxt(exporterParams) break case 'json': await exportToJson(exporterParams) break case 'md': await exportToMarkdown(exporterParams) break case 'html': default: await exportToHtml(exporterParams) break } return validationRef.current }
```

# src/features/tools/backup-chat/helpers/exportUtils.ts

```ts
// src/features/tools/backup-chat/helpers/exportUtils.ts import wa from '@/libs/wa' import { generateVideoThumbnail, getContactName } from '@/utils/util' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import jsPDF from 'jspdf' import JSZip from 'jszip' import _ from 'lodash' import * as XLSX from 'xlsx' // MODIFIED: Added isProPreview to the interface. interface ExporterParams { messages: any[] // Messages now include an `isRedacted` property chat: any filename: string includeMediaTypes: string[] setProgress: (progress: { value: number; label: string }) => void validationRef: React.MutableRefObject<boolean> isLimitApplied?: boolean password?: string isProPreview?: boolean } const REDACTED_PLACEHOLDER = '********' const renderQuotedMessage = (quotedMsg: any): string => { if (!quotedMsg) return '' const quotedSenderName = quotedMsg.sender.isMe ? 'You' : getContactName(quotedMsg.sender) let quotedContent = '' switch (quotedMsg.type) { case 'chat': quotedContent = _.escape(quotedMsg.body) break case 'image': quotedContent = 'ðŸ“· Photo' break case 'video': quotedContent = 'ðŸŽ¥ Video' break case 'document': quotedContent = `ðŸ“„ ${_.escape(quotedMsg.filename) || 'Document'}` break case 'ptt': quotedContent = 'ðŸŽ¤ Voice Message' break default: quotedContent = `[Unsupported message type: ${quotedMsg.type}]` } return ` <a href="#message-${quotedMsg.id}" class="quoted-message-link"> <div class="quoted-message"> <div class="quoted-sender">${_.escape(quotedSenderName)}</div> <div class="quoted-content">${quotedContent}</div> </div> </a> ` } const getRedactedMediaHtml = (type: string): string => { const iconMap: { [key: string]: string } = { image: 'ðŸ–¼ï¸', video: 'ðŸŽ¬', document: 'ðŸ“„', ptt: 'ðŸŽµ', } const icon = iconMap[type] || 'ðŸ”’' return ` <div class="redacted-media-container"> <div class="redacted-bg">${icon}</div> <div class="redacted-overlay"> <div class="lock-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg> </div> <div class="redacted-text">Upgrade to Pro to view</div> </div> </div> ` } const getRedactedTextHtml = (): string => { return `<div class="redacted-text-placeholder">${REDACTED_PLACEHOLDER}</div>` } // MODIFIED: This function now accepts an `isProPreview` flag to render the correct header. const generateHtmlBody = async ({ messages, chat, includeMediaTypes, setProgress, validationRef, isForPdf = false, isLimitApplied = false, isProPreview = false, }: ExporterParams & { isForPdf?: boolean }): Promise<{ htmlBody: string mediaMap: Map<string, Blob> }> => { const exportedMessageCount = messages.filter((m) => !m.isRedacted).length const proPreviewNotice = isProPreview ? '<p style="color: #007bff; font-weight: bold;">Pro Preview: 1 of many media files was exported. Upgrade to Pro to back up all media without limits.</p>' : '' const headerHtml = ` <div class="export-header"> <p><b>Chat With:</b> ${_.escape(getContactName(chat.data.contact))}</p> <p><b>Export Date:</b> ${new Date().toLocaleString()}</p> <p><b>Total Messages Exported:</b> ${exportedMessageCount}</p> ${ isLimitApplied ? '<p style="color: #d9534f;"><b>Notice:</b> Free plan limit reached. Upgrade to Pro to save all messages and media.</p>' : '' } ${proPreviewNotice} </div> ` let messagesHtml = '' const mediaMap = new Map<string, Blob>() for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] if ( !['chat', 'image', 'video', 'document', 'ptt', 'location'].includes( msg.type, ) ) continue // Skip redacted messages from heavy processing. if (msg.isRedacted) { // Still need to render a placeholder for redacted text messages. if (msg.type === 'chat') { const direction = msg.contact.isMe ? 'out' : 'in' messagesHtml += ` <div class="message-cluster message-${direction}" id="message-${msg.id}"> <div class="message"> <div class="message-bubble"> <div class="message-content"> ${getRedactedTextHtml()} <span class="timestamp">${new Date( msg.timestamp, ).toLocaleTimeString([], { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', })}</span> </div> </div> </div> </div> ` } continue } const progressValue = ((i + 1) / messages.length) * 90 // Reserve last 10% setProgress({ value: progressValue, label: `Processing message ${i + 1} of ${messages.length}...`, }) const direction = msg.contact.isMe ? 'out' : 'in' const senderName = !msg.fromMe && chat.data.isGroup ? msg.contact?.pushname || msg.contact?.formattedName || 'Unknown' : '' let mediaHtml = '' const isMediaMessage = ['image', 'video', 'document', 'ptt'].includes( msg.type, ) const shouldIncludeThisMedia = includeMediaTypes.includes(msg.type) if ( isMediaMessage && shouldIncludeThisMedia && !mediaMap.has(msg.id) && !msg.isRedacted ) { setProgress({ value: progressValue, label: `Downloading media for message ${i + 1}... (${ msg.filename || msg.type })`, }) const blob = await wa.chat.downloadMedia(msg.id) if (blob) { mediaMap.set(msg.id, blob) const mediaType = msg.type as 'image' | 'video' | 'document' | 'ptt' const extension = blob.type.split('/')[1] || 'bin' const mediaFilename = `${msg.id}.${extension}` const folderName = mediaType === 'ptt' ? 'audio' : `${mediaType}s` const filePath = `./${folderName}/${mediaFilename}` const blobUrl = URL.createObjectURL(blob) switch (msg.type) { case 'image': mediaHtml = `<img src="${ isForPdf ? blobUrl : filePath }" alt="Image" />` break case 'video': if (isForPdf) { //@ts-ignore const thumb = await generateVideoThumbnail(blob) mediaHtml = `<div class="video-thumb-container"><img src="${thumb}" alt="Video Thumbnail" /><div class="play-button">â–¶</div></div>` } else { mediaHtml = `<video controls src="${filePath}"></video>` } break case 'ptt': if (isForPdf) { const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) mediaHtml = `<div class="media-placeholder">ðŸŽ¤ Voice Message (${duration})</div>` } else { mediaHtml = `<audio controls src="${filePath}"></audio>` } break case 'document': if (isForPdf) { mediaHtml = `<div class="media-placeholder">ðŸ“„ ${ _.escape(msg.filename) || 'Document' }</div>` } else { mediaHtml = `<a href="${filePath}" target="_blank">Download: ${ _.escape(msg.filename) || 'Document' }</a>` } break } } } else if (isMediaMessage) { if (msg.isRedacted) { mediaHtml = getRedactedMediaHtml(msg.type) } else { const mediaType = msg.type === 'ptt' ? 'Audio' : msg.type let placeholderText = `[${ mediaType.charAt(0).toUpperCase() + mediaType.slice(1) } not included]` mediaHtml = `<div class="media-placeholder">${placeholderText}</div>` } } const messageBodyHtml = msg.isRedacted ? getRedactedTextHtml() : `<span>${ _.escape(msg.type === 'chat' ? msg.body : msg.caption) ?? '' }</span>` const quotedHtml = renderQuotedMessage(msg.quotedMsg) messagesHtml += ` <div class="message-cluster message-${direction}" id="message-${msg.id}"> <div class="message"> <div class="message-bubble"> ${ senderName ? `<div class="sender-name">${_.escape(senderName)}</div>` : '' } <div class="message-content"> ${quotedHtml} ${mediaHtml} ${messageBodyHtml} <span class="timestamp">${new Date( msg.timestamp, ).toLocaleTimeString([], { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', })}</span> </div> </div> </div> </div> ` } return { htmlBody: headerHtml + messagesHtml, mediaMap } } const getFullHtmlDocument = (bodyContent: string, chat: any) => { const styles = ` <style> body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; margin: 0; background-color: #E5DDD5; } .chat-container { max-width: 800px; margin: auto; padding: 20px; } .export-header { background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #dee2e6; font-size: 0.9em; } .export-header p { margin: 2px 0; color: #333; } .export-header b { color: #111; } .limit-notice { background-color: #fffbe6; border: 1px solid #ffe58f; border-radius: 4px; padding: 10px; margin-top: 10px; font-size: 0.85em; text-align: center; color: #856404; } .message-cluster { display: flex; flex-direction: column; margin-bottom: 2px; padding: 0 9%; scroll-margin-top: 20px; } .message-cluster.message-out { align-items: flex-end; } .message-cluster.message-in { align-items: flex-start; } .message { max-width: 65%; word-wrap: break-word; margin-bottom: 10px; } .message-bubble { padding: 6px 9px; border-radius: 7.5px; box-shadow: 0 1px 0.5px rgba(11,20,26,.13); position: relative; } .message-out .message-bubble { background-color: #d9fdd3; color: #0f1010; } .message-in .message-bubble { background-color: #fff; color: #111b21; } .sender-name { font-size: 0.8rem; font-weight: 500; color: #028a76; margin-bottom: 4px; } .message-content img, .message-content video { width: 100%; max-width: 300px; border-radius: 6px; margin-top: 5px; display: block; } .message-content a { color: #0088cc; } .timestamp { font-size: 0.7rem; color: #667781; display: flex; justify-content: flex-end; padding-top: 4px; } .media-placeholder { padding: 10px; background-color: #f0f0f0; border: 1px dashed #ccc; border-radius: 6px; color: #888; font-style: italic; font-size: 0.9em; margin-top: 5px; text-align: center; } .quoted-message-link { text-decoration: none; color: inherit; } .quoted-message { background-color: #f0f2f5; border-left: 4px solid #4CAF50; padding: 8px 10px; margin-bottom: 5px; border-radius: 4px; opacity: 0.85; } .quoted-sender { font-weight: bold; font-size: 0.85em; color: #4CAF50; } .quoted-content { font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; } .video-thumb-container { position: relative; display: inline-block; } .video-thumb-container img { display: block; width: 100%; max-width: 300px; border-radius: 6px; } .video-thumb-container .play-button { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: white; background-color: rgba(0, 0, 0, 0.5); border-radius: 50%; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; text-shadow: 1px 1px 2px black;} .redacted-media-container { position: relative; width: 100%; max-width: 300px; height: 200px; background-color: #e9ecef; border-radius: 6px; margin-top: 5px; overflow: hidden; display: flex; align-items: center; justify-content: center; } .redacted-bg { font-size: 50px; filter: blur(8px); opacity: 0.3; user-select: none; } .redacted-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; } .lock-icon svg { width: 32px; height: 32px; } .redacted-text { font-size: 0.9em; font-weight: 500; margin-top: 8px; } .redacted-text-placeholder { padding: 10px; background-color: #f8f9fa; border: 1px dashed #dee2e6; border-radius: 6px; color: #6c757d; font-style: italic; font-size: 0.9em; margin-top: 5px; text-align: center; } </style> ` return ` <html> <head> <meta charset="UTF-8"> <title>Chat with ${_.escape(getContactName(chat.data.contact))}</title> ${styles} </head> <body><div class="chat-container">${bodyContent}</div></body> </html> ` } export const exportToHtml = async (params: ExporterParams) => { const { filename, setProgress, password } = params const { htmlBody, mediaMap } = await generateHtmlBody(params) const fullHtml = getFullHtmlDocument(htmlBody, params.chat) mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) { URL.revokeObjectURL(url) } }) if (mediaMap.size > 0 && params.includeMediaTypes.length > 0) { const zip = new JSZip() const mediaFolders: { [key: string]: JSZip | null } = { image: zip.folder('images'), video: zip.folder('videos'), document: zip.folder('documents'), ptt: zip.folder('audio'), } for (const [msgId, blob] of mediaMap.entries()) { const msg = params.messages.find((m) => m.id === msgId) if (msg && msg.type !== 'chat') { const mediaType = msg.type as 'image' | 'video' | 'document' | 'ptt' const folder = mediaFolders[mediaType] const extension = blob.type.split('/')[1] || 'bin' const mediaFilename = `${msg.id}.${extension}` folder?.file(mediaFilename, blob) } } zip.file(`${filename}.html`, fullHtml) setProgress({ value: 98, label: 'Compressing files...' }) const zipOptions: any = { type: 'blob' } if (password) { zipOptions.password = password } const zipBlob = await zip.generateAsync(zipOptions) //@ts-ignore FileSaver.saveAs(zipBlob, `${filename}.zip`) } else { const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' }) FileSaver.saveAs(blob, `${filename}.html`) } } export const exportToPdf = async (params: ExporterParams) => { const { filename, setProgress, validationRef } = params const { htmlBody, mediaMap } = await generateHtmlBody({ ...params, includeMediaTypes: ['image', 'video'], isForPdf: true, }) const fullHtml = getFullHtmlDocument(htmlBody, params.chat) if (!validationRef.current) { mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) return } setProgress({ value: 92, label: 'Generating PDF document...' }) const container = document.createElement('div') container.style.position = 'absolute' container.style.left = '-9999px' container.style.width = '800px' document.body.appendChild(container) container.innerHTML = fullHtml try { const canvas = await html2canvas(container, { useCORS: true, scale: 2 }) document.body.removeChild(container) mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) if (!validationRef.current) return setProgress({ value: 95, label: 'Formatting PDF pages...' }) const imgData = canvas.toDataURL('image/png') const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4', }) const pdfWidth = pdf.internal.pageSize.getWidth() const pdfHeight = pdf.internal.pageSize.getHeight() const canvasWidth = canvas.width const canvasHeight = canvas.height const ratio = canvasWidth / pdfWidth const canvasHeightInPdf = canvasHeight / ratio let heightLeft = canvasHeightInPdf let position = 0 pdf.addImage( imgData, 'PNG', 0, position, pdfWidth, canvasHeightInPdf, undefined, 'FAST', ) heightLeft -= pdfHeight while (heightLeft > 0) { position = heightLeft - canvasHeightInPdf pdf.addPage() pdf.addImage( imgData, 'PNG', 0, position, pdfWidth, canvasHeightInPdf, undefined, 'FAST', ) heightLeft -= pdfHeight } setProgress({ value: 98, label: 'Saving PDF file...' }) pdf.save(`${filename}.pdf`) } catch (error) { console.error('Error generating PDF:', error) if (document.body.contains(container)) { document.body.removeChild(container) } mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) throw new Error('Failed to generate PDF from chat content.') } } // MODIFIED: Adds Pro Preview notice to TXT exports. export const exportToTxt = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef, isProPreview } = params const exportedMessageCount = messages.filter((m) => !m.isRedacted).length let textContent = `Chat With: ${getContactName(chat.data.contact)}\r\n` textContent += `Export Date: ${new Date().toLocaleString()}\r\n` textContent += `Total Messages Exported: ${exportedMessageCount}\r\n` if (isProPreview) { textContent += `\r\n--- PRO PREVIEW ---\r\n1 of many media files was exported. Upgrade to Pro to back up all media without limits.\r\n-------------------\r\n` } textContent += `\r\n` for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] if (msg.isRedacted) continue setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const sender = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toLocaleString() let content = '' switch (msg.type) { case 'chat': content = msg.body break case 'image': content = `[Image: ${msg.filename || 'image.jpg'}]` if (msg.caption) content += `\r\n${msg.caption}` break case 'video': content = `[Video: ${msg.filename || 'video.mp4'}]` if (msg.caption) content += `\r\n${msg.caption}` break case 'document': content = `[Document: ${msg.filename || 'file'}]` if (msg.caption) content += `\r\n${msg.caption}` break case 'ptt': const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) content = `[Voice Message: ${duration}]` break default: content = `[${msg.type}]` break } if (msg.quotedMsg) { const quotedSender = msg.quotedMsg.sender.isMe ? 'You' : getContactName(msg.quotedMsg.sender) const quotedContent = _.truncate( msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, { length: 40 }, ) content = `[Quoting ${quotedSender}: "${quotedContent}"]\r\n${content}` } textContent += `[${timestamp}] ${sender}: ${content}\r\n\r\n` } if (validationRef.current) { const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' }) FileSaver.saveAs(blob, `${filename}.txt`) } } // MODIFIED: Adds Pro Preview notice to JSON exports. export const exportToJson = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef, isProPreview } = params const messageList: object[] = [] for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] if (msg.isRedacted) continue setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) let bodyContent: string | null = msg.body || null if (msg.type !== 'chat') { let placeholder = `[${msg.type}]` if (msg.filename) { placeholder = `[${msg.type}: ${msg.filename}]` } else if (msg.type === 'ptt' && msg.duration) { const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) placeholder = `[Voice Message: ${duration}]` } bodyContent = placeholder } messageList.push({ id: msg.id, timestamp: new Date(msg.timestamp).toISOString(), sender: { name: msg.contact.isMe ? 'You' : getContactName(msg.contact), id: msg.from, isMe: msg.contact.isMe, }, type: msg.type, body: bodyContent, caption: msg.caption || null, filename: msg.filename || null, quotedMessage: msg.quotedMsg ? { id: msg.quotedMsg.id, sender: getContactName(msg.quotedMsg.sender), body: msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, } : null, }) } if (validationRef.current) { const finalJson = { metadata: { chatWith: getContactName(chat.data.contact), chatId: chat.data.id, exportDate: new Date().toISOString(), totalMessages: messageList.length, notice: isProPreview ? 'Pro Preview: 1 of many media files was exported. Upgrade to Pro to back up all media without limits.' : undefined, }, messages: messageList, } const jsonString = JSON.stringify(finalJson, null, 2) const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8', }) FileSaver.saveAs(blob, `${filename}.json`) } } // MODIFIED: Adds Pro Preview notice to Markdown exports. export const exportToMarkdown = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef, isProPreview } = params const exportedMessageCount = messages.filter((m) => !m.isRedacted).length let mdContent = `# Chat with: ${getContactName(chat.data.contact)}\n\n` mdContent += `**Export Date:** ${new Date().toLocaleString()}\n` mdContent += `**Total Messages:** ${exportedMessageCount}\n\n` if (isProPreview) { mdContent += `> **Pro Preview:** 1 of many media files was exported. Upgrade to Pro to back up all media without limits.\n\n` } mdContent += `---\n\n` for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] if (msg.isRedacted) continue setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const senderName = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toLocaleString() mdContent += `**${_.escape(senderName)}** (*${timestamp}*)\n\n` if (msg.quotedMsg) { const quotedSenderName = msg.quotedMsg.sender.isMe ? 'You' : getContactName(msg.quotedMsg.sender) const quotedBody = _.truncate( msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, { length: 80 }, ) mdContent += `> > **${_.escape(quotedSenderName)}**: ${_.escape( quotedBody, )}\n\n` } let mdMessageContent = '' switch (msg.type) { case 'chat': mdMessageContent = msg.body.replace(/\n/g, ' \n') // Markdown line breaks break case 'image': mdMessageContent = `*Image: \`${_.escape(msg.filename)}\`*` if (msg.caption) mdMessageContent += `\n> ${_.escape(msg.caption)}` break case 'video': mdMessageContent = `*Video: \`${_.escape(msg.filename)}\`*` if (msg.caption) mdMessageContent += `\n> ${_.escape(msg.caption)}` break case 'document': mdMessageContent = `*Document: \`${_.escape(msg.filename)}\`*` if (msg.caption) mdMessageContent += `\n> ${_.escape(msg.caption)}` break case 'ptt': const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) mdMessageContent = `*Voice Message (${duration})*` break default: mdMessageContent = `*[Unsupported message type: ${msg.type}]*` } mdContent += `${mdMessageContent}\n\n---\n` } if (validationRef.current) { const blob = new Blob([mdContent], { type: 'text/markdown;charset=utf-8', }) FileSaver.saveAs(blob, `${filename}.md`) } } // MODIFIED: Adds Pro Preview notice to CSV/Excel exports. const prepareSheetData = (params: ExporterParams): any[] => { const { messages, setProgress, validationRef, isProPreview } = params const sheetData: any[] = [] // Add a notice row at the top for the preview if (isProPreview) { sheetData.push([ 'Pro Preview: 1 of many media files was exported. Upgrade to Pro to back up all media without limits.', ]) sheetData.push([]) // Add a blank row for spacing } // Define headers sheetData.push([ 'Message ID', 'Timestamp', 'Sender Name', 'Sender Number', 'Message Type', 'Content', 'Quoted Message ID', ]) for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] if (msg.isRedacted) continue setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const senderName = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toISOString() let content = '' switch (msg.type) { case 'chat': content = msg.body break case 'image': case 'video': case 'document': content = `[${msg.type.toUpperCase()}] ${msg.caption || ''}`.trim() break case 'ptt': const duration = new Date(msg.duration * 1000) .toISOString() .substr(14, 5) content = `[VOICE MESSAGE] Duration: ${duration}` break default: content = `[${msg.type.toUpperCase()}]` break } sheetData.push([ msg.id, timestamp, senderName, msg.from, msg.type, content, msg.quotedMsg?.id || '', ]) } return sheetData } export const exportToCsv = async (params: ExporterParams) => { const { filename, validationRef } = params const sheetData = prepareSheetData(params) if (validationRef.current) { const worksheet = XLSX.utils.aoa_to_sheet(sheetData) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } } export const exportToXlsx = async (params: ExporterParams) => { const { filename, validationRef } = params const sheetData = prepareSheetData(params) if (validationRef.current) { const worksheet = XLSX.utils.aoa_to_sheet(sheetData) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Chat Backup') XLSX.writeFile(workbook, `${filename}.xlsx`) } }
```

# src/features/tools/backup-chat/hooks/useChatBackup.ts

```ts
// src/features/tools/backup-chat/hooks/useChatBackup.ts import useLicense from '@/hooks/useLicense' import wa from '@/libs/wa' import toast from '@/utils/toast' import { getContactName, goToLandingPage } from '@/utils/util' import { useForm } from '@mantine/form' import { endOfDay, endOfMonth, isWithinInterval, startOfDay, startOfMonth, subDays, subMonths, } from 'date-fns' import _ from 'lodash' import { useRef, useState } from 'react' import { exportToCsv, exportToHtml, exportToJson, exportToMarkdown, exportToPdf, exportToTxt, exportToXlsx, } from '../helpers/exportUtils' const SUPPORTED_MESSAGE_TYPES = ['chat', 'image', 'video', 'document', 'ptt'] const PRO_EXPORT_FORMATS = ['pdf', 'txt', 'json', 'md', 'csv', 'xlsx'] const MEDIA_MESSAGE_TYPES = ['image', 'video', 'document', 'ptt'] export interface BackupResultStats { messagesExported: number messagesOmitted: number mediaOmitted: number isLimitApplied: boolean } export const useChatBackup = () => { const license = useLicense() const [isBackingUp, setIsBackingUp] = useState(false) const [progress, setProgress] = useState({ value: 0, label: 'Initializing...', }) const validationRef = useRef(true) const [backupResult, setBackupResult] = useState<BackupResultStats | null>( null, ) const form = useForm({ initialValues: { chatId: '', exportFormat: 'html', messageTypes: ['chat'], keywords: [] as string[], datePreset: 'today', dateRange: [null, null] as [Date | null, Date | null], }, validate: { chatId: (value) => (value ? null : 'A chat must be selected.'), dateRange: (value, values) => { if (values.datePreset === 'custom' && (!value[0] || !value[1])) { return 'A start and end date are required for a custom range.' } return null }, // MODIFIED: Added validation for the keyword limit on the free plan. keywords: (value) => { if (license.isFree() && value.length > 1) { return 'Free users can only filter by one keyword. Upgrade to Pro for unlimited keywords.' } return null }, }, validateInputOnChange: ['keywords'], }) const cancelBackup = () => { validationRef.current = false } const clearBackupResult = () => { setBackupResult(null) form.reset() } const startBackup = async () => { if (form.validate().hasErrors) return if ( license.isFree() && PRO_EXPORT_FORMATS.includes(form.values.exportFormat) ) { toast.error( 'This export format is a Pro feature. Please upgrade to unlock.', 'Upgrade Required', ) goToLandingPage() // ADDED: Redirect to landing page on Pro feature attempt. return } setIsBackingUp(true) validationRef.current = true setProgress({ value: 5, label: 'Fetching and filtering messages...' }) let resultStats: BackupResultStats = { messagesExported: 0, messagesOmitted: 0, mediaOmitted: 0, isLimitApplied: false, } try { const { chatId, dateRange, keywords, messageTypes, datePreset } = form.values let effectiveDateRange: [Date | null, Date | null] = [null, null] if (datePreset === 'custom') { effectiveDateRange = dateRange } else if (datePreset !== 'all') { const now = new Date() let start: Date | null = null let end: Date | null = null switch (datePreset) { case 'today': start = startOfDay(now) end = endOfDay(now) break case 'yesterday': const yesterday = subDays(now, 1) start = startOfDay(yesterday) end = endOfDay(yesterday) break case 'last7': start = startOfDay(subDays(now, 6)) end = endOfDay(now) break case 'last30': start = startOfDay(subDays(now, 29)) end = endOfDay(now) break case 'thisMonth': start = startOfMonth(now) end = endOfMonth(now) break case 'lastMonth': const lastMonthDate = subMonths(now, 1) start = startOfMonth(lastMonthDate) end = endOfMonth(lastMonthDate) break } effectiveDateRange = [start, end] } const allMessages = await wa.chat.getMessages(chatId, { count: -1 }) let [startDate, endDate] = effectiveDateRange if (license.isFree()) { const sevenDaysAgo = startOfDay(subDays(new Date(), 7)) if (!startDate || startDate < sevenDaysAgo) { startDate = sevenDaysAgo } } const lowercasedKeywords = keywords .map((k) => k.toLowerCase().trim()) .filter(Boolean) const filteredMessages = allMessages.filter((msg) => { const dateMatch = !startDate || !endDate || isWithinInterval(new Date(msg.timestamp), { start: startDate, end: endDate, }) const keywordMatch = lowercasedKeywords.length === 0 || lowercasedKeywords.some( (k) => (msg.body && msg.body.toLowerCase().includes(k)) || (msg.caption && msg.caption.toLowerCase().includes(k)), ) const typeMatch = messageTypes.includes(msg.type) return dateMatch && keywordMatch && typeMatch }) if (filteredMessages.length === 0) { toast.info('No messages found matching your criteria to export.') setIsBackingUp(false) return } const isFreePlan = license.isFree() const isLimitApplied = isFreePlan && filteredMessages.length > 10 let mediaIncludedInFreePreview = false let mediaOmittedCount = 0 const messagesToExport = filteredMessages.map((msg, index) => { const isMedia = MEDIA_MESSAGE_TYPES.includes(msg.type) if (!isFreePlan) { return { ...msg, isRedacted: false } } if (index >= 10) { if (isMedia) mediaOmittedCount++ return { ...msg, isRedacted: true } } if (isMedia) { if (!mediaIncludedInFreePreview) { mediaIncludedInFreePreview = true return { ...msg, isRedacted: false } } else { mediaOmittedCount++ return { ...msg, isRedacted: true } } } return { ...msg, isRedacted: false } }) const exportedMessageCount = messagesToExport.filter( (m) => !m.isRedacted, ).length const messagesOmittedCount = filteredMessages.length - exportedMessageCount resultStats = { messagesExported: exportedMessageCount, messagesOmitted: messagesOmittedCount, mediaOmitted: mediaOmittedCount, isLimitApplied: isLimitApplied || mediaIncludedInFreePreview, } const chat = await wa.chat.find(form.values.chatId) // @ts-ignore const filename = `backup_chat_${_.snakeCase( getContactName(chat.data.contact), )}_${new Date().toISOString().slice(0, 10)}` const exporterParams = { messages: messagesToExport, chat, filename, includeMediaTypes: form.values.messageTypes, setProgress, validationRef, isLimitApplied, isProPreview: mediaIncludedInFreePreview, } switch (form.values.exportFormat) { case 'pdf': await exportToPdf(exporterParams) break case 'txt': await exportToTxt(exporterParams) break case 'json': await exportToJson(exporterParams) break case 'md': await exportToMarkdown(exporterParams) break case 'csv': await exportToCsv(exporterParams) break case 'xlsx': await exportToXlsx(exporterParams) break case 'html': default: await exportToHtml(exporterParams) break } if (validationRef.current) { if (isLimitApplied || mediaIncludedInFreePreview) { toast.warning( 'Backup Limited', 'Free plan limits applied. Upgrade to Pro for unlimited backups.', ) } else { toast.success('Backup completed successfully!') } setBackupResult(resultStats) } else { toast.info('Backup cancelled by user.') } } catch (error: any) { console.error('Backup failed:', error) toast.error(error.message || 'An unknown error occurred during backup.') setBackupResult(null) } finally { setIsBackingUp(false) } } return { form, isBackingUp, progress, startBackup, cancelBackup, SUPPORTED_MESSAGE_TYPES, backupResult, clearBackupResult, } }
```

# src/features/tools/backup-chat/PageChatBackup.tsx

```tsx
// src/features/tools/backup-chat/PageChatBackup.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Icon } from '@iconify/react' import { Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' import BackupOptions from './components/BackupOptions' import BackupProgress from './components/BackupProgress' import BackupResult from './components/BackupResult' import { useChatBackup } from './hooks/useChatBackup' const PageChatBackup: React.FC = () => { const backup = useChatBackup() const renderContent = () => { if (backup.isBackingUp) { return ( <BackupProgress progress={backup.progress} onCancel={backup.cancelBackup} /> ) } if (backup.backupResult) { return ( <BackupResult result={backup.backupResult} onDone={backup.clearBackupResult} /> ) } return <BackupOptions backupHook={backup} onStart={backup.startBackup} /> } return ( <LayoutPage width={800}> <Stack>{renderContent()}</Stack> </LayoutPage> ) } export default PageChatBackup
```

# src/hooks/useAi.ts

```ts
// src/hooks/useAi.ts import { AI } from '@/constants/action' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' const useAi = () => { const rewriteMessage = async ( prompt: string, message: string, system: | string | null = 'You are an expert copywriter. Your task is to rewrite the user message based on their instruction.', ): Promise<Response<string>> => { // Send the request to the background relay defined in `ai.relay.ts` return await sendToBackgroundViaRelay({ //@ts-ignore name: 'ai', body: { prompt, message, system }, }) } return { rewriteMessage, } } export default useAi
```

# src/hooks/useDataQuery.ts

```ts
import type { EntityTable } from 'dexie' import { useLiveQuery } from 'dexie-react-hooks' import { useMemo, useState } from 'react' type SortDirection = 'asc' | 'desc' interface Sort { field: string direction: SortDirection } type SortState = Sort | null type FilterOperator = | 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'between' interface Filter { field: string operator: FilterOperator value: any secondValue?: any } interface useDataQueryOptions<T> { //@ts-ignore table: EntityTable<T, 'id'> initialPageSize?: number searchField?: string initialSort?: Sort initialFilters?: Filter[] } export const useDataQuery = <T>(options: useDataQueryOptions<T>) => { const { table, initialPageSize = 10, searchField = 'name', initialSort = { field: 'id', direction: 'desc' }, initialFilters = [], } = options const [page, setPage] = useState(1) const [pageSize, setPageSize] = useState(initialPageSize) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<T[]>([]) const [sort, setSort] = useState<SortState>(initialSort) const [filters, setFilters] = useState<Filter[]>(initialFilters) const applyFilter = (query: any, filter: Filter) => { const { field, operator, value, secondValue } = filter switch (operator) { case 'equals': return query.filter((item: any) => item[field] === value) case 'contains': return query.filter((item: any) => String(item[field]) .toLowerCase() .includes(String(value).toLowerCase()), ) case 'startsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .startsWith(String(value).toLowerCase()), ) case 'endsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .endsWith(String(value).toLowerCase()), ) case 'greaterThan': return query.filter((item: any) => item[field] > value) case 'lessThan': return query.filter((item: any) => item[field] < value) case 'between': return query.filter( (item: any) => item[field] >= value && item[field] <= (secondValue ?? value), ) default: return query } } const data = useLiveQuery(async () => { if (pageSize <= 0) return { data: [], totalItems: 0, hasMore: false } const startIndex = (page - 1) * pageSize let query = search ? table.where(searchField).startsWithIgnoreCase(search) : table.toCollection() let results = await query.toArray() filters.forEach((filter) => { results = applyFilter(results, filter) }) if (sort) { results.sort((a: any, b: any) => { const aValue = a[sort.field] const bValue = b[sort.field] if (aValue === bValue) return 0 const comparison = aValue > bValue ? 1 : -1 return sort.direction === 'asc' ? comparison : -comparison }) } const paginatedResults = results.slice(startIndex, startIndex + pageSize) return { data: paginatedResults, totalItems: results.length, hasMore: startIndex + paginatedResults.length < results.length, } }, [page, pageSize, search, sort, filters]) const _delete = async (id: any) => { if (confirm('Are you sure?')) { await table.delete(id) } } const toggleSort = (field: string) => { setSort((currentSort) => { // Case 1: No current sort, or a new column is clicked. Start with 'asc'. if (!currentSort || currentSort.field !== field) { return { field, direction: 'asc' } } // Case 2: Currently sorted 'asc'. Switch to 'desc'. if (currentSort.direction === 'asc') { return { field, direction: 'desc' } } // Case 3: Currently sorted 'desc'. Switch to null to remove sorting. if (currentSort.direction === 'desc') { return null } // Fallback, should not be reached. return currentSort }) } const addFilter = (filter: Filter) => { setFilters((prev) => [...prev, filter]) setPage(1) } const removeFilter = (index: number) => { setFilters((prev) => prev.filter((_, i) => i !== index)) setPage(1) } const updateFilter = (index: number, filter: Filter) => { setFilters((prev) => prev.map((f, i) => (i === index ? filter : f))) setPage(1) } const clearFilters = () => { setFilters([]) setPage(1) } const derivedData = useMemo( () => ({ data: data?.data ?? [], totalRecords: data?.totalItems ?? 0, hasMore: data?.hasMore ?? false, }), [data], ) return { ...derivedData, selectedRecords, page, pageSize, search, sort, filters, setPage, setPageSize, setSelectedRecords, setSearch, toggleSort, addFilter, removeFilter, updateFilter, clearFilters, _delete, searchField, } } export default useDataQuery
```

# src/hooks/useFile.ts

```ts
// src/utils/file.ts import { SaveAs, Setting } from '@/constants' import { storage } from '@/libs/storage' import FileSaver from 'file-saver' import _ from 'lodash' import * as XLSX from 'xlsx' import useLicense from './useLicense' const useFile = () => { const license = useLicense() const getSelectedColumns = async () => { return ( (await storage.get<Record<string, boolean>>(Setting.EXPORT_COLUMNS)) || { phoneNumber: true, publicName: true, savedName: true, isBlocked: true, isBusiness: true, isMyContact: true, } ) } const serializeData = async (data: any[]) => { const selectedColumns = await getSelectedColumns() let filteredData = data.map((item: any) => _.pickBy(item, (_, key) => selectedColumns[key] === true), ) if (license.isFree() && filteredData.length > 10) { filteredData = filteredData.map((item, index) => index >= 10 ? _.mapValues(item, () => '********') : item, ) } return filteredData } const defaultFilename = () => { return `export_${new Date().toISOString().slice(0, 10)}` } const saveAsCSV = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } const saveAsExcel = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet 1') XLSX.writeFile(workbook, `${filename}.xlsx`) } const saveAsJson = (data: any[], filename: string) => { const json = JSON.stringify(data, null, 2) const blob = new Blob([json], { type: 'application/json' }) FileSaver.saveAs(blob, `${filename}.json`) } const saveAsVCard = (data: any[]) => { const vcardContent = data .map((contact) => { const name = contact.savedName || contact.publicName || 'Unknown' const phone = contact.phoneNumber ? `+${contact.phoneNumber}` : '' return `BEGIN:VCARD\nVERSION:3.0\nFN:${name}\nTEL;TYPE=CELL:${phone}\nEND:VCARD` }) .join('\n') const blob = new Blob([vcardContent], { type: 'text/vcard' }) FileSaver.saveAs(blob, `${defaultFilename()}.vcf`) } /** * Main function to save data in various formats. * @param fileType The format to save as (e.g., 'csv', 'xlsx'). * @param data The array of data objects to save. * @param filename (Optional) The base name for the file, without extension. */ const saveAs = async (fileType: string, data: any[], filename?: string) => { const processedData = await serializeData(data) const finalFilename = filename || defaultFilename() switch (fileType) { case SaveAs.CSV: saveAsCSV(processedData, finalFilename) break case SaveAs.EXCEL: saveAsExcel(processedData, finalFilename) break case SaveAs.JSON: saveAsJson(processedData, finalFilename) break case SaveAs.VCARD: saveAsVCard(processedData) // VCard has its own filename logic break // Other formats like Markdown and HTML can be added here. default: console.error(`Unsupported file type: ${fileType}`) break } } return { saveAs } } export default useFile
```

# src/hooks/useLicense.ts

```ts
// src/hooks/useLicense.ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import type { License } from '@/types' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { sendToBackground } from '@plasmohq/messaging' import { isPast } from 'date-fns' const useLicense = () => { const { license, setLicense } = useAppStore() const callLemonSqueezyApi = async (action: string, body: any) => { return await sendToBackground({ name: 'lemonsqueezy', body: { action, body, }, }) } const init = async () => { // First, check for a cached, valid license to avoid unnecessary API calls. const cachedLicense = await storage.get<License | null>( Setting.LICENSE_DATA_CACHE, ) if (cachedLicense?.license_key?.status === 'active') { setLicense(cachedLicense) return } // If no valid cache, proceed with the standard validation flow. const licenseKey = await storage.get<string | null>(Setting.LICENSE_KEY) if (!licenseKey) { setLicense(null) await storage.remove(Setting.LICENSE_DATA_CACHE) return } const response = await callLemonSqueezyApi('validateLicense', { licenseKey, }) if (response.error) { // Validation failed, clear all license-related storage. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is invalid or has been deactivated. You have been switched to the Free plan.', 'License Invalid', ) return } if (response.data.meta.store_id.toString() !== getStoreId()) { await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is for a different product. You have been switched to the Free plan.', 'License Error', ) return } // Validation successful, update app state and cache the license data if active. setLicense(response.data) if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } if ( response.data.license_key.expires_at && isPast(new Date(response.data.license_key.expires_at)) ) { toast.info( 'Your license has expired. You have been switched to the Free plan.', 'License Expired', ) await storage.remove(Setting.LICENSE_DATA_CACHE) } } const isFree = (): boolean => { if (!license) { return true } return license.license_key.status !== 'active' } const isPro = () => { if (!license) { return false } return license.license_key.status === 'active' } const isExpired = () => { // For lifetime licenses, 'expires_at' might be null. // The most reliable check is the status. If no expiration date exists, it's not expired. if (!license || !license.license_key.expires_at) { return false } return isPast(new Date(license.license_key.expires_at)) } const getLicense = () => { return license } const activate = async (licenseKey: string) => { const response = await callLemonSqueezyApi('activateLicense', { licenseKey, }) if (!response.error) { setLicense(response.data) await storage.set(Setting.LICENSE_KEY, licenseKey) await storage.set(Setting.LICENSE_INSTANCE_ID, response.data.instance.id) // Cache the license data immediately on successful activation. if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } } return response } const deactivate = async () => { const licenseKey = await storage.get(Setting.LICENSE_KEY) const instanceId = await storage.get(Setting.LICENSE_INSTANCE_ID) try { const response = await callLemonSqueezyApi('deactivateLicense', { licenseKey, instanceId, }) if (response.data.deactivated) { // Clear all license-related data from storage on deactivation. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.success('Your license has been deactivated from this device.') } else { toast.error('Failed to deactivate the license. Please contact support.') } } catch (e) { toast.error('An error occurred during deactivation.') } } const goToMyOrders = async () => { if (!license?.meta?.customer_id) { toast.error('Could not find customer information.') return } try { const response = await callLemonSqueezyApi('getCustomer', { customerId: license.meta.customer_id, }) if (response.error) { toast.error('Could not retrieve customer portal link.') return } window.open( response.data.data.attributes.urls.customer_portal, '_blank', 'noopener,noreferrer', ) } catch (e) { toast.error('An error occurred while fetching your subscription details.') } } return { init, isFree, isPro, isExpired, activate, getLicense, goToMyOrders, deactivate, } } export default useLicense
```

# src/hooks/useRuntimeMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = ( message: T, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void, ) => void | boolean /** * A React hook for handling Chrome runtime messages * @param listener The callback function to handle incoming messages * @returns void * * @example * useRuntimeMessage((message, sender, sendResponse) => { * if (message.type === 'getData') { * sendResponse({ data: 'example' }) * } * // Return true to keep the message channel open for async responses * return true * }) */ const useRuntimeMessage = <T = any>(listener: MessageListener<T>): void => { const memoizedHandler = useCallback<MessageListener<T>>( (message, sender, sendResponse) => { return listener(message, sender, sendResponse) }, [listener], ) useEffect(() => { chrome.runtime.onMessage.addListener(memoizedHandler) return () => { chrome.runtime.onMessage.removeListener(memoizedHandler) } }, [memoizedHandler]) } export default useRuntimeMessage
```

# src/hooks/useWa.ts

```ts
import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' const useWa = () => { const { isReady, activeChat } = useAppStore() return { isReady, activeChat, ...wa, } } export default useWa
```

# src/hooks/useWindowMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = (event: MessageEvent<T>) => void const useWindowMessage = <T = any>(listener: MessageListener<T>): void => { const handleMessage = useCallback<MessageListener<T>>( (event) => { listener(event) }, [listener], ) useEffect(() => { window.addEventListener('message', handleMessage) return () => window.removeEventListener('message', handleMessage) }, [handleMessage]) } export default useWindowMessage
```

# src/libs/db.ts

```ts
// src/libs/db.ts import Dexie, { type EntityTable } from 'dexie' import packageJson from '../../package.json' export interface Media { id: number parentId: number type: string name: string file: File ext: string } export interface Broadcast { id: number name?: string | null type: string message: any isTyping: number isScheduler: number status: string delayMin?: number delayMax?: number pauseEnabled?: number pauseAfter?: number pauseDuration?: number pausedUntil?: Date | null } export interface BroadcastContact { id: number broadcastId: number number: string name?: string | null status: string error?: string | null scheduledAt?: Date | null sendAt?: Date | null } export interface BroadcastTemplate { id: number name: string type: string message: any } export interface BroadcastRecipient { id: number name: string recipients: { name: string; number: string; source: string }[] createdAt: Date } export interface Label { id: number label: string value: string show: number custom: number numbers?: any[] color?: string group?: string isPinned?: number } export interface DirectChatTemplate { id: number name: string message: string } export interface QuickReply { id: number name: string type: string message: any isPinned?: number createdAt?: Date } const db = new Dexie(packageJson.name) as Dexie & { media: EntityTable<Media, 'id'> broadcasts: EntityTable<Broadcast, 'id'> broadcastContacts: EntityTable<BroadcastContact, 'id'> broadcastTemplates: EntityTable<BroadcastTemplate, 'id'> broadcastRecipients: EntityTable<BroadcastRecipient, 'id'> labels: EntityTable<Label, 'id'> directChatTemplates: EntityTable<DirectChatTemplate, 'id'> quickReplies: EntityTable<QuickReply, 'id'> } // NOTE: Dexie cannot index boolean values. Fields intended for use in `where()` clauses // have been changed from `boolean` to `number` (0 for false, 1 for true). db.version(1).stores({ media: '++id, parentId, type, name, file, ext', broadcasts: '++id, name, type, message, isTyping, isScheduler, status, delayMin, delayMax, pauseEnabled, pauseAfter, pauseDuration, pausedUntil', broadcastContacts: '++id, broadcastId, number, name, status, error, scheduledAt, sendAt, [broadcastId+status]', broadcastTemplates: '++id, name, type, message', broadcastRecipients: '++id, name, createdAt', labels: '++id, label, value, show, custom, color, group, isPinned, *numbers', directChatTemplates: '++id, name', quickReplies: '++id, name, type, isPinned, createdAt', }) export default db
```

# src/libs/http.ts

```ts
import fetchAdapter from '@haverstack/axios-fetch-adapter' import axios from 'axios' const http = axios.create({ adapter: fetchAdapter, }) export default http
```

# src/libs/ls.ts

```ts
import * as lemon from '@lemonsqueezy/lemonsqueezy.js' lemon.lemonSqueezySetup({}) const lemonSqueezy = lemon export default lemonSqueezy
```

# src/libs/storage.ts

```ts
import { Storage } from '@plasmohq/storage' export const storage = new Storage({})
```

# src/libs/theme.ts

```ts
import { Button, createTheme, FileInput, Menu, Modal, MultiSelect, NumberInput, Popover, Radio, Select, Switch, TagsInput, Text, Textarea, TextInput, Tooltip, } from '@mantine/core' const theme = createTheme({ colors: { emerald: [ '#effbf3', '#ddf4e5', '#b6eac7', '#8cdfa7', '#6bd68c', '#56d07b', '#4acd72', '#3bb560', '#31a154', '#145229', ], }, primaryColor: 'teal', cursorType: 'pointer', components: { Button: Button.extend({ defaultProps: { size: 'sm', }, }), FileInput: FileInput.extend({ defaultProps: { size: 'md', }, }), Menu: Menu.extend({ defaultProps: { withinPortal: false } }), Modal: Modal.extend({ defaultProps: { size: 'xl', withCloseButton: false, withOverlay: false, withinPortal: false, }, }), NumberInput: NumberInput.extend({ defaultProps: { size: 'md' } }), MultiSelect: MultiSelect.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Popover: Popover.extend({ defaultProps: { withinPortal: false, }, }), Radio: Radio.extend({ defaultProps: { size: 'md', }, }), Select: Select.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Switch: Switch.extend({ defaultProps: { size: 'md', }, }), TagsInput: TagsInput.extend({ defaultProps: { size: 'md', }, }), Text: Text.extend({ defaultProps: { size: 'md', }, }), Textarea: Textarea.extend({ defaultProps: { size: 'md', }, }), TextInput: TextInput.extend({ defaultProps: { size: 'md', }, }), Tooltip: Tooltip.extend({ defaultProps: { position: 'left', withinPortal: false, withArrow: true, }, }), }, }) export default theme
```

# src/libs/wa/blocklist.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' export const all = async (): Promise<Wid[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.ALL, body: {}, }) } export const blockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.BLOCK_CONTACT, body: chatId, }) } export const isBlocked = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.IS_BLOCKED, body: chatId, }) } export const unblockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.UNBLOCK_CONTACT, body: chatId, }) }
```

# src/libs/wa/cart.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { SendMessageOptions } from '@wppconnect/wa-js/dist/chat' /** * Add product in cart * * @example * \`\`\`javascript * const cart = wa.cart.add('[number]@c.us', [ * { id: 'productId', qnt: 2 }, * ]); * \`\`\` */ export const add = async ( chatId: string, products: { id: string qnt: number }[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.ADD, body: { chatId, products }, }) } /** * Clear all items of cart * */ export const clear = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.CLEAR, body: wid, }) } /** * Get products in cart chat * * @example * \`\`\`javascript * const cart = wa.cart.get('[number]@c.us'); * \`\`\` */ export const get = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET, body: wid, }) } /** * Get thumb of a cart * * @example * \`\`\`javascript * const cart = wa.cart.getThumbFromCart('[number]@c.us'); * \`\`\` */ export const getThumbFromCart = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET_THUMB_FROM_CART, body: wid, }) } /** * Remove a product in cart * * @example * \`\`\`javascript * const cart = wa.cart.remove('[number]@c.us', '6987301181294productId'); * \`\`\` */ export const remove = async ( chatId: string, productId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.REMOVE, body: { chatId, productId }, }) } /** * Send a request order to business chat * * @example * \`\`\`javascript * const cart = wa.cart.submit('[number]@c.us'); * \`\`\` * * @example * \`\`\`javascript * // Send cart with a custom message * const cart = wa.cart.submit('[number]@c.us', 'Custom message here'); * \`\`\` */ export const submit = async ( wid: string, msg?: string, options?: SendMessageOptions, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.SUBMIT, body: { wid, msg, options }, }) } /** * Update product in cart * * @example * \`\`\`javascript * const cart = wa.cart.update('[number]@c.us', '6987301181294productId', { quantity: 12 }); * \`\`\` */ export const update = async ( chatId: string, productId: string, options: { quantity: number }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.UPDATE, body: { chatId, productId, options }, }) }
```

# src/libs/wa/catalog.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { createProductParams } from '@wppconnect/wa-js/dist/catalog/functions/createProduct' import type { editProductParams } from '@wppconnect/wa-js/dist/catalog/functions/editProduct' /** * Add image on product * This function include additional images on product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.addProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const addProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.ADD_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Add image on product * This function change main image of product * for change additional images use @addProductImage * * @example * \`\`\`javascript * await wa.catalog.changeProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const changeProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CHANGE_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Create new collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.createCollection('Collection Name', ['565656589898']); * \`\`\` */ export const createCollection = async ( collectionName: string, productsId: string[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_COLLECTION, body: { collectionName, productsId }, }) } /** * Create new product * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.addProduct( { name: 'Product name', image: 'base64 image string', description: 'product description', price: '89.90', isHidden: false, url: 'https://wppconnect.io', retailerId: 'AKA001', } ); * \`\`\` */ export const createProduct = async ( params: createProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_PRODUCT, body: params, }) } /** * Delete a collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.deleteCollection("377095767832354"); * \`\`\` * * @return Return sucess or error */ export const deleteCollection = async (collectionId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_COLLECTION, body: collectionId, }) } /** * @example * \`\`\`javascript * * // Delete various products * const myCatalog = await wa.catalog.delProducts(['6104203702939361', '6104289702939361']); * \`\`\` */ export const deleteProduct = async (productsIds: string[]): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_PRODUCT, body: productsIds, }) } /** * @example * \`\`\`javascript * const myCatalog = await wa.catalog.EditCollection('565656589898', { collectionName: 'New Name for collection', productsToAdd: ['5656523223'], productsToRemove: ['5656523232']}); * \`\`\` */ interface paramsEditCollection { name?: string productsToAdd?: string[] productsToRemove?: string[] } export const editCollection = async ( collectionId: string, params: paramsEditCollection, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_COLLECTION, body: { collectionId, params }, }) } /** * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = wa.catalog.editProduct('5498255476885590', {name: 'Plano 01', price: '89990', description: 'Insert description for your product', isHidden: true, url: 'http://www.wppconnect.io', retailerId: 'AKA001'}); * \`\`\` */ export const editProduct = async ( productId: string, params: editProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_PRODUCT, body: { productId, params }, }) } /** * Get collections of catalog * * @example * \`\`\`javascript * // Retrieve 20 collections of chat * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20'); * * // Retrieve 20 collections of chat and products arrays limit with 10 products * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20', '10'); * \`\`\` */ export const getCollections = async ( chatId: string, qnt?: number, productsCount?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_COLLECTIONS, body: { chatId, qnt, productsCount }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ export const getMyCatalog = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_MY_CATALOG, body: {}, }) } /** * Retrieves product by id * * @example * \`\`\`javascript * // Retrieve data of product * await wa.catalog.getProductById('5521985565656@c.us', '68685985868923'); * \`\`\` */ export const getProductById = async ( chatId: string, productId: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCT_BY_ID, body: { chatId, productId }, }) } /** * Retrieves product by contact id * * @example * Get products of catalogs * \`\`\`javascript * await wa.catalog.getProducts('5521985625689@c.us', 10); * \`\`\` */ export const getProducts = async (chatId: string, qnt: number): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCTS, body: { chatId, qnt }, }) } /** * Remove image on product * This function remove additional images of product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.removeProductImage('68685985868923', '0'); * \`\`\` */ export const removeProductImage = async ( productId: string, index: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.REMOVE_PRODUCT_IMAGE, body: { productId, index }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` */ export const setProductVisibility = async ( productId: any, isHidden: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.SET_PRODUCT_VISIBILITY, body: { productId, isHidden }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` * * @return Return sucess of product visibility set */ export const updateCartEnabled = async (enabled: boolean): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.UPDAGE_CART_ENABLED, body: enabled, }) }
```

# src/libs/wa/chat.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions, DeleteMessageReturn, ForwardMessagesOptions, GetMessagesOptions, RawMessage, } from '@wppconnect/wa-js/dist/chat' import type { ParticipantStatusACK } from '@wppconnect/wa-js/dist/chat/functions/getMessageACK' import type { Stringable } from '@wppconnect/wa-js/dist/types' import type { MsgKey, MsgModel, Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { ACK } from '@wppconnect/wa-js/dist/whatsapp/enums' /** * Archive a chat * * @example * // Archive a chat * wa.chat.archive('[number]@c.us'); * * // Unarchive a chat * wa.chat.archive('[number]@c.us', false); * \`\`\` */ export const archive = async ( chatId: string | Wid, archive = true, ): Promise<{ wid: Wid archive: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.ARCHIVE, body: { chatId, archive }, }) } /** * Get if message can played * * @example * \`\`\`javascript * wa.chat.canMarkPlayed('[message_id]'); * \`\`\` */ export const canMarkPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MARK_PLAYED, body: messageId, }) } /** * Check if is possible to mute this chat * * @example * \`\`\`javascript * const canMute = wa.chat.canMute('[number]@c.us'); * \`\`\` */ export const canMute = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MUTE, body: chatId, }) } /** * Get if message can reply * * @example * \`\`\`javascript * wa.chat.canReply('[message_id]'); * \`\`\` */ export const canReply = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_REPLY, body: messageId, }) } /** * Clear a chat message * */ export const clear = async ( chatId: string | Wid, keepStarred = true, ): Promise<{ wid: Wid status: number keepStarred: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLEAR, body: { chatId, keepStarred }, }) } /** * Close the chat tab * * @example * \`\`\`javascript * await wa.chat.closeChat(); * \`\`\` * */ export const closeChat = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLOSE_CHAT, body: {}, }) } /** * Delete a chat * */ export const _delete = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE, body: chatId, }) } /** * Delete a message * * @example * \`\`\`javascript * // Delete a message * wa.chat.deleteMessage('[number]@c.us', 'msgid'); * // Delete a list of messages * wa.chat.deleteMessage('[number]@c.us', ['msgid1', 'msgid2]); * // Delete a message and delete media * wa.chat.deleteMessage('[number]@c.us', 'msgid', true); * // Revoke a message * wa.chat.deleteMessage('[number]@c.us', 'msgid', true, true); * \`\`\` * */ export const deleteMessage = async ( chatId: string | Wid, ids: string | string[], deleteMediaInDevice = false, revoke = false, ): Promise<DeleteMessageReturn | DeleteMessageReturn[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE_MESSAGE, body: { chatId, ids, deleteMediaInDevice, revoke }, }) } /** * Downloads media from a message * * @example * \`\`\`javascript * await wa.chat.downloadMedia('messageId'); * \`\`\` */ export const downloadMedia = async ( messageId: string | MsgKey, ): Promise<Blob | null> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DOWNLOAD_MEDIA, body: messageId, }) } export const find = async (chatId: string | Wid): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FIND, body: chatId, }) } /** * Forward messages to a chat * * @example * \`\`\`javascript * // Forward messages * wa.chat.forwardMessage('[number]@c.us', 'true_[number]@c.us_ABCDEF'); * \`\`\` */ export const forwardMessage = async ( toChatId: string | Wid, msgId: string | MsgKey, options: ForwardMessagesOptions = {}, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FORWARD_MESSAGE, body: { toChatId, msgId, options }, }) } /** * Find a chat by id * */ export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET, body: chatId, }) } export const getActiveChat = async () => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_ACTIVE_CHAT, body: {}, }) } /** * Get timestamp of last seen * @example * \`\`\`javascript * wa.chat.getLastSeen('[number]@c.us'); * \`\`\` */ export const getLastSeen = async ( chatId: string | Wid, ): Promise<number | boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_LAST_SEEN, body: chatId, }) } /** * Get message ACK from a message * * @example * \`\`\`javascript * // Get message ACK * const ackInfo = await WPP.chat.getMessageACK('true_[number]@c.us_ABCDEF'); * * console.log(ackInfo.deliveryRemaining); // Delivery Remaining * console.log(ackInfo.readRemaining); // Read Remaining * console.log(ackInfo.playedRemaining); // PlayedRemaining, for audio(ptt) only * * console.log(ackInfo.participants[0].deliveredAt); // Delivered At, in timestamp format * console.log(ackInfo.participants[0].readAt); // Read At, in timestamp format * console.log(ackInfo.participants[0].playedAt); // Played At, in timestamp format, for audio(ptt) only * * //To get only how was received * const received = ackInfo.participants.filter(p => p.deliveredAt || p.readAt || p.playedAt); * * //To get only how was read * const read = ackInfo.participants.filter(p => p.readAt || p.playedAt); * * //To get only how was played * const played = ackInfo.participants.filter(p => p.playedAt); * \`\`\` */ export const getMessageACK = async ( msgId: string | MsgKey, ): Promise<{ ack: ACK fromMe: boolean deliveryRemaining: number readRemaining: number playedRemaining: number participants: ParticipantStatusACK[] }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGE_ACK, body: msgId, }) } /** * Fetch messages from a chat * * @example * \`\`\`javascript * // Some messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * }); * * // All messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * }); * * // Last 20 unread messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * onlyUnread: true, * }); * * // All unread messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * onlyUnread: true, * }); * * // 20 messages before specific message * wa.chat.getMessages('[number]@c.us', { * count: 20, * direction: 'before', * id: '<full message id>' * }); * * // Only media messages (url, document and links) * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'all', * }); * * // Only image messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'image', * }); * * // Only document messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'document', * }); * * // Only link (url) messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'url', * }); * \`\`\` */ export const getMessages = async ( chatId: string | Wid, options: GetMessagesOptions = {}, ): Promise<any[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGES, body: { chatId, options }, }) } /** * Get notes from a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.getNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const getNotes = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_NOTES, body: chatId, }) } /** * Get the platform message from message ID * * The platform can be: * * android * * iphone * * web * * unknown * * @example * \`\`\`javascript * // to get platform from a message * const platform = wa.chat.getPlatformFromMessage('[message_id]'); * \`\`\` */ export const getPlatformFromMessage = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<'android' | 'iphone' | 'web' | 'unknown'> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_PLATFORM_MESSAGE, body: messageId, }) } /** * Return a list of chats * * @example * \`\`\`javascript * // All chats * const chats = await wa.chat.list(); * * // Some chats * const chats = wa.chat.list({count: 20}); * * // 20 chats before specific chat * const chats = wa.chat.list({count: 20, direction: 'before', id: '[number]@c.us'}); * * // Only users chats * const chats = await wa.chat.list({onlyUsers: true}); * * // Only groups chats * const chats = await wa.chat.list({onlyGroups: true}); * * // Only communities chats * const chats = await wa.chat.list({onlyCommunities: true}); * * // Only Newsletter * const chats = await wa.chat.list({onlyNewsletter: true}); * * // Only with label Text * const chats = await wa.chat.list({withLabels: ['Test']}); * * // Only with label id * const chats = await wa.chat.list({withLabels: ['1']}); * * // Only with label with one of text or id * const chats = await wa.chat.list({withLabels: ['Alfa','5']}); * \`\`\` * */ export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.LIST, body: options, }) } /** * Mark a chat to composing state * and keep sending "is writting a message" * * @example * \`\`\`javascript * // Mark is composing * wa.chat.markIsComposing('[number]@c.us'); * * // Mark is composing for 5 seconds * wa.chat.markIsComposing('[number]@c.us', 5000); * \`\`\` */ export const markIsComposing = async ( chatId: string | Wid, duration?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_COMPOSING, body: { chatId, duration }, }) } /** * Mark a chat is paused state * * @example * \`\`\`javascript * // Mark as recording * wa.chat.markIsPaused('[number]@c.us'); * \`\`\` */ export const markIsPaused = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_PAUSED, body: chatId, }) } /** * Mark a chat as read and send SEEN event * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsRead('[number]@c.us'); * \`\`\` */ export const markIsRead = async ( chatId: string, ): Promise<{ wid: Wid unreadCount: number }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_READ, body: chatId, }) } /** * Mark a chat to recording state * and keep sending "is recording" * * @example * \`\`\`javascript * // Mark is recording * wa.chat.markIsRecording('[number]@c.us'); * * // Mark is recording for 5 seconds * wa.chat.markIsRecording('[number]@c.us', 5000); * \`\`\` */ export const markIsRecording = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_RECORDING, body: chatId, }) } /** * Mark a chat as unread * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsUnread('[number]@c.us'); * \`\`\` */ export const markIsUnread = async ( chatId: string | Wid, ): Promise<{ wid: Wid }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_UNREAD, body: chatId, }) } /** * Mark message as played * * @example * \`\`\`javascript * wa.chat.markPlayed('[message_id]'); * \`\`\` */ export const markPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_PLAYED, body: messageId, }) } /** * Mute a chat, you can use duration or expiration * For expiration, use unix timestamp (seconds only) * For duration, use seconds * * @example * \`\`\`javascript * // Mute for 60 seconds * wa.chat.mute('[number]@c.us', {duration: 60}); * * // Mute util 2021-01-01 * wa.chat.mute('[number]@c.us', {expiration: 1641006000}); * * // or using date * const expiration = new Date('2022-01-01 00:00:00'); * wa.chat.mute('[number]@c.us', {expiration: expiration}); * \`\`\` * */ export const mute = async ( chatId: string | Wid, time: { expiration: number | Date } | { duration: number }, ): Promise<{ wid: Wid expiration: number isMuted: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MUTE, body: { chatId, time }, }) } /** * Open the chat in the WhatsApp interface in a specific message * * @example * \`\`\`javascript * await wa.chat.openChatAt('[number]@c.us', <message_id>); * \`\`\` * */ export const openChatAt = async ( chatId: string | Wid, messageId: string, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_AT, body: { chatId, messageId }, }) } /** * Open the chat in the WhatsApp interface in bottom position * * @example * \`\`\`javascript * await wa.chat.openChatBottom('[number]@c.us'); * \`\`\` * */ export const openChatBottom = async ( chatId: string, ): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_BOTTOM, body: chatId, }) } /** * Open the chat in the WhatsApp interface from first unread message * * @example * \`\`\`javascript * await wa.chat.openChatFromUnread('[number]@c.us'); * \`\`\` * */ export const openChatFromUnread = async ( chatId: string | Wid, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_FROM_UNREAD, body: chatId, }) } /** * Pin a message in chat * * @example * \`\`\`javascript * // Pin a message in chat * wa.chat.pinMsg('true_[number]@c.us_ABCDEF'); * * // Pin a message in chat for 30 days * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', 2592000); * * // Unpin a message * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', false); * \`\`\` */ export const pinMsg = async ( msgId: string | MsgKey, pin = true, seconds = 604800, // default 7 days ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN_MSG, body: { msgId, pin, seconds }, }) } /** * Set custom Chat list in panel of whatsapp * * @example * \`\`\`javascript * // Your custom list * wa.chat.setChatList('custom', ['number@c.us', 'number2@c.us']); * * // List only with unread chats * wa.chat.setChatList('unread'); * * // List only with favorites chats * wa.chat.setChatList('favorites'); * * // List only with groups chats * wa.chat.setChatList('group'); * * // List only labels chat * wa.chat.setChatList('labels', '454545_labelId'); * \`\`\` */ export const setChatList = async (type: string, ids?: string | string[]) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_CHAT_LIST, body: { type, ids }, }) } export const setInputText = async (text: string, chatId?: string | Wid) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_INPUT_TEXT, body: { text, chatId }, }) } /** * Set notes for a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.setNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const setNotes = async ( chatId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_NOTES, body: { chatId, content }, }) }
```

# src/libs/wa/conn.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Alternative login method using code * Get the Link Device Code for Authentication using the phone number * * @example * \`\`\`javascript * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]'); * * // Disable push notification * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]', false); * \`\`\` */ export const genLinkDeviceCodeForPhoneNumber = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }) } /** * Return the current auth code * * @example * \`\`\`javascript * const authCode = await wa.conn.getAuthCode(); * console.log(authCode.fullCode); // Output: a long string to generate a QRCode * \`\`\` */ export const getAuthCode = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_AUTH_CODE, }) } export const getMyUserId = async (): Promise<Wid | undefined> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_MY_USER_ID, }) }
```

# src/libs/wa/contact.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ContactListOptions } from '@wppconnect/wa-js/dist/contact' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Get a contact by id * * @example * \`\`\`javascript * await wa.contact.get('[number]@c.us'); * \`\`\` * */ export const get = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET, body: contactId, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getBusinessProfile('[number]@c.us'); * \`\`\` * */ export const getBusinessProfile = async ( contactId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_BUSINESS_PROFILE, body: contactId, }) } /** * Get all commons groups for the contact * * @example * \`\`\`javascript * const groups_ids = await wa.contact.getCommonGroups('[number]@c.us'); * \`\`\` * */ export const getCommonGroups = async (wid: Wid | string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_COMMON_GROUPS, body: wid, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getProfilePictureUrl('[number]@c.us'); * \`\`\` * */ export const getProfilePictureUrl = async ( contactId: string | Wid, full = true, ): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_PROFILE_PICTURE_URL, body: { contactId, full }, }) } /** * Get the current text status * * @example * \`\`\`javascript * await wa.contact.getStatus('[number]@c.us'); * \`\`\` */ export const getStatus = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_STATUS, body: contactId, }) } export const list = async (options: ContactListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.LIST, body: options, }) } export const isExist = async (contactId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.IS_EXIST, body: contactId, }) }
```

# src/libs/wa/group.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions } from '@wppconnect/wa-js/dist/chat' import type { GroupProperty } from '@wppconnect/wa-js/dist/group' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Add one or more participants to a group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.addParticipants('[group@g.us]', [number@c.us]); * * // Get participant result: * console.log(result['123@c.us'].code); * console.log(result['123@c.us'].invite_code); * console.log(result['123@c.us'].invite_code_exp); * console.log(result['123@c.us'].message); * console.log(result['123@c.us'].wid); * * const memberResult = result['123@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['123@c.us'].invite_code; * console.log(link); * \`\`\` */ export const addParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.ADD_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Approve a membership request to group * * @example * \`\`\`javascript * await wa.group.approve(12345645@g.us, 5554999999999@c.us); * \`\`\` * */ export const approve = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.APPROVE, body: { groupId, membershipIds }, }) } /** * Check if your account is allowed to add new participants * * @example * \`\`\`javascript * const result = await wa.group.canAdd('group@g.us'); * console.log(result); * \`\`\` */ export const canAdd = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_ADD, body: groupId, }) } /** * Check if your account is allowed to demote participants * * @example * \`\`\`javascript * await wa.group.canDemote('group@g.us'); * console.log(result); * \`\`\` */ export const canDemote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_DEMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to promote participants * * @example * \`\`\`javascript * await WPP.group.canPromote('group@g.us'); * console.log(result); * \`\`\` * */ export const canPromote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_PROMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to remove participants * * @example * \`\`\`javascript * const result = await wa.group.canRemove('group@g.us'); * console.log(result); * \`\`\` */ export const canRemove = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_REMOVE, body: { groupId, participantsIds }, }) } /** * Create a new group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.create('Test Group', ['number@c.us']); * * console.log(result.gid.toString()); // Get the group ID * * // Get participant result: * console.log(result['number@c.us'].code); * console.log(result['number@c.us'].invite_code); * console.log(result['number@c.us'].invite_code_exp); * console.log(result['number@c.us'].message); * console.log(result['number@c.us'].wid); * * const memberResult = result['number@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['number@c.us'].invite_code; * console.log(link); * * // Create a Subgroup for a community * const result = await wa.group.create('Test Group', ['number@c.us'], 'communit@g.us'); * \`\`\` */ export const create = async ( groupName: string, participantsIds: (string | Wid) | (string | Wid)[], parentGroup: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CREATE, body: { groupName, participantsIds, parentGroup }, }) } /** * @example * \`\`\`javascript * // One member * await wa.group.demoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.demoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const demoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.DEMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Get group info from an inviteCode * * @example * \`\`\`javascript * await wa.group.getGroupInfoFromInviteCode('<inviteCode>'); * \`\`\` */ export const getGroupInfoFromInviteCode = async ( inviteCode: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, body: inviteCode, }) } /** * Get the max number of participants for a group * * @example * \`\`\`javascript * const limit = await wa.group.getGroupSizeLimit(); * console.log(limit); * \`\`\` */ export const getGroupSizeLimit = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_SIZE_LIMIT, body: {}, }) } export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LIST, }) } /** * @description Sends a request to the background script to get a group's invite link. * @param groupId The ID of the group (e.g., '1234567890@g.us'). * @returns A promise that resolves with the invite link string. */ export const getInviteLink = async (groupId: string): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_INVITE_LINK, body: { groupId }, }) } /** * Retrieve a lista of a membership approval requests * * @example * \`\`\`javascript * await wa.group.getMembershipRequests(12345645@g.us); * \`\`\` */ export const getMembershipRequests = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_MEMBERSHIP_REQUESTS, body: groupId, }) } /** * Get an array of participants of a group * * @example * \`\`\`javascript * wa.group.getParticipants('[group-id]@g.us'); * \`\`\` */ export const getParticipants = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_PARTICIPANTS, body: groupId, }) } export const iAmAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_ADMIN, body: groupId, }) } export const iAmMember = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_MEMBER, body: groupId, }) } export const iAmRestrictedMember = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_RESTRICTED_MEMBER, body: groupId, }) } export const iAmSuperAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_SUPER_ADMIN, body: groupId, }) } /** * Join in a group from an invite code. * * @example * \`\`\`javascript * await wa.group.join('abcde....'); * \`\`\` */ export const join = async (inviteCode: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.JOIN, body: inviteCode, }) } /** * Leave from a group. * * @example * \`\`\`javascript * await wa.group.leave('[number]@g.us'); * \`\`\` */ export const leave = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LEAVE, body: groupId, }) } /** * Promote group member to admin * * @example * \`\`\`javascript * // One member * await wa.group.promoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.promoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` * * @category Group */ export const promoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.PROMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Reject a membership request to group * * @example * \`\`\`javascript * await wa.group.reject(12345645@g.us, 5554999999999@c.us); * \`\`\` */ export const reject = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REJECT, body: { groupId, membershipIds }, }) } /** * Remove the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.removeIcon('[group@g.us]'); * \`\`\` */ export const removeIcon = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_ICON, body: groupId, }) } /** * Remove participants of a group * * @example * \`\`\`javascript * // One member * await wa.group.removeParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.removeParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const removeParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Revoke the current invite code and generate new one. * * @example * \`\`\`javascript * const code = WPP.group.revokeInviteCode('[group-id]@g.us'); * const link = 'https://chat.whatsapp.com/' + code; * \`\`\` */ export const revokeInviteCode = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REVOKE_INVITE_CODE, body: groupId, }) } /** * Define the group description * * @example * \`\`\`javascript * await wa.group.setDescription('[group-id]@g.us', 'new group description'); * \`\`\` */ export const setDescription = async ( groupId: string | Wid, description: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_DESCRIPTION, body: { groupId, description }, }) } /** * Set the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.setIcon('[group@g.us]', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const setIcon = async ( groupId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_ICON, body: { groupId, content }, }) } /** * Set the group property * * @example * \`\`\`javascript * // Only admins can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', true); * * // All can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', false); * * // Disatble temporary messages * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 0); * * // Enable temporary messages for 24 hours * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 86400); * * // Enable temporary messages for 7 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 604800); * * // Enable temporary messages for 90 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 7776000); * * // Only admins can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', true); * * // All can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', false); * \`\`\` */ export const setProperty = async ( groupId: string | Wid, property: GroupProperty, value: 0 | 1 | 86400 | 604800 | 7776000 | boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_PROPERTY, body: { groupId, property, value }, }) } /** * Define the group subject * * @example * \`\`\`javascript * await wa.group.setSubject('[group-id]@g.us', 'new group subject'); * \`\`\` */ export const setSubject = async ( groupId: string | Wid, subject: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_SUBJECT, body: { groupId, subject }, }) }
```

# src/libs/wa/index.ts

```ts
import * as chat from './chat' import * as conn from './conn' import * as contact from './contact' import * as group from './group' import * as on from './on' import * as send from './send' export default { on, conn, send, contact, chat, group, }
```

# src/libs/wa/newsletter.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' /** * Create a newsletter * * @example * \`\`\`javascript * // To edit name * wa.newsletter.create('Name for your newsletter', { * description: 'Description for that', * picture: '<base64_string', * }); * \`\`\` */ export const create = async ( name: string, opts: { description?: string; picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.CREATE, body: { name, opts }, }) } /** * Delete a newsletter * * @example * \`\`\`javascript * const code = wa.newsletter.destroy('[newsletter-id]@newsletter'); * \`\`\` */ export const destroy = async (id: string): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.DESTROY, body: id, }) } /** * Edit the newsletter data * * @example * \`\`\`javascript * // To edit name * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * name: 'New Name' * }); * * // To edit description * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * description: 'New description' * }); * * // To change picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: '<base64_image>' * }); * * // To remove picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: null * }); * \`\`\` */ export const edit = async ( newsletterId: string, opts: { name?: string description?: string picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.EDIT, body: { newsletterId, opts }, }) } /** * Get subscribers of a newsletters * * @example * \`\`\`javascript * const code = wa.newsletter.getSubscribers('[newsletter-id]@newsletter'); * \`\`\` */ export const getSubscribers = async (id: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.GET_SUBSCRIBERS, body: id, }) } /** * Mute and unmute a newsletter * * @example * // Mute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', true); * \`\`\` * * // Unmute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', false); * \`\`\` */ export const mute = async ( newsletterId: string, value?: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.MUTE, body: { newsletterId, value }, }) }
```

# src/libs/wa/on.ts

```ts
export const ready = (callback = () => {}) => { const targetSelector = '#side' // WhatsApp left-panel root const node = document.querySelector(targetSelector) if (node) { require('@wppconnect/wa-js/dist/wppconnect-wa') callback() return } // Wait for the node to appear only once const observer = new MutationObserver(() => { const el = document.querySelector(targetSelector) if (el) { console.log('âœ…âœ…âœ…âœ…âœ…') observer.disconnect() // stop watching require('@wppconnect/wa-js/dist/wppconnect-wa') callback() } }) observer.observe(document.body, { childList: true, subtree: true, }) }
```

# src/libs/wa/profile.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { BusinessProfileModel } from '@wppconnect/wa-js/dist/whatsapp' /** * Update your business profile * * @example * \`\`\`javascript * await wa.profile.editBusinessProfile({description: 'New description for profile'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({categories: { id: "133436743388217", localized_display_name: "Artes e entretenimento", not_a_biz: false, }}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({email: 'test@test.com.br'}); * \`\`\` * * Change website of profile (max 2 sites) * \`\`\`javascript * await wa.profile.editBusinessProfile({website: [ "https://www.wppconnect.io", "https://www.teste2.com.br", ]}); * \`\`\` * * Change businessHours for Specific Hours * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { * { tue: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, wed: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, thu: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, fri: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sat: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sun: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, } }, timezone: "America/Sao_Paulo" }); * * Change businessHours for Always Opened * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "open_24h", }, tue: { mode: "open_24h", }, wed: { mode: "open_24h", }, thu: { mode: "open_24h", }, fri: { mode: "open_24h", }, sat: { mode: "open_24h", }, sun: { mode: "open_24h", }, } timezone: "America/Sao_Paulo" }); * * Change businessHours for Appointment Only * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "appointment_only", }, tue: { mode: "appointment_only", }, wed: { mode: "appointment_only", }, thu: { mode: "appointment_only", }, fri: { mode: "appointment_only", }, sat: { mode: "appointment_only", }, sun: { mode: "appointment_only", }, } timezone: "America/Sao_Paulo" }); * * */ export const editBusinessProfile = async ( params: BusinessProfileModel, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.EDIT_BUSINESS_PROFILE, body: params, }) } /** * Get your current profile name * * @example * \`\`\`javascript * const myProfileName = wa.profile.getMyProfileName(); * \`\`\` */ export const getMyProfileName = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_NAME, body: {}, }) } /** * Get your current profile picture * * @example * \`\`\`javascript * await wa.profile.getMyProfilePicture(); * \`\`\` */ export const getMyProfilePicture = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_PICTURE, body: {}, }) } /** * Get your current text status * * @example * \`\`\`javascript * await wa.profile.getMyStatus(); * \`\`\` */ export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_STATUS, body: {}, }) } /** * Return the current logged user is Bussiness or not * * @example * \`\`\`javascript * wa.profile.isBusiness(); * \`\`\` */ export const isBusiness = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.IS_BUSINESS, body: {}, }) } /** * Remove your profile picture * * @example * \`\`\`javascript * await wa.profile.removeMyProfilePicture(); * \`\`\` */ export const removeMyProfilePicture = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.REMOVE_MY_PROFILE_PICTURE, body: {}, }) } /** * Update your current profile name * * @example * \`\`\`javascript * await wa.profile.setMyProfileName('My new name'); * \`\`\` */ export const setMyProfileName = async (name: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_NAME, body: {}, }) } /** * Update your profile picture * * @example * \`\`\`javascript * await wa.profile.setMyProfilePicture('data:image/jpeg;base64,.....'); * \`\`\` */ export const setMyProfilePicture = async (content: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_PICTURE, body: content, }) } /** * Update your current text status * * @example * \`\`\`javascript * await wa.profile.setMyStatus('Example text'); * \`\`\` */ export const setMyStatus = async (statusText: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_STATUS, body: statusText, }) }
```

# src/libs/wa/send.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { AudioMessageOptions, AutoDetectMessageOptions, DocumentMessageOptions, ImageMessageOptions, LocationMessageOptions, PoolMessageOptions, SendMessageOptions, StickerMessageOptions, TextMessageOptions, VCardContact, VideoMessageOptions, } from '@wppconnect/wa-js/dist/chat' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { SendMsgResult } from '@wppconnect/wa-js/dist/whatsapp/enums' export const text = async ( chatId: any, content: any, options: TextMessageOptions = {}, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.TEXT, body: { chatId, content, options, }, }) } export const file = async ( chatId: string | Wid, content: string | Blob | File, options: | AutoDetectMessageOptions | AudioMessageOptions | DocumentMessageOptions | ImageMessageOptions | VideoMessageOptions | StickerMessageOptions | TextMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.FILE, body: { chatId, content, options, }, }) } export const location = async ( chatId: string | Wid, options: LocationMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.LOCATION, body: { chatId, options, }, }) } export const poll = async ( chatId: any, name: string, choices: string[], options?: PoolMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.POLL, body: { chatId, name, choices, options, }, }) } export const vcard = async ( chatId: string | Wid, contacts: string | Wid | VCardContact | (string | Wid | VCardContact)[], options?: SendMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.VCARD, body: { chatId, contacts, options, }, }) }
```

# src/libs/wa/status.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ImageStatusOptions, TextStatusOptions, VideoStatusOptions, } from '@wppconnect/wa-js/dist/status' import type { MsgKey, Wid } from '@wppconnect/wa-js/dist/whatsapp' export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET, body: chatId, }) } export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET_MY_STATUS, body: {}, }) } export const remove = async (msgId: string | MsgKey): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.REMOVE, body: msgId, }) } /** * Send a image message to status stories * * @example * \`\`\`javascript * wa.status.sendImageStatus('data:image/jpeg;base64,<a long base64 file...>'); * \`\`\` */ export const sendImageStatus = async ( content: any, options: ImageStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_IMAGE_STATUS, body: { content, options }, }) } /** * Mark status as read/seen * * @example * \`\`\`javascript * wa.status.sendReadStatus('[phone_number]@c.us', 'false_status@broadcast_3A169E0FD4BC6E92212F_5521526232927@c.us'); * \`\`\` */ export const sendReadStatus = async ( chatId: string | Wid, statusId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_READ_STATUS, body: { chatId, statusId }, }) } /** * Send a text message to status stories * * @example * \`\`\`javascript * wa.status.sendTextStatus(`Bootstrap primary color: #0275d8`, { backgroundColor: '#0275d8', font: 2}); * \`\`\` */ export const sendTextStatus = async ( content: any, options: TextStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_TEXT_STATUS, body: { content, options }, }) } /** * Send a video message to status stories * * @example * \`\`\`javascript * wa.status.sendVideoStatus('data:video/mp4;base64,<a long base64 file...>'); * \`\`\` */ export const sendVideoStatus = async ( content: any, options: VideoStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_VIDEO_STATUS, body: { content, options }, }) } /** * Define a custom list of participants to send the status message * * @example * \`\`\`javascript * // Use a custom list * await wa.status.updateParticipants(['123@c.us', '456@c.us']); * // Use the contacts by default * await wa.status.updateParticipants(null); * \`\`\` */ export const updateParticipants = async ( ids?: (string | Wid)[] | null, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.UPDATE_PARTICIPANTS, body: ids, }) }
```

# src/relays/blocklist.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const blockContact = () => { relay( { name: Action.Blocklist.BLOCK_CONTACT, }, async ({ body }) => { return await WPP.blocklist.blockContact(body) }, ) } const isBlocked = () => { relay( { name: Action.Blocklist.IS_BLOCKED, }, async ({ body }) => { return WPP.blocklist.isBlocked(body) }, ) } const unblockContact = () => { relay( { name: Action.Blocklist.UNBLOCK_CONTACT, }, async ({ body }) => { return WPP.blocklist.unblockContact(body) }, ) } const initBlocklistRelays = () => { all() blockContact() isBlocked() unblockContact() } export default initBlocklistRelays
```

# src/relays/cart.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const add = () => { relay( { name: Action.Cart.ADD, }, async ({ body }) => { const { chatId, products } = body return await WPP.cart.add(chatId, products) }, ) } const clear = () => { relay( { name: Action.Cart.CLEAR, }, async ({ body }) => { return await WPP.cart.clear(body) }, ) } const get = () => { relay( { name: Action.Cart.GET, }, async ({ body }) => { return WPP.cart.get(body) }, ) } const getThumbFromCart = () => { relay( { name: Action.Cart.GET_THUMB_FROM_CART, }, async ({ body }) => { return await WPP.cart.getThumbFromCart(body) }, ) } const remove = () => { relay( { name: Action.Cart.REMOVE, }, async ({ body }) => { const { chatId, productId } = body return WPP.cart.remove(chatId, productId) }, ) } const submit = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { wid, msg, options } = body return WPP.cart.submit(wid, msg, options) }, ) } const update = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { chatId, productId, options } = body return WPP.cart.update(chatId, productId, options) }, ) } const initCartRelays = () => { add() clear() get() getThumbFromCart() remove() submit() update() } export default initCartRelays
```

# src/relays/catalog.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const addProductImage = () => { relay( { name: Action.Catalog.ADD_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.addProductImage(productId, content) }, ) } const changeProductImage = () => { relay( { name: Action.Catalog.CHANGE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.changeProductImage(productId, content) }, ) } const createCollection = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { const { collectionName, productsId } = body return await WPP.catalog.createCollection(collectionName, productsId) }, ) } const createProduct = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.createProduct(body) }, ) } const deleteCollection = () => { relay( { name: Action.Catalog.DELETE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.deleteCollection(body) }, ) } const deleteProduct = () => { relay( { name: Action.Catalog.DELETE_PRODUCT, }, async ({ body }) => { return await WPP.catalog.delProducts(body) }, ) } const editCollection = () => { relay( { name: Action.Catalog.EDIT_COLLECTION, }, async ({ body }) => { const { collectionId, params } = body return await WPP.catalog.editCollection(collectionId, params) }, ) } const editProduct = () => { relay( { name: Action.Catalog.EDIT_PRODUCT, }, async ({ body }) => { const { productId, params } = body return await WPP.catalog.editProduct(productId, params) }, ) } const getCollections = () => { relay( { name: Action.Catalog.GET_COLLECTIONS, }, async ({ body }) => { const { chatId, qnt, productsCount } = body return await WPP.catalog.getCollections(chatId, qnt, productsCount) }, ) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ const getMyCatalog = () => { relay( { name: Action.Catalog.GET_MY_CATALOG, }, async ({ body }) => { return await WPP.catalog.getMyCatalog() }, ) } const getProductById = () => { relay( { name: Action.Catalog.GET_PRODUCT_BY_ID, }, async ({ body }) => { const { chatId, productId } = body return await WPP.catalog.getProductById(chatId, productId) }, ) } const getProducts = () => { relay( { name: Action.Catalog.GET_PRODUCTS, }, async ({ body }) => { const { chatId, qnt } = body return await WPP.catalog.getProducts(chatId, qnt) }, ) } const removeProductImage = () => { relay( { name: Action.Catalog.REMOVE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, index } = body return await WPP.catalog.removeProductImage(productId, index) }, ) } const setProductVisibility = () => { relay( { name: Action.Catalog.SET_PRODUCT_VISIBILITY, }, async ({ body }) => { const { productId, isHidden } = body return await WPP.catalog.setProductVisibility(productId, isHidden) }, ) } const updateCartEnabled = () => { relay( { name: Action.Catalog.UPDAGE_CART_ENABLED, }, async ({ body }) => { return await WPP.catalog.updateCartEnabled(body) }, ) } const initCatalogRelays = () => { addProductImage() changeProductImage() createCollection() createProduct() deleteCollection() deleteProduct() editCollection() editProduct() getCollections() getMyCatalog() getProductById() getProducts() removeProductImage() setProductVisibility() updateCartEnabled() } export default initCatalogRelays
```

# src/relays/chat.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const archive = () => { relay( { name: Action.Chat.ARCHIVE, }, async ({ body }) => { return await WPP.chat.archive(body) }, ) } const canMarkPlayed = () => { relay( { name: Action.Chat.CAN_MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.canMarkPlayed(body) }, ) } const canMute = () => { relay( { name: Action.Chat.CAN_MUTE, }, async ({ body }) => { return WPP.chat.canMute(body) }, ) } const canReply = () => { relay( { name: Action.Chat.CAN_REPLY, }, async ({ body }) => { return await WPP.chat.canReply(body) }, ) } const clear = () => { relay( { name: Action.Chat.CLEAR, }, async ({ body }) => { return await WPP.chat.clear(body) }, ) } const closeChat = () => { relay( { name: Action.Chat.CLOSE_CHAT, }, async ({ body }) => { return await WPP.chat.closeChat() }, ) } const _delete = () => { relay( { name: Action.Chat.DELETE, }, async ({ body }) => { return await WPP.chat.delete(body) }, ) } const deleteMessage = () => { relay( { name: Action.Chat.DELETE_MESSAGE, }, async ({ body }) => { const { chatId, ids, deleteMediaInDevice, revoke } = body return await WPP.chat.deleteMessage( chatId, ids, deleteMediaInDevice, revoke, ) }, ) } const list = () => { relay( { name: Action.Chat.LIST, }, async ({ body }) => { console.log('body', body) return (await WPP.chat.list(body)).map(serialize.chat) }, ) } const find = () => { relay( { name: Action.Chat.FIND, }, async (req) => { try { const chatId = req.body const chat = await WPP.chat.find(chatId) return response.success(serialize.chat(chat)) } catch (error) { return response.error(error.message) } }, ) } const forwardMessage = () => { relay( { name: Action.Chat.FORWARD_MESSAGE, }, async ({ body }) => { const { toChatId, msgId, options } = body return await WPP.chat.forwardMessage(toChatId, msgId, options) }, ) } const get = () => { relay( { name: Action.Chat.GET, }, async ({ body }) => { try { const chat = WPP.chat.get(body) return serialize.chat(chat) } catch (error) {} }, ) } const getActiveChat = () => { relay( { name: Action.Chat.GET_ACTIVE_CHAT, }, async (req) => { try { const chat = WPP.chat.getActiveChat() if (!chat) { return null } return serialize.chat(chat) } catch (error) { return null } }, ) } const getLastSeen = () => { relay( { name: Action.Chat.GET_LAST_SEEN, }, async ({ body }) => { return await WPP.chat.getLastSeen(body) }, ) } const getMessageACK = () => { relay( { name: Action.Chat.GET_MESSAGE_ACK, }, async ({ body }) => { return await WPP.chat.getMessageACK(body) }, ) } const getMessages = () => { relay( { name: Action.Chat.GET_MESSAGES, }, async ({ body }) => { const { chatId, options } = body const messages = await WPP.chat.getMessages(chatId, options) return messages.map(serialize.message) }, ) } const getNotes = () => { relay( { name: Action.Chat.GET_NOTES, }, async ({ body }) => { return await WPP.chat.getNotes(body) }, ) } const getPlatformFromMessage = () => { relay( { name: Action.Chat.GET_PLATFORM_MESSAGE, }, async ({ body }) => { return WPP.chat.getPlatformFromMessage(body) }, ) } const markIsComposing = () => { relay( { name: Action.Chat.MARK_IS_COMPOSING, }, async ({ body }) => { const { chatId, duration } = body return WPP.chat.markIsComposing(chatId, duration) }, ) } const markIsPaused = () => { relay( { name: Action.Chat.MARK_IS_PAUSED, }, async ({ body }) => { return await WPP.chat.markIsPaused(body) }, ) } const markIsRead = () => { relay( { name: Action.Chat.MARK_IS_READ, }, async ({ body }) => { return await WPP.chat.markIsRead(body) }, ) } const markIsRecording = () => { relay( { name: Action.Chat.MARK_IS_RECORDING, }, async ({ body }) => { return await WPP.chat.markIsRecording(body) }, ) } const markIsUnread = () => { relay( { name: Action.Chat.MARK_IS_UNREAD, }, async ({ body }) => { return await WPP.chat.markIsUnread(body) }, ) } const markPlayed = () => { relay( { name: Action.Chat.MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.markPlayed(body) }, ) } const mute = () => { relay( { name: Action.Chat.MUTE, }, async ({ body }) => { const { chatId, time } = body return await WPP.chat.mute(chatId, time) }, ) } const openChatAt = () => { relay( { name: Action.Chat.OPEN_CHAT_AT, }, async ({ body }) => { const { chatId, messageId } = body return await WPP.chat.openChatAt(chatId, messageId) }, ) } const openChatFromUnread = () => { relay( { name: Action.Chat.OPEN_CHAT_FROM_UNREAD, }, async ({ body }) => { return await WPP.chat.openChatFromUnread(body) }, ) } const pinMsg = () => { relay( { name: Action.Chat.PIN_MSG, }, async ({ body }) => { const { msgId, pin, seconds } = body return await WPP.chat.pinMsg(msgId, pin, seconds) }, ) } const openChatBottom = () => { relay( { name: Action.Chat.OPEN_CHAT_BOTTOM, }, async (req) => { try { const chatId = req.body return await WPP.chat.openChatBottom(chatId) } catch (error) { return false } }, ) } const setChatList = () => { relay( { name: Action.Chat.SET_CHAT_LIST, }, async (req) => { try { const { type, ids } = req.body await WPP.chat.setChatList(type, ids) } catch (error) { console.error(`setChatList: ${error}`) } }, ) } const setInputText = () => { relay( { name: Action.Chat.SET_INPUT_TEXT, }, async ({ body }) => { const { text, chatId } = body return await WPP.chat.setInputText(text, chatId) }, ) } const setNotes = () => { relay( { name: Action.Chat.SET_NOTES, }, async ({ body }) => { const { chatId, content } = body return await WPP.chat.setNotes(chatId, content) }, ) } const downloadMedia = () => { relay( { name: Action.Chat.DOWNLOAD_MEDIA, }, async ({ body: messageId }) => { try { const media = await Promise.race([ WPP.chat.downloadMedia(messageId), new Promise((_, reject) => setTimeout(() => reject(new Error('Error download media')), 3000), ), ]) return media } catch (error) { return null } }, ) } const initChatRelay = () => { archive() canMarkPlayed() canMute() canReply() clear() closeChat() _delete() deleteMessage() downloadMedia() find() forwardMessage() get() getActiveChat() getLastSeen() getMessageACK() getMessages() getNotes() getPlatformFromMessage() markIsComposing() markIsPaused() markIsRead() markIsRecording() markIsUnread() markPlayed() mute() list() openChatBottom() openChatAt() openChatFromUnread() pinMsg() setChatList() setInputText() setNotes() } export default initChatRelay
```

# src/relays/community.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const initCommunityRelays = () => { all() } export default initCommunityRelays
```

# src/relays/conn.relay.ts

```ts
import { Account, Action } from '@/constants' import country from '@/utils/country' import { delay } from '@/utils/util' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const genLinkDeviceCodeForPhoneNumber = () => { relay( { name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }, async ({ body }) => { const { phone, sendPushNotification } = body return await WPP.conn.genLinkDeviceCodeForPhoneNumber( phone, sendPushNotification, ) }, ) } const getAuthCode = () => { relay( { name: Action.Conn.GET_AUTH_CODE, }, async ({ body }) => { return await WPP.conn.getAuthCode() }, ) } const getMyUserId = () => { relay( { name: Action.Conn.GET_MY_USER_ID, }, async (req) => { return WPP.conn.getMyUserId() }, ) } const getProfile = () => { relay( { name: Action.Conn.GET_PROFILE, }, async (req) => { await delay(1000) const { user: number } = WPP.conn.getMyUserId() const contact = await WPP.contact.get(`${number}@c.us`) const countryCode = await WPP.whatsapp.functions.getCountryShortcodeByPhone(contact.id.user) const selectedCountry = country.getCountryByCode(countryCode) return { name: contact.pushname || contact.formattedName || contact.name || contact.verifiedName, number, type: contact.isBusiness ? Account.BUSINESS : Account.PERSONAL, country: selectedCountry.label, } }, ) } const initConnRelays = () => { genLinkDeviceCodeForPhoneNumber() getAuthCode() getMyUserId() getProfile() } export default initConnRelays
```

# src/relays/contact.relay.ts

```ts
import { Action } from '@/constants' import filterBy from '@/utils/filterBy' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Contact.GET, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getBusinessProfile = () => { relay( { name: Action.Contact.GET_BUSINESS_PROFILE, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getCommonGroups = () => { relay( { name: Action.Contact.GET_COMMON_GROUPS, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getProfilePictureUrl = () => { relay( { name: Action.Contact.GET_PROFILE_PICTURE_URL, }, async ({ body }) => { const { contactId, full } = body return await WPP.contact.getProfilePictureUrl(contactId, full) }, ) } const getStatus = () => { relay( { name: Action.Contact.GET_STATUS, }, async ({ body }) => { return await WPP.contact.getStatus(body) }, ) } const list = () => { relay( { name: Action.Contact.LIST, }, async (req) => { const options = req.body const contacts = ((await WPP.contact.list(options)) ?? []) .filter(filterBy.dontIncludeLid) .map(serialize.contact) return contacts }, ) } const isExist = () => { relay( { name: Action.Contact.IS_EXIST, }, async (req) => { try { const contactId = req.body const result = await WPP.contact.queryExists(contactId) return !!result } catch (error) { return false } }, ) } const initContactRelay = () => { get() getBusinessProfile() getCommonGroups() getProfilePictureUrl() getStatus() isExist() list() } export default initContactRelay
```

# src/relays/group.relay.ts

```ts
import { Action } from '@/constants' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const addParticipants = () => { relay( { name: Action.Group.ADD_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.addParticipants(groupId, participantsIds) }, ) } const approve = () => { relay( { name: Action.Group.APPROVE, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.approve(groupId, membershipIds) }, ) } const canAdd = () => { relay( { name: Action.Group.CAN_ADD, }, async ({ body }) => { return await WPP.group.canAdd(body) }, ) } const canDemote = () => { relay( { name: Action.Group.CAN_DEMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canDemote(groupId, participantsIds) }, ) } const canPromote = () => { relay( { name: Action.Group.CAN_PROMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canPromote(groupId, participantsIds) }, ) } const canRemove = () => { relay( { name: Action.Group.CAN_REMOVE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canRemove(groupId, participantsIds) }, ) } const create = () => { relay( { name: Action.Group.CREATE, }, async ({ body }) => { const { groupName, participantsIds, parentGroup } = body return await WPP.group.create(groupName, participantsIds, parentGroup) }, ) } const demoteParticipants = () => { relay( { name: Action.Group.DEMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.demoteParticipants(groupId, participantsIds) }, ) } const getGroupInfoFromInviteCode = () => { relay( { name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, }, async ({ body }) => { return await WPP.group.getGroupInfoFromInviteCode(body) }, ) } const getGroupSizeLimit = () => { relay( { name: Action.Group.GET_GROUP_SIZE_LIMIT, }, async ({ body }) => { return await WPP.group.getGroupSizeLimit() }, ) } const list = () => { relay( { name: Action.Group.LIST, }, async ({ body }) => { const list = await WPP.chat.list(body) if (!list) { return [] } return list.map(serialize.chat) }, ) } const getInviteLink = () => { relay( { name: Action.Group.GET_INVITE_LINK, }, async (req) => { try { const { groupId } = req.body const link = await WPP.group.getInviteCode(groupId) return `https://chat.whatsapp.com/${link}` } catch (error) { console.error(`getInviteLink relay error: ${error}`) return null } }, ) } const getMembershipRequests = () => { relay( { name: Action.Group.GET_MEMBERSHIP_REQUESTS, }, async ({ body }) => { return await WPP.group.getMembershipRequests(body) }, ) } const getParticipants = () => { relay( { name: Action.Group.GET_PARTICIPANTS, }, async ({ body }) => { try { const participants = await WPP.group.getParticipants(body) return participants.map(serialize.participant) } catch (error) { return [] } }, ) } const iAmAdmin = () => { relay( { name: Action.Group.IAM_ADMIN, }, async ({ body }) => { return await WPP.group.iAmAdmin(body) }, ) } const iAmMember = () => { relay( { name: Action.Group.IAM_MEMBER, }, async ({ body }) => { return await WPP.group.iAmMember(body) }, ) } const iAmRestrictedMember = () => { relay( { name: Action.Group.IAM_RESTRICTED_MEMBER, }, async ({ body }) => { return await WPP.group.iAmRestrictedMember(body) }, ) } const iAmSuperAdmin = () => { relay( { name: Action.Group.IAM_SUPER_ADMIN, }, async ({ body }) => { return await WPP.group.iAmSuperAdmin(body) }, ) } const join = () => { relay( { name: Action.Group.JOIN, }, async ({ body }) => { return await WPP.group.join(body) }, ) } const leave = () => { relay( { name: Action.Group.LEAVE, }, async ({ body }) => { return await WPP.group.leave(body) }, ) } const promoteParticipants = () => { relay( { name: Action.Group.PROMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.promoteParticipants(groupId, participantsIds) }, ) } const reject = () => { relay( { name: Action.Group.REJECT, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.reject(groupId, membershipIds) }, ) } const removeIcon = () => { relay( { name: Action.Group.REMOVE_ICON, }, async ({ body }) => { return await WPP.group.removeIcon(body) }, ) } const removeParticipants = () => { relay( { name: Action.Group.REMOVE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.removeParticipants(groupId, participantsIds) }, ) } const revokeInviteCode = () => { relay( { name: Action.Group.REVOKE_INVITE_CODE, }, async ({ body }) => { return await WPP.group.revokeInviteCode(body) }, ) } const setDescription = () => { relay( { name: Action.Group.SET_DESCRIPTION, }, async ({ body }) => { const { groupId, description } = body return await WPP.group.setDescription(groupId, description) }, ) } const setIcon = () => { relay( { name: Action.Group.SET_ICON, }, async ({ body }) => { const { groupId, content } = body return await WPP.group.setIcon(groupId, content) }, ) } const setProperty = () => { relay( { name: Action.Group.SET_PROPERTY, }, async ({ body }) => { const { groupId, property, value } = body return await WPP.group.setProperty(groupId, property, value) }, ) } const setSubject = () => { relay( { name: Action.Group.SET_SUBJECT, }, async ({ body }) => { const { groupId, subject } = body return await WPP.group.setSubject(groupId, subject) }, ) } const initGroupRelay = () => { addParticipants() approve() canAdd() canDemote() canPromote() canRemove() create() demoteParticipants() getInviteLink() getGroupInfoFromInviteCode() getGroupSizeLimit() getMembershipRequests() getParticipants() list() iAmAdmin() iAmMember() iAmRestrictedMember() iAmSuperAdmin() join() leave() promoteParticipants() reject() removeIcon() removeParticipants() revokeInviteCode() setDescription() setIcon() setProperty() setSubject() } export default initGroupRelay
```

# src/relays/index.ts

```ts
import initBlocklistRelays from './blocklist.relay' import initCartRelays from './cart.relay' import initChatRelay from './chat.relay' import initConnRelays from './conn.relay' import initContactRelay from './contact.relay' import initGroupRelay from './group.relay' import initSendRelay from './send.relay' import initStatusRelay from './status.relay' export const initInjectScriptRelays = () => { initBlocklistRelays() initCartRelays() initChatRelay() initConnRelays() initContactRelay() initGroupRelay() initSendRelay() initStatusRelay() }
```

# src/relays/newsletter.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const create = () => { relay( { name: Action.Newsletter.CREATE, }, async ({ body }) => { const { name, opts } = body return await WPP.newsletter.create(name, opts) }, ) } const destroy = () => { relay( { name: Action.Newsletter.DESTROY, }, async ({ body }) => { return await WPP.newsletter.destroy(body) }, ) } const edit = () => { relay( { name: Action.Newsletter.EDIT, }, async ({ body }) => { const { newsletterId, opts } = body return await WPP.newsletter.edit(newsletterId, opts) }, ) } const getSubscribers = () => { relay( { name: Action.Newsletter.GET_SUBSCRIBERS, }, async ({ body }) => { return await WPP.newsletter.getSubscribers(body) }, ) } const mute = () => { relay( { name: Action.Newsletter.MUTE, }, async ({ body }) => { const { newsletterId, value } = body return await WPP.newsletter.mute(newsletterId, value) }, ) } const initNewsletterRelay = () => { create() destroy() edit() getSubscribers() mute() } export default initNewsletterRelay
```

# src/relays/profile.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Profile.EDIT_BUSINESS_PROFILE, }, async ({ body }) => { return WPP.status.get(body) }, ) } const initProfileRelays = () => { get() } export default initProfileRelays
```

# src/relays/send.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const sendText = () => { relay( { name: Action.Send.TEXT, }, async (req) => { try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendTextMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendFile = () => { relay( { name: Action.Send.FILE, }, async (req) => { console.log('req', req) try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendFileMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendLocation = () => { relay( { name: Action.Send.LOCATION, }, async (req) => { try { const { chatId, options } = req.body const { sendMsgResult } = await WPP.chat.sendLocationMessage( chatId, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendPoll = () => { relay( { name: Action.Send.POLL, }, async (req) => { try { const { chatId, name, choices, options } = req.body const { sendMsgResult } = await WPP.chat.sendCreatePollMessage( chatId, name, choices, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendVCard = () => { relay( { name: Action.Send.VCARD, }, async (req) => { try { const { chatId, contacts, options } = req.body const { sendMsgResult } = await WPP.chat.sendVCardContactMessage( chatId, contacts, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const initSendRelay = () => { sendText() sendFile() sendLocation() sendPoll() sendVCard() } export default initSendRelay
```

# src/relays/status.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Status.GET, }, async ({ body }) => { return WPP.status.get(body) }, ) } const getMyStatus = () => { relay( { name: Action.Status.GET_MY_STATUS, }, async ({ body }) => { return await WPP.status.getMyStatus() }, ) } const remove = () => { relay( { name: Action.Status.REMOVE, }, async ({ body }) => { return await WPP.status.remove(body) }, ) } const sendImageStatus = () => { relay( { name: Action.Status.SEND_IMAGE_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendImageStatus(content, options) }, ) } const sendReadStatus = () => { relay( { name: Action.Status.SEND_READ_STATUS, }, async ({ body }) => { const { chatId, statusId } = body return await WPP.status.sendReadStatus(chatId, statusId) }, ) } const sendTextStatus = () => { relay( { name: Action.Status.SEND_TEXT_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendTextStatus(content, options) }, ) } const sendVideoStatus = () => { relay( { name: Action.Status.SEND_VIDEO_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendVideoStatus(content, options) }, ) } const updateParticipants = () => { relay( { name: Action.Status.UPDATE_PARTICIPANTS, }, async ({ body }) => { return await WPP.status.updateParticipants(body) }, ) } const initStatusRelay = () => { get() getMyStatus() remove() sendImageStatus() sendReadStatus() sendTextStatus() sendVideoStatus() updateParticipants() } export default initStatusRelay
```

# src/stores/app.ts

```ts
import type { License } from '@/types' import { create } from 'zustand' interface AppState { isReady: boolean setIsReady: (isReady: boolean) => void profile: any setProfile: (profile: any) => void license?: License | null setLicense: (license: any) => void groups: any[] setGroups: (groups: []) => void isLoading: boolean setIsLoading: (state: boolean) => void activeChat: any setActiveChat: (chat: any) => void } export const useAppStore = create<AppState>((set) => ({ isReady: false, setIsReady: (isReady: boolean) => set({ isReady }), license: null, setLicense: (license: any) => set({ license: license }), groups: [], setGroups: (groups: []) => set({ groups }), profile: {}, setProfile: (profile: any) => set({ profile }), isLoading: false, setIsLoading: (state: any) => set({ isLoading: state }), activeChat: {}, setActiveChat: (chat: any) => set({ activeChat: chat }), }))
```

# src/stores/toast.ts

```ts
import { create } from 'zustand' export interface Toast { id: number type: 'success' | 'error' | 'info' | 'warning' title: string message: string duration?: number } interface ToastState { toasts: Toast[] addToast: (toast: Omit<Toast, 'id'>) => void removeToast: (id: number) => void } export const useToastStore = create<ToastState>((set) => ({ toasts: [], addToast: (toast) => set((state) => ({ toasts: [...state.toasts, { ...toast, id: Date.now() }], })), removeToast: (id) => set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id), })), }))
```

# src/styles/globals.css

```css
div.plasmo-csui-container { margin: 0; color-scheme: var(--mantine-color-scheme); font-family: var(--mantine-font-family); font-size: var(--mantine-font-size-md); line-height: var(--mantine-line-height); background-color: var(--mantine-color-body); color: var(--mantine-color-text); -webkit-font-smoothing: var(--mantine-webkit-font-smoothing); -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing); right: 0px; left: auto !important; } .root { position: fixed; top: '30%'; left: '50%'; transform: 'translate(-50%, -50%)'; z-index: 1001; background-color: red; } #plasmo-inline { background: transparent; }
```

# src/tabs/landing-page.tsx

```tsx
// src/tabs/landing-page.tsx import plans, { features as comparisonFeatures } from '@/config/plans' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { Accordion, Anchor, Avatar, Badge, Box, Button, Card, Center, Container, Divider, Grid, Group, List, MantineProvider, Paper, Stack, Table, Text, ThemeIcon, Title, Tooltip, Transition, } from '@mantine/core' import '@mantine/core/styles.css' import { useWindowScroll } from '@mantine/hooks' import React, { useEffect, useState } from 'react' const CheckIcon = () => ( <Icon icon="tabler:check" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-teal-6)" /> ) const CrossIcon = () => ( <Icon icon="tabler:x" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-red-6)" /> ) // --- Countdown Timer Logic --- // // English: Define TimeLeft interface for type safety. interface TimeLeft { days: number hours: number minutes: number seconds: number } // English: Calculate the time remaining until the offer ends. const calculateTimeLeft = (offerEndDate: Date): TimeLeft | null => { const difference = +offerEndDate - +new Date() if (difference <= 0) { return null } return { days: Math.floor(difference / (1000 * 60 * 60 * 24)), hours: Math.floor((difference / (1000 * 60 * 60)) % 24), minutes: Math.floor((difference / 1000 / 60) % 60), seconds: Math.floor((difference / 1000) % 60), } } const TimeSegment: React.FC<{ value: number; label: string }> = ({ value, label, }) => ( <Stack align="center" gap={0}> <Text fz={32} fw={700} c="yellow.6"> {String(value).padStart(2, '0')} </Text> <Text size="xs" c="dimmed"> {label} </Text> </Stack> ) const CountdownTimer: React.FC<{ offerEndDate: Date; isMini?: boolean }> = ({ offerEndDate, isMini = false, }) => { const [timeLeft, setTimeLeft] = useState<TimeLeft | null>( calculateTimeLeft(offerEndDate), ) useEffect(() => { const timer = setInterval(() => { setTimeLeft(calculateTimeLeft(offerEndDate)) }, 1000) return () => clearInterval(timer) }, [offerEndDate]) if (!timeLeft) { return ( <Text c="red.7" fw={700} size="lg"> Offer has ended! </Text> ) } if (isMini) { return ( <Text c="white" size="sm" fw={500}> Offer Ends In: {String(timeLeft.days).padStart(2, '0')}: {String(timeLeft.hours).padStart(2, '0')}: {String(timeLeft.minutes).padStart(2, '0')}: {String(timeLeft.seconds).padStart(2, '0')} </Text> ) } return ( <Group justify="center" gap="lg"> <TimeSegment value={timeLeft.days} label="DAYS" /> <TimeSegment value={timeLeft.hours} label="HOURS" /> <TimeSegment value={timeLeft.minutes} label="MINUTES" /> <TimeSegment value={timeLeft.seconds} label="SECONDS" /> </Group> ) } // --- End Countdown Timer Logic --- // // --- Section Components --- // const HeroSection = () => ( <Center p="xl" pt={80}> <Stack align="center" gap="xl" ta="center" maw={700}> <ThemeIcon size={80} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon="tabler:shield-lock" fontSize={48} /> </ThemeIcon> <Title order={1} fz={{ base: 36, sm: 48 }}> Archive & Export Your WhatsApp Chats into Secure Files. </Title> <Text c="dimmed" fz="lg"> A one-time payment solution to back up and convert your WhatsApp history into PDF, Excel, CSV, and moreâ€”all processed securely on your own computer. </Text> <Stack align="center"> {/* MODIFIED: CTA button size is increased for more prominence. */} <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > Get Lifetime Access Now </Button> <Text size="xs" c="dimmed"> Includes 30-day money-back guarantee </Text> </Stack> <Text size="sm" c="dimmed"> Trusted by 1,000+ happy users worldwide </Text> </Stack> </Center> ) const FeaturesSection = () => { const featuresData = [ { icon: 'tabler:database-export', title: 'Unlimited Backups', description: 'Save everything. Back up unlimited messages, photos, videos, and documents from any chat.', }, { icon: 'tabler:files', title: 'Multiple Formats', description: 'Convert your chats into professional PDF, CSV, Excel, JSON, and TXT files for any purpose.', }, { icon: 'tabler:shield-lock', title: 'Private & Secure', description: 'Your data never leaves your computer. All backups are processed and stored locally for maximum security.', }, { icon: 'tabler:filter', title: 'Advanced Filtering', description: 'Easily find what you need. Filter your exports by custom date ranges or multiple keywords.', }, { icon: 'tabler:device-mobile-message', title: 'Media Included', description: 'Donâ€™t just save text. The Pro version allows you to include all media types in your backups.', }, { icon: 'tabler:headset', title: 'Priority Support', description: 'Get help when you need it. Pro users get priority access to our dedicated support team.', }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Powerful Features at Your Fingertips</Title> <Text c="dimmed"> Unlock the full potential of your WhatsApp data with the Pro version. </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {featuresData.map((feature) => ( <Grid.Col span={{ base: 12, md: 4 }} key={feature.title}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon={feature.icon} fontSize={22} /> </ThemeIcon> <Text fw={700} fz="lg"> {feature.title} </Text> </Group> <Text c="dimmed" size="sm" mt="md"> {feature.description} </Text> </Card> </Grid.Col> ))} </Grid> </Box> ) } // English: New section to address specific user needs. const UserPersonaSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Built For Everyone</Title> <Text c="dimmed"> Whether for work or personal memories, we've got you covered. </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:briefcase" fontSize={22} /> </ThemeIcon> <Title order={3}>For Professionals & Business</Title> </Group> <Text c="dimmed" size="sm" mt="md"> Effortlessly manage client communications, generate reports, and maintain legal records. </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> Export client chats to Excel/CSV for reporting. </List.Item> <List.Item> Backup unlimited project data without risk of loss. </List.Item> <List.Item> Use keyword filters to find specific agreements or details. </List.Item> </List> </Stack> </Card> </Grid.Col> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:heart" fontSize={22} /> </ThemeIcon> <Title order={3}>For Personal Use</Title> </Group> <Text c="dimmed" size="sm" mt="md"> Securely save precious conversations with loved ones, from family chats to special moments. </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> Save conversations as a readable PDF, complete with photos. </List.Item> <List.Item> Backup all your media so you never lose a precious memory. </List.Item> <List.Item> Keep a permanent, private archive of your most important chats. </List.Item> </List> </Stack> </Card> </Grid.Col> </Grid> </Box> ) const PricingSection: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => ( <Group justify="center" align="stretch" mt="xl" gap="lg"> {plans.map((plan, index) => ( <Paper key={index} withBorder w={{ base: '100%', sm: 380 }} radius={'lg'} p="xl" style={{ border: !plan.isFree ? '2px solid var(--mantine-color-teal-6)' : undefined, boxShadow: !plan.isFree ? 'var(--mantine-shadow-lg)' : 'var(--mantine-shadow-sm)', position: 'relative', }} > <Stack justify="space-between" style={{ height: '100%' }}> <Box ta="center"> <Title order={2}>{plan.name}</Title> <Text c="dimmed" mt={4} size="sm"> {plan.description} </Text> </Box> <Box my="lg" ta="center"> {!plan.isFree && ( <Stack mb="lg"> {/* MODIFIED: Added a title to give context to the countdown timer. */} <Title order={4} c="orange.7"> LAUNCH OFFER: 56% OFF ENDS SOON! </Title> <CountdownTimer offerEndDate={offerEndDate} /> {/* MODIFIED: Updated the savings amount to reflect the new price. */} <Text size="xs" c="dimmed" mt="xs"> Don't miss out on saving $50. Price returns to normal after the timer ends. </Text> </Stack> )} <Group gap={8} align={'baseline'} justify="center"> {plan.placeholderPrice && ( <Title order={3} c={'dimmed'} style={{ textDecorationLine: 'line-through' }} > {plan.placeholderPrice} </Title> )} <Title order={1} fz={52}> {plan.price} </Title> </Group> </Box> <Divider label="Key Features" labelPosition="center" my="sm" /> <Stack gap="sm" mb="lg"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="sm" wrap="nowrap" align="flex-start"> <ThemeIcon variant="light" color={plan.isFree ? 'gray' : 'teal'} size="sm" radius="xl" > {plan.isFree ? ( <Icon icon="tabler:circle-check" fontSize={16} /> ) : ( <Icon icon="tabler:star" fontSize={16} /> )} </ThemeIcon> <Text size="sm">{feature}</Text> </Group> ))} </Stack> <Box mt="auto"> {plan.isFree ? ( <Button size="md" variant="default" fullWidth disabled> Your Current Plan </Button> ) : ( <Stack gap="xs"> {/* MODIFIED: CTA button size is increased for emphasis. */} <Button size="lg" component="a" href={plan.link} target="_blank" fullWidth leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > Upgrade to Pro </Button> {/* MODIFIED: Enhanced trust signals below the purchase button. */} <Group justify="center" gap={6}> <Icon icon="tabler:lock" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> 100% Secure Payment via Lemon Squeezy </Text> </Group> <Group justify="center" gap={6}> <Icon icon="tabler:shield-check" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> 30-Day Money-Back Guarantee </Text> </Group> </Stack> )} </Box> </Stack> </Paper> ))} </Group> ) const FeatureComparisonTable = () => ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> Features Comparison </Title> </Center> <Card withBorder radius="lg" p={0}> <Table striped highlightOnHover verticalSpacing="md" fz="sm"> <Table.Thead> <Table.Tr> <Table.Th w="40%">Feature</Table.Th> <Table.Th ta="center">Free</Table.Th> <Table.Th ta="center">Pro</Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {comparisonFeatures.map((item) => ( <Table.Tr key={item.feature} style={{ backgroundColor: item.free === false ? 'var(--mantine-color-teal-0)' : undefined, }} > <Table.Td> <Group gap="xs" justify="space-between"> <Text fw={500}>{item.feature}</Text> {item.free === false && ( <Tooltip label="This feature is exclusive to the Pro version." withArrow position="top" > <Icon icon="tabler:info-circle" color="var(--mantine-color-teal-5)" /> </Tooltip> )} </Group> </Table.Td> <Table.Td ta="center"> {typeof item.free === 'boolean' ? ( item.free ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Text size="sm">{item.free}</Text> )} </Table.Td> <Table.Td ta="center"> {typeof item.pro === 'boolean' ? ( item.pro ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Badge color="teal" variant="light"> {item.pro} </Badge> )} </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </Card> </Box> ) // English: Added a dedicated security section for trust-building. const SecuritySection = () => ( <Box mt={80}> <Card withBorder p="xl" radius="lg" bg="gray.0"> <Grid align="center"> <Grid.Col span={{ base: 12, md: 2 }} ta="center"> <ThemeIcon size={80} radius="xl" variant="light" color="teal"> <Icon icon="tabler:shield-lock" fontSize={48} /> </ThemeIcon> </Grid.Col> <Grid.Col span={{ base: 12, md: 10 }}> <Title order={2}>Your Privacy is Our Top Priority</Title> <Text c="dimmed" mt="md"> We designed this extension with a "privacy-first" approach. You have complete and total control over your data, always. </Text> <List mt="md" spacing="xs" size="sm" icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> <b>100% Local Processing:</b> Your chats and media are processed directly on your computer. </List.Item> <List.Item> <b>No Data Uploads:</b> We never see, save, or have access to your conversations or files. </List.Item> <List.Item> <b>You Are in Control:</b> Your exported files are saved only where you chooseâ€”on your local device. </List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const TestimonialsSection = () => { // MODIFIED: Expanded testimonials from 2 to 6 to increase social proof. const testimonialsData = [ { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-8.png', name: 'Sarah L.', role: 'Small Business Owner', quote: 'I kept putting off the upgrade. Last week, my phone died completely. I would have <b>deeply regretted losing everything</b> if I hadnâ€™t backed up thousands of client chats with the Pro version a few days prior. The best investment for peace of mind.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-2.png', name: 'Mike P.', role: 'Freelancer', quote: 'I needed to export a long chat history for a project report. The <b>Excel export feature in Pro</b> saved me hours of manual copy-pasting. A fantastic one-time purchase, no annoying subscriptions!', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-4.png', name: 'Dr. Alisha Chen', role: 'Researcher', quote: 'For my study on communication patterns, the <b>JSON export was invaluable</b>. It provided clean, structured data that was easy to parse and analyze. This tool is surprisingly powerful for academic purposes.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-5.png', name: 'David G.', role: 'Family Historian', quote: 'I wanted to create a keepsake of conversations with my grandmother. The ability to back up everything, including photos and voice notes, and export it to a single <b>beautifully formatted PDF</b>, is priceless. These are memories I now have forever.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-7.png', name: 'Maria Rodriguez', role: 'Legal Assistant', quote: 'We required timestamped chat logs for a legal case. The Pro version allowed us to filter by date and export a complete, verifiable record. It was <b>straightforward, secure, and professional</b>. Highly recommended for legal compliance.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-3.png', name: 'Tom B.', role: 'Retiree', quote: "I'm not very tech-savvy, but I was worried about losing years of family photos on WhatsApp. The process was <b>incredibly simple</b>. I clicked a few buttons, and everything was saved to my computer. A huge relief!", }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Trusted by Users Like You</Title> <Text c="dimmed"> See what our happy customers are saying about the Pro version. </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {testimonialsData.map((testimonial) => ( <Grid.Col span={{ base: 12, md: 6 }} key={testimonial.name}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack> <Text c="dimmed" dangerouslySetInnerHTML={{ __html: testimonial.quote }} /> <Group mt="md"> <Avatar src={testimonial.avatar} alt={testimonial.name} radius="xl" /> <div> <Text fw={500}>{testimonial.name}</Text> <Text size="xs" c="dimmed"> {testimonial.role} </Text> </div> </Group> </Stack> </Card> </Grid.Col> ))} </Grid> </Box> ) } const GuaranteeSection = () => ( <Paper bg="teal.0" radius="lg" p="xl" mt={80}> <Group justify="center" align="center"> <ThemeIcon variant="light" color="teal" size={60} radius="xl"> <Icon icon="tabler:certificate" fontSize={32} /> </ThemeIcon> <Stack gap={0} ta={{ base: 'center', sm: 'left' }}> <Title order={3}>Our "Peace of Mind" Guarantee</Title> <Text c="dimmed" maw={500}> We're confident you'll love the Pro features. If you're not 100% satisfied, contact us within 30 days of your purchase for a full, no-questions-asked refund. </Text> </Stack> </Group> </Paper> ) const FaqSection = () => { const faqData = [ { icon: 'tabler:rocket', question: 'What are the main benefits of upgrading to Pro?', answer: "With Pro, you get <b>Total Protection</b> by backing up all messages and media without limits. You'll unlock <b>Exclusive Features</b> like PDF/Excel exports and advanced filtering. Plus, you receive <b>Priority Support</b>, ensuring our team assists you first.", }, { icon: 'tabler:key', question: 'Is this a one-time payment or a subscription?', answer: 'It is a <b>one-time payment</b>. You pay once and get lifetime access to all current and future Pro features. No monthly fees, no subscriptions, ever.', }, { icon: 'tabler:shield-check', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our top priority. The extension processes everything <b>locally on your computer</b>. No chat data is ever sent to our servers. You have 100% control.', }, { icon: 'tabler:help-octagon', question: 'How do I get my license key after purchase?', answer: 'Immediately after your purchase, you will receive an email from our payment partner, <b>Lemon Squeezy</b>, containing your license key and instructions to activate it.', }, ] return ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> Frequently Asked Questions </Title> </Center> <Accordion variant="separated" radius="lg"> {faqData.map((item, index) => ( <Accordion.Item key={index} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > <Text fw={500}>{item.question}</Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} /> </Accordion.Panel> </Accordion.Item> ))} </Accordion> </Box> ) } // English: New section for value stacking before the final CTA. const ValueStackSection = () => ( <Box mt={80}> <Card withBorder radius="lg" p="xl"> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Here's Everything You Get</Title> <Text c="dimmed"> Your Pro Lifetime License is a complete package for total peace of mind. </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Unlimited Message & Media Backups</List.Item> <List.Item>Export to All Formats (PDF, Excel, etc.)</List.Item> <List.Item>Advanced Date & Keyword Filtering</List.Item> </List> </Grid.Col> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Priority Customer Support</List.Item> <List.Item>All Future Updates Included</List.Item> <List.Item>30-Day Money-Back Guarantee</List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const ContactUsSection = () => ( <Box mt={80}> <Card withBorder p="xl" shadow="sm" radius="lg"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still Have Questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us for any inquiries. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Card> </Box> ) const StickyHeader: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => { const [scroll] = useWindowScroll() return ( <Transition mounted={scroll.y > 200} transition="slide-down" duration={300} timingFunction="ease" > {(styles) => ( <Paper shadow="md" radius={0} p="xs" style={{ ...styles, position: 'fixed', top: 0, left: 0, right: 0, zIndex: 1000, backgroundColor: 'var(--mantine-color-dark-8)', }} > <Container size="md"> <Group justify="space-between"> <CountdownTimer offerEndDate={offerEndDate} isMini /> <Button size="sm" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={18} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > Get Lifetime Access </Button> </Group> </Container> </Paper> )} </Transition> ) } const LandingPage = () => { const [notification, setNotification] = useState<{ city: string country: string } | null>(null) // English: Set a fixed target date for the offer to end. // Using useState to ensure the date is only calculated once on component mount. const [offerEndDate] = useState(() => { const date = new Date() date.setDate(date.getDate() + 3) // Offer ends in 3 days. return date }) useEffect(() => { const locations = [ { city: 'Torino', country: 'Italy' }, { city: 'Shaqra', country: 'Saudi Arabia' }, { city: 'Miami', country: 'United States' }, ] let timeoutId: NodeJS.Timeout const scheduleNextNotification = () => { clearTimeout(timeoutId) const randomDelay = Math.floor(Math.random() * (15000 - 8000 + 1)) + 8000 // 8-15 seconds timeoutId = setTimeout(() => { const randomLocation = locations[Math.floor(Math.random() * locations.length)] setNotification(randomLocation) timeoutId = setTimeout(() => { setNotification(null) scheduleNextNotification() }, 4000) // Show for 4 seconds }, randomDelay) } timeoutId = setTimeout(scheduleNextNotification, 5000) // First one after 5 seconds return () => clearTimeout(timeoutId) }, []) return ( <MantineProvider theme={theme}> <StickyHeader offerEndDate={offerEndDate} /> <Container size="md" py="xl"> <Stack gap={80}> <HeroSection /> <FeaturesSection /> <UserPersonaSection /> <PricingSection offerEndDate={offerEndDate} /> <FeatureComparisonTable /> <SecuritySection /> <TestimonialsSection /> <GuaranteeSection /> <FaqSection /> <ValueStackSection /> <ContactUsSection /> <Center mt={40}> <Stack align="center" gap="lg"> <Title order={2}>Ready to Secure Your Chats?</Title> {/* MODIFIED: Added text to reinforce the value before the final CTA */} <Text c="dimmed" size="lg"> Get all Pro features for a one-time payment. </Text> <Stack align="center"> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > {/* MODIFIED: Final CTA button updated with new price. */} Get Lifetime Access Now for Just $39 </Button> <Text size="xs" c="dimmed"> 30-day no-questions-asked money-back guarantee. </Text> </Stack> </Stack> </Center> </Stack> </Container> <Transition mounted={!!notification} transition="slide-right" duration={500} timingFunction="ease" > {(styles) => ( <Paper shadow="lg" p="sm" radius="md" withBorder style={{ ...styles, position: 'fixed', bottom: 20, left: 20, zIndex: 2000, }} > <Group> <ThemeIcon color="teal" size={36} radius="xl"> <Icon icon="tabler:shield-check" fontSize={22} /> </ThemeIcon> <Stack gap={0}> <Text fw={500} size="sm"> Just upgraded to Pro! </Text> <Text size="xs" c="dimmed"> {`Someone from ${notification?.city}, ${notification?.country}`} </Text> </Stack> </Group> </Paper> )} </Transition> </MantineProvider> ) } export default LandingPage
```

# src/tabs/resource-page.tsx

```tsx
// src/tabs/resource-page.tsx // English: This file provides promotional materials for the Chrome Web Store listing. import PromoIcon from '@/components/Promo/PromoIcon' import ScreenshotWrapper from '@/components/Promo/ScreenshotWrapper' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { Avatar, Badge, Button, Card, Center, Checkbox, Code, Container, CopyButton, Grid, Group, List, MantineProvider, Paper, Radio, Select, Stack, Tabs, TagsInput, Text, Textarea, ThemeIcon, Title, } from '@mantine/core' import '@mantine/core/styles.css' import { DatePickerInput } from '@mantine/dates' import '@mantine/dates/styles.css' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import React, { useRef } from 'react' // --- Promotional Tile Components (for generation) --- // // These components are designed to be rendered inside ScreenshotWrapper. // English: Using a darker gradient that matches the landing page's teal-to-lime theme with darker shades for a more prominent look. const PROMO_GRADIENT_BACKGROUND = 'linear-gradient(135deg, var(--mantine-color-teal-8), var(--mantine-color-lime-8))' // --- Small Promo Tile Options (440x280px) --- // // English: Three distinct design options for the small promotional tile, // all focused on showcasing the extension's key features in different layouts. // English: Option 1 uses a classic 2x2 grid layout for features. const SmallTileFeaturesGrid = () => ( <Paper w={440} h={280} withBorder radius="md" p="lg" display="flex" style={{ flexDirection: 'column', alignItems: 'center', justifyContent: 'center', textAlign: 'center', background: PROMO_GRADIENT_BACKGROUND, }} > <Text size="xl" fw={'bolder'} c="white"> Powerful Whatsapp Backup Tool </Text> <Text c="gray.2" size="sm" fw={500} mt="xs" mb="lg"> Export chats to PDF, Excel, and more. 100% Private. </Text> <Grid w="100%" gutter="sm"> <Grid.Col span={6}> <Group gap="xs"> <ThemeIcon size="md" radius="sm"> <Icon icon="tabler:files" fontSize={16} /> </ThemeIcon> <Text size="sm" c="white"> Multiple Formats </Text> </Group> </Grid.Col> <Grid.Col span={6}> <Group gap="xs"> <ThemeIcon size="md" radius="sm"> <Icon icon="tabler:shield-lock" fontSize={16} /> </ThemeIcon> <Text size="sm" c="white"> 100% Private </Text> </Group> </Grid.Col> <Grid.Col span={6}> <Group gap="xs"> <ThemeIcon size="md" radius="sm"> <Icon icon="tabler:photo-video" fontSize={16} /> </ThemeIcon> <Text size="sm" c="white"> Include Media </Text> </Group> </Grid.Col> <Grid.Col span={6}> <Group gap="xs"> <ThemeIcon size="md" radius="sm"> <Icon icon="tabler:filter" fontSize={16} /> </ThemeIcon> <Text size="sm" c="white"> Advanced Filters </Text> </Group> </Grid.Col> </Grid> </Paper> ) // English: Option 2 uses a clean, centered vertical list for features. const SmallTileFeaturesList = () => ( <Paper w={440} h={280} withBorder radius="md" p="xl" display="flex" style={{ flexDirection: 'column', justifyContent: 'center', background: PROMO_GRADIENT_BACKGROUND, }} > <Title order={3} ta="center" lh={1.2} c="white" mb="xl"> Your Complete WhatsApp Archive </Title> <Stack gap="sm" align="center"> <Group gap="xs"> <Icon icon="tabler:database-export" fontSize={20} color="white" /> <Text size="sm" c="white"> Unlimited Backups </Text> </Group> <Group gap="xs"> <Icon icon="tabler:photo-video" fontSize={20} color="white" /> <Text size="sm" c="white"> Export All Media </Text> </Group> <Group gap="xs"> <Icon icon="tabler:files" fontSize={20} color="white" /> <Text size="sm" c="white"> Multiple Formats (PDF, Excel) </Text> </Group> <Group gap="xs"> <Icon icon="tabler:shield-check" fontSize={20} color="white" /> <Text size="sm" c="white"> 100% Private & Secure </Text> </Group> </Stack> </Paper> ) // English: Option 3 uses a more visual, icon-driven horizontal layout for features. const SmallTileFeaturesIcons = () => ( <Paper w={440} h={280} withBorder radius="md" p="lg" display="flex" style={{ flexDirection: 'column', alignItems: 'center', justifyContent: 'center', textAlign: 'center', background: PROMO_GRADIENT_BACKGROUND, }} > <Title order={3} ta="center" lh={1.2} c="white"> All-in-One Backup Solution </Title> <Text c="gray.2" size="sm" fw={500} mt="xs" mb="xl"> Securely save your chats with all the features you need. </Text> <Group justify="center" gap="md"> <Stack align="center" gap={4}> <ThemeIcon size="lg" radius="lg"> <Icon icon="tabler:files" /> </ThemeIcon> <Text c="white" fz="xs"> Formats </Text> </Stack> <Stack align="center" gap={4}> <ThemeIcon size="lg" radius="lg"> <Icon icon="tabler:photo-video" /> </ThemeIcon> <Text c="white" fz="xs"> Media </Text> </Stack> <Stack align="center" gap={4}> <ThemeIcon size="lg" radius="lg"> <Icon icon="tabler:filter" /> </ThemeIcon> <Text c="white" fz="xs"> Filters </Text> </Stack> <Stack align="center" gap={4}> <ThemeIcon size="lg" radius="lg"> <Icon icon="tabler:shield-lock" /> </ThemeIcon> <Text c="white" fz="xs"> Secure </Text> </Stack> </Group> </Paper> ) // --- Marquee Promo Tiles (1280x800px) --- // // English: [MODIFIED] Component dimensions changed to 1280x800. const MarqueeTileFeatureShowcase = () => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ // English: Applying the consistent dark theme gradient. background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center" gutter={40}> <Grid.Col span={5}> <Stack> {/* English: [MODIFIED] Font size adjusted and color changed for dark background. */} <Title order={1} fz={44} lh={1.2} c="white"> The Ultimate WhatsApp Backup & Export Tool </Title> <Text size="xl" c="gray.3" mt="md"> Securely save your conversations and media in multiple formats with advanced filtering. </Text> </Stack> </Grid.Col> <Grid.Col span={7}> <Grid gutter="lg"> <Grid.Col span={6}> <Card withBorder radius="md" p="lg"> <Group> <ThemeIcon variant="light" size="lg"> <Icon icon="tabler:files" /> </ThemeIcon> <Text fw={700}>Multiple Formats</Text> </Group> <Text size="sm" c="dimmed" mt="xs"> Export to PDF, Excel, CSV, JSON, and more. </Text> </Card> </Grid.Col> <Grid.Col span={6}> <Card withBorder radius="md" p="lg"> <Group> <ThemeIcon variant="light" size="lg"> <Icon icon="tabler:shield-lock" /> </ThemeIcon> <Text fw={700}>100% Private</Text> </Group> <Text size="sm" c="dimmed" mt="xs"> Your data never leaves your computer. </Text> </Card> </Grid.Col> <Grid.Col span={6}> <Card withBorder radius="md" p="lg"> <Group> <ThemeIcon variant="light" size="lg"> <Icon icon="tabler:photo-video" /> </ThemeIcon> <Text fw={700}>Include Media</Text> </Group> <Text size="sm" c="dimmed" mt="xs"> Save images, videos, and documents. </Text> </Card> </Grid.Col> <Grid.Col span={6}> <Card withBorder radius="md" p="lg"> <Group> <ThemeIcon variant="light" size="lg"> <Icon icon="tabler:filter" /> </ThemeIcon> <Text fw={700}>Advanced Filtering</Text> </Group> <Text size="sm" c="dimmed" mt="xs"> Filter by date range and keywords. </Text> </Card> </Grid.Col> </Grid> </Grid.Col> </Grid> </Stack> </Paper> ) // --- Feature Mockups for Screenshots --- // // English: These components represent the light-themed UI and remain unchanged. const FeatureMockupExportFormats = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={5}>Export Options</Title> <Text c="dimmed" size="sm"> Choose your desired format for the chat backup. </Text> <Radio.Group label="Format" defaultValue="pdf"> <Group mt="xs"> <Radio value="html" label="HTML (.zip)" /> <Radio value="pdf" label="PDF" /> <Radio value="xlsx" label="Excel" /> <Radio value="csv" label="CSV" /> </Group> </Radio.Group> <Button mt="lg" leftSection={<Icon icon="tabler:download" />}> Start Backup </Button> </Stack> </Card> ) const FeatureMockupAdvancedFiltering = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={5}>Advanced Filtering</Title> <Text c="dimmed" size="sm"> Pinpoint the exact messages you need. </Text> <DatePickerInput type="range" label="Filter by Date Range" placeholder="Pick start and end dates" value={[new Date(2025, 6, 10), new Date(2025, 6, 24)]} disabled /> <TagsInput label="Filter by Keywords" placeholder="Add keywords" description="Only export messages containing these words." value={['contract', 'invoice', 'approved']} disabled /> </Stack> </Card> ) const FeatureMockupMediaBackup = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={5}>Include Media in Your Backup</Title> <Text c="dimmed" size="sm"> Don't just save textâ€”save the whole story. </Text> <Checkbox.Group label="Include Message Types" defaultValue={['chat', 'image', 'video']} > <Group mt="xs"> <Checkbox value="chat" label="Text" /> <Checkbox value="image" label="Images" /> <Checkbox value="video" label="Videos" /> <Checkbox value="document" label="Documents" /> </Group> </Checkbox.Group> </Stack> </Card> ) const FeatureMockupPrivacy = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack align="center"> <ThemeIcon size={60} radius="xl" variant="light" color="teal"> <Icon icon="tabler:shield-lock" fontSize={32} /> </ThemeIcon> <Title order={4} mt="md"> 100% Private & Secure </Title> <Text c="dimmed" size="sm" ta="center"> Your data is processed locally and never leaves your computer. </Text> <List mt="lg" spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item> <b>100% Local Processing:</b> Your conversations are never uploaded. </List.Item> <List.Item> <b>No Cloud Sync:</b> We have no access to your files or chats. </List.Item> <List.Item> <b>You Are in Control:</b> Save your backups on your own device. </List.Item> </List> </Stack> </Card> ) const FeatureMockupSimpleInterface = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={4}>Start Your Backup in Seconds</Title> <Text c="dimmed" size="sm"> Our intuitive interface makes saving your chats effortless. </Text> <Select mt="md" label="1. Select Chat" placeholder="Click to choose a conversation" data={[{ value: 'jane', label: 'Jane Doe' }]} defaultValue="jane" disabled leftSection={ <Avatar src="https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-5.png" size="sm" /> } /> <Select label="2. Choose Date Range" placeholder="Select a date range" data={[{ value: 'all', label: 'All Time' }]} defaultValue="all" disabled /> <Radio.Group label="3. Select Format" defaultValue="pdf"> <Group mt="xs"> <Radio value="pdf" label="PDF" /> <Radio value="xlsx" label="Excel" /> <Radio value="html" label="HTML (.zip)" /> </Group> </Radio.Group> <Button mt="lg" size="md" leftSection={<Icon icon="tabler:download" />}> Start Backup </Button> </Stack> </Card> ) // --- New Reusable Marquee Tile for Feature Details --- interface MarqueeTileFeatureDetailProps { icon: string title: string description: string featureComponent: React.ReactNode } const MarqueeTileFeatureDetail: React.FC<MarqueeTileFeatureDetailProps> = ({ icon, title, description, featureComponent, }) => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ // English: Applying the consistent dark theme gradient. background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center" gutter={50}> <Grid.Col span={5}> <Stack> <ThemeIcon size={60} radius="lg"> <Icon icon={icon} fontSize={40} /> </ThemeIcon> {/* English: [MODIFIED] Font size adjusted and color changed for dark background. */} <Title order={1} fz={44} lh={1.2} c="white"> {title} </Title> <Text size="xl" fw={500} c="gray.1" mt="md"> {description} </Text> </Stack> </Grid.Col> <Grid.Col span={7}> <Center h="100%">{featureComponent}</Center> </Grid.Col> </Grid> </Stack> </Paper> ) const ScreenshotGallery: React.FC = () => { // English: Data for generating promotional assets. const screenshotData = [ { title: 'Small Promo Tile: Option 1 (Grid Layout)', filename: 'small_promo_tile_grid.png', component: <SmallTileFeaturesGrid />, }, { title: 'Small Promo Tile: Option 2 (List Layout)', filename: 'small_promo_tile_list.png', component: <SmallTileFeaturesList />, }, { title: 'Small Promo Tile: Option 3 (Icons Layout)', filename: 'small_promo_tile_icons.png', component: <SmallTileFeaturesIcons />, }, { title: 'Marquee Promo Tile: Feature Showcase (1280x800)', filename: 'marquee_promo_tile_features.png', component: <MarqueeTileFeatureShowcase />, }, { title: 'Feature Screenshot: Multiple Export Formats (1280x800)', filename: 'feature_export_formats.png', component: ( <MarqueeTileFeatureDetail icon="tabler:files" title="Multiple Export Formats" description="Convert your chats into professional PDF, CSV, Excel, JSON, and TXT files for any purpose." featureComponent={<FeatureMockupExportFormats />} /> ), }, { title: 'Feature Screenshot: Advanced Filtering (1280x800)', filename: 'feature_advanced_filtering.png', component: ( <MarqueeTileFeatureDetail icon="tabler:filter" title="Advanced Filtering" description="Easily find what you need. Filter your exports by custom date ranges or multiple keywords to pinpoint specific messages." featureComponent={<FeatureMockupAdvancedFiltering />} /> ), }, { title: 'Feature Screenshot: Media Backups (1280x800)', filename: 'feature_media_backups.png', component: ( <MarqueeTileFeatureDetail icon="tabler:photo-video" title="Save Your Media" description="Donâ€™t just save text. The Pro version allows you to back up and include all media types in your exports." featureComponent={<FeatureMockupMediaBackup />} /> ), }, { title: 'Feature Screenshot: Privacy First (1280x800)', filename: 'feature_privacy_secure.png', component: ( <MarqueeTileFeatureDetail icon="tabler:shield-lock" title="Your Privacy is Our Priority" description="This extension operates 100% locally on your computer. Your messages and media are never uploaded to any server, ensuring complete privacy." featureComponent={<FeatureMockupPrivacy />} /> ), }, { title: 'Feature Screenshot: Simple Interface (1280x800)', filename: 'feature_simple_interface.png', component: ( <MarqueeTileFeatureDetail icon="tabler:mouse" title="Easy-to-Use Interface" description="A clean and straightforward design allows you to back up your important chats in just a few clicks. No complicated steps." featureComponent={<FeatureMockupSimpleInterface />} /> ), }, ] return ( <Stack> <Text c="dimmed" mb="md"> Generate and download high-resolution promotional assets for the Chrome Web Store. </Text> <Stack gap="xl"> {screenshotData.map((item) => ( <ScreenshotWrapper key={item.title} title={item.title} filename={item.filename} > {item.component} </ScreenshotWrapper> ))} </Stack> </Stack> ) } // --- End of Embedded Screenshot Components --- const ResourcePage = () => { const icon1Ref = useRef<HTMLDivElement>(null) const icon2Ref = useRef<HTMLDivElement>(null) const icon3Ref = useRef<HTMLDivElement>(null) // English: Defines the data for the three icon options to be mapped in the UI. const icons = [ { component: <PromoIcon size={128} icon="tabler:camera" />, ref: icon1Ref, name: 'Icon-Option-1.png', }, { component: <PromoIcon size={128} icon="tabler:file-export" />, ref: icon2Ref, name: 'Icon-Option-2.png', }, { component: <PromoIcon size={128} icon="tabler:download" />, ref: icon3Ref, name: 'Icon-Option-3.png', }, ] const storeListingText = { titles: [ 'Backup & Export for WhatsApp', 'WhatsApp Chat Exporter & Saver', 'Secure WhatsApp Chat Backup', ], shortDescriptions: [ 'Securely back up and export your WhatsApp chats to PDF, Excel, CSV, and more formats right from your computer.', 'One-click tool to save your WhatsApp chat history. Export conversations and media to PDF, Excel, or CSV locally & privately.', 'Never lose your chat history. Archive any WhatsApp conversation with media into multiple file formats. 100% secure & private.', ], longDescription: `ðŸ›¡ï¸ Secure Your WhatsApp Conversations Forever Never lose important conversations or precious memories again. Backup & Export for WhatsApp is the ultimate tool for archiving your WhatsApp chats securely and easily. With a single click, convert your chat history into professional, organized files like PDF, Excel, and CSV, all processed 100% locally on your computer for maximum privacy. âœ¨ Key Features ðŸ’¾ Unlimited Backups: Archive entire conversations with no message limits. ðŸ–¼ï¸ Include Media: Save photos, videos, voice notes, and documents. ðŸ“„ Multiple Export Formats: Export to PDF, Excel (XLSX), CSV, JSON, HTML, and TXT. ðŸ” Advanced Filtering: Pinpoint messages with custom date ranges and keyword searches. ðŸ” 100% Secure: Your data never leaves your computer. ðŸ’¬ Priority Support: Get faster, dedicated support when you need it. ðŸ’Ž Lifetime Access: A one-time purchase gets you all features and future updates forever. No subscriptions! ðŸ”’ Your Privacy is Our Priority We believe you should have complete control over your data. This extension operates entirely within your browser. âœ… Your messages and media are never uploaded to any server. âœ… The entire backup process happens on your own machine. âœ… Your conversations remain private and secure, always. ðŸ¤” Who Is This For? ðŸ’¼ Professionals: Archive client communications for record-keeping or legal compliance. â¤ï¸ Individuals: Save precious conversations with family and friends forever. ðŸ”¬ Researchers: Export chat data into structured formats like CSV or JSON for analysis. ðŸ™‹â€â™€ï¸ Anyone who values their data: Protect yourself from accidental data loss from a lost or broken phone. ðŸš€ Get peace of mind knowing your WhatsApp history is safe, secure, and accessible in any format you need.`, } const keywords = [ 'WhatsApp backup', 'export chat', 'PDF converter', 'save WhatsApp', 'WhatsApp archive', 'Excel export', 'download whatsapp chat', 'whatsapp to pdf', 'whatsapp to excel', 'chat history', ] const keywordsString = keywords.join(', ') const handleDownloadIcon = async ( ref: React.RefObject<HTMLDivElement>, filename: string, ) => { if (!ref.current) return const canvas = await html2canvas(ref.current, { backgroundColor: null, // Transparent background }) canvas.toBlob((blob) => { if (blob) FileSaver.saveAs(blob, filename) }) } return ( <MantineProvider theme={theme}> <Container size="lg" py="xl"> <Stack gap="xl"> <Title order={1} ta="center"> Chrome Web Store - Promotional Resources </Title> <Text c="dimmed" ta="center"> Use these assets and text to create your store listing page. </Text> <Tabs defaultValue="screenshots"> <Tabs.List grow> <Tabs.Tab value="text" leftSection={<Icon icon="tabler:file-text" />} > Store Listing Text </Tabs.Tab> <Tabs.Tab value="icons" leftSection={<Icon icon="tabler:photo" />} > Promotional Icons </Tabs.Tab> <Tabs.Tab value="screenshots" leftSection={<Icon icon="tabler:camera" />} > Screenshots & Tiles </Tabs.Tab> <Tabs.Tab value="keywords" leftSection={<Icon icon="tabler:tags" />} > Keywords (SEO) </Tabs.Tab> </Tabs.List> <Tabs.Panel value="text" pt="lg"> <Stack gap="xl"> <Stack> <Title order={3}>Titles</Title> {storeListingText.titles.map((title, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={title.length > 30 ? 'red' : 'dimmed'} > {title.length} / 30 chars </Text> </Group> <Group mt="sm" justify="space-between"> <Code>{title}</Code> <CopyButton value={title}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Stack> <Title order={3}>Short Descriptions</Title> {storeListingText.shortDescriptions.map((desc, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={desc.length > 132 ? 'red' : 'dimmed'} > {desc.length} / 132 chars </Text> </Group> <Textarea mt="sm" readOnly value={desc} autosize maxRows={4} /> <Group justify="flex-end" mt="sm"> <CopyButton value={desc}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Card withBorder radius="md"> <Title order={3}>Detailed Description</Title> <Textarea mt="sm" readOnly value={storeListingText.longDescription} autosize minRows={15} /> <Group justify="flex-end" mt="sm"> <CopyButton value={storeListingText.longDescription}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> </Card> </Stack> </Tabs.Panel> <Tabs.Panel value="icons" pt="lg"> <Grid> {icons.map(({ component, ref, name }, index) => ( <Grid.Col span={{ base: 12, sm: 4 }} key={index}> <Card withBorder radius="md" p="xl" style={{ height: '100%' }} > <Stack align="center" justify="space-between" style={{ height: '100%' }} > <div ref={ref}>{component}</div> <Stack align="center" gap="md"> <Text fw={500}>Option {index + 1} (128x128 px)</Text> <Button mt="md" variant="light" onClick={() => handleDownloadIcon(ref, name)} > Download </Button> </Stack> </Stack> </Card> </Grid.Col> ))} </Grid> </Tabs.Panel> <Tabs.Panel value="screenshots" pt="lg"> <ScreenshotGallery /> </Tabs.Panel> <Tabs.Panel value="keywords" pt="lg"> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={3}>Keywords for Store Listing</Title> <CopyButton value={keywordsString}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} leftSection={<Icon icon="tabler:copy" />} > {copied ? 'Copied All' : 'Copy All'} </Button> )} </CopyButton> </Group> <Text c="dimmed" size="sm" mt="xs"> Use these keywords in your store listing's metadata to improve search visibility. </Text> <Paper withBorder p="md" mt="md" radius="sm"> <Group gap="xs"> {keywords.map((keyword) => ( <Badge key={keyword} variant="light" color="gray" size="lg" > {keyword} </Badge> ))} </Group> </Paper> </Card> </Tabs.Panel> </Tabs> </Stack> </Container> </MantineProvider> ) } export default ResourcePage
```

# src/types/globals.d.ts

```ts
import type * as wajs from '@wppconnect/wa-js' declare global { interface Window { WPP: typeof wajs } const WPP: typeof wajs }
```

# src/types/index.d.ts

```ts
import type { Status } from '@/constants' export interface Response<T> { status: keyof typeof Status | string data?: T | null error?: string | null } interface LicenseInstance { createt_at: Date id: string name: string } interface LicenseKey { activation_limit: number activation_usage: number create_at: Date expires_at: Date id: number status: string test_mode: boolean } interface LicenseMeta { customer_email: string customer_id: number customer_name: string order_id: number order_item_id: number product_id: number store_id: number variant_id: number variant_name: string } export interface License { activated?: boolean | null valid?: boolean | null instance?: LicenseInstance | null license_key: LicenseKey meta: LicenseMeta }
```

# src/utils/country.ts

```ts
const countries = { AD: { label: 'ðŸ‡¦ðŸ‡© Andorra', phone: '376' }, AE: { label: 'ðŸ‡¦ðŸ‡ª United Arab Emirates', phone: '971' }, AF: { label: 'ðŸ‡¦ðŸ‡« Afghanistan', phone: '93' }, AG: { label: 'ðŸ‡¦ðŸ‡¬ Antigua and Barbuda', phone: '1-268' }, AI: { label: 'ðŸ‡¦ðŸ‡® Anguilla', phone: '1-264' }, AL: { label: 'ðŸ‡¦ðŸ‡± Albania', phone: '355' }, AM: { label: 'ðŸ‡¦ðŸ‡² Armenia', phone: '374' }, AO: { label: 'ðŸ‡¦ðŸ‡´ Angola', phone: '244' }, AQ: { label: 'ðŸ‡¦ðŸ‡¶ Antarctica', phone: '672' }, AR: { label: 'ðŸ‡¦ðŸ‡· Argentina', phone: '54' }, AS: { label: 'ðŸ‡¦ðŸ‡¸ American Samoa', phone: '1-684' }, AT: { label: 'ðŸ‡¦ðŸ‡¹ Austria', phone: '43' }, AU: { label: 'ðŸ‡¦ðŸ‡º Australia', phone: '61' }, AW: { label: 'ðŸ‡¦ðŸ‡¼ Aruba', phone: '297' }, AX: { label: 'ðŸ‡¦ðŸ‡½ Alland Islands', phone: '358' }, AZ: { label: 'ðŸ‡¦ðŸ‡¿ Azerbaijan', phone: '994' }, BA: { label: 'ðŸ‡§ðŸ‡¦ Bosnia and Herzegovina', phone: '387' }, BB: { label: 'ðŸ‡§ðŸ‡§ Barbados', phone: '1-246' }, BD: { label: 'ðŸ‡§ðŸ‡© Bangladesh', phone: '880' }, BE: { label: 'ðŸ‡§ðŸ‡ª Belgium', phone: '32' }, BF: { label: 'ðŸ‡§ðŸ‡« Burkina Faso', phone: '226' }, BG: { label: 'ðŸ‡§ðŸ‡¬ Bulgaria', phone: '359' }, BH: { label: 'ðŸ‡§ðŸ‡­ Bahrain', phone: '973' }, BI: { label: 'ðŸ‡§ðŸ‡® Burundi', phone: '257' }, BJ: { label: 'ðŸ‡§ðŸ‡¯ Benin', phone: '229' }, BL: { label: 'ðŸ‡§ðŸ‡± Saint Barthelemy', phone: '590' }, BM: { label: 'ðŸ‡§ðŸ‡² Bermuda', phone: '1-441' }, BN: { label: 'ðŸ‡§ðŸ‡³ Brunei Darussalam', phone: '673' }, BO: { label: 'ðŸ‡§ðŸ‡´ Bolivia', phone: '591' }, BR: { label: 'ðŸ‡§ðŸ‡· Brazil', phone: '55' }, BS: { label: 'ðŸ‡§ðŸ‡¸ Bahamas', phone: '1-242' }, BT: { label: 'ðŸ‡§ðŸ‡¹ Bhutan', phone: '975' }, BV: { label: 'ðŸ‡§ðŸ‡» Bouvet Island', phone: '47' }, BW: { label: 'ðŸ‡§ðŸ‡¼ Botswana', phone: '267' }, BY: { label: 'ðŸ‡§ðŸ‡¾ Belarus', phone: '375' }, BZ: { label: 'ðŸ‡§ðŸ‡¿ Belize', phone: '501' }, CA: { label: 'ðŸ‡¨ðŸ‡¦ Canada', phone: '1' }, CC: { label: 'ðŸ‡¨ðŸ‡¨ Cocos (Keeling) Islands', phone: '61' }, CD: { label: 'ðŸ‡¨ðŸ‡© Congo, Democratic Republic of the', phone: '243' }, CF: { label: 'ðŸ‡¨ðŸ‡« Central African Republic', phone: '236' }, CG: { label: 'ðŸ‡¨ðŸ‡¬ Congo, Republic of the', phone: '242' }, CH: { label: 'ðŸ‡¨ðŸ‡­ Switzerland', phone: '41' }, CI: { label: "ðŸ‡¨ðŸ‡® Cote d'Ivoire", phone: '225' }, CK: { label: 'ðŸ‡¨ðŸ‡° Cook Islands', phone: '682' }, CL: { label: 'ðŸ‡¨ðŸ‡± Chile', phone: '56' }, CM: { label: 'ðŸ‡¨ðŸ‡² Cameroon', phone: '237' }, CN: { label: 'ðŸ‡¨ðŸ‡³ China', phone: '86' }, CO: { label: 'ðŸ‡¨ðŸ‡´ Colombia', phone: '57' }, CR: { label: 'ðŸ‡¨ðŸ‡· Costa Rica', phone: '506' }, CU: { label: 'ðŸ‡¨ðŸ‡º Cuba', phone: '53' }, CV: { label: 'ðŸ‡¨ðŸ‡» Cape Verde', phone: '238' }, CW: { label: 'ðŸ‡¨ðŸ‡¼ Curacao', phone: '599' }, CX: { label: 'ðŸ‡¨ðŸ‡½ Christmas Island', phone: '61' }, CY: { label: 'ðŸ‡¨ðŸ‡¾ Cyprus', phone: '357' }, CZ: { label: 'ðŸ‡¨ðŸ‡¿ Czech Republic', phone: '420' }, DE: { label: 'ðŸ‡©ðŸ‡ª Germany', phone: '49' }, DJ: { label: 'ðŸ‡©ðŸ‡¯ Djibouti', phone: '253' }, DK: { label: 'ðŸ‡©ðŸ‡° Denmark', phone: '45' }, DM: { label: 'ðŸ‡©ðŸ‡² Dominica', phone: '1-767' }, DO: { label: 'ðŸ‡©ðŸ‡´ Dominican Republic', phone: '1-809' }, DZ: { label: 'ðŸ‡©ðŸ‡¿ Algeria', phone: '213' }, EC: { label: 'ðŸ‡ªðŸ‡¨ Ecuador', phone: '593' }, EE: { label: 'ðŸ‡ªðŸ‡ª Estonia', phone: '372' }, EG: { label: 'ðŸ‡ªðŸ‡¬ Egypt', phone: '20' }, EH: { label: 'ðŸ‡ªðŸ‡­ Western Sahara', phone: '212' }, ER: { label: 'ðŸ‡ªðŸ‡· Eritrea', phone: '291' }, ES: { label: 'ðŸ‡ªðŸ‡¸ Spain', phone: '34' }, ET: { label: 'ðŸ‡ªðŸ‡¹ Ethiopia', phone: '251' }, FI: { label: 'ðŸ‡«ðŸ‡® Finland', phone: '358' }, FJ: { label: 'ðŸ‡«ðŸ‡¯ Fiji', phone: '679' }, FK: { label: 'ðŸ‡«ðŸ‡° Falkland Islands (Malvinas)', phone: '500' }, FM: { label: 'ðŸ‡«ðŸ‡² Micronesia, Federated States of', phone: '691' }, FO: { label: 'ðŸ‡«ðŸ‡´ Faroe Islands', phone: '298' }, FR: { label: 'ðŸ‡«ðŸ‡· France', phone: '33' }, GA: { label: 'ðŸ‡¬ðŸ‡¦ Gabon', phone: '241' }, GB: { label: 'ðŸ‡¬ðŸ‡§ United Kingdom', phone: '44' }, GD: { label: 'ðŸ‡¬ðŸ‡© Grenada', phone: '1-473' }, GE: { label: 'ðŸ‡¬ðŸ‡ª Georgia', phone: '995' }, GF: { label: 'ðŸ‡¬ðŸ‡« French Guiana', phone: '594' }, GG: { label: 'ðŸ‡¬ðŸ‡¬ Guernsey', phone: '44' }, GH: { label: 'ðŸ‡¬ðŸ‡­ Ghana', phone: '233' }, GI: { label: 'ðŸ‡¬ðŸ‡® Gibraltar', phone: '350' }, GL: { label: 'ðŸ‡¬ðŸ‡± Greenland', phone: '299' }, GM: { label: 'ðŸ‡¬ðŸ‡² Gambia', phone: '220' }, GN: { label: 'ðŸ‡¬ðŸ‡³ Guinea', phone: '224' }, GP: { label: 'ðŸ‡¬ðŸ‡µ Guadeloupe', phone: '590' }, GQ: { label: 'ðŸ‡¬ðŸ‡¶ Equatorial Guinea', phone: '240' }, GR: { label: 'ðŸ‡¬ðŸ‡· Greece', phone: '30' }, GS: { label: 'ðŸ‡¬ðŸ‡¸ South Georgia and the South Sandwich Islands', phone: '500', }, GT: { label: 'ðŸ‡¬ðŸ‡¹ Guatemala', phone: '502' }, GU: { label: 'ðŸ‡¬ðŸ‡º Guam', phone: '1-671' }, GW: { label: 'ðŸ‡¬ðŸ‡¼ Guinea-Bissau', phone: '245' }, GY: { label: 'ðŸ‡¬ðŸ‡¾ Guyana', phone: '592' }, HK: { label: 'ðŸ‡­ðŸ‡° Hong Kong', phone: '852' }, HM: { label: 'ðŸ‡­ðŸ‡² Heard Island and McDonald Islands', phone: '672' }, HN: { label: 'ðŸ‡­ðŸ‡³ Honduras', phone: '504' }, HR: { label: 'ðŸ‡­ðŸ‡· Croatia', phone: '385' }, HT: { label: 'ðŸ‡­ðŸ‡¹ Haiti', phone: '509' }, HU: { label: 'ðŸ‡­ðŸ‡º Hungary', phone: '36' }, ID: { label: 'ðŸ‡®ðŸ‡© Indonesia', phone: '62' }, IE: { label: 'ðŸ‡®ðŸ‡ª Ireland', phone: '353' }, IL: { label: 'ðŸ‡®ðŸ‡± Israel', phone: '972' }, IM: { label: 'ðŸ‡®ðŸ‡² Isle of Man', phone: '44' }, IN: { label: 'ðŸ‡®ðŸ‡³ India', phone: '91' }, IO: { label: 'ðŸ‡®ðŸ‡´ British Indian Ocean Territory', phone: '246' }, IQ: { label: 'ðŸ‡®ðŸ‡¶ Iraq', phone: '964' }, IR: { label: 'ðŸ‡®ðŸ‡· Iran, Islamic Republic of', phone: '98' }, IS: { label: 'ðŸ‡®ðŸ‡¸ Iceland', phone: '354' }, IT: { label: 'ðŸ‡®ðŸ‡¹ Italy', phone: '39' }, JE: { label: 'ðŸ‡¯ðŸ‡ª Jersey', phone: '44' }, JM: { label: 'ðŸ‡¯ðŸ‡² Jamaica', phone: '1-876' }, JO: { label: 'ðŸ‡¯ðŸ‡´ Jordan', phone: '962' }, JP: { label: 'ðŸ‡¯ðŸ‡µ Japan', phone: '81' }, KE: { label: 'ðŸ‡°ðŸ‡ª Kenya', phone: '254' }, KG: { label: 'ðŸ‡°ðŸ‡¬ Kyrgyzstan', phone: '996' }, KH: { label: 'ðŸ‡°ðŸ‡­ Cambodia', phone: '855' }, KI: { label: 'ðŸ‡°ðŸ‡® Kiribati', phone: '686' }, KM: { label: 'ðŸ‡°ðŸ‡² Comoros', phone: '269' }, KN: { label: 'ðŸ‡°ðŸ‡³ Saint Kitts and Nevis', phone: '1-869' }, KP: { label: "ðŸ‡°ðŸ‡µ Korea, Democratic People's Republic of", phone: '850' }, KR: { label: 'ðŸ‡°ðŸ‡· Korea, Republic of', phone: '82' }, KW: { label: 'ðŸ‡°ðŸ‡¼ Kuwait', phone: '965' }, KY: { label: 'ðŸ‡°ðŸ‡¾ Cayman Islands', phone: '1-345' }, KZ: { label: 'ðŸ‡°ðŸ‡¿ Kazakhstan', phone: '7' }, LA: { label: "ðŸ‡±ðŸ‡¦ Lao People's Democratic Republic", phone: '856' }, LB: { label: 'ðŸ‡±ðŸ‡§ Lebanon', phone: '961' }, LC: { label: 'ðŸ‡±ðŸ‡¨ Saint Lucia', phone: '1-758' }, LI: { label: 'ðŸ‡±ðŸ‡® Liechtenstein', phone: '423' }, LK: { label: 'ðŸ‡±ðŸ‡° Sri Lanka', phone: '94' }, LR: { label: 'ðŸ‡±ðŸ‡· Liberia', phone: '231' }, LS: { label: 'ðŸ‡±ðŸ‡¸ Lesotho', phone: '266' }, LT: { label: 'ðŸ‡±ðŸ‡¹ Lithuania', phone: '370' }, LU: { label: 'ðŸ‡±ðŸ‡º Luxembourg', phone: '352' }, LV: { label: 'ðŸ‡±ðŸ‡» Latvia', phone: '371' }, LY: { label: 'ðŸ‡±ðŸ‡¾ Libya', phone: '218' }, MA: { label: 'ðŸ‡²ðŸ‡¦ Morocco', phone: '212' }, MC: { label: 'ðŸ‡²ðŸ‡¨ Monaco', phone: '377' }, MD: { label: 'ðŸ‡²ðŸ‡© Moldova, Republic of', phone: '373' }, ME: { label: 'ðŸ‡²ðŸ‡ª Montenegro', phone: '382' }, MF: { label: 'ðŸ‡²ðŸ‡« Saint Martin (French part)', phone: '590' }, MG: { label: 'ðŸ‡²ðŸ‡¬ Madagascar', phone: '261' }, MH: { label: 'ðŸ‡²ðŸ‡­ Marshall Islands', phone: '692' }, MK: { label: 'ðŸ‡²ðŸ‡° Macedonia, the Former Yugoslav Republic of', phone: '389' }, ML: { label: 'ðŸ‡²ðŸ‡± Mali', phone: '223' }, MM: { label: 'ðŸ‡²ðŸ‡² Myanmar', phone: '95' }, MN: { label: 'ðŸ‡²ðŸ‡³ Mongolia', phone: '976' }, MO: { label: 'ðŸ‡²ðŸ‡´ Macao', phone: '853' }, MP: { label: 'ðŸ‡²ðŸ‡µ Northern Mariana Islands', phone: '1-670' }, MQ: { label: 'ðŸ‡²ðŸ‡¶ Martinique', phone: '596' }, MR: { label: 'ðŸ‡²ðŸ‡· Mauritania', phone: '222' }, MS: { label: 'ðŸ‡²ðŸ‡¸ Montserrat', phone: '1-664' }, MT: { label: 'ðŸ‡²ðŸ‡¹ Malta', phone: '356' }, MU: { label: 'ðŸ‡²ðŸ‡º Mauritius', phone: '230' }, MV: { label: 'ðŸ‡²ðŸ‡» Maldives', phone: '960' }, MW: { label: 'ðŸ‡²ðŸ‡¼ Malawi', phone: '265' }, MX: { label: 'ðŸ‡²ðŸ‡½ Mexico', phone: '52' }, MY: { label: 'ðŸ‡²ðŸ‡¾ Malaysia', phone: '60' }, MZ: { label: 'ðŸ‡²ðŸ‡¿ Mozambique', phone: '258' }, NA: { label: 'ðŸ‡³ðŸ‡¦ Namibia', phone: '264' }, NC: { label: 'ðŸ‡³ðŸ‡¨ New Caledonia', phone: '687' }, NE: { label: 'ðŸ‡³ðŸ‡ª Niger', phone: '227' }, NF: { label: 'ðŸ‡³ðŸ‡« Norfolk Island', phone: '672' }, NG: { label: 'ðŸ‡³ðŸ‡¬ Nigeria', phone: '234' }, NI: { label: 'ðŸ‡³ðŸ‡® Nicaragua', phone: '505' }, NL: { label: 'ðŸ‡³ðŸ‡± Netherlands', phone: '31' }, NO: { label: 'ðŸ‡³ðŸ‡´ Norway', phone: '47' }, NP: { label: 'ðŸ‡³ðŸ‡µ Nepal', phone: '977' }, NR: { label: 'ðŸ‡³ðŸ‡· Nauru', phone: '674' }, NU: { label: 'ðŸ‡³ðŸ‡º Niue', phone: '683' }, NZ: { label: 'ðŸ‡³ðŸ‡¿ New Zealand', phone: '64' }, OM: { label: 'ðŸ‡´ðŸ‡² Oman', phone: '968' }, PA: { label: 'ðŸ‡µðŸ‡¦ Panama', phone: '507' }, PE: { label: 'ðŸ‡µðŸ‡ª Peru', phone: '51' }, PF: { label: 'ðŸ‡µðŸ‡« French Polynesia', phone: '689' }, PG: { label: 'ðŸ‡µðŸ‡¬ Papua New Guinea', phone: '675' }, PH: { label: 'ðŸ‡µðŸ‡­ Philippines', phone: '63' }, PK: { label: 'ðŸ‡µðŸ‡° Pakistan', phone: '92' }, PL: { label: 'ðŸ‡µðŸ‡± Poland', phone: '48' }, PM: { label: 'ðŸ‡µðŸ‡² Saint Pierre and Miquelon', phone: '508' }, PN: { label: 'ðŸ‡µðŸ‡³ Pitcairn', phone: '870' }, PR: { label: 'ðŸ‡µðŸ‡· Puerto Rico', phone: '1' }, PS: { label: 'ðŸ‡µðŸ‡¸ Palestine, State of', phone: '970' }, PT: { label: 'ðŸ‡µðŸ‡¹ Portugal', phone: '351' }, PW: { label: 'ðŸ‡µðŸ‡¼ Palau', phone: '680' }, PY: { label: 'ðŸ‡µðŸ‡¾ Paraguay', phone: '595' }, QA: { label: 'ðŸ‡¶ðŸ‡¦ Qatar', phone: '974' }, RE: { label: 'ðŸ‡·ðŸ‡ª Reunion', phone: '262' }, RO: { label: 'ðŸ‡·ðŸ‡´ Romania', phone: '40' }, RS: { label: 'ðŸ‡·ðŸ‡¸ Serbia', phone: '381' }, RU: { label: 'ðŸ‡·ðŸ‡º Russian Federation', phone: '7' }, RW: { label: 'ðŸ‡·ðŸ‡¼ Rwanda', phone: '250' }, SA: { label: 'ðŸ‡¸ðŸ‡¦ Saudi Arabia', phone: '966' }, SB: { label: 'ðŸ‡¸ðŸ‡§ Solomon Islands', phone: '677' }, SC: { label: 'ðŸ‡¸ðŸ‡¨ Seychelles', phone: '248' }, SD: { label: 'ðŸ‡¸ðŸ‡© Sudan', phone: '249' }, SE: { label: 'ðŸ‡¸ðŸ‡ª Sweden', phone: '46' }, SG: { label: 'ðŸ‡¸ðŸ‡¬ Singapore', phone: '65' }, SH: { label: 'ðŸ‡¸ðŸ‡­ Saint Helena', phone: '290' }, SI: { label: 'ðŸ‡¸ðŸ‡® Slovenia', phone: '386' }, SJ: { label: 'ðŸ‡¸ðŸ‡¯ Svalbard and Jan Mayen', phone: '47' }, SK: { label: 'ðŸ‡¸ðŸ‡° Slovakia', phone: '421' }, SL: { label: 'ðŸ‡¸ðŸ‡± Sierra Leone', phone: '232' }, SM: { label: 'ðŸ‡¸ðŸ‡² San Marino', phone: '378' }, SN: { label: 'ðŸ‡¸ðŸ‡³ Senegal', phone: '221' }, SO: { label: 'ðŸ‡¸ðŸ‡´ Somalia', phone: '252' }, SR: { label: 'ðŸ‡¸ðŸ‡· Suriname', phone: '597' }, SS: { label: 'ðŸ‡¸ðŸ‡¸ South Sudan', phone: '211' }, ST: { label: 'ðŸ‡¸ðŸ‡¹ Sao Tome and Principe', phone: '239' }, SV: { label: 'ðŸ‡¸ðŸ‡» El Salvador', phone: '503' }, SX: { label: 'ðŸ‡¸ðŸ‡½ Sint Maarten (Dutch part)', phone: '1-721' }, SY: { label: 'ðŸ‡¸ðŸ‡¾ Syrian Arab Republic', phone: '963' }, SZ: { label: 'ðŸ‡¸ðŸ‡¿ Swaziland', phone: '268' }, TC: { label: 'ðŸ‡¹ðŸ‡¨ Turks and Caicos Islands', phone: '1-649' }, TD: { label: 'ðŸ‡¹ðŸ‡© Chad', phone: '235' }, TF: { label: 'ðŸ‡¹ðŸ‡« French Southern Territories', phone: '262' }, TG: { label: 'ðŸ‡¹ðŸ‡¬ Togo', phone: '228' }, TH: { label: 'ðŸ‡¹ðŸ‡­ Thailand', phone: '66' }, TJ: { label: 'ðŸ‡¹ðŸ‡¯ Tajikistan', phone: '992' }, TK: { label: 'ðŸ‡¹ðŸ‡° Tokelau', phone: '690' }, TL: { label: 'ðŸ‡¹ðŸ‡± Timor-Leste', phone: '670' }, TM: { label: 'ðŸ‡¹ðŸ‡² Turkmenistan', phone: '993' }, TN: { label: 'ðŸ‡¹ðŸ‡³ Tunisia', phone: '216' }, TO: { label: 'ðŸ‡¹ðŸ‡´ Tonga', phone: '676' }, TR: { label: 'ðŸ‡¹ðŸ‡· Turkey', phone: '90' }, TT: { label: 'ðŸ‡¹ðŸ‡¹ Trinidad and Tobago', phone: '1-868' }, TV: { label: 'ðŸ‡¹ðŸ‡» Tuvalu', phone: '688' }, TW: { label: 'ðŸ‡¹ðŸ‡¼ Taiwan, Province of China', phone: '886' }, TZ: { label: 'ðŸ‡¹ðŸ‡¿ United Republic of Tanzania', phone: '255' }, UA: { label: 'ðŸ‡ºðŸ‡¦ Ukraine', phone: '380' }, UG: { label: 'ðŸ‡ºðŸ‡¬ Uganda', phone: '256' }, US: { label: 'ðŸ‡ºðŸ‡¸ United States', phone: '1' }, UY: { label: 'ðŸ‡ºðŸ‡¾ Uruguay', phone: '598' }, UZ: { label: 'ðŸ‡ºðŸ‡¿ Uzbekistan', phone: '998' }, VA: { label: 'ðŸ‡»ðŸ‡¦ Holy See (Vatican City State)', phone: '379' }, VC: { label: 'ðŸ‡»ðŸ‡¨ Saint Vincent and the Grenadines', phone: '1-784' }, VE: { label: 'ðŸ‡»ðŸ‡ª Venezuela', phone: '58' }, VG: { label: 'ðŸ‡»ðŸ‡¬ British Virgin Islands', phone: '1-284' }, VI: { label: 'ðŸ‡»ðŸ‡® US Virgin Islands', phone: '1-340' }, VN: { label: 'ðŸ‡»ðŸ‡³ Vietnam', phone: '84' }, VU: { label: 'ðŸ‡»ðŸ‡º Vanuatu', phone: '678' }, WF: { label: 'ðŸ‡¼ðŸ‡« Wallis and Futuna', phone: '681' }, WS: { label: 'ðŸ‡¼ðŸ‡¸ Samoa', phone: '685' }, XK: { label: 'ðŸ‡½ðŸ‡° Kosovo', phone: '383' }, YE: { label: 'ðŸ‡¾ðŸ‡ª Yemen', phone: '967' }, YT: { label: 'ðŸ‡¾ðŸ‡¹ Mayotte', phone: '262' }, ZA: { label: 'ðŸ‡¿ðŸ‡¦ South Africa', phone: '27' }, ZM: { label: 'ðŸ‡¿ðŸ‡² Zambia', phone: '260' }, ZW: { label: 'ðŸ‡¿ðŸ‡¼ Zimbabwe', phone: '263' }, } const getCountryByCode = (code: string) => { return countries[code] ?? { label: '-', phone: '-' } } export default { getCountryByCode, countries, }
```

# src/utils/env.ts

```ts
const isProduction = () => { return process.env.NODE_ENV === 'production' } const isDevelopment = () => { return process.env.NODE_ENV === 'development' } export const isStaging = () => { return process.env.PLASMO_PUBLIC_STAGING === 'true' } export default { isProduction, isDevelopment, isStaging, }
```

# src/utils/ext.ts

```ts
import type { Tabs } from 'webextension-polyfill' import browser from 'webextension-polyfill' export async function getCurrentTab(): Promise<Tabs.Tab> { const queryOptions = { active: true, currentWindow: true } const [tab] = await browser.tabs.query(queryOptions) return tab } export async function getTabs(): Promise<Tabs.Tab[]> { return new Promise(async (resolve, reject) => { try { const tabs = await browser.tabs.query({ currentWindow: true }) const filteredTabs = tabs.filter( (tab) => !tab.url?.startsWith('chrome://'), ) return resolve(filteredTabs) } catch (error) { reject(error) } }) } export async function getTabByUrl(url: string): Promise<Tabs.Tab | null> { const queryOptions = { url: url } const tabs = await browser.tabs.query(queryOptions) return tabs.length > 0 ? tabs[0] : null } export const openWa = async () => { await browser.tabs.create({ url: 'https://web.whatsapp.com' }) } export const isWaTabActive = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return result?.active } export const isWaTabAvailable = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return !!result }
```

# src/utils/filterBy.ts

```ts
import { AccountType, ContactType, MessageType } from '@/constants' import type { ContactModel } from '@wppconnect/wa-js/dist/whatsapp' const dontIncludeLid = (contact: ContactModel) => contact.id.server !== 'lid' const dontIncludeMe = (contact: any, number: any) => contact.phoneNumber !== number const accountType = (contact: any, type: string) => { switch (type) { case AccountType.ALL: return true case AccountType.PERSONAL: return contact.isBusiness === false case AccountType.BUSINESS: return contact.isBusiness === true default: return true } } const contactType = (contact: any, type: string): boolean => { switch (type) { case ContactType.ALL: return true case ContactType.SAVED_CONTACTS: return contact.isMyContact === true case ContactType.UNSAVED_CONTACTS: return contact.isMyContact === false default: return true } } const includeAdmin = (data: any, isIncludeAdmin: boolean) => { if (isIncludeAdmin) { if (data.isAdmin) { return true } } else { if (data.isAdmin) return false } return true } const onlyMyContact = (data: any, onlyMyContact: boolean) => { if (onlyMyContact) { return data.isMyContact === true } else { return data.isMyContact !== true } } const messageType = (contact: any, type: string): boolean => { switch (type) { case MessageType.ALL: return true case MessageType.HAVE_UNREAD_MESSAGES: return contact.hasUnread === true case MessageType.NO_UNREAD_MESSAGES: return contact.hasUnread === false default: return true } } const country = (contact: any, country: string) => { const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) return countryCode === country } export default { dontIncludeLid, dontIncludeMe, accountType, includeAdmin, onlyMyContact, contactType, messageType, country, }
```

# src/utils/page.ts

```ts
import { Action } from '@/constants' import { postMessage } from './util' const goTo = (page: string) => { postMessage(Action.Window.GO_TO_PAGE, page) } export default { goTo, }
```

# src/utils/response.ts

```ts
import { Status } from '@/constants' import type { Response } from '@/types' const success = <T = any>(data?: T | null): Response<T | undefined | null> => { return { status: Status.SUCCESS, data: data, } } const error = (error: string | undefined | null): Response<null> => { return { status: Status.FAILED, error: error, } } export const response = { success, error, }
```

# src/utils/serialize.ts

```ts
import type { ChatModel, ContactModel, GroupMetadataModel, MediaDataModel, MsgModel, ParticipantModel, } from '@wppconnect/wa-js/dist/whatsapp' import _ from 'lodash' import country from './country' const button = (buttons: any[]) => { return buttons .map(({ type, label, value }) => { switch (type) { case 'text': return { text: value } case 'url': return { text: label, url: value } case 'phoneNumber': return { text: label, phoneNumber: value } default: break } }) .filter((button) => !!button) } const list = (rows: any[]) => { return rows.filter((row) => row.title !== '') } const contact = (contact: ContactModel) => { if (!contact) return {} const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) const hasUnread = WPP.chat.get(contact.id._serialized)?.hasUnread ?? false const selectedCountry = country.getCountryByCode(countryCode) return { id: contact.id._serialized, avatar: contact.getProfilePicThumb().__x_eurl, country: selectedCountry.label, name: contact.name, pushname: contact.pushname, shortname: contact.shortName, notifyName: contact.notifyName, formattedName: contact.formattedName, formattedPhone: contact.formattedPhone, formattedShortName: contact.formattedShortName, formattedShortNameWithNonBreakingSpaces: contact.formattedShortNameWithNonBreakingSpaces, formattedUser: contact.formattedUser, isBusiness: contact.isBusiness, isContactBlocked: contact.isContactBlocked, //@ts-ignore isFavorite: contact.isFavorite, isGroup: contact.isGroup, isMe: contact.isMe, isMyContact: contact.isMyContact, isUser: contact.isUser, isWaContact: contact.isWAContact, labels: contact.labels, hasUnread, } } const mediaData = (data?: MediaDataModel) => { if (!data) return {} return { mimeType: data?.mimetype, size: data?.size, base64: data?.preview?.base64, height: data?.fullHeight, width: data?.fullWidth, } } const message = (msgModel: MsgModel) => { return { id: msgModel.id._serialized, ack: msgModel.ack, body: msgModel.body, from: msgModel.from, isViewOnce: msgModel.isViewOnce, timestamp: msgModel.t * 1000, to: msgModel.to, type: msgModel.type, mimetype: msgModel.mimetype, size: msgModel.size, filename: msgModel.filename, caption: msgModel.caption, duration: msgModel.duration, height: msgModel.height, width: msgModel.width, quotedMessage: msgModel.quotedMsg, contact: contact(msgModel.senderObj), } } const groupMetadata = (data: GroupMetadataModel) => { return { id: data?.id?._serialized, description: data?.desc, size: data?.size, subject: data?.subject, creation: data?.creation * 1000, participants: data?.participants?.getModelsArray().map(participant), } } const chat = (chat: ChatModel) => { return { id: chat.id._serialized, name: chat.name, messages: chat.msgs.getModelsArray().map(message), contact: contact(chat.contact), groupMetadata: groupMetadata(chat.groupMetadata), } } const participant = (participant: ParticipantModel) => { return { id: participant.id, isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, contact: contact(participant.contact), } } export default { button, list, contact, chat, participant, message, }
```

# src/utils/style.ts

```ts
import appMenuStyle from 'data-text:@/components/AppMenu.module.css' import layoutStyle from 'data-text:@/components/Layout/LayoutPage.module.css' import toastStyle from 'data-text:@/components/Toast/Toast.module.css' import globalsStyle from 'data-text:@/styles/globals.css' import coreStyle from 'data-text:@mantine/core/styles.css' import dateStyle from 'data-text:@mantine/dates/styles.css' import dropzoneStyle from 'data-text:@mantine/dropzone/styles.css' import tableStyle from 'data-text:mantine-datatable/styles.layer.css' const styles = [ coreStyle, dateStyle, dropzoneStyle, tableStyle, toastStyle, globalsStyle, layoutStyle, appMenuStyle, ] const generate = () => { return styles.join('') } export default { generate }
```

# src/utils/throwError.ts

```ts
const broadcastNotFound = () => { throw new Error('Broadcast not found') } const mediaNotFound = () => { throw new Error('Media not found') } const contactNotExist = () => { throw new Error('Contact not exist') } export default { broadcastNotFound, mediaNotFound, contactNotExist, }
```

# src/utils/toast.ts

```ts
import { useToastStore } from '@/stores/toast' const showSuccess = (message: string, title: string = 'Success') => { useToastStore.getState().addToast({ type: 'success', title, message }) } const showError = (message: string, title: string = 'Error') => { useToastStore.getState().addToast({ type: 'error', title, message }) } const showInfo = (message: string, title: string = 'Information') => { useToastStore.getState().addToast({ type: 'info', title, message }) } const showWarning = (message: string, title: string = 'Warning') => { useToastStore.getState().addToast({ type: 'warning', title, message }) } export default { success: showSuccess, error: showError, info: showInfo, // ADDED: Export the new 'warning' function. warning: showWarning, }
```

# src/utils/util.ts

```ts
// src/utils/util.ts import { Action, Message } from '@/constants' import type { UseFormReturnType } from '@mantine/form' import { sendToBackground } from '@plasmohq/messaging' import _ from 'lodash' export async function delay(timeoutMs = 1000) { await new Promise((resolve) => setTimeout(resolve, timeoutMs)) } export const generateRandomDelay = (min: number, max: number) => { // Calculate the range of multiples of 1000 const minThousand = Math.ceil(min / 1000) const maxThousand = Math.floor(max / 1000) // Generate a random integer in that range and multiply by 1000 const randomThousand = Math.floor(Math.random() * (maxThousand - minThousand + 1)) + minThousand return randomThousand * 1000 } export const truncate = (data: string, length: number = 30) => { return _.chain(data) .thru((str) => (str.length > length ? `${str.slice(0, length)}...` : str)) .value() } export const postMessage = (action: string, body: any = null) => { window.postMessage({ action, body }) } export const showModalUpgrade = () => { postMessage(Action.Window.SHOW_MODAL_UPGRADE) } export const showModalMain = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } export const showModalActivation = () => { postMessage(Action.Window.SHOW_MODAL_ACTIVATION) } export const showModalProfile = () => { postMessage(Action.Window.SHOW_MODAL_PROFILE) } export const showModalFaq = () => { postMessage(Action.Window.SHOW_MODAL_FAQ) } export const goToLandingPage = async () => { await sendToBackground({ name: 'landing-page', body: {}, }) } export const getStoreId = () => { return process.env.PLASMO_PUBLIC_STORE_ID } export const isTypeMessageMedia = (type: string) => { return [Message.MEDIA, Message.IMAGE, Message.VIDEO, Message.FILE].includes( type, ) } export const formHasErrors = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ): boolean => { let hasError = false if (form1.validate().hasErrors) { hasError = true } if (form2.validate().hasErrors) { hasError = true } return hasError } export const resetForms = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ) => { form1.reset() form2.reset() } /** * @description Generates a thumbnail from a video file. * @param {File} file The video file. * @returns {Promise<string>} A promise that resolves with a base64 data URL of the thumbnail. */ export const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve, reject) => { try { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.muted = true video.playsInline = true video.onloadeddata = () => { canvas.width = video.videoWidth canvas.height = video.videoHeight video.currentTime = 1 // Seek to 1 second to get a good frame video.onseeked = () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up memory resolve(thumbnailUrl) } else { reject(new Error('Could not get canvas context.')) } } } video.onerror = () => { URL.revokeObjectURL(video.src) reject(new Error('Failed to load video file for thumbnail.')) } video.src = URL.createObjectURL(file) } catch (error) { reject(error) } }) } export const getContactName = (contact: any) => { return ( contact.name || contact.pushname || contact.notifyName || contact.formattedName || '-' ) }
```

# tsconfig.json

```json
{ "extends": "plasmo/templates/tsconfig.base", "exclude": ["node_modules"], "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"], "compilerOptions": { "paths": { "@/*": ["src/*"] }, "baseUrl": "." } }
```

