# assets/icon.png

This is a binary file of the type: Image

# package.json

```json
{ "name": "starter-wa", "displayName": "Starter wa", "version": "0.0.1", "description": "A basic Plasmo extension.", "author": "Plasmo Corp. <foss@plasmo.com>", "scripts": { "dev": "plasmo dev --no-cs-reload", "build": "plasmo build", "package": "plasmo package" }, "dependencies": { "@haverstack/axios-fetch-adapter": "^0.12.0", "@lemonsqueezy/lemonsqueezy.js": "^4.0.0", "@mantine/core": "^8.2.2", "@mantine/dates": "^8.2.2", "@mantine/dropzone": "^8.2.2", "@mantine/form": "^8.2.2", "@mantine/hooks": "^8.2.2", "@plasmohq/messaging": "0.7.1", "@plasmohq/storage": "^1.15.0", "@tabler/icons-react": "^3.34.1", "@wppconnect/wa-js": "^3.18.0", "axios": "^1.11.0", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dayjs": "^1.11.13", "dexie": "^4.0.11", "dexie-react-hooks": "^1.1.7", "emoji-picker-react": "^4.13.2", "file-saver": "^2.0.5", "html2canvas": "^1.4.1", "jquery": "^3.7.1", "jspdf": "^3.0.1", "jszip": "^3.10.1", "lodash": "^4.17.21", "mantine-datatable": "^8.2.0", "plasmo": "0.90.5", "react": "18.2.0", "react-dom": "18.2.0", "react-if": "^4.1.6", "webextension-polyfill": "^0.12.0", "xlsx": "^0.18.5", "zustand": "^5.0.7" }, "devDependencies": { "@ianvs/prettier-plugin-sort-imports": "4.1.1", "@iconify/react": "^6.0.0", "@types/chrome": "0.0.258", "@types/file-saver": "^2.0.7", "@types/jquery": "^3.5.32", "@types/lodash": "^4.17.20", "@types/node": "20.11.5", "@types/react": "18.2.48", "@types/react-dom": "18.2.18", "@types/webextension-polyfill": "^0.12.3", "postcss": "^8.5.6", "postcss-preset-mantine": "1.17.0", "postcss-simple-vars": "^7.0.1", "prettier": "3.2.4", "typescript": "5.3.3" }, "manifest": { "host_permissions": [ "https://web.whatsapp.com/*", "https://api.lemonsqueezy.com/*" ], "permissions": [] } }
```

# postcss.config.cjs

```cjs
module.exports = { plugins: { 'postcss-preset-mantine': {}, 'postcss-simple-vars': { variables: { 'mantine-breakpoint-xs': '36em', 'mantine-breakpoint-sm': '48em', 'mantine-breakpoint-md': '62em', 'mantine-breakpoint-lg': '75em', 'mantine-breakpoint-xl': '88em', }, }, }, }
```

# README.md

```md
This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo). ## Getting Started First, run the development server: \`\`\`bash pnpm dev # or npm run dev \`\`\` Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`. You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser. For further guidance, [visit our Documentation](https://docs.plasmo.com/) ## Making production build Run the following: \`\`\`bash pnpm build # or npm run build \`\`\` This should create a production bundle for your extension, ready to be zipped and published to the stores. ## Submit to the webstores The easiest way to deploy your Plasmo extension is to use the built-in [bpp](https://bpp.browser.market) GitHub action. Prior to using this action however, make sure to build your extension and upload the first version to the store to establish the basic credentials. Then, simply follow [this setup instruction](https://docs.plasmo.com/framework/workflows/submit) and you should be on your way for automated submission!
```

# src/background/index.ts

```ts
import { Action, Setting } from '@/constants' import { storage } from '@/libs/storage' import { getTabByUrl, openWa } from '@/utils/ext' import { sendToContentScript } from '@plasmohq/messaging' import browser from 'webextension-polyfill' browser.runtime.onInstalled.addListener(async (details) => { if (details.reason === 'install') { await storage.set(Setting.LICENSE_KEY, null) await storage.set(Setting.IS_FIRST_TIME, true) await storage.set(Setting.NEED_TO_OPEN, true) await storage.set(Setting.BLUR_PROFILE_PICTURES, false) await storage.set(Setting.BLUR_MESSAGES, false) await storage.set(Setting.BLUR_USER_GROUP_NAMES, false) await storage.set(Setting.BLUR_RECENT_MESSAGES, false) await openWa() } }) browser.action.onClicked.addListener(async () => { const waTab = await getTabByUrl('https://web.whatsapp.com/') if (waTab?.active) { sendToContentScript({ name: Action.Window.SHOW_MODAL_MAIN, }) return } await storage.set(Setting.NEED_TO_OPEN, true) await openWa() })
```

# src/background/messages/http.ts

```ts
import http from '@/libs/http' import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { url, method, data, config } = req.body const httpInstance = { POST: () => { return http.post(url, data, config) }, GET: () => { return http.get(url, config) }, } const result = await httpInstance[method]?.() return res.send(result.data) } export default handler
```

# src/background/messages/lemonsqueezy.ts

```ts
import lemonSqueezy from '@/libs/ls' import type { PlasmoMessaging } from '@plasmohq/messaging' import pkg from '../../../package.json' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body try { let response switch (action) { case 'validateLicense': response = await lemonSqueezy.validateLicense(body.licenseKey) break case 'activateLicense': response = await lemonSqueezy.activateLicense(body.licenseKey, pkg.name) break case 'deactivateLicense': response = await lemonSqueezy.deactivateLicense( body.licenseKey, body.instanceId, ) break case 'getCustomer': response = await lemonSqueezy.getCustomer(body.customerId) break default: return res.send({ error: 'Invalid Lemon Squeezy action' }) } res.send(response) } catch (error) { // Tangani error yang mungkin dilempar oleh SDK Lemon Squeezy res.send({ error: true, message: error.message || 'An unknown error occurred.', }) } } export default handler
```

# src/components/App.module.css

```css
.tab { &:hover, &[data-active] { background-color: var(--mantine-primary-color-filled-hover); } }
```

# src/components/App.tsx

```tsx
import { Action, Page, Setting } from '@/constants' import BroadcastListener from '@/features/broadcast/components/Listeners/BroadcastListener' import PageBroadcast from '@/features/broadcast/PageBroadcast' import PageFaq from '@/features/faq/PageFaq' import PageHome from '@/features/home/PageHome' import PageLabel from '@/features/label/PageLabel' import PageProfile from '@/features/profile/PageProfile' import PageQuickReply from '@/features/quick-reply/PageQuickReply' import PageChatBackup from '@/features/tools/backup-chat/PageChatBackup' import PageDirectChat from '@/features/tools/direct-chat/PageDirectChat' import PageGroupLinkGenerator from '@/features/tools/group-link-generator/PageGroupLinkGenerator' import PageNumberValidator from '@/features/tools/number-validator/PageNumberValidator' import PageTools from '@/features/tools/PageTools' import PagePrivacy from '@/features/tools/privacy/components/PagePrivacy' import PrivacyListener from '@/features/tools/privacy/components/PrivacyListener' import PageWaMeGenerator from '@/features/tools/wa-me/PageWaMeGenerator' import useLicense from '@/hooks/useLicense' import useRuntimeMessage from '@/hooks/useRuntimeMessage' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Box, Stack, Tabs, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' import classes from './App.module.css' import Modal from './Modal/Modal' import ModalActivation from './Modal/ModalActivation' import ModalUpgrade from './Modal/ModalUpgrade' const App: React.FC = () => { const wa = useWa() const { setIsReady, setGroups, setProfile, setActiveChat } = useAppStore() const license = useLicense() const [showModalMain, modalMain] = useDisclosure(true) const [showModalUpgrade, modalUpgrade] = useDisclosure(false) const [showModalActivation, modalActivation] = useDisclosure(false) const [needToOpen, setNeedToOpen] = useStorage(Setting.NEED_TO_OPEN, false) const [activeTab, setActiveTab] = useState<string | null>(Page.HOME) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.ACTIVE_CHAT: setActiveChat(body) break case Action.Window.GO_TO_PAGE: setActiveTab(body) break case Action.Window.SHOW_MODAL_UPGRADE: modalUpgrade.toggle() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break } }) useRuntimeMessage((message, sender, sendResponse) => { switch (message.name) { case Action.Window.SHOW_MODAL_MAIN: modalMain.toggle() sendResponse() break default: break } // Return true to keep the message channel open for async responses return true }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { if (needToOpen) { modalMain.open() setNeedToOpen(false).then().catch(console.error) } }, [needToOpen]) useEffect(() => { ;(async function () { if (!wa.isReady) return setTimeout(async () => { await getGroups() }, 2000) })() }, [wa.isReady]) const getGroups = async () => { const response = await wa.chat.list({ onlyGroups: true }) setGroups(response) } const handleChangeTab = (value: string | null) => { if (Page.UPGRADE === value) { modalUpgrade.toggle() return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } setActiveTab(value) } const renderTabList = () => { return ( <Tabs.List style={{ gap: 10, background: 'var(--mantine-primary-color-filled)', }} > <Stack justify="space-between" gap={0} style={{ height: '100%' }}> <Box> <Tabs.Tab value={Page.HOME} className={classes.tab}> <Tooltip label="Home" position="left"> <Icon icon="tabler:home" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.BROADCAST} className={classes.tab}> <Tooltip label="Broadcast" position="left"> <Icon icon="tabler:broadcast" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.LABEL} className={classes.tab}> <Tooltip label="Labels" position="left"> <Icon icon="tabler:tags" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.QUICK_REPLY} className={classes.tab}> <Tooltip label="Quick Reply" position="left"> <Icon icon="tabler:arrow-back-up-double" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.TOOLS} className={classes.tab}> <Tooltip label="Tools"> <Icon icon="tabler:tools" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> <Box> <Tabs.Tab value={Page.FAQ} className={classes.tab}> <Tooltip label="Faqs"> <Icon icon="tabler:world-question" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.UPGRADE} className={classes.tab}> <Tooltip label="Upgrade"> <Icon icon="tabler:crown" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab}> <Tooltip label="Activate"> <Icon icon="tabler:key" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PROFILE} className={classes.tab}> <Tooltip label="Profile"> <Icon icon="tabler:user-square-rounded" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> </Stack> </Tabs.List> ) } const renderTabPanel = () => { return ( <> <Tabs.Panel value={Page.HOME}> <PageHome /> </Tabs.Panel> <Tabs.Panel value={Page.BROADCAST}> <PageBroadcast /> </Tabs.Panel> <Tabs.Panel value={Page.LABEL}> <PageLabel /> </Tabs.Panel> <Tabs.Panel value={Page.QUICK_REPLY}> <PageQuickReply /> </Tabs.Panel> <Tabs.Panel value={Page.TOOLS}> <PageTools /> </Tabs.Panel> <Tabs.Panel value={Page.FAQ}> <PageFaq /> </Tabs.Panel> <Tabs.Panel value={Page.PROFILE}> <PageProfile /> </Tabs.Panel> <Tabs.Panel value={Page.DIRECT_CHAT}> <PageDirectChat /> </Tabs.Panel> <Tabs.Panel value={Page.NUMBER_VALIDATOR}> <PageNumberValidator /> </Tabs.Panel> <Tabs.Panel value={Page.PRIVACY}> <PagePrivacy /> </Tabs.Panel> <Tabs.Panel value={Page.WA_ME_GENERATOR}> <PageWaMeGenerator /> </Tabs.Panel> <Tabs.Panel value={Page.GROUP_LINK_GENERATOR}> <PageGroupLinkGenerator /> </Tabs.Panel> <Tabs.Panel value={Page.CHAT_BACKUP}> <PageChatBackup /> </Tabs.Panel> </> ) } return ( <> <Modal opened={showModalMain} onClose={modalMain.close} p={0}> <Tabs value={activeTab} onChange={handleChangeTab} variant="pills" orientation="vertical" radius={0} keepMounted={false} > {renderTabList()} {renderTabPanel()} </Tabs> </Modal> <ModalUpgrade opened={showModalUpgrade} onClose={modalUpgrade.close} /> <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <BroadcastListener /> <PrivacyListener /> </> ) } export default App
```

# src/components/Input/Excel/ExcelUploader.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Button, FileInput, Group, ScrollArea, Stack, Table, Text, } from '@mantine/core' import FileSaver from 'file-saver' import React, { useState } from 'react' import * as XLSX from 'xlsx' interface Props { onConfirm: (data: any[]) => void onClose: () => void } /** * @component ExcelUploader * @description A generic component for uploading, parsing, previewing, and confirming Excel data. * It encapsulates the core logic previously duplicated in ModalSourceExcel and ExcelUploadPopover. */ const ExcelUploader: React.FC<Props> = ({ onConfirm, onClose }) => { const [parsedData, setParsedData] = useState<any[]>([]) const [excelFile, setExcelFile] = useState<File | null>(null) const handleDownloadSample = () => { const sampleData = [{ number: '6281234567890', name: 'John Doe' }] const worksheet = XLSX.utils.json_to_sheet(sampleData) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Contacts') const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array', }) const data = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8', }) FileSaver.saveAs(data, 'sample_contacts.xlsx') } const handleFileChange = (file: File | null) => { if (!file) { setParsedData([]) setExcelFile(null) return } setExcelFile(file) const reader = new FileReader() reader.onload = (event) => { const data = new Uint8Array(event.target?.result as ArrayBuffer) const workbook = XLSX.read(data, { type: 'array' }) const sheetName = workbook.SheetNames[0] const worksheet = workbook.Sheets[sheetName] const json = XLSX.utils.sheet_to_json(worksheet) setParsedData(json) } reader.readAsArrayBuffer(file) } // Removes a specific row from the preview data const handleDeleteRow = (indexToRemove: number) => { setParsedData((currentData) => currentData.filter((_, index) => index !== indexToRemove), ) } // Confirms the upload, passes the data to the parent, and calls the parent's close handler const handleConfirmUpload = () => { onConfirm(parsedData) onClose() } // Resets state and calls the parent's close handler const handleClose = () => { setParsedData([]) setExcelFile(null) onClose() } return ( <> <Text size="xs" c="dimmed" mt={-10}> File must contain a 'number' column. </Text> <Group justify="center"> <Button variant="light" size="xs" onClick={handleDownloadSample} leftSection={<Icon icon="tabler:download" />} > Download Sample </Button> </Group> <FileInput placeholder="Choose file" onChange={handleFileChange} accept=".xlsx, .xls, .csv" clearable value={excelFile} /> {parsedData.length > 0 && ( <> <Text size="sm">Data Preview:</Text> <ScrollArea h={150}> <Table striped highlightOnHover withTableBorder withColumnBorders fz="xs" > <Table.Thead> <Table.Tr> <Table.Th>Number</Table.Th> <Table.Th>Name</Table.Th> <Table.Th></Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {parsedData.map((row, index) => ( <Table.Tr key={index}> <Table.Td>{row.number}</Table.Td> <Table.Td>{row.name}</Table.Td> <Table.Td> <ActionIcon color="red" variant="transparent" onClick={() => handleDeleteRow(index)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </ScrollArea> </> )} <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleConfirmUpload} disabled={parsedData.length === 0} > Add {parsedData.length} Numbers </Button> </Group> </> ) } export default ExcelUploader
```

# src/components/Input/Excel/ExcelUploadPopover.tsx

```tsx
import { Icon } from '@iconify/react' import { Button, Popover, Stack, Text, Tooltip } from '@mantine/core' import React, { useState } from 'react' import ExcelUploader from './ExcelUploader' interface Props { onConfirm: (data: any[]) => void } /** * @component ExcelUploadPopover * @description A popover component for Excel uploads, now refactored to use the generic ExcelUploader. * It acts as a lightweight wrapper, placing the uploader logic inside a Mantine Popover. */ const ExcelUploadPopover: React.FC<Props> = ({ onConfirm }) => { const [popoverOpened, setPopoverOpened] = useState(false) return ( <Popover opened={popoverOpened} onChange={setPopoverOpened} withArrow shadow="md" position="bottom-end" > <Popover.Target> <Tooltip label="Upload excel" position="top"> <Button size={'compact-sm'} variant="outline" onClick={() => setPopoverOpened((o) => !o)} > <Icon icon={'tabler:file-type-xls'} fontSize={24} /> </Button> </Tooltip> </Popover.Target> <Popover.Dropdown w={350}> <Stack> <Text size="sm" fw={500}> Upload Excel File </Text> <ExcelUploader onConfirm={onConfirm} onClose={() => setPopoverOpened(false)} /> </Stack> </Popover.Dropdown> </Popover> ) } export default ExcelUploadPopover
```

# src/components/Input/InputContact.tsx

```tsx
import { Group, TagsInput, Text, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import ExcelUploadPopover from './Excel/ExcelUploadPopover' interface Props { form: UseFormReturnType<any> } const InputContact: React.FC<Props> = ({ form }) => { const handleAddNumbers = (newNumbers: (string | number)[]) => { const currentValues = form.values.numbers const uniqueNumbers = [ ...new Set([...currentValues, ...newNumbers.map(String)]), ] form.setFieldValue('numbers', uniqueNumbers) } const handleConfirmExcelUpload = (parsedData: any[]) => { const newNumbers = parsedData .map((item) => item.number?.toString()) .filter(Boolean) if (newNumbers.length > 0) { handleAddNumbers(newNumbers) } } return ( <> <TagsInput label={ <Group justify="space-between" w={687}> <Text fw={500}> Numbers{' '} {form.values.numbers.length ? `(${form.values.numbers.length})` : ''} </Text> <Group mb={6}> <ExcelUploadPopover onConfirm={handleConfirmExcelUpload} /> </Group> </Group> } placeholder="Number with country code, Press Enter to submit" {...form.getInputProps('numbers')} clearable /> </> ) } export default InputContact
```

# src/components/Input/InputSendLater.tsx

```tsx
import useLicense from '@/hooks/useLicense' import { Badge, Group, Switch, Text } from '@mantine/core' import { DateTimePicker } from '@mantine/dates' import type { UseFormReturnType } from '@mantine/form' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputSendLater: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <> <Switch label={ <Group gap="xs"> <Text fw={500}>Send later</Text> <When condition={license.isFree()}> <Badge size="sm" variant="light" color="teal"> PRO </Badge> </When> </Group> } {...form.getInputProps('scheduler.enabled', { type: 'checkbox' })} /> <When condition={form.values.scheduler.enabled}> <DateTimePicker label="Date time" size="md" minDate={dayjs().add(2, 'minutes').toDate()} clearable {...form.getInputProps('scheduler.scheduledAt')} /> </When> </> ) } export default InputSendLater
```

# src/components/Input/InputTextarea.tsx

```tsx
import { Status } from '@/constants' import useAi from '@/hooks/useAi' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Box, Button, Group, LoadingOverlay, Menu, Popover, Stack, Text, Textarea, Tooltip, } from '@mantine/core' import EmojiPicker from 'emoji-picker-react' import React, { useRef, useState } from 'react' interface Props { value: string onChange: (value: string) => void error?: any placeholder?: string | null variables?: { label: string; variable: string }[] } const InputTextarea: React.FC<Props> = ({ value, onChange, error = null, placeholder = 'Enter your message here', variables = [], }) => { const textareaRef = useRef<HTMLTextAreaElement>(null) const [emojiPickerOpened, setEmojiPickerOpened] = useState<boolean>(false) const ai = useAi() const [isRewriting, setIsRewriting] = useState(false) const applyFormat = (startTag: string, endTag: string = '') => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const selectedText = value.substring(start, end) const newText = value.substring(0, start) + startTag + (selectedText || '') + endTag + value.substring(end) onChange(newText) setTimeout(() => { if (textarea) { const newPosition = start + startTag.length + (selectedText.length || 0) textarea.focus() textarea.setSelectionRange(newPosition, newPosition) } }, 0) } const insertSpintaxExample = () => { applyFormat('{option1|option2}') } const handleEmojiSelect = (emojiData: any) => { applyFormat(emojiData.emoji) setEmojiPickerOpened(false) } const insertVariable = (variable: string) => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const newText = value.substring(0, start) + variable + value.substring(end) onChange(newText) setTimeout(() => { if (textarea) { const newPosition = start + variable.length textarea.focus() textarea.setSelectionRange(newPosition, newPosition) } }, 0) } const handleAiRewrite = async (rewriteType: string) => { if (!value) { toast.error('Please enter a message to rewrite.') return } const prompts: Record<string, string> = { professional: 'Rewrite the following message to be more professional', friendly: 'Rewrite the following message to be more friendly and casual', fix_grammar: 'Correct any spelling and grammar mistakes in the following message', } const prompt = prompts[rewriteType] if (!prompt) return setIsRewriting(true) try { const result = await ai.rewriteMessage(prompt, value) if (result.status === Status.SUCCESS && result.data) { onChange(result.data) } else { toast.error(result.error || 'Failed to rewrite message.') } } catch (error: any) { toast.error(error.message || 'An error occurred.') } finally { setIsRewriting(false) } } const renderEmojiToolbar = () => { return ( <Popover opened={emojiPickerOpened} onChange={setEmojiPickerOpened} position="right-end" > <Popover.Target> <Tooltip label="Emoji" position="top"> <ActionIcon onClick={() => setEmojiPickerOpened((o) => !o)} variant="subtle" > <Icon icon="tabler:mood-smile" width={16} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown p={0}> <EmojiPicker width={350} height={370} onEmojiClick={handleEmojiSelect} searchDisabled skinTonesDisabled previewConfig={{ showPreview: false }} /> </Popover.Dropdown> </Popover> ) } return ( <Stack gap={3}> <Group justify="space-between"> <Group gap={6}> <Tooltip label="Italic" position="top"> <ActionIcon onClick={() => applyFormat('_', '_')} variant="subtle"> <Icon icon="tabler:italic" fontSize={18} /> </ActionIcon> </Tooltip> <Tooltip label="Bold" position="top"> <ActionIcon onClick={() => applyFormat('*', '*')} variant="subtle"> <Icon icon="tabler:bold" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Strikethrough" position="top"> <ActionIcon onClick={() => applyFormat('~', '~')} variant="subtle"> <Icon icon="tabler:strikethrough" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Monospace" position="top"> <ActionIcon onClick={() => applyFormat('\`\`\`', '\`\`\`')} variant="subtle" > <Icon icon="tabler:code" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Use Spintax for message variations. Example: {Hello|Hi}" position="top" multiline w={220} > <ActionIcon onClick={insertSpintaxExample} variant="subtle"> <Icon icon="tabler:arrows-shuffle" fontSize={18} /> </ActionIcon> </Tooltip> {/* This Popover provides users with in-context help on how to use advanced formatting features. */} <Popover width={350} position="top-start" withArrow shadow="md"> <Popover.Target> <Tooltip label="Personalization Help" position="top"> <ActionIcon variant="subtle"> <Icon icon="tabler:help-circle" fontSize={18} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown> <Stack gap="sm"> {/* Section explaining Spintax */} <Box> <Text fw={500} size="sm"> {' '} Message Variations (Spintax){' '} </Text> <Text c="dimmed" size="xs"> {' '} Create random text variations to make your messages unique. Wrap your options in curly braces `{}` and separate them with a pipe `|`.{' '} </Text> <Text size="xs" mt={4}> {' '} <b>Example:</b>{' '} <code> {' '} {'{Hi|Hello}'}, have a {'{great|wonderful}'} day!{' '} </code>{' '} </Text> </Box> {/* Section explaining Personalization variables */} <Box> <Text fw={500} size="sm"> {' '} Personalization{' '} </Text> <Text c="dimmed" size="xs"> {' '} Use variables to automatically insert contact-specific details into your message.{' '} </Text> <Text size="xs" mt={4}> {' '} - <code>{'{name}'}</code>: Inserts the contact's saved name.{' '} </Text> <Text size="xs"> {' '} - <code>{'{number}'}</code>: Inserts the contact's phone number.{' '} </Text> </Box> </Stack> </Popover.Dropdown> </Popover> {/* <Menu shadow="md" width={220} position="top-start" withArrow> <Menu.Target> <Tooltip label="Rewrite with AI" position="top"> <ActionIcon variant="subtle" loading={isRewriting}> <Icon icon="tabler:sparkles" fontSize={18} /> </ActionIcon> </Tooltip> </Menu.Target> <Menu.Dropdown> <Menu.Label>AI Actions</Menu.Label> <Menu.Item leftSection={<Icon icon="tabler:briefcase" />} onClick={() => handleAiRewrite('professional')} > {' '} Make More Professional{' '} </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:mood-smile-beam" />} onClick={() => handleAiRewrite('friendly')} > {' '} Make More Friendly{' '} </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:language" />} onClick={() => handleAiRewrite('fix_grammar')} > {' '} Fix Spelling & Grammar{' '} </Menu.Item> </Menu.Dropdown> </Menu> */} {renderEmojiToolbar()} </Group> </Group> <Box style={{ position: 'relative' }}> <LoadingOverlay visible={isRewriting} zIndex={1000} overlayProps={{ radius: 'sm', blur: 1 }} /> <Stack gap={8}> <Textarea ref={textareaRef} value={value} onChange={(event) => onChange(event.currentTarget.value)} placeholder={ placeholder || 'Write a message... Try variations with Spintax: {Hi|Hello}' } minRows={6} autosize styles={{ input: { ...(error ? { borderColor: 'red', borderWidth: '1px' } : {}), transition: 'border-color 0.3s ease', }, }} /> {variables.length > 0 && ( <Group mb={4}> {variables.map((variable, index) => ( <Button key={index} variant="outline" size="compact-xs" onClick={() => insertVariable(variable.variable)} > {variable.label} </Button> ))} </Group> )} </Stack> </Box> {error && ( <Text c="red" size="sm"> {' '} {error}{' '} </Text> )} </Stack> ) } export default InputTextarea
```

# src/components/Input/InputTyping.tsx

```tsx
import useLicense from '@/hooks/useLicense' import { Badge, Group, Switch, Text, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputTyping: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <Tooltip label='Show "Typing..." status on the recipient to mimic messaging process' refProp="rootRef" position="top-start" > <Switch label={ <Group gap="xs"> <Text fw={500}>Typing effect</Text> <When condition={license.isFree()}> <Badge size="sm" variant="light" color="teal"> PRO </Badge> </When> </Group> } {...form.getInputProps('isTyping', { type: 'checkbox' })} /> </Tooltip> ) } export default InputTyping
```

# src/components/Input/Message/FormFile.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> } const FormFile: React.FC<Props> = ({ form }: Props) => { return ( <> <Upload type="file" value={form.values.inputFile.file} onDrop={(file) => { form.setFieldValue('inputFile.file', file) }} /> <InputTextarea value={form.values.inputFile.caption} onChange={(data) => form.setFieldValue('inputFile.caption', data)} placeholder="Enter your caption here" /> </> ) } export default FormFile
```

# src/components/Input/Message/FormImage.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React, { useEffect, useState } from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> } const FormImage: React.FC<Props> = ({ form }: Props) => { const [preview, setPreview] = useState<string | null>(null) useEffect(() => { return () => { if (preview) { URL.revokeObjectURL(preview) } } }, [preview]) return ( <> <Upload type="image" value={form.values.inputImage.file} onDrop={(file) => { form.setFieldValue('inputImage.file', file) }} /> <InputTextarea value={form.values.inputImage.caption} onChange={(data) => form.setFieldValue('inputImage.caption', data)} placeholder="Enter your caption here" /> </> ) } export default FormImage
```

# src/components/Input/Message/FormLocation.tsx

```tsx
import { Group, TextInput } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' interface Props { form: UseFormReturnType<any> } const FormLocation: React.FC<Props> = ({ form }: Props) => { return ( <> <Group grow> <TextInput required label="Latitude" placeholder="-22.95201" {...form.getInputProps('inputLocation.lat')} /> <TextInput required label="Longitude" placeholder="-43.2102601" {...form.getInputProps('inputLocation.lng')} /> </Group> <TextInput label="Name" {...form.getInputProps('inputLocation.name')} /> <TextInput label="Address" {...form.getInputProps('inputLocation.address')} /> <TextInput label="Url" {...form.getInputProps('inputLocation.url')} /> </> ) } export default FormLocation
```

# src/components/Input/Message/FormPoll.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Button, Fieldset, Group, Stack, Text, TextInput, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const FormPoll: React.FC<Props> = ({ form }: Props) => { const handleInsert = () => { form.insertListItem('inputPoll.choices', '') } const handleRemove = (index: number) => { form.removeListItem('inputPoll.choices', index) } return ( <> <TextInput required label="Name" {...form.getInputProps('inputPoll.name')} /> <Fieldset legend={<Text fw={500}>Choices</Text>}> <Stack> {form.values.inputPoll.choices.map((button: any, index: number) => ( <Group key={index}> <TextInput style={{ flexGrow: 1, }} {...form.getInputProps(`inputPoll.choices.${index}`)} /> <When condition={index !== 0}> <ActionIcon color="red" onClick={() => handleRemove(index)}> <Icon icon={'tabler:trash'} fontSize={24} /> </ActionIcon> </When> </Group> ))} <Box> <Button size="xs" onClick={handleInsert}> Add </Button> </Box> </Stack> </Fieldset> </> ) } export default FormPoll
```

# src/components/Input/Message/FormText.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' interface Props { form: UseFormReturnType<any> } const FormText: React.FC<Props> = ({ form }: Props) => { return ( <InputTextarea value={form.values.inputText} onChange={(data) => form.setFieldValue('inputText', data)} error={form.errors.inputText} /> ) } export default FormText
```

# src/components/Input/Message/FormVCard.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Button, Card, Group, ScrollArea, Stack, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import React from 'react' import ModalSelectContacts from './ModalSelectContacts' interface Props { form: UseFormReturnType<any> } /** * @component FormVCard * @description Renders the UI for selecting one or more contacts to send as a VCard. */ const FormVCard: React.FC<Props> = ({ form }) => { const [showModal, modalHandlers] = useDisclosure(false) const selectedContacts = form.values.inputVCard.contacts // Handler to add contacts from the modal to the form state const handleSelectContacts = (newContacts: any[]) => { // Store the full contact objects; the sender function will extract the ID. form.setFieldValue('inputVCard.contacts', newContacts) modalHandlers.close() } // Handler to remove a contact from the list const handleRemoveContact = (contactId: string) => { form.setFieldValue( 'inputVCard.contacts', selectedContacts.filter((c: any) => c.id !== contactId), ) } return ( <> <Stack> <Group justify="space-between"> <Text fw={500}>Selected Contacts ({selectedContacts.length})</Text> <Button size="xs" variant="outline" leftSection={<Icon icon="tabler:address-book" fontSize={16} />} onClick={modalHandlers.open} > Select Contact(s) </Button> </Group> {/* Display selected contacts */} <ScrollArea h={150} style={{ border: '1px solid #dee2e6', borderRadius: '4px' }} > <Stack gap="xs" p="xs"> {selectedContacts.length > 0 ? ( selectedContacts.map((contact: any) => ( <Card withBorder p="xs" radius="sm" key={contact.id}> <Group justify="space-between"> <Text size="sm"> {/* -- MODIFIED: Updated to use the correct properties for displaying the contact's name or number. */} {contact.savedName || contact.publicName || contact.phoneNumber} </Text> <Tooltip label="Remove"> {/* -- MODIFIED: Pass `contact.id` to the remove handler. */} <ActionIcon color="red" variant="transparent" onClick={() => handleRemoveContact(contact.id)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Tooltip> </Group> </Card> )) ) : ( <Text c="dimmed" ta="center" pt="xl"> No contacts selected. </Text> )} </Stack> </ScrollArea> {form.errors['inputVCard.contacts'] && ( <Text c="red" size="xs"> {form.errors['inputVCard.contacts']} </Text> )} </Stack> <ModalSelectContacts opened={showModal} onClose={modalHandlers.close} onSubmit={handleSelectContacts} /> </> ) } export default FormVCard
```

# src/components/Input/Message/FormVideo.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> } const FormVideo: React.FC<Props> = ({ form }: Props) => { return ( <> <Upload type="video" value={form.values.inputVideo.file} onDrop={(file) => { form.setFieldValue('inputVideo.file', file) }} /> <InputTextarea value={form.values.inputVideo.caption} onChange={(data) => form.setFieldValue('inputVideo.caption', data)} placeholder="Enter your caption here" /> </> ) } export default FormVideo
```

# src/components/Input/Message/InputMessage.tsx

```tsx
import { Media, Message } from '@/constants' import ModalManageTemplate from '@/features/broadcast/components/Modal/ModalManageTemplate' import useLicense from '@/hooks/useLicense' import db, { type BroadcastTemplate } from '@/libs/db' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Popover, Select, SimpleGrid, Stack, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo } from 'react' import { When } from 'react-if' import FormDocument from './FormFile' import FormImage from './FormImage' import FormLocation from './FormLocation' import FormPoll from './FormPoll' import FormText from './FormText' import FormVCard from './FormVCard' // Import new VCard form import FormVideo from './FormVideo' import ProFeatureButton from './ProFeatureButton' interface Props { form: UseFormReturnType<any> disabledTemplateButton?: boolean } const InputMessage: React.FC<Props> = ({ form, disabledTemplateButton = false, }: Props) => { const license = useLicense() const templates = useLiveQuery( async () => await db.broadcastTemplates.toArray(), ) const [showModalManageTemplate, modalManageTemplate] = useDisclosure(false) const labelValueTemplates = useMemo(() => { return templates?.map((template: BroadcastTemplate, index) => ({ label: template.name, value: index.toString(), })) }, [templates]) const handleSelectTemplate = async (index: string) => { const { id, message, type } = templates![parseInt(index, 10)] const dataByMessageTypes: { [key: string]: () => any } = { [Message.TEXT]: () => ({ type, inputText: message }), [Message.IMAGE]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputImage: { file: broadcastFile?.file, ...(message as object) }, } }, [Message.VIDEO]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputVideo: { file: broadcastFile?.file, ...(message as object) }, } }, [Message.FILE]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputFile: { file: broadcastFile?.file, caption: message }, } }, [Message.LOCATION]: () => ({ type, inputLocation: { ...(message as object) }, }), [Message.POLL]: () => ({ type, inputPoll: { ...(message as object) } }), } const data = await dataByMessageTypes[type]?.() form.setValues(data) } const renderInputMessage = () => { switch (form.values.type) { case Message.TEXT: return <FormText form={form} /> case Message.IMAGE: return <FormImage form={form} /> case Message.VIDEO: return <FormVideo form={form} /> case Message.FILE: return <FormDocument form={form} /> case Message.LOCATION: return <FormLocation form={form} /> case Message.POLL: return <FormPoll form={form} /> case Message.VCARD: return <FormVCard form={form} /> default: return null } } const renderMenuMessage = () => { return ( <SimpleGrid cols={7}> <Tooltip label="Text" position="top"> <Button size="sm" variant={form.values.type === Message.TEXT ? 'filled' : 'default'} onClick={() => form.setFieldValue('type', Message.TEXT)} > <Icon icon={'tabler:text-size'} fontSize={24} /> </Button> </Tooltip> <ProFeatureButton form={form} label="Image" icon="tabler:photo" messageType={Message.IMAGE} /> <ProFeatureButton form={form} label="Video" icon="tabler:video" messageType={Message.VIDEO} /> <ProFeatureButton form={form} label="File" icon="tabler:file" messageType={Message.FILE} /> <ProFeatureButton form={form} label="Location" icon="tabler:map-pin" messageType={Message.LOCATION} /> <ProFeatureButton form={form} label="Poll" icon="tabler:list-details" messageType={Message.POLL} /> {/* ++ ADDED: The new button for sending a contact VCard */} <ProFeatureButton form={form} label="Contact (VCard)" icon="tabler:user-square" messageType={Message.VCARD} /> </SimpleGrid> ) } return ( <> <Stack> <Group justify="space-between"> <Text fw={500}>Message</Text> <When condition={!disabledTemplateButton}> <Popover width={300} position="top-end" withArrow shadow="md"> <Popover.Target> <Tooltip label="Get template" position="top"> <Button size={'compact-sm'} variant="outline"> <Icon icon={'tabler:template'} fontSize={26} /> </Button> </Tooltip> </Popover.Target> <Popover.Dropdown> <Stack> <Select label={ <Group justify="space-between" w={270}> <Text>Use a template</Text> <Tooltip label="Manage Templates"> <ActionIcon variant="transparent" onClick={modalManageTemplate.toggle} > <Icon icon={'tabler:settings'} fontSize={18} /> </ActionIcon> </Tooltip> </Group> } searchable placeholder="Select a template to use" data={labelValueTemplates} onChange={(value) => handleSelectTemplate(value!)} comboboxProps={{ withinPortal: false }} /> </Stack> </Popover.Dropdown> </Popover> </When> </Group> </Stack> {renderMenuMessage()} {renderInputMessage()} <ModalManageTemplate opened={showModalManageTemplate} onClose={modalManageTemplate.close} /> </> ) } export default InputMessage
```

# src/components/Input/Message/ModalSelectContacts.tsx

```tsx
import Modal from '@/components/Modal/Modal' import wa from '@/libs/wa' import { Icon } from '@iconify/react' import { Button, Group, Stack, TextInput, Title } from '@mantine/core' import { DataTable, type DataTableColumn } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (contacts: any[]) => void } /** * @component ModalSelectContacts * @description A modal for fetching, displaying, and selecting from a user's contact list. */ const ModalSelectContacts: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const [contacts, setContacts] = useState<any[]>([]) const [loading, setLoading] = useState(true) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<any[]>([]) useEffect(() => { if (opened) { const fetchContacts = async () => { setLoading(true) try { const contactList = await wa.contact.list({ onlyMyContacts: true }) setContacts(contactList) } catch (error) { console.error('Failed to fetch contacts:', error) } finally { setLoading(false) } } fetchContacts() } else { // Reset state when modal is closed setContacts([]) setSelectedRecords([]) setSearch('') } }, [opened]) const filteredContacts = useMemo(() => { if (!search) return contacts return contacts.filter( (c) => c.publicName?.toLowerCase().includes(search.toLowerCase()) || c.savedName?.toLowerCase().includes(search.toLowerCase()) || c.phoneNumber.includes(search), ) }, [contacts, search]) const handleSubmit = () => { onSubmit(selectedRecords) onClose() } const columns: DataTableColumn<any>[] = [ { accessor: 'name', title: 'Name', render: (record) => record.publicName || record.savedName || 'N/A', }, { accessor: 'number', title: 'Number', render: (record) => record.phoneNumber, }, ] return ( <Modal opened={opened} onClose={onClose} w={700} withCloseButton> <Stack h={500} p="sm"> <Title order={4}>Select Contact(s) to Send</Title> <TextInput placeholder="Search contacts by name or number..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={search} onChange={(e) => setSearch(e.currentTarget.value)} disabled={loading} /> <DataTable height="100%" withTableBorder borderRadius="sm" striped highlightOnHover records={filteredContacts} columns={columns} fetching={loading} minHeight={150} noRecordsText="No contacts found" selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} selectionCheckboxProps={{ 'aria-label': 'Select row' }} // This tells the DataTable to use the `id` field of each record object // as its unique identifier, which fixes the selection bug. idAccessor="id" /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedRecords.length === 0} > Add {selectedRecords.length} Contact(s) </Button> </Group> </Stack> </Modal> ) } export default ModalSelectContacts
```

# src/components/Input/Message/ProFeatureButton.tsx

```tsx
import useLicense from '@/hooks/useLicense' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' const ProFeatureButton = ({ form, label, icon, messageType, }: { form: UseFormReturnType<any> label: string icon: string messageType: string }) => { const license = useLicense() return ( <Tooltip label={label} position="top"> <Button size="sm" variant={form.values.type === messageType ? 'filled' : 'default'} onClick={() => { if (license.isFree()) { showModalUpgrade() return } form.setFieldValue('type', messageType) }} rightSection={ <When condition={license.isFree()}> <Badge size="xs" variant="light" color="teal" radius="sm"> PRO </Badge> </When> } > <Icon icon={icon} fontSize={24} /> </Button> </Tooltip> ) } export default ProFeatureButton
```

# src/components/Input/Message/Upload.tsx

```tsx
// src/components/Input/Message/Upload.tsx import { generateVideoThumbnail } from '@/utils/util' import { Icon } from '@iconify/react' import { Stack, Text } from '@mantine/core' import { Dropzone, IMAGE_MIME_TYPE, type FileRejection, } from '@mantine/dropzone' import React, { useEffect, useState } from 'react' interface Props { type: 'image' | 'video' | 'file' value: File | null onDrop: (file: File) => void onReject?: (fileRejections: FileRejection[]) => void | null } const Upload: React.FC<Props> = ({ type, value, onDrop, onReject = () => {}, }) => { const [preview, setPreview] = useState<string | null>(null) const [fileInfo, setFileInfo] = useState<{ name: string size: string } | null>(null) // ... (mimes, maxSizes, descriptions are unchanged) ... const mimes = { image: IMAGE_MIME_TYPE, video: ['video/mp4'], audio: [], file: [], } const maxSizes = { image: 3 * 1024 * 1024, video: 8 * 1024 * 1024, file: 8 * 1024 * 1024, } const idleDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } const rejectDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } useEffect(() => { return () => { if (preview) { URL.revokeObjectURL(preview) } } }, [preview]) useEffect(() => { if (value) { if (type === 'image') { const previewUrl = URL.createObjectURL(value) setPreview(previewUrl) } else if (type === 'video') { generateVideoThumbnail(value) .then((thumbnail) => setPreview(thumbnail)) .catch(console.error) } else if (type === 'file') { const sizeInMB = (value.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: value.name, size: `${sizeInMB} MB` }) } } else { setPreview(null) setFileInfo(null) } }, [value, type]) const handleDrop = async (files: File[]) => { if (files.length > 0) { const file = files[0] onDrop(file) if (type === 'video') { const thumbnail = await generateVideoThumbnail(file) setPreview(thumbnail) } else if (type === 'image') { const previewUrl = URL.createObjectURL(file) setPreview(previewUrl) } else if (type === 'file') { const sizeInMB = (file.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: file.name, size: `${sizeInMB} MB` }) } } } const handleReject = (fileRejections: FileRejection[]) => { onReject(fileRejections) console.log(fileRejections) } return ( <Dropzone onDrop={handleDrop} onReject={handleReject} maxSize={maxSizes[type]} accept={mimes[type]} multiple={false} > {type === 'file' && fileInfo ? ( <div style={{ textAlign: 'center' }}> {' '} <Stack justify="center" align="center"> {' '} <Icon icon="tabler:file-text" fontSize={50} />{' '} <Text>File: {fileInfo.name}</Text>{' '} <Text size="sm">Size: {fileInfo.size}</Text>{' '} </Stack>{' '} </div> ) : preview ? ( <div style={{ textAlign: 'center' }}> {' '} <img src={preview} alt="Preview" style={{ maxWidth: '100%', height: 100, objectFit: 'contain' }} />{' '} </div> ) : ( <> {' '} <Dropzone.Idle> {' '} <Stack justify="center" align="center"> {' '} <Icon icon={ type === 'image' ? 'tabler:photo' : type === 'video' ? 'tabler:video' : type === 'file' ? 'tabler:file-text' : 'tabler:file' } fontSize={50} />{' '} <Text>Drag & drop here or click to select a file</Text>{' '} <Text size="xs" c="dimmed"> {' '} {idleDescriptions[type]}{' '} </Text>{' '} </Stack>{' '} </Dropzone.Idle>{' '} <Dropzone.Accept> {' '} <Stack justify="center" align="center"> {' '} <Icon icon={'tabler:upload'} fontSize={50} />{' '} <Text>Drop the file here...</Text>{' '} </Stack>{' '} </Dropzone.Accept>{' '} <Dropzone.Reject> {' '} <Stack justify="center" align="center"> {' '} <Icon icon={'tabler:x'} fontSize={50} />{' '} <Text>{rejectDescriptions[type]}</Text>{' '} </Stack>{' '} </Dropzone.Reject>{' '} </> )} </Dropzone> ) } export default Upload
```

# src/components/Input/Message/useInputMessage.ts

```ts
// src/components/Input/Message/useInputMessage.ts import { Message } from '@/constants' import db from '@/libs/db' import { useForm } from '@mantine/form' import _ from 'lodash' const defaultValues = { type: Message.TEXT, inputText: '', inputImage: { file: null, caption: '', }, inputVideo: { file: null, caption: '', }, inputAudio: { file: null, isPtt: false, caption: '', }, inputFile: { file: null, caption: '', }, inputLocation: { lat: '', lng: '', name: '', address: '', url: '', }, inputPoll: { name: '', choices: ['Choice 1'], }, inputVCard: { contacts: [], }, } const useInputMessage = (options?: { isEditing?: boolean }) => { const form = useForm({ initialValues: defaultValues, validate: { inputText: (value, parent) => { if (parent.type === Message.TEXT && _.isEmpty(value)) { return 'Required' } return null }, inputImage: { file: (value, parent) => { if (options?.isEditing && parent.type === Message.IMAGE) { return null } if (parent.type === Message.IMAGE && !value) { return 'Required' } return null }, }, inputVideo: { file: (value, parent) => { if (options?.isEditing && parent.type === Message.VIDEO) { return null } if (parent.type === Message.VIDEO && !value) { return 'Required' } return null }, }, inputAudio: { file: (value, parent) => { if (options?.isEditing && parent.type === Message.AUDIO) { return null } if (parent.type === Message.AUDIO && !value) { return 'Required' } return null }, }, inputFile: { file: (value, parent) => { if (options?.isEditing && parent.type === Message.FILE) { return null } if (parent.type === Message.FILE && !value) { return 'Required' } return null }, }, inputLocation: { lat: (value, parent) => { if (parent.type === Message.LOCATION && _.isEmpty(value)) { return 'Required' } return null }, lng: (value, parent) => { if (parent.type === Message.LOCATION && _.isEmpty(value)) { return 'Required' } return null }, }, inputVCard: { contacts: (value, parent) => { if (parent.type === Message.VCARD && (!value || value.length === 0)) { return 'At least one contact must be selected.' } return null }, }, }, }) const getMessage = () => { const { type, inputText, inputImage, inputVideo, inputFile, inputLocation, inputPoll, inputVCard, } = form.values const messages = { [Message.TEXT]: inputText, [Message.IMAGE]: { caption: inputImage.caption, }, [Message.VIDEO]: { caption: inputVideo.caption, }, [Message.FILE]: inputFile.caption, [Message.LOCATION]: { lat: inputLocation.lat, lng: inputLocation.lng, name: inputLocation.name, address: inputLocation.address, url: inputLocation.url, }, [Message.VCARD]: inputVCard.contacts, [Message.POLL]: { name: inputPoll.name, choices: inputPoll.choices, }, } return messages[type] ?? inputText } const insertBroadcastFile = async ( parentId: number, broadcastFileType: string, ) => { const { type, inputImage, inputVideo, inputAudio, inputFile } = form.values const inputTypes = { [Message.IMAGE]: inputImage.file, [Message.VIDEO]: inputVideo.file, [Message.AUDIO]: inputAudio.file, [Message.FILE]: inputFile.file, } const file = inputTypes[type] as File await db.media.add({ parentId, type: broadcastFileType, name: file.name, file, ext: file.type, }) } return { form, getMessage, insertBroadcastFile, } } export default useInputMessage
```

# src/components/Layout/LayoutPage.module.css

```css
.header { border-bottom: 1px solid var(--mantine-color-gray-3); } .footer { border-top: 2px solid var(--mantine-color-gray-3); }
```

# src/components/Layout/LayoutPage.tsx

```tsx
import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import { useAppStore } from '@/stores/app' import env from '@/utils/env' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Loader, ScrollArea, Stack, Text, Title, type MantineSpacing, type StyleProp, } from '@mantine/core' import icon from 'data-base64:../../../assets/icon.png' import { When } from 'react-if' import packageJson from '../../../package.json' import classes from './LayoutPage.module.css' interface Props { width?: StyleProp<React.CSSProperties['width']> | null height?: StyleProp<React.CSSProperties['height']> | null p?: StyleProp<MantineSpacing> title?: string | null children: React.ReactNode } const LayoutPage: React.FC<Props> = ({ width = 900, height = 620, p = 'xl', children, title = null, }: Props) => { const wa = useWa() const license = useLicense() const { isLoading } = useAppStore() const renderBody = () => { return ( <Stack p={'xl'} w={width}> {children} </Stack> ) } return ( <> <Stack w={width} gap={0}> <Group justify="space-between" px={'md'} py={'xs'} className={classes.header} > <Group gap={6}> <img width={32} height={32} src={icon} style={{ borderRadius: 10, }} /> <Title order={3} ml={2}> {title ? title : packageJson.displayName} </Title> <When condition={license.isPro() && env.isProduction()}> <Button radius={'lg'} size="compact-sm" variant="outline" px={'sm'} > <Text fw={500}>Pro</Text> </Button> </When> </Group> </Group> {wa.isReady ? ( <ScrollArea h={height}>{renderBody()}</ScrollArea> ) : ( <Center h={height}> <Loader /> </Center> )} </Stack> </> ) } export default LayoutPage
```

# src/components/Modal/Modal.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Card, Paper, type MantineSpacing, type StyleProp, } from '@mantine/core' import React, { type CSSProperties } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void height?: string | number width?: string | number style?: CSSProperties withCloseButton?: boolean | false h?: StyleProp<React.CSSProperties['height']> w?: StyleProp<React.CSSProperties['width']> p?: StyleProp<MantineSpacing> children: React.ReactNode } const Modal: React.FC<Props> = ({ opened, onClose, style = {}, withCloseButton = false, p = 'lg', h, w, children, ...rest }: Props) => { if (!opened) return null return ( <> <div style={{ position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, zIndex: 399, width: '100%', height: '100%', backgroundColor: 'black', opacity: '0.15', }} onClick={onClose} ></div> <Box style={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 1050, ...style, }} {...rest} > <Card shadow={'xs'} p={p} w={w} h={h} radius={'md'}> <When condition={withCloseButton}> <ActionIcon onClick={onClose} color="red" variant="transparent" style={{ position: 'absolute', right: 3, top: 1, }} > <Icon icon="tabler:x" fontSize={16} /> </ActionIcon> <Box mb={'md'} /> </When> {children} </Card> </Box> </> ) } export default Modal
```

# src/components/Modal/ModalActivation.tsx

```tsx
// src/components/Modal/ModalActivation.tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, rem, Stack, Text, TextInput, ThemeIcon, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalActivation: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const form = useForm({ initialValues: defaultValues, validate: { license: (value) => _.isEmpty(value) ? 'A license key is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) const handleOnClose = () => { form.reset() onClose() } const handleSubmit = async () => { const { hasErrors } = form.validate() if (hasErrors) { return } setLoading(true) form.clearErrors() try { const response = await license.activate(form.values.license) if (response.data.error) { form.setFieldError('license', response.data.error.replace(/_/g, ' ')) setLoading(false) return } if (response.data.meta.store_id.toString() !== getStoreId()) { form.setFieldError( 'license', 'This license key is not valid for this product.', ) setLoading(false) return } toast.success('Successfully activated! 🎉') handleOnClose() } catch (err) { console.error('Activation error:', err) form.setFieldError( 'license', 'An unexpected error occurred. Please try again.', ) } finally { setLoading(false) } } return ( <Modal opened={opened} onClose={handleOnClose} w={500} p="xl" withCloseButton > <Stack gap="lg"> <Stack align="center" gap="xs"> <ThemeIcon color="teal" size={rem(60)} radius="xl"> <Icon icon="tabler:key" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> {' '} License Activation{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Enter your license key below to unlock all Pro features.{' '} </Text> </Stack> <Stack> <TextInput label="License Key" placeholder="xxxx-xxxx-xxxx-xxxx" required leftSection={<Icon icon="tabler:key" fontSize={18} />} {...form.getInputProps('license')} /> <Text size="xs" c="dimmed"> {' '} You can find your license key in the purchase confirmation email. If you need help, please check our FAQ page or contact support.{' '} </Text> </Stack> <Button loading={loading} onClick={handleSubmit} fullWidth size="md" mt="md" leftSection={<Icon icon="tabler:circle-check" fontSize={20} />} > {' '} Activate License{' '} </Button> </Stack> </Modal> ) } export default ModalActivation
```

# src/components/Modal/ModalSourceExcel.tsx

```tsx
import ExcelUploader from '@/components/Input/Excel/ExcelUploader' import Modal from '@/components/Modal/Modal' import { Center, Stack, Title } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } const ModalSourceExcel: React.FC<Props> = ({ opened, onClose, onSubmit }) => { // This handler receives the raw parsed data from the uploader and formats it // for the broadcast recipient list before passing it up to the parent. const handleConfirmUpload = (parsedData: any[]) => { const newRecipients = parsedData .map((item) => ({ number: item.number?.toString(), name: item.name?.toString() || 'From Excel', source: 'Excel', })) .filter((item) => item.number) if (newRecipients.length > 0) { onSubmit(newRecipients) } } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Numbers From Excel</Title> </Center> <ExcelUploader onConfirm={handleConfirmUpload} onClose={onClose} /> </Stack> </Modal> ) } export default ModalSourceExcel
```

# src/components/Modal/ModalUpgrade.tsx

```tsx
import Modal from '@/components/Modal/Modal' import plans from '@/config/plans' import { Button, Card, Group, Stack, Text, Title } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalUpgrade: React.FC<Props> = ({ opened, onClose }: Props) => { const form = useForm({ initialValues: defaultValues, }) const handleOnClose = () => { form.reset() onClose() } const renderPlans = () => { return ( <Group> {plans.map((plan, index) => ( <Card key={index} withBorder w={370} radius={'md'} p="lg"> <Card.Section withBorder px={'lg'} py={'md'}> <Stack justify="space-between" gap={2}> <Group justify="space-between"> <Stack gap={0}> <Title order={2}>{plan.name}</Title> <Text fw={500}>{plan.description}</Text> </Stack> </Group> <Group gap={0} align={'flex-end'}> <When condition={plan.placeholderPrice}> <Title order={3} c={'dimmed'} style={{ textDecorationLine: 'line-through', }} mb={3} > {plan.placeholderPrice} </Title> </When> <Title>{plan.isFree ? 'Free' : plan.price}</Title> </Group> </Stack> </Card.Section> <Stack gap={10} pt={'md'}> {plan.features.map((feature, index) => ( <Text key={`${index}`}>{feature}</Text> ))} </Stack> {plan.isFree ? ( <Button size="sm" mt={'lg'}> Free </Button> ) : ( <Button size="sm" component="a" href={plan.link} target="_blank" mt={'lg'} > Upgrade now </Button> )} </Card> ))} </Group> ) } return ( <Modal opened={opened} onClose={handleOnClose} w={1000} p={'md'} withCloseButton > <Stack py={'xl'}> <Stack justify="center" align="center"> <Stack justify="center" align="center" gap={4} mb={30}> <Title order={2}>Pricing & Plans</Title> <Text fw={500} size="md"> Select the right plan for you business. Upgrade or downgrade at any time. </Text> </Stack> {renderPlans()} </Stack> </Stack> </Modal> ) } export default ModalUpgrade
```

# src/components/Toast/Toast.module.css

```css
@keyframes fadeIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .toast { animation: fadeIn 0.3s ease-out forwards; }
```

# src/components/Toast/Toast.tsx

```tsx
import { type Toast } from '@/stores/toast' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Text, ThemeIcon } from '@mantine/core' import { useEffect } from 'react' import classes from './Toast.module.css' interface ToastProps extends Toast { onClose: () => void } const ToastComponent: React.FC<ToastProps> = ({ id, type, title, message, duration = 2000, onClose, }) => { useEffect(() => { const timer = setTimeout(() => { onClose() }, duration) return () => clearTimeout(timer) }, [id, duration, onClose]) const toastConfig = { success: { icon: 'tabler:check', color: 'teal' }, error: { icon: 'tabler:x', color: 'red' }, info: { icon: 'tabler:info-circle', color: 'blue' }, } const { icon, color } = toastConfig[type] return ( <Paper shadow="lg" p="sm" radius="md" withBorder className={classes.toast} style={{ minWidth: 350, maxWidth: 400 }} > <Group align="flex-start" wrap="nowrap"> <ThemeIcon color={color} size={36} radius="xl" mt={4}> <Icon icon={icon} fontSize={22} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Text fw={600} size="md"> {title} </Text> <Text size="sm" c="dimmed"> {message} </Text> </Stack> <ActionIcon variant="transparent" color="gray" onClick={onClose}> <Icon icon="tabler:x" /> </ActionIcon> </Group> </Paper> ) } export default ToastComponent
```

# src/components/Toast/ToastProvider.tsx

```tsx
import { useToastStore } from '@/stores/toast' import { Box } from '@mantine/core' import React from 'react' import ToastComponent from './Toast' const ToastProvider: React.FC = () => { const { toasts, removeToast } = useToastStore() return ( <Box style={{ position: 'fixed', top: 20, right: 20, zIndex: 2000, display: 'flex', flexDirection: 'column', gap: '10px', }} > {toasts.map((toast) => ( <ToastComponent key={toast.id} id={toast.id} type={toast.type} title={toast.title} message={toast.message} duration={toast.duration} onClose={() => removeToast(toast.id)} /> ))} </Box> ) } export default ToastProvider
```

# src/config/plans.ts

```ts
const plans = [ { name: 'Free', description: 'For starters and hobbyists.', price: 'Free', isFree: true, placeholderPrice: null, link: '#', features: [ '⚫ Max 5 groups', '⚫ Max 1 template', '❌ Typing effect', '❌ Schedule message', '❌ Send Image, Video, File, Location, Poll', '⚫ Limited features', '⚫ Basic support', ], tags: [], }, { name: 'Lifetime', description: 'Pay once, access forever, no monthly fees.', placeholderPrice: '$59', price: '$39', isFree: false, link: 'https://extdotninja.lemonsqueezy.com/buy/554f3fc2-a924-496d-9b4e-57e21e55a59a?media=0&logo=0&desc=0&discount=0', features: [ '✅ Unlimited groups', '✅ Unlimited templates', '✅ Typing effect', '✅ Schedule message', '✅ Send Image, Video, File, Location, Poll', '✅ No monthly fees, No subscription', '✅ Pay once, access forever', ], }, ] export default plans
```

# src/constants/action.ts

```ts
export const App = { HTTP: 'App.HTPP', AI: 'App.AI', } export const Blocklist = { ALL: 'Blocklist.ALL', BLOCK_CONTACT: 'Blocklist.BLOCK_CONTACT', IS_BLOCKED: 'Blocklist.IS_BLOCKED', UNBLOCK_CONTACT: 'Blocklist.UNBLOCK_CONTACT', } export const Cart = { ADD: 'Cart.ADD', CLEAR: 'Cart.CLEAR', GET: 'Cart.GET', GET_THUMB_FROM_CART: 'Cart.GET_THUMB_FROM_CART', REMOVE: 'Cart.REMOVE', SUBMIT: 'Cart.SUBMIT', UPDATE: 'Cart.UPDATE', } export const Catalog = { ADD_PRODUCT_IMAGE: 'Catalog.ADD_PRODUCT_IMAGE', CHANGE_PRODUCT_IMAGE: 'Catalog.CHANGE_PRODUCT_IMAGE', CREATE_COLLECTION: 'Catalog.CREATE_COLLECTION', CREATE_PRODUCT: 'Catalog.CREATE_PRODUCT', DELETE_COLLECTION: 'Catalog.DELETE_COLLECTION', DELETE_PRODUCT: 'Catalog.DELETE_PRODUCT', EDIT_COLLECTION: 'Catalog.EDIT_COLLECTION', EDIT_PRODUCT: 'Catalog.EDIT_PRODUCT', GET_COLLECTIONS: 'Catalog.GET_COLLECTIONS', GET_MY_CATALOG: 'Catalog.GET_MY_CATALOG', GET_PRODUCT_BY_ID: 'Catalog.GET_PRODUCT_BY_ID', GET_PRODUCTS: 'Catalog.GET_PRODUCTS', REMOVE_PRODUCT_IMAGE: 'Catalog.REMOVE_PRODUCT_IMAGE', SET_PRODUCT_VISIBILITY: 'Catalog.SET_PRODUCT_VISIBILITY', UPDAGE_CART_ENABLED: 'Catalog.UPDAGE_CART_ENABLED', } export const Community = { ADD_SUB_GROUPS: 'Community.ADD_SUB_GROUPS', } export const Chat = { ARCHIVE: 'Chat.ARCHIVE', CAN_MARK_PLAYED: 'Chat.CAN_MARK_PLAYED', CAN_MUTE: 'Chat.CAN_MUTE', CAN_REPLY: 'Chat.CAN_REPLY', CLEAR: 'Chat.CLEAR', CLOSE_CHAT: 'Chat.CLOSE_CHAT', DELETE: 'Chat.DELETE', DELETE_MESSAGE: 'Chat.DELETE_MESSAGE', DOWNLOAD_MEDIA: 'Chat.DOWNLOAD_MEDIA', // ++ ADDED FIND: 'Chat.FIND', FORWARD_MESSAGE: 'Chat.FORWARD_MESSAGE', GET: 'Chat.GET', GET_ACTIVE_CHAT: 'Chat.GET_ACTIVE_CHAT', GET_LAST_SEEN: 'Chat.GET_LAST_SEEN', GET_MESSAGE_ACK: 'Chat.GET_MESSAGE_ACK', GET_MESSAGES: 'Chat.GET_MESSAGES', GET_NOTES: 'Chat.GET_NOTES', GET_PLATFORM_MESSAGE: 'Chat.GET_PLATFORM_MESSAGE', MARK_IS_COMPOSING: 'Chat.MARK_IS_COMPOSING', MARK_IS_PAUSED: 'Chat.MARK_IS_PAUSED', MARK_IS_READ: 'Chat.MARK_IS_READ', MARK_IS_RECORDING: 'Chat.MARK_IS_RECORDING', MARK_IS_UNREAD: 'Chat.MARK_IS_UNREAD', MARK_PLAYED: 'Chat.MARK_PLAYED', MUTE: 'Chat.MUTE', OPEN_CHAT_AT: 'Chat.OPEN_CHAT_AT', OPEN_CHAT_BOTTOM: 'Chat.OPEN_CHAT_BOTTOM', OPEN_CHAT_FROM_UNREAD: 'Chat.OPEN_CHAT_FROM_UNREAD', PIN_MSG: 'Chat.PIN_MSG', LIST: 'Chat.LIST', SET_CHAT_LIST: 'Chat.SET_CHAT_LIST', SET_INPUT_TEXT: 'Chat.SET_INPUT_TEXT', SET_NOTES: 'Chat.SET_NOTES', } export const Contact = { GET: 'Contact.GET', GET_BUSINESS_PROFILE: 'Contact.GET_BUSINESS_PROFILE', GET_COMMON_GROUPS: 'Contact.GET_COMMON_GROUPS', GET_PROFILE_PICTURE_URL: 'Contact.GET_PROFILE_PICTURE_URL', GET_STATUS: 'Contact.GET_STATUS', LIST: 'Contact.LIST', LIST_CONTACT_BY_COUNTRY: 'Contact.LIST_CONTACT_BY_COUNTRY', IS_EXIST: 'Contact.IS_EXIST', REMOVE: 'Contact.REMOVE', } export const Conn = { GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER: 'Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER', GET_AUTH_CODE: 'Conn.GET_AUTH_CODE', GET_PROFILE: 'Conn.GET_PROFILE', GET_MY_USER_ID: 'Conn.GET_MY_USER_ID', } export const Group = { ADD_PARTICIPANTS: 'Group.ADD_PARTICIPANTS', APPROVE: 'Group.APPROVE', LIST: 'Group.LIST', CAN_ADD: 'Group.CAN_ADD', CAN_DEMOTE: 'Group.CAN_DEMOTE', CAN_PROMOTE: 'Group.CAN_PROMOTE', CAN_REMOVE: 'Group.CAN_REMOVE', CREATE: 'Group.CREATE', DEMOTE_PARTICIPANTS: 'Group.DEMOTE_PARTICIPANTS', GET_GROUP_INFO_FROM_INVITE_CODE: 'Group.GET_GROUP_INFO_FROM_INVITE_CODE', GET_GROUP_SIZE_LIMIT: 'Group.GET_GROUP_SIZE_LIMIT', GET_INVITE_LINK: 'Group.GET_INVITE_LINK', GET_MEMBERSHIP_REQUESTS: 'Group.GET_MEMBERSHIP_REQUESTS', GET_PARTICIPANTS: 'Group.GET_PARTICIPANTS', IAM_ADMIN: 'Group.IAM_ADMIN', IAM_MEMBER: 'Group.IAM_MEMBER', IAM_RESTRICTED_MEMBER: 'Group.IAM_RESTRICTED_MEMBER', IAM_SUPER_ADMIN: 'Group.IAM_SUPER_ADMIN', JOIN: 'Group.JOIN', LEAVE: 'Group.LEAVE', PROMOTE_PARTICIPANTS: 'Group.PROMOTE_PARTICIPANTS', REJECT: 'Group.REJECT', REMOVE_ICON: 'Group.REMOVE_ICON', REMOVE_PARTICIPANTS: 'Group.REMOVE_PARTICIPANTS', REVOKE_INVITE_CODE: 'Group.REVOKE_INVITE_CODE', SET_DESCRIPTION: 'Group.SET_DESCRIPTION', SET_ICON: 'Group.SET_ICON', SET_PROPERTY: 'Group.SET_PROPERTY', SET_SUBJECT: 'Group.SET_SUBJECT', } export const Newsletter = { CREATE: 'Newsletter.CREATE', DESTROY: 'Newsletter.DESTROY', EDIT: 'Newsletter.EDIT', GET_SUBSCRIBERS: 'Newsletter.GET_SUBSCRIBERS', MUTE: 'Newsletter.MUTE', } export const Send = { TEXT: 'Send.TEXT', IMAGE: 'Send.IMAGE', LOCATION: 'Send.LOCATION', DOCUMENT: 'Send.DOCUMENT', FILE: 'Send.FILE', POLL: 'Send.POLL', VCARD: 'Send.VCARD', } export const Status = { GET: 'Status.GET', GET_MY_STATUS: 'Status.GET_MY_STATUS', REMOVE: 'Status.REMOVE', SEND_IMAGE_STATUS: 'Status.SEND_IMAGE_STATUS', SEND_READ_STATUS: 'Status.SEND_READ_STATUS', SEND_TEXT_STATUS: 'Status.SEND_TEXT_STATUS', SEND_VIDEO_STATUS: 'Status.SEND_VIDEO_STATUS', UPDATE_PARTICIPANTS: 'Status.UPDATE_PARTICIPANTS', } export const Profile = { EDIT_BUSINESS_PROFILE: 'Profile.EDIT_BUSINESS_PROFILE', GET_MY_PROFILE_NAME: 'Profile.GET_MY_PROFILE_NAME', GET_MY_PROFILE_PICTURE: 'Profile.GET_MY_PROFILE_PICTURE', GET_MY_STATUS: 'Profile.GET_MY_STATUS', IS_BUSINESS: 'Profile.IS_BUSINESS', REMOVE_MY_PROFILE_PICTURE: 'Profile.REMOVE_MY_PROFILE_PICTURE', SET_MY_PROFILE_NAME: 'Profile.SET_MY_PROFILE_NAME', SET_MY_PROFILE_PICTURE: 'Profile.SET_MY_PROFILE_PICTURE', SET_MY_STATUS: 'Profile.SET_MY_STATUS', } export const AI = { REWRITE_MESSAGE: 'AI.REWRITE_MESSAGE', } export const Window = { READY: 'Window.READY', ACTIVE_CHAT: 'Window.ACTIVE_CHAT', GO_TO_PAGE: 'Window.GO_TO_PAGE', CLOSE_PAGE: 'Window.CLOSE_PAGE', SHOW_MODAL_MAIN: 'Window.SHOW_MODAL_MAIN', SHOW_MODAL_UPGRADE: 'Window.SHOW_MODAL_UPGRADE', SHOW_MODAL_ACTIVATION: 'Window.SHOW_MODAL_ACTIVATION', SEND_BROADCAST: 'Window.SEND_BROADCAST', }
```

# src/constants/index.ts

```ts
// src/constants/index.ts export * as Action from './action' export * as Setting from './setting' export const Status = { SUCCESS: 'SUCCESS', IDLE: 'IDLE', PENDING: 'PENDING', FAILED: 'FAILED', RUNNING: 'RUNNING', SCHEDULER: 'SCHEDULER', CANCELLED: 'CANCELLED', PAUSED: 'PAUSED', DRAFT: 'DRAFT', POSTED: 'POSTED', } export const Page = { HOME: 'Page.HOME', BROADCAST: 'Page.BROADCAST', TOOLS: 'Page.TOOLS', NUMBER_VALIDATOR: 'Page.NUMBER_VALIDATOR', DIRECT_CHAT: 'Page.DIRECT_CHAT', PRIVACY: 'Page.PRIVACY', EXPORT: 'Page.EXPORT', FAQ: 'Page.FAQ', UPGRADE: 'Page.UPGRADE', ACTIVATE: 'Page.ACTIVATE', PROFILE: 'Page.PROFILE', QUICK_REPLY: 'Page.QUICK_REPLY', WA_ME_GENERATOR: 'Page.WA_ME_GENERATOR', LABEL: 'Page.LABEL', GROUP_LINK_GENERATOR: 'Page.GROUP_LINK_GENERATOR', CHAT_BACKUP: 'Page.CHAT_BACKUP', // ++ ADDED } export const Account = { BUSINESS: 'BUSINESS', PERSONAL: 'PERSONAL', } export const Message = { TEXT: 'TEXT', MEDIA: 'MEDIA', IMAGE: 'IMAGE', VIDEO: 'VIDEO', AUDIO: 'AUDIO', FILE: 'FILE', LOCATION: 'LOCATION', VCARD: 'VCARD', BUTTON: 'BUTTON', LIST: 'LIST', POLL: 'POLL', } export const Media = { BROADCAST: 'BROADCAST', BROADCAST_TEMPLATE: 'BROADCAST_TEMPLATE', STATUS_CONTENT: 'STATUS_CONTENT', QUICK_REPLY: 'QUICK_REPLY', } export const ContactType = { ALL: 'CONTACT_TYPE_ALL', SAVED_CONTACTS: 'CONTACT_TYPE_SAVED_CONTACTS', UNSAVED_CONTACTS: 'CONTACT_TYPE_UNSAVED_CONTACTS', } export const AccountType = { ALL: 'ACCOUNT_TYPE_ALL', PERSONAL: 'ACCOUNT_TYPE_PERSONAL', BUSINESS: 'ACCOUNT_TYPE_BUSINESS', } export const MessageType = { ALL: 'MESSAGE_TYPE_ALL', HAVE_UNREAD_MESSAGES: 'MESSAGE_TYPE_HAVE_UNREAD_MESSAGES', NO_UNREAD_MESSAGES: 'MESSAGE_TYPE_NO_UNREAD_MESSAGES', } export const SaveAs = { CSV: 'SAVE_AS_CSV', EXCEL: 'SAVE_AS_EXCEL', PDF: 'SAVE_AS_PDF', JSON: 'SAVE_AS_JSON', MARKDOWN: 'SAVE_AS_MARKDOWN', HTML: 'SAVE_AS_HTML', VCARD: 'SAVE_AS_VCARD', }
```

# src/constants/setting.ts

```ts
export const LICENSE_KEY = 'SETTING_LICENSE_KEY' export const LICENSE_INSTANCE_ID = 'SETTING_LICENSE_INSTANCE_ID' export const LICENSE_DATA_CACHE = 'SETTING_LICENSE_DATA_CACHE' export const IS_FIRST_TIME = 'SETTING_IS_FIRST_TIME' export const NEED_TO_OPEN = 'SETTING_NEED_TO_OPEN' export const HAS_ACKNOWLEDGED_BROADCAST_WARNING = 'SETTING.HAS_ACKNOWLEDGED_BROADCAST_WARNING' export const BLUR_PROFILE_PICTURES = 'SETTING.BLUR_PROFILE_PICTURES' export const BLUR_MESSAGES = 'SETTING.BLUR_MESSAGES' export const BLUR_USER_GROUP_NAMES = 'SETTING.BLUR_USER_GROUP_NAMES' export const BLUR_RECENT_MESSAGES = 'SETTING.BLUR_RECENT_MESSAGES' export const EXPORT_COLUMNS = 'SETTING_EXPORT_COLUMNS'
```

# src/contents/chat.tsx

```tsx
// src/contents/chat.tsx import ModalCreateUpdateLabel from '@/features/label/components/ModalCreateUpdateLabel' import PopoverQuickReplies from '@/features/quick-reply/components/Popover/PopoverQuickReplies' import useWa from '@/hooks/useWa' import db, { type Label } from '@/libs/db' import theme from '@/libs/theme' import { useAppStore } from '@/stores/app' import style from '@/utils/style' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Checkbox, Group, MantineProvider, Popover, ScrollArea, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useClipboard, useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import $ from 'jquery' import _ from 'lodash' import type { PlasmoCSConfig, PlasmoGetInlineAnchor, PlasmoGetShadowHostId, } from 'plasmo' import { useMemo, useState } from 'react' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-chat` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } export const getInlineAnchor: PlasmoGetInlineAnchor = async () => ({ element: $( 'div[class="x78zum5 xdt5ytf x1iyjqo2 xl56j7k xeuugli xtnn1bt x9v5kkp xmw7ebm xrdum7p"]', )[0], }) const Chat = () => { const wa = useWa() const { activeChat } = useAppStore() const { copy, copied } = useClipboard() const [searchQuery, setSearchQuery] = useState('') const [showCreateLabelModal, createLabelModalHandlers] = useDisclosure(false) const allLabels = useLiveQuery(() => db.labels.where({ custom: 1 }).toArray()) || [] // This memoized value filters and groups the labels for display. // It runs only when the labels or search query change, improving performance. const groupedLabels = useMemo(() => { const filtered = allLabels.filter((label) => label.label.toLowerCase().includes(searchQuery.toLowerCase()), ) const grouped = _.groupBy(filtered, (label) => label.group || 'Ungrouped') return Object.entries(grouped) }, [allLabels, searchQuery]) const handleCopy = () => { copy(activeChat.number) } // Adds or removes the active chat's number from a label. const handleToggleLabel = async (label: Label) => { const { number } = activeChat const isIncluded = label.numbers?.includes(number) const updatedNumbers = isIncluded ? label.numbers?.filter((n) => n !== number) : [...(label.numbers || []), number] await db.labels.update(label.id, { numbers: updatedNumbers }) if (isIncluded) { toast.info(`Removed from "${label.label}"`) } else { toast.success(`Added to "${label.label}"`) } } const renderCopyNumber = () => { return ( <Tooltip label={copied ? 'Copied!' : 'Copy number'} position="top" withArrow > <ActionIcon variant="subtle" onClick={handleCopy}> <Icon fontSize={24} icon={copied ? 'tabler:check' : 'tabler:copy'} /> </ActionIcon> </Tooltip> ) } const renderLabelItem = (label: Label) => ( <Group key={`popup-chat-${label.id}`} gap="xs" wrap="nowrap"> <Checkbox size="sm" checked={label.numbers?.includes(activeChat.number)} onChange={() => handleToggleLabel(label)} aria-label={`Toggle label ${label.label}`} /> <Text size="sm" truncate> {label.label} </Text> </Group> ) const renderPopoverManageLabels = () => { return ( <Popover width={300} shadow="md"> <Popover.Target> <Tooltip label="Add to label" position="top"> <ActionIcon variant="subtle"> <Icon fontSize={24} icon={'tabler:folder-symlink'} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown> <Stack> <TextInput placeholder="Search labels..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} onChange={(event) => setSearchQuery(event.currentTarget.value)} /> <ScrollArea h={250}> {groupedLabels.length > 0 ? ( <Stack gap="sm"> {groupedLabels.map(([groupName, labels]) => ( <Stack key={groupName} gap="xs"> <Text size="xs" c="dimmed" fw={700}> {groupName} </Text> {labels.map(renderLabelItem)} </Stack> ))} </Stack> ) : ( <Text size="sm" c="dimmed" ta="center" mt="md"> No labels found. </Text> )} </ScrollArea> <Button variant="light" size="xs" leftSection={<Icon icon="tabler:plus" fontSize={16} />} onClick={createLabelModalHandlers.open} > Create New Label </Button> </Stack> </Popover.Dropdown> </Popover> ) } return ( <> <MantineProvider theme={theme} cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-chat') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <Group style={{ borderRight: '2px solid var(--mantine-color-gray-3)' }} pr={'lg'} > {renderCopyNumber()} {/* ++ ADDED: The Quick Reply popover is now rendered here. */} <PopoverQuickReplies /> {renderPopoverManageLabels()} </Group> <ModalCreateUpdateLabel opened={showCreateLabelModal} onClose={createLabelModalHandlers.close} /> </MantineProvider> </> ) } export default Chat
```

# src/contents/header.tsx

```tsx
import { Page } from '@/constants' import useWa from '@/hooks/useWa' import db, { type Label } from '@/libs/db' import theme from '@/libs/theme' import page from '@/utils/page' import style from '@/utils/style' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Box, Checkbox, Group, MantineProvider, Menu, ScrollArea, Text, Tooltip, } from '@mantine/core' import { useLiveQuery } from 'dexie-react-hooks' import $ from 'jquery' import _ from 'lodash' import type { PlasmoCSConfig, PlasmoGetInlineAnchor, PlasmoGetShadowHostId, } from 'plasmo' import React, { useMemo, useState } from 'react' import { When } from 'react-if' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-header` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } export const getInlineAnchor: PlasmoGetInlineAnchor = async () => ({ element: $('div[class="x78zum5 xdt5ytf x5yr21d"]')[0], insertPosition: 'afterbegin', }) const Header = () => { const wa = useWa() const [activeLabelId, setActiveLabelId] = useState<number | null>(null) const allLabels = useLiveQuery(() => db.labels.toArray()) const { pinnedLabels, unpinnedLabels } = useMemo(() => { const pinned = allLabels?.filter((label) => label.isPinned === 1 && label.show) || [] const unpinned = allLabels?.filter((label) => !label.isPinned && label.show) || [] return { pinnedLabels: pinned, unpinnedLabels: unpinned } }, [allLabels]) const handleFilterChat = async (label: Label) => { if (label.id === activeLabelId) { await wa.chat.setChatList('all') setActiveLabelId(null) return } const numbers = label.numbers?.map((number) => `${number}@c.us`) await wa.chat.setChatList('custom', numbers) setActiveLabelId(label.id) } const handleClearFilter = async () => { await wa.chat.setChatList('all') setActiveLabelId(null) } const handleToggleVisibility = async (label: Label) => { await db.labels.update(label.id, { show: label.show ? 0 : 1 }) } const handleTogglePin = async (label: Label) => { await db.labels.update(label.id, { isPinned: label.isPinned ? 0 : 1 }) } const renderLabel = (label: Label) => { const isActive = activeLabelId === label.id return ( <Badge key={label.id} size="lg" color={label.color || 'gray'} radius={'sm'} variant={isActive ? 'filled' : 'light'} onClick={() => handleFilterChat(label)} mr={'sm'} style={{ cursor: 'pointer' }} > {label.label} ({label.numbers?.length || 0}) </Badge> ) } return ( <MantineProvider theme={theme} cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-header') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <Group style={{ backgroundColor: 'var(--mantine-color-body)', borderBottom: '1px solid var(--mantine-color-gray-3)', }} w={'100%'} px="lg" py={10} justify="space-between" gap="xs" wrap="nowrap" > <Group gap="xs"> {pinnedLabels.map(renderLabel)} <ScrollArea w={'100%'} style={{ whiteSpace: 'nowrap' }}> <Box style={{ display: 'inline-block' }}> {unpinnedLabels.map(renderLabel)} </Box> </ScrollArea> </Group> <Group mr={60} justify="flex-end" wrap="nowrap"> <When condition={activeLabelId !== null}> <Tooltip label="Clear Filter" position="bottom"> <ActionIcon variant="subtle" color="red" size="lg" onClick={handleClearFilter} > <Icon fontSize={22} icon={'tabler:x'} /> </ActionIcon> </Tooltip> </When> <Menu shadow="md" width={280} position="bottom-end"> <Menu.Target> <Tooltip label="Manage Filters & Labels" position="bottom"> <ActionIcon variant="subtle" size="lg"> <Icon fontSize={22} icon={'tabler:adjustments-alt'} /> </ActionIcon> </Tooltip> </Menu.Target> <Menu.Dropdown> <ScrollArea h={200}> {allLabels?.map((label) => ( <Menu.Item key={label.id} closeMenuOnClick={false}> <Group justify="space-between" wrap="nowrap"> <Checkbox checked={!!label.show} onChange={() => handleToggleVisibility(label)} label={ <Text size="sm" truncate> {label.label} </Text> } color={label.color} /> <Tooltip label={label.isPinned ? 'Unpin' : 'Pin'} position="left" > <ActionIcon variant="subtle" color={label.isPinned ? 'yellow' : 'gray'} onClick={() => handleTogglePin(label)} > <Icon icon={ label.isPinned ? 'tabler:star-filled' : 'tabler:star' } fontSize={16} /> </ActionIcon> </Tooltip> </Group> </Menu.Item> ))} </ScrollArea> <Menu.Divider /> <Menu.Item leftSection={<Icon icon="tabler:settings" fontSize={16} />} onClick={() => page.goTo(Page.LABEL)} > Manage labels </Menu.Item> </Menu.Dropdown> </Menu> </Group> </Group> </MantineProvider> ) } export default Header
```

# src/contents/inject-script.ts

```ts
import { Action } from '@/constants' import wa from '@/libs/wa' import { initInjectScriptRelays } from '@/relays' import { postMessage } from '@/utils/util' import type { PlasmoCSConfig } from 'plasmo' export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], world: 'MAIN', } initInjectScriptRelays() wa.on.ready(() => { setTimeout(() => { onReady() }, 2000) }) const onReady = () => { setTimeout(() => { window.postMessage({ action: Action.Window.READY, body: {}, }) WPP.on('chat.active_chat', (chat) => { const body = { name: chat.contact?.__x_pushname || chat.contact?.__x_verifiedName || chat.name || chat.formattedTitle, number: chat.id.user, formattedNumber: chat.id._serialized, isUser: chat.id._serialized.includes('@c.us'), isGroup: chat.id._serialized.includes('@g.us'), isBusiness: chat.contact?.__x_isBusiness, } postMessage(Action.Window.ACTIVE_CHAT, body) }) }, 1000) }
```

# src/contents/main.tsx

```tsx
import App from '@/components/App' import ToastProvider from '@/components/Toast/ToastProvider' import theme from '@/libs/theme' import style from '@/utils/style' import { MantineProvider } from '@mantine/core' import type { PlasmoCSConfig, PlasmoGetShadowHostId } from 'plasmo' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-main` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Main = () => { return ( <> <MantineProvider theme={theme} //@ts-ignore cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-main') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <App /> <ToastProvider /> </MantineProvider> </> ) } export default Main
```

# src/features/broadcast/components/Datatable/BroadcastColumns.tsx

```tsx
// src/features/Broadcast/Datatable/BroadcastColumns.tsx import { Message, Status } from '@/constants' import type { Broadcast } from '@/libs/db' import { truncate } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Box, Group, Menu, Stack, Text, Tooltip, } from '@mantine/core' import type { DataTableColumn } from 'mantine-datatable' import React from 'react' import MessageStatus from './MessageStatus' import MessageType from './MessageType' interface ColumnActions { onViewDetails: (broadcast: Broadcast) => void onResendToFailed: (broadcast: Broadcast) => void onClone: (broadcast: Broadcast) => void onExport: (broadcast: Broadcast, format: string) => void onCancel: (broadcastId: number) => void onDelete: (broadcast: Broadcast) => void } type BroadcastStatsMap = Map< number, { total: number success: number pending: number running: number failed: number scheduled: number cancelled: number firstError?: string } > const renderMessagePreview = (broadcast: Broadcast) => { const { type, message } = broadcast if (!message) return 'N/A' switch (type) { case Message.TEXT: return typeof message === 'string' ? message : JSON.stringify(message) case Message.IMAGE: case Message.VIDEO: case Message.FILE: return (message as any).caption || `Media File (${type})` case Message.LOCATION: return (message as any).name || (message as any).address || 'Location' case Message.POLL: return (message as any).name || 'Poll' case Message.VCARD: return 'Contact Card' default: return `Unsupported type: ${type}` } } export const getBroadcastColumns = ( actions: ColumnActions, broadcastStatsMap: BroadcastStatsMap, ): DataTableColumn<Broadcast>[] => { const defaultStats = { total: 0, success: 0, pending: 0, running: 0, failed: 0, scheduled: 0, cancelled: 0, } return [ { accessor: 'name', title: 'Name', render: (broadcast) => <Text truncate>{broadcast.name || 'N/A'}</Text>, sortable: true, width: 150, }, { accessor: 'type', title: 'Type', render: (broadcast) => <MessageType type={broadcast.type} />, width: 130, }, { accessor: 'message', title: 'Content Preview', render: (broadcast) => { const fullMessage = renderMessagePreview(broadcast) return ( <Tooltip label={fullMessage} multiline w={220} withArrow position="top-start" disabled={fullMessage.length <= 50} > <Text truncate>{truncate(fullMessage, 50)}</Text> </Tooltip> ) }, ellipsis: true, }, { accessor: 'status', title: 'Status', render: (broadcast) => { const stats = broadcastStatsMap.get(broadcast.id) let overallError = broadcast.status === Status.FAILED ? 'Broadcast failed' : undefined if (!overallError && stats?.failed > 0) { overallError = stats.firstError || 'Some recipients failed' } return <MessageStatus status={broadcast.status} error={overallError} /> }, width: 150, sortable: true, }, { accessor: 'stats', title: 'Recipients', render: (broadcast) => { const stats = broadcastStatsMap.get(broadcast.id) || defaultStats return ( <Stack gap={2}> <Text size="xs">Total: {stats.total}</Text> {stats.success > 0 && ( <Text size="xs" c="green"> {' '} Success: {stats.success}{' '} </Text> )} {(stats.pending > 0 || stats.running > 0) && ( <Text size="xs" c="yellow"> {' '} In Progress: {stats.pending + stats.running}{' '} </Text> )} {stats.failed > 0 && ( <Text size="xs" c="red"> {' '} Failed: {stats.failed}{' '} </Text> )} {stats.cancelled > 0 && ( <Text size="xs" c="gray"> {' '} Cancelled: {stats.cancelled}{' '} </Text> )} {stats.scheduled > 0 && ( <Text size="xs" c="blue"> {' '} Scheduled: {stats.scheduled}{' '} </Text> )} </Stack> ) }, width: 150, }, { accessor: 'actions', title: <Box mr="xs">Actions</Box>, textAlign: 'right', width: '0%', render: (broadcast) => { const stats = broadcastStatsMap.get(broadcast.id) || defaultStats const isFinished = [ Status.SUCCESS, Status.FAILED, Status.CANCELLED, ].includes(broadcast.status) const isRunning = [ Status.PENDING, Status.RUNNING, Status.SCHEDULER, ].includes(broadcast.status) return ( <Group gap={4} justify="flex-end" wrap="nowrap"> <Tooltip label="View Details"> <ActionIcon variant="subtle" color="blue" onClick={() => actions.onViewDetails(broadcast)} > <Icon icon="tabler:eye" /> </ActionIcon> </Tooltip> {isFinished && stats.failed > 0 && ( <Tooltip label="Resend to Failed"> <ActionIcon variant="subtle" color="purple" onClick={() => actions.onResendToFailed(broadcast)} > <Icon icon="tabler:send-off" /> </ActionIcon> </Tooltip> )} {!isRunning && ( <Tooltip label="Clone Broadcast"> <ActionIcon variant="subtle" color="teal" onClick={() => actions.onClone(broadcast)} > <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> )} <Menu shadow="md" position="left" withArrow> <Menu.Target> <ActionIcon variant="subtle"> <Icon icon="tabler:download" /> </ActionIcon> </Menu.Target> <Menu.Dropdown> <Menu.Item onClick={() => actions.onExport(broadcast, 'csv')}> <Text>Export as CSV</Text> </Menu.Item> <Menu.Item onClick={() => actions.onExport(broadcast, 'xlsx')}> <Text>Export as XLSX</Text> </Menu.Item> </Menu.Dropdown> </Menu> {isRunning && ( <Tooltip label="Cancel Broadcast"> <ActionIcon variant="subtle" color="orange" onClick={() => actions.onCancel(broadcast.id)} > <Icon icon="tabler:player-stop" /> </ActionIcon> </Tooltip> )} {isFinished && ( <Tooltip label="Delete Broadcast"> <ActionIcon variant="subtle" color="red" onClick={() => actions.onDelete(broadcast)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> )} </Group> ) }, }, ] }
```

# src/features/broadcast/components/Datatable/MessageStatus.tsx

```tsx
import { Status } from '@/constants' import { Icon } from '@iconify/react' import { ActionIcon, Group, Loader, Text, Tooltip } from '@mantine/core' import _ from 'lodash' import React from 'react' interface Props { status: string error?: string | null } const MessageStatus: React.FC<Props> = ({ status, error = null }: Props) => { const statuses = { [Status.RUNNING]: ( <Group gap={2}> <Loader color="yellow" size={16} /> <Text fw={500} c={'yellow'}> Running </Text> </Group> ), [Status.PENDING]: ( <Group gap={0}> <ActionIcon variant="transparent"> <Icon icon="tabler:clock" fontSize={18} /> </ActionIcon> <Text fw={500}>Pending</Text> </Group> ), [Status.SUCCESS]: ( <Group gap={0}> <ActionIcon variant="transparent" color="green"> <Icon icon="tabler:checks" fontSize={18} /> </ActionIcon> <Text fw={500} c={'green'}> Done </Text> </Group> ), [Status.CANCELLED]: ( <Group gap={0}> <ActionIcon variant="transparent" color="red"> <Icon icon="tabler:cancel" fontSize={18} /> </ActionIcon> <Text fw={500} c={'red'}> Cancelled </Text> </Group> ), [Status.FAILED]: ( <Tooltip label={error} position="top"> <Group gap={0}> <ActionIcon variant="transparent" color="red"> <Icon icon="tabler:x" fontSize={18} /> </ActionIcon> <Text fw={500} c={'red'}> Failed </Text> </Group> </Tooltip> ), [Status.SCHEDULER]: ( <Group gap={0}> <Text fw={500}>In queue</Text> </Group> ), } return statuses[status] } export default MessageStatus
```

# src/features/broadcast/components/Datatable/MessageType.tsx

```tsx
// src/features/broadcast/components/Datatable/MessageType.tsx import { Message } from '@/constants' import { Icon } from '@iconify/react' import { Group, Text } from '@mantine/core' import _ from 'lodash' import React from 'react' interface Props { type: string } const MessageType: React.FC<Props> = ({ type }: Props) => { const icons = { [Message.TEXT]: 'tabler:text-size', [Message.IMAGE]: 'tabler:photo', [Message.VIDEO]: 'tabler:video', [Message.FILE]: 'tabler:file-text', [Message.MEDIA]: 'tabler:library-photo', [Message.BUTTON]: 'tabler:hand-finger', [Message.LIST]: 'tabler:list', [Message.LOCATION]: 'tabler:map-pin', [Message.POLL]: 'tabler:list-details', [Message.VCARD]: 'tabler:user-square', } const icon = icons[type] ?? 'tabler:text-size' return ( <Group gap={4}> <Icon icon={icon} fontSize={18} /> </Group> ) } export default MessageType
```

# src/features/broadcast/components/Form/AntiBlockingSettings.tsx

```tsx
import InputTyping from '@/components/Input/InputTyping' import { Icon } from '@iconify/react' import { ActionIcon, Fieldset, Group, NumberInput, Popover, Stack, Switch, Text, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' interface Props { form: UseFormReturnType<any> } /** * @component AntiBlockingSettings * @description A sub-component for ModalCreateBroadcast that groups all anti-blocking settings. * This includes delay settings, typing effect, and message pausing. */ const AntiBlockingSettings: React.FC<Props> = ({ form }) => { return ( <Fieldset legend={ <Group gap="xs"> <Text fw={500}>Anti-Blocking Settings</Text> <Popover width={300} position="top" withArrow shadow="md"> <Popover.Target> <ActionIcon variant="transparent" radius="xl" size="sm"> <Icon icon="tabler:help-circle" /> </ActionIcon> </Popover.Target> <Popover.Dropdown style={{ pointerEvents: 'none' }}> <Text size="sm"> These settings help mimic human-like sending behavior to reduce the risk of your account being blocked by WhatsApp. It is highly recommended to use random delays and pauses, especially when sending to a large number of contacts. </Text> </Popover.Dropdown> </Popover> </Group> } > <Stack> <InputTyping form={form} /> <Group grow> <NumberInput label="Min Delay (sec)" description="Minimum time between messages." min={1} {...form.getInputProps('delayMin')} /> <NumberInput label="Max Delay (sec)" description="Maximum time between messages." min={1} {...form.getInputProps('delayMax')} /> </Group> <Switch label="Pause after a number of messages" {...form.getInputProps('pauseEnabled', { type: 'checkbox' })} /> {form.values.pauseEnabled && ( <Group grow> <NumberInput label="Pause After (messages)" description="Number of messages to send before pausing." min={1} {...form.getInputProps('pauseAfter')} /> <NumberInput label="Pause For (minutes)" description="How long to pause the broadcast." min={1} {...form.getInputProps('pauseDuration')} /> </Group> )} </Stack> </Fieldset> ) } export default AntiBlockingSettings
```

# src/features/broadcast/components/Form/BroadcastActions.tsx

```tsx
import { Icon } from '@iconify/react' import { Button, Group } from '@mantine/core' import { isFuture } from 'date-fns' import React from 'react' interface Props { onPreview: () => void onSend: () => void isPreviewing: boolean isScheduled: boolean scheduledAt: Date | null } /** * @component BroadcastActions * @description A sub-component for ModalCreateBroadcast that holds the main action buttons. * It displays "Send Preview" and a dynamic "Send/Schedule Broadcast" button. */ const BroadcastActions: React.FC<Props> = ({ onPreview, onSend, isPreviewing, isScheduled, scheduledAt, }) => { const isScheduledForFuture = isScheduled && scheduledAt && isFuture(new Date(scheduledAt)) return ( <Group justify="flex-end" mt="lg"> <Button variant="outline" leftSection={<Icon icon="tabler:send-2" fontSize={18} />} onClick={onPreview} loading={isPreviewing} disabled={isPreviewing} > Send Preview </Button> <Button leftSection={<Icon icon="tabler:send" fontSize={18} />} onClick={onSend} > {isScheduledForFuture ? 'Schedule Broadcast' : 'Send Broadcast'} </Button> </Group> ) } export default BroadcastActions
```

# src/features/broadcast/components/Form/BroadcastScheduler.tsx

```tsx
import InputSendLater from '@/components/Input/InputSendLater' import { Icon } from '@iconify/react' import { Group, Stack, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' interface Props { form: UseFormReturnType<any> estimatedTime: string } /** * @component BroadcastScheduler * @description A sub-component for ModalCreateBroadcast that handles scheduling. * It contains the "Send Later" switch and date/time picker, and displays the estimated completion time. */ const BroadcastScheduler: React.FC<Props> = ({ form, estimatedTime }) => { return ( <Stack> <InputSendLater form={form} /> {estimatedTime && ( <Group justify="flex-start" mt="lg" p="xs" style={{ backgroundColor: 'var(--mantine-color-gray-0)', borderRadius: 'var(--mantine-radius-sm)', border: '1px solid var(--mantine-color-gray-2)', }} > <Icon icon="tabler:clock-hour-4" style={{ verticalAlign: 'middle', color: 'var(--mantine-color-dimmed)', }} /> <Text size="sm" c="dimmed"> <b>Estimated Completion:</b> {estimatedTime} </Text> </Group> )} </Stack> ) } export default BroadcastScheduler
```

# src/features/broadcast/components/Form/RecipientManager.tsx

```tsx
import { Icon } from '@iconify/react' import { Button, Group, Stack, Text } from '@mantine/core' import React from 'react' interface Props { recipientCount: number error?: string | any onClear: () => void onManage: () => void } /** * @component RecipientManager * @description A sub-component for ModalCreateBroadcast that handles the UI for managing recipients. * It displays the recipient count and provides buttons to clear or manage the recipient list. */ const RecipientManager: React.FC<Props> = ({ recipientCount, error, onClear, onManage, }) => { return ( <Stack gap="xs"> <Group justify="space-between"> <Text fw={500}>Recipients ({recipientCount})</Text> <Group> <Button variant="outline" color="red" size="compact-sm" onClick={onClear} disabled={recipientCount === 0} leftSection={<Icon icon="tabler:x" fontSize={16} />} > Clear Recipients </Button> <Button variant="outline" size="compact-sm" onClick={onManage} leftSection={<Icon icon="tabler:users-plus" fontSize={16} />} > Manage Recipients </Button> </Group> </Group> {error && ( <Text c="red" size="sm"> {error} </Text> )} </Stack> ) } export default RecipientManager
```

# src/features/broadcast/components/Listeners/BroadcastListener.tsx

```tsx
import { Action } from '@/constants' import useBroadcast from '@/features/broadcast/hooks/useBroadcast' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import _ from 'lodash' import { useEffect } from 'react' const BroadcastListener: React.FC = () => { const wa = useWa() const broadcast = useBroadcast() useWindowMessage(async (event: MessageEvent) => { const { data: { action }, } = event switch (action) { case Action.Window.SEND_BROADCAST: await broadcast.init() break default: break } }) useEffect(() => { if (!wa.isReady) return broadcast .init() .then(() => { console.log('Broadcast listener initialized.') }) .catch(console.error) const interval = setInterval(broadcast.checkScheduled, 5000) return () => { clearInterval(interval) } }, [wa.isReady]) return null } export default BroadcastListener
```

# src/features/broadcast/components/Modal/ModalCreateBroadcast.tsx

```tsx
import InputMessage from '@/components/Input/Message/InputMessage' import Modal from '@/components/Modal/Modal' import type { Broadcast } from '@/libs/db' import { ScrollArea, Stack, TextInput } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import React from 'react' import { useBroadcastForm } from '../../hooks/useBroadcastForm' import AntiBlockingSettings from '../Form/AntiBlockingSettings' import BroadcastActions from '../Form/BroadcastActions' import BroadcastScheduler from '../Form/BroadcastScheduler' import RecipientManager from '../Form/RecipientManager' import ModalFirstBroadcastWarning from './ModalFirstBroadcastWarning' import ModalManageSources from './ModalManageSources' interface Props { opened: boolean onClose: () => void onSuccess: () => void cloneData?: (Broadcast & { recipients?: any[] }) | null } const ModalCreateBroadcast: React.FC<Props> = ({ opened, onClose, onSuccess, cloneData = null, }) => { const [showWarningModal, warningModalHandlers] = useDisclosure(false) const [showSourcesModal, sourcesModalHandlers] = useDisclosure(false) const { form, inputMessageForm, isPreviewing, estimatedTime, handleClose, handlePreviewBroadcast, handleSendBroadcast, handleWarningAccepted, } = useBroadcastForm({ cloneData, onSuccess, onClose, }) // This handler remains in the component as it deals with another modal's state. const handleUpdateRecipients = (newNumbers: any[]) => { form.setFieldValue('numbers', newNumbers) sourcesModalHandlers.close() } // This handler orchestrates the send action, opening the warning modal if needed. const onSendClick = async () => { const result = await handleSendBroadcast() if (result === false) { warningModalHandlers.open() } } return ( <> <Modal opened={opened} onClose={handleClose} w={900} withCloseButton> <ScrollArea h={650}> <Stack> <TextInput label="Broadcast Name" placeholder="e.g., Weekly Newsletter" {...form.getInputProps('name')} /> <RecipientManager recipientCount={form.values.numbers.length} error={form.errors.numbers} onClear={() => form.setFieldValue('numbers', [])} onManage={sourcesModalHandlers.open} /> <InputMessage form={inputMessageForm} /> <AntiBlockingSettings form={form} /> <BroadcastScheduler form={form} estimatedTime={estimatedTime} /> <BroadcastActions onPreview={handlePreviewBroadcast} onSend={onSendClick} isPreviewing={isPreviewing} isScheduled={form.values.scheduler.enabled} scheduledAt={form.values.scheduler.scheduledAt} /> </Stack> </ScrollArea> </Modal> <ModalManageSources opened={showSourcesModal} onClose={sourcesModalHandlers.close} onSubmit={handleUpdateRecipients} initialRecipients={form.values.numbers} /> <ModalFirstBroadcastWarning opened={showWarningModal} onClose={warningModalHandlers.close} onConfirm={async () => { warningModalHandlers.close() await handleWarningAccepted() }} /> </> ) } export default ModalCreateBroadcast
```

# src/features/broadcast/components/Modal/ModalCreateUpdateTemplate.tsx

```tsx
// src/components/Modal/ModalCreateUpdateTemplate.tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import db, { type BroadcastTemplate } from '@/libs/db' import { formHasErrors, isTypeMessageMedia } from '@/utils/util' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void data?: Partial<BroadcastTemplate> | null } const ModalCreateUpdateTemplate: React.FC<Props> = ({ opened, onClose, data = null, }: Props) => { const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => (_.isEmpty(value) ? 'Required' : null), }, }) // The useEffect hook for populating the form based on `data` prop. // This logic is complex and specific to this component, so it remains here. useEffect(() => { if (opened) { if (data) { form.setValues({ name: data.name }) const messageData = data.message as any const type = data.type inputMessageForm.reset() inputMessageForm.setFieldValue('type', type) switch (type) { case Message.TEXT: inputMessageForm.setFieldValue('inputText', messageData as string) break case Message.IMAGE: inputMessageForm.setFieldValue( 'inputImage.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputImage.file', null) break case Message.VIDEO: inputMessageForm.setFieldValue( 'inputVideo.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputVideo.file', null) break case Message.FILE: inputMessageForm.setFieldValue( 'inputFile.caption', messageData as string, ) inputMessageForm.setFieldValue('inputFile.file', null) break case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', messageData) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', messageData) break default: if (typeof messageData === 'string' && !isTypeMessageMedia(type)) { inputMessageForm.setFieldValue('inputText', messageData) } break } } else { form.reset() inputMessageForm.reset() } } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, opened]) // Separated logic for creating a new template. const handleCreate = async () => { const { type } = inputMessageForm.values const { name } = form.values const templateId = await db.broadcastTemplates.add({ name, type, message: getMessage(), }) if (isTypeMessageMedia(type)) { if (typeof templateId === 'number') { await insertBroadcastFile(templateId, Media.BROADCAST_TEMPLATE) } else { console.error('Failed to get templateId as number for media upload') } } } // Separated logic for updating an existing template. const handleUpdate = async () => { if (!data?.id) return const { type } = inputMessageForm.values const { name } = form.values const messagePayload = getMessage() await db.broadcastTemplates.update(data.id, { name, type, message: messagePayload, }) const newFileIsSelected = (type === Message.IMAGE && inputMessageForm.values.inputImage.file) || (type === Message.VIDEO && inputMessageForm.values.inputVideo.file) || (type === Message.FILE && inputMessageForm.values.inputFile.file) if (isTypeMessageMedia(type)) { if (newFileIsSelected) { // If a new file is selected, delete old media and add the new one await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() await insertBroadcastFile(data.id, Media.BROADCAST_TEMPLATE) } // If no new file is selected, and type is still media, existing media is preserved. } else if (isTypeMessageMedia(data.type) && !isTypeMessageMedia(type)) { // If type changed from media to non-media, delete old media. await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() } } // The main submit handler now decides which function to call. const handleSubmit = async () => { if (formHasErrors(form, inputMessageForm)) return if (data && data.id !== undefined) { await handleUpdate() } else { await handleCreate() } onClose() } const handleClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleClose} w={750} withCloseButton> <Stack justify="space-between"> <Stack> <Center> <Title order={3}>{data?.id ? 'Edit' : 'Create'} Template</Title> </Center> <TextInput label="Name" required {...form.getInputProps('name')} /> <InputMessage disabledTemplateButton form={inputMessageForm} /> </Stack> <Group align="end" justify="end"> <Button onClick={handleSubmit}>Submit</Button> </Group> </Stack> </Modal> ) } export default ModalCreateUpdateTemplate
```

# src/features/broadcast/components/Modal/ModalDetailHistory.tsx

```tsx
// src/features/broadcast/components/Modal/ModalDetailHistory.tsx import Modal from '@/components/Modal/Modal' import { Status } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import { Icon } from '@iconify/react' import { Box, Card, Center, Divider, Grid, Group, SimpleGrid, Stack, Text, ThemeIcon, Title, useMantineTheme, } from '@mantine/core' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import { DataTable } from 'mantine-datatable' // ++ ADDED: Import DataTable import React, { useEffect, useMemo, useState } from 'react' // ++ ADDED: Import useEffect and useState for pagination import MessageStatus from '../Datatable/MessageStatus' // This component displays campaign performance as a series of stacked, colored trapezoids. const FunnelChart = ({ stats }: { stats: any }) => { const theme = useMantineTheme() // Define the stages for the funnel, ensuring that stages with zero value are not rendered. const funnelData = [ { label: 'Total Recipients', value: stats.total, color: theme.colors.blue[7], }, { label: 'Successful', value: stats.success, color: theme.colors.teal[6] }, { label: 'Failed', value: stats.failed, color: theme.colors.red[6] }, { label: 'Cancelled', value: stats.cancelled, color: theme.colors.gray[6] }, ] .filter((item) => item.value > 0) .sort((a, b) => b.value - a.value) // Sort from largest to smallest for visual consistency. if (stats.total === 0) { return <Text c="dimmed">No data to visualize.</Text> } return ( <Stack align="center" gap={0}> {funnelData.map((item, index) => { // Calculate the width of the segment. This creates the funnel effect. const segmentWidth = 200 * (1 - index * 0.15) const percentageOfTotal = (item.value / stats.total) * 100 return ( <Box key={item.label} style={{ textAlign: 'center', marginBottom: -1 }} > {/* The trapezoid shape is created using CSS clip-path */} <Box style={{ height: 50, width: segmentWidth, backgroundColor: item.color, clipPath: 'polygon(10% 0, 90% 0, 100% 100%, 0% 100%)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', }} > <Stack gap={0} align="center"> <Text fw={700} size="sm" style={{ textShadow: '1px 1px 2px black' }} > {item.label} </Text> <Text size="xs" style={{ textShadow: '1px 1px 2px black' }}> {item.value} ({percentageOfTotal.toFixed(1)}%) </Text> </Stack> </Box> </Box> ) })} </Stack> ) } const PAGE_SIZE = 15 // Define page size for pagination const ModalDetailHistory: React.FC<{ opened: boolean onClose: () => void data?: Broadcast | null }> = ({ opened, onClose, data = null }) => { const contacts = useLiveQuery(async () => { if (!data?.id) return [] return await db.broadcastContacts .where({ broadcastId: data.id }) .toArray() }, [data]) || [] const [page, setPage] = useState(1) const [records, setRecords] = useState<BroadcastContact[]>([]) useEffect(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE setRecords(contacts.slice(from, to)) }, [page, contacts]) const { stats, summaryData } = useMemo(() => { const defaultStats = { total: 0, success: 0, failed: 0, pending: 0, running: 0, scheduled: 0, cancelled: 0, } if (!contacts || contacts.length === 0) { return { stats: defaultStats, summaryData: [] } } const total = contacts.length const success = contacts.filter((c) => c.status === Status.SUCCESS).length const failed = contacts.filter((c) => c.status === Status.FAILED).length const pending = contacts.filter((c) => c.status === Status.PENDING).length const running = contacts.filter((c) => c.status === Status.RUNNING).length const scheduled = contacts.filter( (c) => c.status === Status.SCHEDULER, ).length const cancelled = contacts.filter( (c) => c.status === Status.CANCELLED, ).length const calculatedStats = { total, success, failed, pending, running, scheduled, cancelled, } const summaryItems = [ { title: 'Success', value: success, color: 'teal', icon: 'tabler:circle-check', }, { title: 'Failed', value: failed, color: 'red', icon: 'tabler:circle-x' }, { title: 'Pending', value: pending, color: 'yellow', icon: 'tabler:clock', }, { title: 'Running', value: running, color: 'orange', icon: 'tabler:player-play', }, { title: 'Scheduled', value: scheduled, color: 'blue', icon: 'tabler:calendar-event', }, { title: 'Cancelled', value: cancelled, color: 'gray', icon: 'tabler:ban', }, ].filter((item) => item.value > 0) return { stats: calculatedStats, summaryData: summaryItems } }, [contacts]) const renderSummaryCards = () => { return summaryData.map((item) => ( <Card withBorder radius="md" p="sm" key={item.title}> <Group wrap="nowrap"> <ThemeIcon color={item.color} variant="light" size={40} radius="md"> <Icon icon={item.icon} fontSize={24} /> </ThemeIcon> <div> <Text c="dimmed" size="xs" tt="uppercase" fw={700}> {item.title} </Text> <Text fw={700} size="xl"> {item.value} </Text> </div> </Group> </Card> )) } return ( <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack p="md"> <Title order={3} ta="center"> Report for: {data?.name || 'Broadcast'} </Title> {contacts && contacts.length > 0 ? ( <> <Card withBorder radius="md" mt="md" shadow="none"> <Grid align="center"> <Grid.Col span={{ base: 12, md: 4 }}> <Center h={230}> <FunnelChart stats={stats} /> </Center> </Grid.Col> <Grid.Col span={{ base: 12, md: 8 }}> <SimpleGrid cols={{ base: 2, sm: 3 }} spacing="lg"> {renderSummaryCards()} </SimpleGrid> </Grid.Col> </Grid> </Card> <Divider my="md" label="Recipient Details" labelPosition="center" /> {/* ++ MODIFIED: Replaced ScrollArea and Table with paginated DataTable */} <DataTable height={350} records={records} totalRecords={contacts.length} recordsPerPage={PAGE_SIZE} page={page} onPageChange={(p) => setPage(p)} noRecordsText="No recipient data available" striped highlightOnHover withTableBorder columns={[ { accessor: 'recipient', title: 'Recipient', render: (contact) => contact.name || contact.number, }, { accessor: 'status', title: 'Status', render: (contact) => ( <MessageStatus status={contact.status} error={contact.error} /> ), }, { accessor: 'sentAt', title: 'Sent At', render: (contact) => contact.sendAt ? dayjs(contact.sendAt).format('DD/MM/YYYY HH:mm') : '-', }, ]} /> </> ) : ( <Center h={200}> <Stack align="center"> <Icon icon="tabler:database-off" fontSize={48} color="gray" /> <Text c="dimmed"> No recipient data found for this broadcast. </Text> </Stack> </Center> )} </Stack> </Modal> ) } export default ModalDetailHistory
```

# src/features/broadcast/components/Modal/ModalEditRecipient.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (recipient: { number: string; name: string }) => void recipientData: { number: string; name: string } | null } const ModalEditRecipient: React.FC<Props> = ({ opened, onClose, onSubmit, recipientData, }) => { const form = useForm({ initialValues: { name: '', number: '', }, validate: { name: (value) => value.trim().length > 0 ? null : 'Name cannot be empty', }, }) useEffect(() => { if (recipientData) { form.setValues({ name: recipientData.name, number: recipientData.number, }) } else { form.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [recipientData, opened]) const handleSubmit = (values: { name: string; number: string }) => { onSubmit(values) onClose() } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Edit Recipient</Title> </Center> <TextInput label="Name" placeholder="Enter contact name" {...form.getInputProps('name')} data-autofocus /> <TextInput label="Number" readOnly {...form.getInputProps('number')} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Save Changes</Button> </Group> </Stack> </form> </Modal> ) } export default ModalEditRecipient
```

# src/features/broadcast/components/Modal/ModalFirstBroadcastWarning.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Checkbox, Group, List, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void onConfirm: () => void } const ModalFirstBroadcastWarning: React.FC<Props> = ({ opened, onClose, onConfirm, }) => { const [acknowledged, setAcknowledged] = useState(false) const handleConfirm = () => { if (acknowledged) { onConfirm() } } return ( <Modal opened={opened} onClose={onClose} w={600} withCloseButton> <Stack p="md"> <Title order={3} ta="center"> Important: Please Read Before Broadcasting </Title> <Text c="dimmed" ta="center" size="sm" mb="md"> Broadcasting on WhatsApp carries a risk of account blocking if not done carefully. To protect your account, please follow these best practices. </Text> <Stack gap="lg"> <div> <Text fw={500}>Best Practices (Do's)</Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item> <b>Warm-Up Your Account:</b> Start by sending to a small number of contacts if your account is new or rarely used. </List.Item> <List.Item> <b>Use Personalization:</b> Utilize Spintax {'{Hi|Hello}'} and variables like {'{name}'} to make each message unique. </List.Item> <List.Item> <b>Prioritize Known Contacts:</b> Sending to contacts who have saved your number is significantly safer. </List.Item> <List.Item> <b>Provide an Opt-Out:</b> Include a message like "Reply STOP to unsubscribe" to reduce spam reports. </List.Item> </List> </div> <div> <Text fw={500}>Things to Avoid (Don'ts)</Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="red" size={20} radius="xl"> <Icon icon="tabler:x" fontSize={14} /> </ThemeIcon> } > <List.Item> <b>Don't Bulk-Send to Strangers:</b> This is the fastest way to get your account banned. </List.Item> <List.Item> <b>Don't Send Identical Messages:</b> Always use message variation. </List.Item> </List> </div> </Stack> <Checkbox mt="xl" checked={acknowledged} onChange={(event) => setAcknowledged(event.currentTarget.checked)} label="I understand the risks and will use this feature responsibly." /> <Group justify="flex-end" mt="xl"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleConfirm} disabled={!acknowledged}> Continue </Button> </Group> </Stack> </Modal> ) } export default ModalFirstBroadcastWarning
```

# src/features/broadcast/components/Modal/ModalLoadRecipientList.tsx

```tsx
import Modal from '@/components/Modal/Modal' import db, { type BroadcastRecipient } from '@/libs/db' import { Icon } from '@iconify/react' import { ActionIcon, Button, Card, Center, Group, Loader, ScrollArea, Stack, Text, Title, Tooltip, } from '@mantine/core' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import React from 'react' interface Props { opened: boolean onClose: () => void onLoad: (recipients: any[]) => void } const ModalLoadRecipientList: React.FC<Props> = ({ opened, onClose, onLoad, }) => { const recipientLists = useLiveQuery( () => db.broadcastRecipients.orderBy('createdAt').reverse().toArray(), [], ) const handleDelete = async (id: number) => { if (confirm('Are you sure you want to delete this list?')) { await db.broadcastRecipients.delete(id) } } const handleLoad = (list: BroadcastRecipient) => { onLoad(list.recipients) onClose() } return ( <Modal opened={opened} onClose={onClose} w={700} withCloseButton> <Stack p="sm"> <Center> <Title order={3}>Load Recipient List</Title> </Center> <ScrollArea h={450} mt="md"> <Stack> {/* ++ ADDED: Show a loader while fetching data. */} {recipientLists === undefined && ( <Center p="xl"> <Loader /> </Center> )} {recipientLists && recipientLists.length === 0 && ( <Center h={150}> <Stack align="center" gap="sm"> <Icon icon="tabler:list-off" fontSize={48} color="gray" /> <Text c="dimmed">No saved recipient lists found.</Text> </Stack> </Center> )} {recipientLists?.map((list) => ( <Card withBorder shadow="none" key={list.id} p="md" radius="md"> <Group justify="space-between"> <Stack gap={2}> <Text fw={500}>{list.name}</Text> <Text size="sm" c="dimmed"> {list.recipients.length} recipients | Saved on{' '} {dayjs(list.createdAt).format('DD MMM YYYY')} </Text> </Stack> <Group gap="xs"> <Tooltip label="Delete List"> <ActionIcon color="red" variant="subtle" onClick={() => handleDelete(list.id)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> <Button variant="light" size="xs" onClick={() => handleLoad(list)} > Load </Button> </Group> </Group> </Card> ))} </Stack> </ScrollArea> </Stack> </Modal> ) } export default ModalLoadRecipientList
```

# src/features/broadcast/components/Modal/ModalManageSources.tsx

```tsx
// src/features/broadcast/components/Modal/ModalManageSources.tsx import Modal from '@/components/Modal/Modal' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Menu, Stack, Text, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import _ from 'lodash' import { DataTable, type DataTableColumn } from 'mantine-datatable' import React, { useEffect, useState } from 'react' import ModalEditRecipient from './ModalEditRecipient' import ModalLoadRecipientList from './ModalLoadRecipientList' import ModalSaveRecipientList from './ModalSaveRecipientList' import ModalSourceExcel from './ModalSourceExcel' import ModalSourceGroups from './ModalSourceGroups' import ModalSourceManual from './ModalSourceManual' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void initialRecipients: any[] } const PAGE_SIZE = 10 // Define page size for pagination const ModalManageSources: React.FC<Props> = ({ opened, onClose, onSubmit, initialRecipients, }) => { const [recipients, setRecipients] = useState<any[]>([]) const [editingRecipient, setEditingRecipient] = useState<any | null>(null) const [page, setPage] = useState(1) const [paginatedRecipients, setPaginatedRecipients] = useState<any[]>([]) const [showManualModal, manualModalHandlers] = useDisclosure(false) const [showExcelModal, excelModalHandlers] = useDisclosure(false) const [showGroupsModal, groupsModalHandlers] = useDisclosure(false) const [showEditModal, editModalHandlers] = useDisclosure(false) const [showSaveListModal, saveListModalHandlers] = useDisclosure(false) const [showLoadListModal, loadListModalHandlers] = useDisclosure(false) // Sync with initial recipients when modal opens useEffect(() => { if (opened) { setRecipients(_.cloneDeep(initialRecipients)) setPage(1) // Reset to first page on open } }, [opened, initialRecipients]) useEffect(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE setPaginatedRecipients(recipients.slice(from, to)) }, [recipients, page]) const handleAddRecipients = (newRecipients: any[]) => { const formattedNewRecipients = newRecipients.map((rec) => { if (typeof rec === 'string') { return { number: rec, name: 'N/A', source: 'Manual' } } return { number: rec.number || rec.phoneNumber, name: rec.name || rec.savedName || rec.publicName || 'N/A', source: rec.source || 'Import', } }) const initialCount = recipients.length const combined = [...recipients, ...formattedNewRecipients] const uniqueRecipients = _.uniqBy(combined, 'number') const finalCount = uniqueRecipients.length setRecipients(uniqueRecipients) const addedCount = finalCount - initialCount const duplicateCount = combined.length - finalCount if (addedCount > 0 && duplicateCount > 0) { toast.info( `${addedCount} recipient(s) added. ${duplicateCount} duplicate(s) were automatically removed.`, ) } else if (addedCount > 0) { toast.success(`${addedCount} recipient(s) added successfully.`) } else if (duplicateCount > 0) { toast.info( `No new recipients added. ${duplicateCount} duplicate(s) were found.`, ) } else { toast.info('No new recipients were added.') } } const handleDeleteRecipient = (numberToDelete: string) => { setRecipients((current) => current.filter((r) => r.number !== numberToDelete), ) } const handleOpenEditModal = (recipient: any) => { setEditingRecipient(recipient) editModalHandlers.open() } const handleUpdateRecipient = (updatedData: { number: string name: string }) => { setRecipients((currentRecipients) => currentRecipients.map((r) => r.number === updatedData.number ? { ...r, name: updatedData.name } : r, ), ) editModalHandlers.close() } const handleClearAll = () => { setRecipients([]) } const handleConfirm = () => { onSubmit(recipients) onClose() } const columns: DataTableColumn<any>[] = [ { accessor: 'name', title: 'Name', ellipsis: true }, { accessor: 'number', title: 'Number', ellipsis: true }, { accessor: 'actions', title: <Text>Actions</Text>, textAlign: 'right', width: '0%', render: (recipient) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Edit"> <ActionIcon size="sm" variant="subtle" color="blue" onClick={() => handleOpenEditModal(recipient)} > <Icon icon="tabler:edit" /> </ActionIcon> </Tooltip> <Tooltip label="Delete"> <ActionIcon size="sm" variant="subtle" color="red" onClick={() => handleDeleteRecipient(recipient.number)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ] return ( <> <Modal opened={opened} onClose={onClose} w={900} withCloseButton> <Stack justify="space-between" h={'calc(80vh)'} p="sm"> <Stack> <Group justify="space-between"> <Text fw={500}>Current Recipients ({recipients.length})</Text> <Group> <Button size="xs" color="blue" variant="outline" onClick={saveListModalHandlers.open} disabled={recipients.length === 0} leftSection={ <Icon icon="tabler:device-floppy" fontSize={16} /> } > Save List </Button> <Button size="xs" color="red" variant="outline" onClick={handleClearAll} disabled={recipients.length === 0} leftSection={<Icon icon="tabler:x" fontSize={16} />} > Clear All </Button> <Menu shadow="md"> <Menu.Target> <Button size="xs" leftSection={<Icon icon="tabler:plus" fontSize={16} />} > Add Recipients </Button> </Menu.Target> <Menu.Dropdown> <Menu.Label>Saved Lists</Menu.Label> <Menu.Item leftSection={ <Icon icon="tabler:list-check" fontSize={16} /> } onClick={loadListModalHandlers.open} > Load from Saved List </Menu.Item> <Menu.Divider /> <Menu.Label>Sources</Menu.Label> <Menu.Item leftSection={ <Icon icon="tabler:keyboard" fontSize={16} /> } onClick={manualModalHandlers.open} > Manual Input </Menu.Item> <Menu.Item leftSection={ <Icon icon="tabler:file-type-xls" fontSize={16} /> } onClick={excelModalHandlers.open} > From Excel </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:users" fontSize={16} />} onClick={groupsModalHandlers.open} > From Groups </Menu.Item> </Menu.Dropdown> </Menu> </Group> </Group> {/* ++ MODIFIED: Replaced ScrollArea with a paginated DataTable */} <DataTable height={'calc(70vh - 120px)'} records={paginatedRecipients} columns={columns} totalRecords={recipients.length} recordsPerPage={PAGE_SIZE} page={page} onPageChange={(p) => setPage(p)} minHeight={recipients.length === 0 ? 150 : 0} noRecordsText="No recipients added yet." withTableBorder={false} striped /> </Stack> <Group justify="flex-end"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleConfirm}>Confirm & Close</Button> </Group> </Stack> </Modal> <ModalEditRecipient opened={showEditModal} onClose={editModalHandlers.close} onSubmit={handleUpdateRecipient} recipientData={editingRecipient} /> <ModalSourceManual opened={showManualModal} onClose={manualModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceExcel opened={showExcelModal} onClose={excelModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceGroups opened={showGroupsModal} onClose={groupsModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSaveRecipientList opened={showSaveListModal} onClose={saveListModalHandlers.close} recipients={recipients} /> <ModalLoadRecipientList opened={showLoadListModal} onClose={loadListModalHandlers.close} onLoad={handleAddRecipients} /> </> ) } export default ModalManageSources
```

# src/features/broadcast/components/Modal/ModalManageTemplate.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import useDataQuery from '@/hooks/useDataQuery' import useLicense from '@/hooks/useLicense' import type { BroadcastTemplate } from '@/libs/db' import db from '@/libs/db' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Stack, TextInput, Title, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import MessageType from '../Datatable/MessageType' import ModalCreateUpdateTemplate from './ModalCreateUpdateTemplate' interface Props { opened: boolean onClose: () => void } const ModalManageTemplate: React.FC<Props> = ({ opened, onClose }) => { const license = useLicense() const dataQuery = useDataQuery<BroadcastTemplate>({ table: db.broadcastTemplates, }) const [editingTemplate, setEditingTemplate] = useState<Partial<BroadcastTemplate> | null>(null) const [showModalCreateUpdate, modalCreateUpdate] = useDisclosure(false) const handleDelete = async (template: BroadcastTemplate) => { if (!confirm('Are you sure you want to delete this template?')) return // First, delete any associated media to prevent orphaned data. await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: template.id }) .delete() // After associated media is deleted, delete the template itself. await db.broadcastTemplates.delete(template.id) } const handleEdit = (template: BroadcastTemplate) => { setEditingTemplate(template) modalCreateUpdate.open() } // ADDED: Handler for cloning a template. const handleClone = (template: BroadcastTemplate) => { // Create a new template object for cloning, omitting the id // and appending "(Copy)" to the name. This ensures it's treated as a new entry. const { id, ...restOfTemplate } = template const clonedTemplate = { ...restOfTemplate, name: `${template.name} (Copy)`, } setEditingTemplate(clonedTemplate) modalCreateUpdate.open() } const handleOpenCreateModal = () => { if (license.isFree() && dataQuery.totalRecords >= 1) { showModalUpgrade() return } setEditingTemplate(null) modalCreateUpdate.open() } const renderMessage = (broadcastTemplate: BroadcastTemplate) => { const { message } = broadcastTemplate if (!message) return '-' const typeContent = { [Message.TEXT]: typeof message === 'string' ? message : JSON.stringify(message), [Message.MEDIA]: message.caption, [Message.IMAGE]: message.caption, [Message.VIDEO]: message.caption, [Message.FILE]: typeof message === 'string' ? message : message.caption, [Message.BUTTON]: message.title, [Message.LIST]: message.title, [Message.LOCATION]: message.name, [Message.POLL]: message.name, [Message.VCARD]: '-', } return typeContent[broadcastTemplate.type] || JSON.stringify(message) } return ( <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack> <Center> <Title order={3}>Manage Templates</Title> </Center> <Stack gap={0} p={'md'}> <Group justify="space-between"> <TextInput placeholder={`Search by ${dataQuery.searchField}...`} size="sm" value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} /> <Button size="xs" leftSection={<Icon icon="tabler:plus" fontSize={20} />} onClick={handleOpenCreateModal} > {' '} Add{' '} </Button> </Group> <DataTable records={dataQuery?.data} totalRecords={dataQuery?.totalRecords} recordsPerPage={dataQuery?.pageSize} page={dataQuery?.page} onPageChange={dataQuery?.setPage} columns={[ { accessor: 'name' }, { accessor: 'type', render: (record) => <MessageType type={record.type} />, }, { accessor: 'message', title: 'Message', render: renderMessage, }, { accessor: 'actions', title: '', textAlign: 'right', render: (template: BroadcastTemplate) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Edit Template" position="top"> <ActionIcon color="blue" variant="subtle" onClick={() => handleEdit(template)} > <Icon icon="tabler:edit" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Clone Template" position="top"> <ActionIcon color="teal" variant="subtle" onClick={() => handleClone(template)} > <Icon icon="tabler:copy" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Delete Template" position="top"> <ActionIcon color="red" variant="subtle" onClick={async () => await handleDelete(template)} > <Icon icon="tabler:trash" fontSize={22} /> </ActionIcon> </Tooltip> </Group> ), }, ]} /> </Stack> <ModalCreateUpdateTemplate opened={showModalCreateUpdate} onClose={() => { modalCreateUpdate.close() setEditingTemplate(null) }} data={editingTemplate} /> </Stack> </Modal> ) } export default ModalManageTemplate
```

# src/features/broadcast/components/Modal/ModalSaveRecipientList.tsx

```tsx
import Modal from '@/components/Modal/Modal' import db from '@/libs/db' import toast from '@/utils/toast' import { Button, Center, Group, Stack, Text, TextInput, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import React from 'react' interface Props { opened: boolean onClose: () => void recipients: any[] } const ModalSaveRecipientList: React.FC<Props> = ({ opened, onClose, recipients, }) => { const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => value.trim().length > 0 ? null : 'List name is required', }, }) const handleSubmit = async (values: { name: string }) => { try { await db.broadcastRecipients.add({ name: values.name, recipients: recipients, createdAt: new Date(), }) toast.success(`Recipient list "${values.name}" saved successfully!`) handleClose() } catch (error) { console.error('Failed to save recipient list:', error) toast.error('An error occurred while saving the list.') } } const handleClose = () => { form.reset() onClose() } return ( <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Save Recipient List</Title> </Center> <Text ta="center" size="sm" c="dimmed"> Save the current {recipients.length} recipients as a list for future use. </Text> <TextInput label="List Name" placeholder="e.g., Weekly Newsletter Subscribers" required {...form.getInputProps('name')} data-autofocus /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button type="submit">Save List</Button> </Group> </Stack> </form> </Modal> ) } export default ModalSaveRecipientList
```

# src/features/broadcast/components/Modal/ModalSourceExcel.tsx

```tsx
import ExcelUploader from '@/components/Input/Excel/ExcelUploader' import Modal from '@/components/Modal/Modal' import { Center, Stack, Title } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } const ModalSourceExcel: React.FC<Props> = ({ opened, onClose, onSubmit }) => { // This handler receives the raw parsed data from the uploader and formats it // for the broadcast recipient list before passing it up to the parent. const handleConfirmUpload = (parsedData: any[]) => { const newRecipients = parsedData .map((item) => ({ number: item.number?.toString(), name: item.name?.toString() || 'From Excel', source: 'Excel', })) .filter((item) => item.number) if (newRecipients.length > 0) { onSubmit(newRecipients) } } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Numbers From Excel</Title> </Center> <ExcelUploader onConfirm={handleConfirmUpload} onClose={onClose} /> </Stack> </Modal> ) } export default ModalSourceExcel
```

# src/features/broadcast/components/Modal/ModalSourceGroups.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Button, Card, Center, Checkbox, Group, Image, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' import React, { useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } /** * @component ModalSourceGroups * @description A modal component to select recipients from the user's WhatsApp groups. * It now includes a search functionality to filter groups by name. */ const ModalSourceGroups: React.FC<Props> = ({ opened, onClose, onSubmit }) => { const { groups } = useAppStore() const [selectedGroups, setSelectedGroups] = useState<string[]>([]) const [searchQuery, setSearchQuery] = useState('') const filteredAndFormattedGroups = useMemo(() => { const lowerCaseQuery = searchQuery.toLowerCase() return ( groups ?.filter((group: any) => group.name?.toLowerCase()?.includes(lowerCaseQuery), ) .map((group: any) => ({ avatar: group.contact.avatar, label: `${group.name}`, value: group.id, })) || [] ) }, [groups, searchQuery]) const handleToggleGroup = (groupId: string) => { setSelectedGroups((prev) => prev.includes(groupId) ? prev.filter((id) => id !== groupId) : [...prev, groupId], ) } const handleSubmit = () => { const finalRecipients = groups ?.filter((group: any) => selectedGroups.includes(group.id)) .map((group: any) => ({ number: group.id, // The group's ID (e.g., xxxxx@g.us) name: group.name, // The group's name source: 'Group', // The source identifier })) || [] onSubmit(finalRecipients) handleClose() } const handleClose = () => { setSelectedGroups([]) setSearchQuery('') // Reset search on close onClose() } return ( <> <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Select groups</Title> </Center> <TextInput placeholder="Search groups by name..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={groups.length === 0} /> <When condition={groups.length === 0}> <Center h={200}> <Loader /> <Text ml="md">Loading groups...</Text> </Center> </When> <When condition={groups.length > 0}> <ScrollArea h={300}> {filteredAndFormattedGroups.length > 0 ? ( <Stack> {filteredAndFormattedGroups.map((group) => ( <Card key={group.value} withBorder p="xs" radius="sm" style={{ cursor: 'pointer' }} onClick={() => handleToggleGroup(group.value)} > <Group> <Checkbox checked={selectedGroups.includes(group.value)} readOnly aria-label={`Select group ${group.label}`} /> <Group justify="start"> <Image radius={'lg'} src={group.avatar} h={40} w={40} fit="contain" /> <Text>{group.label}</Text> </Group> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No groups match your search.</Text> </Center> )} </ScrollArea> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedGroups.length === 0} > Add {selectedGroups.length} Group(s) </Button> </Group> </Stack> </Modal> </> ) } export default ModalSourceGroups
```

# src/features/broadcast/components/Modal/ModalSourceManual.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { Button, Center, Group, Stack, TagsInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import React from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (numbers: string[]) => void } const ModalSourceManual: React.FC<Props> = ({ opened, onClose, onSubmit }) => { const form = useForm({ initialValues: { numbers: [] as string[], }, validate: { numbers: (value) => value.length === 0 ? 'Please enter at least one number.' : null, }, }) const handleSubmit = (values: { numbers: string[] }) => { onSubmit(values.numbers) form.reset() onClose() } return ( <> <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Add Numbers Manually</Title> </Center> <TagsInput label="Phone Numbers" placeholder="Enter number with country code and press Enter" description="Example: 6281234567890" {...form.getInputProps('numbers')} clearable /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Add Numbers</Button> </Group> </Stack> </form> </Modal> </> ) } export default ModalSourceManual
```

# src/features/broadcast/helpers/broadcastActions.ts

```ts
// src/features/broadcast/helpers/broadcastActions.ts import { Media, Message } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import wa from '@/libs/wa' import MediaModel from '@/models/MediaModel' import parse from '@/utils/parse' import throwError from '@/utils/throwError' import { generateRandomDelay } from '@/utils/util' /** * @description Returns the appropriate sending function based on broadcast type. * @param {Broadcast} broadcast - The parent broadcast record. * @param {BroadcastContact} contact - The recipient contact. * @returns {Function | null} The async function to send the message, or null. */ export const getBroadcastAction = ( broadcast: Broadcast, contact: BroadcastContact, ) => { const sendOptions = { ...(broadcast.isTyping && { delay: generateRandomDelay(1000, 3000) }), } const actions: { [key: string]: () => Promise<any> } = { [Message.TEXT]: async () => { const text = await parse.text(broadcast.message as string, contact.number) return wa.send.text(contact.number, text, sendOptions) }, [Message.IMAGE]: async () => { const file = await MediaModel.findFirstByParent( broadcast.id, Media.BROADCAST, ) if (!file) throwError.mediaNotFound() const message = broadcast.message as { caption?: string } return wa.send.file(contact.number, file.file, { type: 'image', caption: message.caption, ...sendOptions, }) }, [Message.VIDEO]: async () => { const file = await MediaModel.findFirstByParent( broadcast.id, Media.BROADCAST, ) if (!file) throwError.mediaNotFound() const message = broadcast.message as { caption?: string } return wa.send.file(contact.number, file.file, { type: 'video', caption: message.caption, ...sendOptions, }) }, [Message.FILE]: async () => { const file = await MediaModel.findFirstByParent( broadcast.id, Media.BROADCAST, ) if (!file) throwError.mediaNotFound() return wa.send.file(contact.number, file.file, { type: 'document', caption: broadcast.message as string, ...sendOptions, }) }, [Message.LOCATION]: async () => { const message = broadcast.message as any return wa.send.location(contact.number, { ...message, ...sendOptions }) }, [Message.POLL]: async () => { const { name, choices } = broadcast.message as any return wa.send.poll(contact.number, name, choices, sendOptions) }, [Message.VCARD]: async () => { return wa.send.vcard( contact.number, broadcast.message as any[], sendOptions, ) }, } return actions[broadcast.type] || null }
```

# src/features/broadcast/hooks/useBroadcast.ts

```ts
// src/features/Broadcast/hooks/useBroadcast.ts import { Status } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import BroadcastContactModel from '@/models/BroadcastContactModel' import BroadcastModel from '@/models/BroadcastModel' import toast from '@/utils/toast' import { delay } from '@/utils/util' import dayjs from 'dayjs' import _ from 'lodash' import { useRef } from 'react' import { getBroadcastAction } from '../helpers/broadcastActions' /** * @hook useBroadcast * @description Manages the entire broadcast queue processing logic. * It uses a state machine ('IDLE', 'PROCESSING') to prevent concurrent runs * and processes pending messages in a linear loop. */ const useBroadcast = () => { const processingState = useRef<'IDLE' | 'PROCESSING'>('IDLE') /** * Checks if a broadcast needs to pause based on its settings after a message is sent. * @param {Broadcast} broadcast - The parent broadcast record. */ const checkAndApplyPause = async (broadcast: Broadcast) => { if ( !broadcast.pauseEnabled || !broadcast.pauseAfter || !broadcast.pauseDuration ) { return } // This query is faster now due to the compound index [broadcastId+status] const successCount = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.SUCCESS }) .count() if (successCount > 0 && successCount % broadcast.pauseAfter === 0) { const pausedUntil = dayjs() .add(broadcast.pauseDuration, 'minutes') .toDate() await db.broadcasts.update(broadcast.id, { status: Status.PAUSED, pausedUntil: pausedUntil, }) toast.info( `Broadcast "${broadcast.name}" paused for ${broadcast.pauseDuration} minutes.`, ) } } /** * Executes the sending logic for a single contact. * @param {Broadcast} broadcast - The parent broadcast. * @param {BroadcastContact} contact - The recipient contact. */ const runBroadcast = async ( broadcast: Broadcast, contact: BroadcastContact, ) => { const randomDelay = Math.floor( Math.random() * (broadcast.delayMax - broadcast.delayMin + 1), ) + broadcast.delayMin await delay(randomDelay) const action = getBroadcastAction(broadcast, contact) if (action) { await action() } else { throw new Error(`Unsupported broadcast message type: ${broadcast.type}`) } } /** * Checks if all contacts for a broadcast are done and updates the status. * @param {Broadcast} broadcast - The broadcast to check. */ const checkAllContactsDone = async (broadcast: Broadcast) => { // This query is now more efficient due to the compound index. const pendingCount = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.PENDING }) .count() const runningCount = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.RUNNING }) .count() if (pendingCount === 0 && runningCount === 0) { await BroadcastModel.success(broadcast.id) toast.success( `Broadcast "${broadcast.name || 'Untitled'}" has been completed.`, ) } } /** * The main processing loop for the broadcast queue. */ const processBroadcastQueue = async () => { if (processingState.current === 'PROCESSING') return processingState.current = 'PROCESSING' try { while (true) { // 1. Fetch contacts in a batch instead of one by one. const contacts = await BroadcastContactModel.getStatusPendingBatch(20) if (!contacts.length) break // No more pending contacts, exit the loop. // 2. Group contacts by their parent broadcast ID. const contactsByBroadcast = _.groupBy(contacts, 'broadcastId') // 3. Process each group. for (const broadcastIdStr in contactsByBroadcast) { const broadcastId = parseInt(broadcastIdStr, 10) const contactGroup = contactsByBroadcast[broadcastId] // 4. Fetch the parent broadcast object ONCE per group. const broadcast = await BroadcastModel.get(broadcastId) if (!broadcast || broadcast.status === Status.PAUSED) { if (!broadcast) { // Mark contacts as failed if their parent broadcast is missing. const contactIds = contactGroup.map((c) => c.id) await db.broadcastContacts .bulkUpdate( contactIds.map((id) => ({ key: id, changes: { status: Status.FAILED, error: 'Broadcast record missing.', }, })), ) .catch(console.error) } continue // Skip to the next group. } if (broadcast.status !== Status.RUNNING) { await BroadcastModel.running(broadcast.id) } // 5. Process each contact within the group. for (const contact of contactGroup) { if (!validationRef.current) return // Allow cancellation mid-batch try { await BroadcastContactModel.running(contact.id) await runBroadcast(broadcast, contact) await BroadcastContactModel.success(contact.id) await checkAndApplyPause(broadcast) // Check for pause after each success } catch (error: any) { await BroadcastContactModel.failed(contact.id, error.message) } } // 6. Check if the entire broadcast is done after processing a batch. await checkAllContactsDone(broadcast) } } } catch (e) { console.error( 'An unexpected error occurred in the broadcast processor:', e, ) } finally { processingState.current = 'IDLE' } } /** * Checks for scheduled items and resumes paused campaigns. */ const checkScheduled = async () => { const now = new Date() // Resume paused broadcasts const unpausedCount = await db.broadcasts .where('status') .equals(Status.PAUSED) .and((b) => b.pausedUntil! <= now) .modify({ status: Status.PENDING, pausedUntil: null }) if (unpausedCount > 0) { toast.info(`Resumed ${unpausedCount} paused broadcast(s).`) } // Mark scheduled contacts as 'PENDING' await db.broadcastContacts .where('status') .equals(Status.SCHEDULER) .and((contact) => dayjs(contact.scheduledAt).isBefore(now)) .modify({ status: Status.PENDING }) await processBroadcastQueue() } const validationRef = useRef(true) // Added for cancellation logic /** * Cancels a running or scheduled broadcast. */ const cancel = async (broadcastId: number) => { validationRef.current = false // Stop processing loop while (processingState.current === 'PROCESSING') { await delay(200) // Wait for current message to finish } processingState.current = 'PROCESSING' try { await db.broadcastContacts .where({ broadcastId }) .and((c) => [Status.PENDING, Status.SCHEDULER].includes(c.status)) .modify({ status: Status.CANCELLED, error: 'Cancelled by user' }) await BroadcastModel.cancel(broadcastId) toast.info('Broadcast has been cancelled.') } catch (e) { console.error(`Error during cancellation of broadcast ${broadcastId}:`, e) toast.error('Failed to cancel broadcast.') } finally { validationRef.current = true // Reset for next run processingState.current = 'IDLE' } } const initializeBroadcaster = async () => { await BroadcastContactModel.resetRunningStatuses() await processBroadcastQueue() } return { init: initializeBroadcaster, checkScheduled, cancel } } export default useBroadcast
```

# src/features/broadcast/hooks/useBroadcastForm.ts

```ts
import useInputMessage from '@/components/Input/Message/useInputMessage' import { Media, Message, Setting, Status } from '@/constants' import useLicense from '@/hooks/useLicense' import db, { type Broadcast, type BroadcastContact } from '@/libs/db' import { storage } from '@/libs/storage' import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' import parse from '@/utils/parse' import toast from '@/utils/toast' import { formHasErrors, isTypeMessageMedia, showModalUpgrade, } from '@/utils/util' import { useForm } from '@mantine/form' import { addMinutes, isFuture } from 'date-fns' import _ from 'lodash' import { useEffect, useMemo, useState } from 'react' const defaultValues = { name: '', numbers: [] as any[], isTyping: false, scheduler: { enabled: false, scheduledAt: addMinutes(new Date(), 5), }, delayMin: 3, delayMax: 6, pauseEnabled: false, pauseAfter: 50, pauseDuration: 5, } interface useBroadcastFormProps { cloneData?: (Broadcast & { recipients?: any[] }) | null onSuccess: () => void onClose: () => void } /** * @hook useBroadcastForm * @description Encapsulates all the logic for creating and editing a broadcast campaign. * This includes form management, validation, data cloning, and submission handlers. */ export const useBroadcastForm = ({ cloneData = null, onSuccess, onClose, }: useBroadcastFormProps) => { const license = useLicense() const [isPreviewing, setIsPreviewing] = useState(false) const { profile } = useAppStore() const form = useForm({ initialValues: defaultValues, validate: { numbers: (value) => { if (_.isEmpty(value)) return 'At least one recipient is required' if (license.isFree() && value.length > 5) { form.setFieldValue('numbers', _.initial(value)) showModalUpgrade() return 'Free plan allows up to 5 contacts.' } return null }, isTyping: (value) => { if (license.isFree() && value) { form.setFieldValue('isTyping', false) showModalUpgrade() return 'Typing effect is a Pro feature.' } return null }, scheduler: (value) => { if (license.isFree() && value.enabled) { form.setFieldValue('scheduler.enabled', false) showModalUpgrade() return 'Scheduler is a Pro feature.' } if (value.enabled && !value.scheduledAt) { return 'Scheduled date and time is required.' } if ( value.enabled && value.scheduledAt && !isFuture(new Date(value.scheduledAt)) ) { return 'Scheduled time must be in the future.' } return null }, delayMin: (value) => !value || value < 1 ? 'Minimum delay must be at least 1 second.' : null, delayMax: (value, values) => { if (!value || value < 1) return 'Maximum delay must be at least 1 second.' if (values.delayMin && value < values.delayMin) { return 'Max delay cannot be less than min delay.' } return null }, pauseAfter: (value, values) => values.pauseEnabled && (!value || value < 1) ? 'Please enter a valid number of messages.' : null, pauseDuration: (value, values) => values.pauseEnabled && (!value || value < 1) ? 'Please enter a valid pause duration in minutes.' : null, }, validateInputOnChange: ['numbers'], }) const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() const estimatedTime = useMemo(() => { const { numbers, delayMin, delayMax, pauseEnabled, pauseAfter, pauseDuration, } = form.values const recipientCount = numbers.length if ( recipientCount === 0 || !delayMin || !delayMax || delayMin <= 0 || delayMax <= 0 ) { return '' } let minSeconds = recipientCount * delayMin let maxSeconds = recipientCount * delayMax if (pauseEnabled && pauseAfter > 0 && pauseDuration > 0) { const numberOfPauses = Math.floor((recipientCount - 1) / pauseAfter) if (numberOfPauses > 0) { const totalPauseSeconds = numberOfPauses * pauseDuration * 60 minSeconds += totalPauseSeconds maxSeconds += totalPauseSeconds } } const minMinutes = Math.round(minSeconds / 60) const maxMinutes = Math.round(maxSeconds / 60) if (maxMinutes < 1) return 'Less than a minute.' if (minMinutes === maxMinutes) return `About ${minMinutes} minute${minMinutes > 1 ? 's' : ''}.` return `About ${minMinutes} to ${maxMinutes} minutes.` }, [form.values]) // Effect for populating form when cloning data useEffect(() => { const populateForm = async () => { if (cloneData) { let recipientsToSet: any[] = [] let nameSuffix = ' (Copy)' const broadcastName = `${cloneData.name || 'Broadcast'}` if (cloneData.recipients && cloneData.recipients.length > 0) { recipientsToSet = cloneData.recipients nameSuffix = ' (Resend)' } else { const originalRecipients = await db.broadcastContacts .where({ broadcastId: cloneData.id }) .toArray() recipientsToSet = originalRecipients.map((contact) => ({ number: contact.number, name: contact.name, })) } form.setValues({ name: `${broadcastName}${nameSuffix}`, numbers: recipientsToSet, isTyping: !!cloneData.isTyping, scheduler: { enabled: false, scheduledAt: addMinutes(new Date(), 5), }, delayMin: cloneData.delayMin ? cloneData.delayMin / 1000 : 3, delayMax: cloneData.delayMax ? cloneData.delayMax / 1000 : 6, pauseEnabled: !!cloneData.pauseEnabled, pauseAfter: cloneData.pauseAfter || 50, pauseDuration: cloneData.pauseDuration || 5, }) const { type, message } = cloneData inputMessageForm.setFieldValue('type', type) switch (type) { case Message.TEXT: inputMessageForm.setFieldValue('inputText', message as string) break case Message.IMAGE: case Message.VIDEO: case Message.FILE: const mediaFile = await db.media .where({ parentId: cloneData.id, type: Media.BROADCAST }) .first() const caption = (message as any)?.caption || (typeof message === 'string' ? message : '') if (type === Message.IMAGE) { inputMessageForm.setFieldValue('inputImage', { file: mediaFile?.file || null, caption, }) } else if (type === Message.VIDEO) { inputMessageForm.setFieldValue('inputVideo', { file: mediaFile?.file || null, caption, }) } else { inputMessageForm.setFieldValue('inputFile', { file: mediaFile?.file || null, caption, }) } break case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', message) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', message) break } } } if (cloneData) { populateForm().catch(console.error) } else { form.reset() inputMessageForm.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [cloneData]) const handleClose = () => { form.reset() inputMessageForm.reset() onClose() } const handlePreviewBroadcast = async () => { if (formHasErrors(form, inputMessageForm)) return setIsPreviewing(true) const { type } = inputMessageForm.values const myChatId = `${profile?.number}@c.us` if (!myChatId) { toast.error( 'Could not retrieve your number for the preview. Please try again.', ) setIsPreviewing(false) return } try { switch (type) { case Message.TEXT: await wa.send.text( myChatId, await parse.text(inputMessageForm.values.inputText, myChatId), ) break case Message.IMAGE: if (!inputMessageForm.values.inputImage.file) throw new Error() await wa.send.file( myChatId, inputMessageForm.values.inputImage.file, { type: 'image', caption: await parse.text( inputMessageForm.values.inputImage.caption, myChatId, ), }, ) break // NOTE: Previews for other media types can be added here. default: toast.info( 'Preview is currently only available for text and image messages.', ) break } toast.success('Preview sent to your number!') } catch (e) { toast.error('Failed to send preview. Please check your message content.') } finally { setIsPreviewing(false) } } const proceedWithBroadcast = async () => { const broadcastData = { ...form.values, type: inputMessageForm.values.type, message: getMessage(), isTyping: form.values.isTyping ? 1 : 0, isScheduler: form.values.scheduler.enabled ? 1 : 0, status: Status.PENDING, delayMin: form.values.delayMin * 1000, delayMax: form.values.delayMax * 1000, pauseEnabled: form.values.pauseEnabled ? 1 : 0, } try { //@ts-ignore const broadcastId = await db.broadcasts.add(broadcastData as Broadcast) if (isTypeMessageMedia(inputMessageForm.values.type)) { await insertBroadcastFile(broadcastId, Media.BROADCAST) } //@ts-ignore const contacts: BroadcastContact[] = form.values.numbers.map( (recipient: any) => ({ broadcastId, number: recipient.number, name: recipient.name, status: form.values.scheduler.enabled ? Status.SCHEDULER : Status.PENDING, scheduledAt: form.values.scheduler.enabled ? form.values.scheduler.scheduledAt : null, }), ) await db.broadcastContacts.bulkAdd(contacts) onSuccess() } catch (error) { console.error('Failed to save broadcast:', error) toast.error('An error occurred while saving the broadcast.') } } const handleSendBroadcast = async () => { if (formHasErrors(form, inputMessageForm)) return const hasAcknowledged = await storage.get( Setting.HAS_ACKNOWLEDGED_BROADCAST_WARNING, ) if (!hasAcknowledged) { return false // Indicate that the warning modal should be shown } await proceedWithBroadcast() return true // Indicate that the action was performed } const handleWarningAccepted = async () => { await storage.set(Setting.HAS_ACKNOWLEDGED_BROADCAST_WARNING, true) await proceedWithBroadcast() } return { form, inputMessageForm, isPreviewing, estimatedTime, handleClose, handlePreviewBroadcast, handleSendBroadcast, handleWarningAccepted, } }
```

# src/features/broadcast/PageBroadcast.tsx

```tsx
// src/features/Broadcast/PageBroadcast.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Media, Status } from '@/constants' import useDataQuery from '@/hooks/useDataQuery' import useFile from '@/hooks/useFile' import useLicense from '@/hooks/useLicense' import type { Broadcast } from '@/libs/db' import db from '@/libs/db' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Box, Button, Group, LoadingOverlay, Stack, TextInput, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import { DataTable } from 'mantine-datatable' import React, { useMemo, useState } from 'react' import { getBroadcastColumns } from './components/Datatable/BroadcastColumns' import ModalCreateBroadcast from './components/Modal/ModalCreateBroadcast' import ModalDetailHistory from './components/Modal/ModalDetailHistory' import useBroadcast from './hooks/useBroadcast' const PageBroadcast: React.FC = () => { const dataQuery = useDataQuery<Broadcast>({ table: db.broadcasts, initialPageSize: 10, searchField: 'name', initialSort: { field: 'id', direction: 'desc' }, }) const broadcastHook = useBroadcast() const fileExporter = useFile() const allBroadcastContacts = useLiveQuery(() => db.broadcastContacts.toArray(), []) || [] const [showModalCreate, modalCreateHandlers] = useDisclosure(false) const [showModalDetail, modalDetailHandlers] = useDisclosure(false) const [detailData, setDetailData] = useState<Broadcast | null>(null) const [cloneData, setCloneData] = useState< (Broadcast & { recipients?: any[] }) | null >(null) const [isExporting, setIsExporting] = useState(false) // This avoids re-calculating stats for every row on every render. const broadcastStatsMap = useMemo(() => { const statsMap = new Map< number, { total: number success: number pending: number running: number failed: number scheduled: number cancelled: number firstError?: string } >() for (const contact of allBroadcastContacts) { if (!statsMap.has(contact.broadcastId)) { statsMap.set(contact.broadcastId, { total: 0, success: 0, pending: 0, running: 0, failed: 0, scheduled: 0, cancelled: 0, }) } const stats = statsMap.get(contact.broadcastId)! stats.total++ switch (contact.status) { case Status.SUCCESS: stats.success++ break case Status.PENDING: stats.pending++ break case Status.RUNNING: stats.running++ break case Status.FAILED: stats.failed++ // Store the first error message found for tooltip display if (!stats.firstError && contact.error) { stats.firstError = contact.error } break case Status.SCHEDULER: stats.scheduled++ break case Status.CANCELLED: stats.cancelled++ break } } return statsMap }, [allBroadcastContacts]) const handleOpenCreateModal = ( dataToClone: (Broadcast & { recipients?: any[] }) | null = null, ) => { setCloneData(dataToClone) modalCreateHandlers.open() } const handleResendToFailed = async (broadcast: Broadcast) => { const failedRecipients = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.FAILED }) .toArray() if (failedRecipients.length === 0) { toast.info('No failed recipients to resend to.') return } const recipients = failedRecipients.map((c) => ({ number: c.number, name: c.name, })) handleOpenCreateModal({ ...broadcast, recipients }) } const handleViewDetails = (broadcast: Broadcast) => { setDetailData(broadcast) modalDetailHandlers.open() } const handleDelete = async (broadcast: Broadcast) => { if ( !confirm( `Are you sure you want to delete broadcast "${ broadcast.name || `ID ${broadcast.id}` }"? This is irreversible.`, ) ) return try { await db.transaction( 'rw', db.broadcasts, db.broadcastContacts, db.media, async () => { await db.broadcastContacts .where({ broadcastId: broadcast.id }) .delete() await db.media .where({ parentId: broadcast.id, type: Media.BROADCAST }) .delete() await db.broadcasts.delete(broadcast.id) }, ) toast.success('Broadcast deleted successfully.') } catch (error) { console.error('Failed to delete broadcast:', error) toast.error('Failed to delete broadcast.') } } const handleExport = async (broadcast: Broadcast, format: string) => { setIsExporting(true) try { const contacts = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .toArray() if (contacts.length === 0) { toast.info('No data to export.') return } const dataForExport = contacts.map((c) => ({ Name: c.name || '-', 'Number/ID': c.number.split('@')[0], Status: c.status, 'Sent At': c.sendAt ? new Date(c.sendAt).toLocaleString() : '-', Error: c.error || '-', })) const filename = `broadcast_${ broadcast.name || broadcast.id }_${new Date().toISOString().slice(0, 10)}` await fileExporter.saveAs(format, dataForExport, filename) } catch (error) { console.error('Failed to export broadcast data:', error) toast.error('An error occurred during export.') } finally { setIsExporting(false) } } const columns = getBroadcastColumns( { onViewDetails: handleViewDetails, onResendToFailed: handleResendToFailed, onClone: handleOpenCreateModal, onExport: handleExport, onCancel: broadcastHook.cancel, onDelete: handleDelete, }, broadcastStatsMap, ) return ( <LayoutPage title="Broadcast"> <Stack style={{ height: '100%' }}> <Group justify="space-between" mb="md"> <TextInput placeholder="Search by Name" value={dataQuery.search} size="sm" onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} /> <Button leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={() => handleOpenCreateModal()} > Create Broadcast </Button> </Group> <Box style={{ position: 'relative' }}> <LoadingOverlay visible={isExporting || dataQuery.data === undefined} zIndex={1000} overlayProps={{ radius: 'sm', blur: 2 }} /> <DataTable records={dataQuery.data} columns={columns} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} sortStatus={ dataQuery.sort ? { columnAccessor: dataQuery.sort.field, direction: dataQuery.sort.direction, } : undefined } onSortStatusChange={(status) => { if (typeof status.columnAccessor === 'string') { dataQuery.toggleSort(status.columnAccessor) } }} minHeight={200} noRecordsText="No broadcasts found" striped highlightOnHover withTableBorder borderRadius="sm" shadow="xs" verticalAlign="top" /> </Box> </Stack> <ModalCreateBroadcast opened={showModalCreate} onClose={() => { modalCreateHandlers.close() setCloneData(null) }} onSuccess={() => { modalCreateHandlers.close() setCloneData(null) }} cloneData={cloneData} /> <ModalDetailHistory opened={showModalDetail} onClose={modalDetailHandlers.close} data={detailData} /> </LayoutPage> ) } export default PageBroadcast
```

# src/features/faq/PageFaq.tsx

```tsx
import LayoutPage from '@/components/Layout/LayoutPage' import { Icon } from '@iconify/react' import { Accordion, Anchor, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' const faqData = [ { icon: 'tabler:key', question: 'Where can I find my license key?', answer: 'You will receive an email from Lemon Squeezy after making a purchase. This email usually contains your purchase details and your license key.', }, { icon: 'tabler:shield-lock', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our priority. This extension does not collect, store, or share any personal data from your WhatsApp account. All processes occur locally on your device.', }, { icon: 'tabler:mail-question', question: 'How can I get more help and support?', answer: 'If you have other questions or need assistance, please feel free to email us at extdotninja@gmail.com. Our team will be happy to help you.', }, ] const PageFaq: React.FC = () => { return ( <LayoutPage title="Help & FAQ"> <Stack p="md"> {/* Accordion */} <Accordion variant="separated" radius="md"> {faqData.map((item) => ( <Accordion.Item key={item.question} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > <Text fw={500}>{item.question}</Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6}> {item.answer} </Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> {/* Contact Support */} <Paper withBorder p="md" shadow="none" radius="md" mt="xl"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still have questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us via email. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Paper> </Stack> </LayoutPage> ) } export default PageFaq
```

# src/features/home/PageHome.tsx

```tsx
import LayoutPage from '@/components/Layout/LayoutPage' import React, { useMemo } from 'react' const PageHome: React.FC = () => { return ( <LayoutPage title="Home"> Lorem ipsum dolor sit amet consectetur adipisicing elit. Non ullam nulla reiciendis omnis iure dolore, nihil adipisci tempore repellat quisquam asperiores illum minus et enim sunt saepe amet quas molestiae. </LayoutPage> ) } export default PageHome
```

# src/features/label/components/ModalCreateUpdateLabel.tsx

```tsx
import Modal from '@/components/Modal/Modal' import type { Label } from '@/libs/db' import db from '@/libs/db' import toast from '@/utils/toast' import { Button, Center, ColorInput, Group, Stack, Switch, Text, TextInput, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect } from 'react' interface Props { opened: boolean data?: Label | null onClose: () => void onSuccess?: () => void } const ModalCreateUpdateLabel: React.FC<Props> = ({ opened, data, onClose, onSuccess, }: Props) => { const form = useForm({ initialValues: { name: '', group: '', color: '#228be6', isPinned: false, }, validate: { name: (value) => { if (_.isEmpty(value)) { return 'Required' } if (value.length > 20) { return 'Max 20 characters' } return null }, }, }) useEffect(() => { if (data && opened) { form.setValues({ name: data.label || '', group: data.group || '', color: data.color || '#228be6', isPinned: data.isPinned === 1, }) } else { form.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, opened]) const handleCreate = async (values: typeof form.values) => { const payload = { label: values.name, value: values.name, group: values.group, color: values.color, isPinned: values.isPinned ? 1 : 0, } try { await db.labels.add({ ...payload, show: 1, custom: 1, numbers: [] }) toast.success(`Label "${values.name}" created successfully.`) onSuccess?.() onClose() } catch (error) { console.error('Failed to create label:', error) toast.error('An error occurred while creating the label.') } } const handleUpdate = async (values: typeof form.values) => { if (!data?.id) return const payload = { label: values.name, value: values.name, group: values.group, color: values.color, isPinned: values.isPinned ? 1 : 0, } try { await db.labels.update(data.id, payload) toast.success(`Label "${values.name}" updated successfully.`) onSuccess?.() onClose() } catch (error) { console.error('Failed to update label:', error) toast.error('An error occurred while updating the label.') } } // The main submit handler. const handleSubmit = async (values: typeof form.values) => { if (data && data.id) { await handleUpdate(values) } else { await handleCreate(values) } form.reset() } return ( <Modal opened={opened} onClose={onClose} w={500} withCloseButton style={{ zIndex: 9999 }} > <form onSubmit={form.onSubmit(handleSubmit)}> <Stack justify="space-between"> <Stack> <Center> <Title order={3}>{data ? 'Edit' : 'Create'} Label</Title> </Center> <TextInput label="Name" required data-autofocus {...form.getInputProps('name')} /> <TextInput label="Group (Optional)" placeholder="e.g., Leads, Customers" {...form.getInputProps('group')} /> <ColorInput label="Color" placeholder="Pick a color" {...form.getInputProps('color')} /> <Switch mt="md" label={ <Text fw={500} size="sm"> Pin to Header </Text> } description="Pinned labels appear first for quick access." {...form.getInputProps('isPinned', { type: 'checkbox' })} /> </Stack> <Group align="end" justify="end" mt="md"> <Button type="submit">{data ? 'Save Changes' : 'Submit'}</Button> </Group> </Stack> </form> </Modal> ) } export default ModalCreateUpdateLabel
```

# src/features/label/PageLabel.tsx

```tsx
import LayoutPage from '@/components/Layout/LayoutPage' import useDataQuery from '@/hooks/useDataQuery' import type { Label } from '@/libs/db' import db from '@/libs/db' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Box, Button, Group, Stack, Text, TextInput, Title, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable, type DataTableColumn } from 'mantine-datatable' import React, { useMemo, useState } from 'react' import ModalCreateUpdateLabel from './components/ModalCreateUpdateLabel' /** * @component PageLabels * @description A dedicated page for managing and viewing analytics for all labels. */ const PageLabels: React.FC = () => { // A custom hook to handle data fetching, searching, and sorting for the table. const dataQuery = useDataQuery<Label>({ table: db.labels, searchField: 'label', initialSort: { field: 'label', direction: 'asc' }, }) const [showCreateUpdateModal, createUpdateModalHandlers] = useDisclosure(false) const [editingLabel, setEditingLabel] = useState<Label | null>(null) const [showManageContactsModal, manageContactsModalHandlers] = useDisclosure(false) const [selectedLabel, setSelectedLabel] = useState<Label | null>(null) // Handlers for CRUD operations const handleCreate = () => { setEditingLabel(null) createUpdateModalHandlers.open() } const handleEdit = (label: Label) => { setEditingLabel(label) createUpdateModalHandlers.open() } const handleManageContacts = (label: Label) => { setSelectedLabel(label) manageContactsModalHandlers.open() } const handleDelete = async (label: Label) => { if ( confirm(`Are you sure you want to delete the label "${label.label}"?`) ) { try { await db.labels.delete(label.id) toast.success(`Label "${label.label}" has been deleted.`) } catch (error) { console.error('Failed to delete label:', error) toast.error('An error occurred while deleting the label.') } } } const columns = useMemo<DataTableColumn<Label>[]>( () => [ { accessor: 'label', title: 'Name', sortable: true, render: (label) => ( <Badge color={label.color || 'gray'}>{label.label}</Badge> ), }, { accessor: 'group', title: 'Group', sortable: true, render: (label) => label.group || <Text c="dimmed">-</Text>, }, { accessor: 'contacts', title: 'Contacts', // This column is not directly sortable via the query but can be sorted on the client side. render: (label) => label.numbers?.length || 0, }, { accessor: 'actions', title: <Box mr="xs">Actions</Box>, textAlign: 'right', render: (label) => ( <Group gap={4} justify="flex-end" wrap="nowrap"> <Tooltip label="Edit Label"> <ActionIcon variant="subtle" color="blue" onClick={() => handleEdit(label)} > <Icon icon="tabler:edit" /> </ActionIcon> </Tooltip> <Tooltip label="Delete Label"> <ActionIcon variant="subtle" color="red" onClick={() => handleDelete(label)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ], [], // Empty dependency array means this function runs only once. ) return ( <> <LayoutPage title="Labels"> <Stack gap="md"> <Group justify="space-between"> <TextInput placeholder="Search by label name..." value={dataQuery.search} size="sm" onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} /> <Button leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={handleCreate} > Add Label </Button> </Group> <DataTable records={dataQuery.data} columns={columns} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} sortStatus={ dataQuery.sort ? { columnAccessor: dataQuery.sort.field, direction: dataQuery.sort.direction, } : undefined } onSortStatusChange={(status) => { if (typeof status.columnAccessor === 'string') { dataQuery.toggleSort(status.columnAccessor) } }} minHeight={300} noRecordsText="No labels found." striped highlightOnHover withTableBorder borderRadius="sm" /> </Stack> </LayoutPage> {/* Modal for Creating/Updating Labels */} <ModalCreateUpdateLabel opened={showCreateUpdateModal} onClose={createUpdateModalHandlers.close} data={editingLabel} onSuccess={() => { // The useLiveQuery in useDataQuery will automatically refresh the data. createUpdateModalHandlers.close() }} /> </> ) } export default PageLabels
```

# src/features/profile/PageProfile.tsx

```tsx
// src/features/profile/PageProfile.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Setting } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import { showModalActivation, showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' import packageJson from '../../../package.json' const PageProfile: React.FC = () => { const license = useLicense() const { profile, license: licenseData } = useAppStore() const [licenseKey] = useStorage(Setting.LICENSE_KEY) const handleDeactivate = async () => { if ( confirm( 'Are you sure you want to deactivate your license on this device?', ) ) { await license.deactivate() } } const handleUpgrade = () => { showModalUpgrade() } const handleActivate = () => { showModalActivation() } const maskLicenseKey = (key: string | undefined | null) => { if (!key) return 'N/A' const keyParts = key.split('-') if (keyParts.length > 1) { return `****-****-****-${keyParts[keyParts.length - 1]}` } return '****' + key.slice(-4) } const InfoItem = ({ icon, label, value, }: { icon: string label: string value: React.ReactNode }) => ( <Group wrap="nowrap" gap="lg"> <ThemeIcon variant="light" size={36} radius="md"> <Icon icon={icon} fontSize={20} /> </ThemeIcon> <div> <Text size="xs" c="dimmed"> {label} </Text> <Text size="sm" fw={500}> {value || '-'} </Text> </div> </Group> ) return ( <LayoutPage title="My Profile"> <Stack> {/* Account Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Title order={5}>Account Details</Title> <Divider /> <InfoItem icon="tabler:device-mobile" label="Number" value={profile?.number} /> <InfoItem icon="tabler:map-pin" label="Country" value={profile?.country} /> <InfoItem icon="tabler:building-store" label="Account Type" value={profile?.type} /> <InfoItem icon="tabler:info-circle" label="App Version" value={packageJson.version} /> </Stack> </Card> {/* License Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>License Status</Title> <Badge color={license.isPro() ? 'teal' : 'gray'} size="lg" variant="filled" > {license.isPro() ? 'Pro' : 'Free'} </Badge> </Group> <Divider /> <When condition={license.isPro()}> <Stack my="xs" gap="sm"> <InfoItem icon="tabler:user" label="Licensed To" value={licenseData?.meta.customer_name} /> <InfoItem icon="tabler:mail" label="Email" value={licenseData?.meta.customer_email} /> <InfoItem icon="tabler:key" label="License Key" value={maskLicenseKey(licenseKey)} /> <InfoItem icon="tabler:calendar-event" label="Expires On" value={ licenseData?.license_key.expires_at ? dayjs(licenseData.license_key.expires_at).format( 'DD MMMM YYYY', ) : 'Lifetime' } /> </Stack> </When> <Text size="sm" c="dimmed"> {license.isPro() ? 'Thank you for being a Pro user! You have access to all features.' : 'Upgrade to Pro to unlock all features.'} </Text> <Group justify="flex-end" mt="md"> <When condition={license.isFree()}> <Button onClick={handleUpgrade} color="teal" leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Pro </Button> <Button onClick={handleActivate} variant="outline" leftSection={<Icon icon="tabler:key" fontSize={18} />} > Activate License </Button> </When> <When condition={license.isPro()}> <Button onClick={license.goToMyOrders} variant="outline" leftSection={<Icon icon="tabler:credit-card" fontSize={18} />} > Manage Subscription </Button> <Button onClick={handleDeactivate} color="red" variant="light" leftSection={<Icon icon="tabler:key-off" fontSize={18} />} > Deactivate License </Button> </When> </Group> </Stack> </Card> <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>Data Privacy Guarantee</Title> <ThemeIcon variant="light" color="teal"> <Icon icon="tabler:shield-check" fontSize={20} /> </ThemeIcon> </Group> <Divider /> <Text size="sm" c="dimmed"> All your data is stored only on your computer and is never sent to our servers. You have 100% control over your data. </Text> </Stack> </Card> </Stack> </LayoutPage> ) } export default PageProfile
```

# src/features/quick-reply/components/MediaPreviewCell.tsx

```tsx
// src/features/quick-reply/components/MediaPreviewCell.tsx import { Media, Message } from '@/constants' import type { QuickReply } from '@/libs/db' import db from '@/libs/db' import { generateVideoThumbnail } from '@/utils/util' import { Group, Image, Loader, Text } from '@mantine/core' import React, { useEffect, useState } from 'react' import { getQuickReplyMessagePreview } from '../helpers/preview' interface Props { reply: QuickReply } /** * @component MediaPreviewCell * @description A component for DataTable cells that asynchronously loads and displays * a thumbnail for media-based quick replies (Image/Video) alongside a text preview. */ const MediaPreviewCell: React.FC<Props> = ({ reply }) => { const [previewUrl, setPreviewUrl] = useState<string | null>(null) const [isLoading, setIsLoading] = useState(true) useEffect(() => { let isMounted = true const generatePreview = async () => { // Only attempt to load media for Image or Video types if (reply.type !== Message.IMAGE && reply.type !== Message.VIDEO) { setIsLoading(false) return } const media = await db.media .where({ parentId: reply.id, type: Media.QUICK_REPLY }) .first() if (media?.file && isMounted) { try { if (reply.type === Message.IMAGE) { const url = URL.createObjectURL(media.file) setPreviewUrl(url) } else if (reply.type === Message.VIDEO) { const thumbnailUrl = await generateVideoThumbnail(media.file) setPreviewUrl(thumbnailUrl) } } catch (error) { console.error('Failed to generate preview:', error) setPreviewUrl(null) } } setIsLoading(false) } generatePreview() return () => { isMounted = false if (previewUrl && previewUrl.startsWith('blob:')) { URL.revokeObjectURL(previewUrl) } } }, [reply]) // Use the new centralized helper function for a consistent text preview const textPreview = getQuickReplyMessagePreview(reply, 80) // Show a loader only while fetching media if ( isLoading && (reply.type === Message.IMAGE || reply.type === Message.VIDEO) ) { return <Loader size="xs" /> } return ( <Group gap="xs" wrap="nowrap" style={{ alignItems: 'center' }}> {previewUrl && ( <Image src={previewUrl} w={40} h={40} radius="sm" fit="cover" alt="Media preview" /> )} <Text size="sm" style={{ whiteSpace: 'normal', flex: 1 }}> {textPreview} </Text> </Group> ) } export default MediaPreviewCell
```

# src/features/quick-reply/components/Modal/ModalCreateUpdateQuickReply.tsx

```tsx
// src/features/quick-reply/components/Modal/ModalCreateUpdateQuickReply.tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import db, { type QuickReply } from '@/libs/db' import { formHasErrors, isTypeMessageMedia } from '@/utils/util' import { Button, Center, Group, Stack, Switch, Text, TextInput, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void data?: Partial<QuickReply> | null } const ModalCreateUpdateQuickReply: React.FC<Props> = ({ opened, onClose, data = null, }: Props) => { const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage({ isEditing: !!data?.id }) const form = useForm({ initialValues: { name: '', isPinned: false, }, validate: { name: (value) => (_.isEmpty(value) ? 'Required.' : null), }, }) // Effect to populate the form when editing an existing template. useEffect(() => { const populateForm = async () => { if (data) { form.setValues({ name: data.name, isPinned: data.isPinned === 1, }) const messageData = data.message as any const type = data.type inputMessageForm.reset() inputMessageForm.setFieldValue('type', type) if (isTypeMessageMedia(type) && data.id) { const media = await db.media .where({ parentId: data.id, type: Media.QUICK_REPLY }) .first() // If media is found, set it in the form to trigger the preview. if (media?.file) { switch (type) { case Message.IMAGE: inputMessageForm.setFieldValue( 'inputImage.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputImage.file', media.file) break case Message.VIDEO: inputMessageForm.setFieldValue( 'inputVideo.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputVideo.file', media.file) break case Message.FILE: inputMessageForm.setFieldValue( 'inputFile.caption', messageData as string, ) inputMessageForm.setFieldValue('inputFile.file', media.file) break } } } else if (type === Message.TEXT) { inputMessageForm.setFieldValue('inputText', messageData as string) } } else { form.reset() inputMessageForm.reset() } } if (opened) { populateForm() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, opened]) const handleCreate = async () => { const { type } = inputMessageForm.values const { name, isPinned } = form.values const id = await db.quickReplies.add({ name, type, message: getMessage(), isPinned: isPinned ? 1 : 0, createdAt: new Date(), }) if (isTypeMessageMedia(type)) { await insertBroadcastFile(id, Media.QUICK_REPLY) } } const handleUpdate = async () => { if (!data?.id) return const { type } = inputMessageForm.values const { name, isPinned } = form.values const messagePayload = getMessage() await db.quickReplies.update(data.id, { name, type, message: messagePayload, isPinned: isPinned ? 1 : 0, }) const newFileIsSelected = (type === Message.IMAGE && inputMessageForm.values.inputImage.file) || (type === Message.VIDEO && inputMessageForm.values.inputVideo.file) || (type === Message.FILE && inputMessageForm.values.inputFile.file) if (isTypeMessageMedia(type)) { if (newFileIsSelected) { await db.media .where({ parentId: data.id, type: Media.QUICK_REPLY }) .delete() await insertBroadcastFile(data.id, Media.QUICK_REPLY) } } else if ( data.type && isTypeMessageMedia(data.type) && !isTypeMessageMedia(type) ) { await db.media .where({ parentId: data.id, type: Media.QUICK_REPLY }) .delete() } } const handleSubmit = async () => { if (formHasErrors(form, inputMessageForm)) return if (data && data.id !== undefined) { await handleUpdate() } else { await handleCreate() } onClose() } return ( <Modal opened={opened} onClose={onClose} w={900} withCloseButton> <Stack justify="space-between"> <Stack> <Center> <Title order={3}>{data?.id ? 'Edit' : 'Create'} Quick Reply</Title> </Center> <TextInput label="Name" required {...form.getInputProps('name')} /> <Switch mt="md" label={ <Text fw={500} size="sm"> Pin to Top </Text> } description="Pinned replies always appear at the top of the list for quick access." {...form.getInputProps('isPinned', { type: 'checkbox' })} /> <InputMessage form={inputMessageForm} /> </Stack> <Group justify="end" mt="lg"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleSubmit}>Save</Button> </Group> </Stack> </Modal> ) } export default ModalCreateUpdateQuickReply
```

# src/features/quick-reply/components/Popover/PopoverQuickReplies.tsx

```tsx
// src/features/quick-reply/components/Popover/PopoverQuickReplies.tsx import { Media, Page } from '@/constants' import type { QuickReply } from '@/libs/db' import db from '@/libs/db' import page from '@/utils/page' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Popover, ScrollArea, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo, useState } from 'react' import ModalCreateUpdateQuickReply from '../Modal/ModalCreateUpdateQuickReply' import QuickReplyItem from './QuickReplyItem' /** * @component PopoverQuickReplies * @description A popover for quickly accessing and sending pre-defined replies. */ const PopoverQuickReplies: React.FC = () => { const [searchQuery, setSearchQuery] = useState('') const [showCreateModal, createModalHandlers] = useDisclosure(false) const quickReplies = useLiveQuery( async () => // Sort by isPinned (descending) then by createdAt (descending) (await db.quickReplies.toArray()).sort((a, b) => { const pinA = a.isPinned ? 1 : 0 const pinB = b.isPinned ? 1 : 0 if (pinB !== pinA) return pinB - pinA return (b.createdAt?.getTime() || 0) - (a.createdAt?.getTime() || 0) }), [], ) || [] const filteredReplies = useMemo(() => { if (!searchQuery) return quickReplies const lowerCaseQuery = searchQuery.toLowerCase() return quickReplies.filter( (reply) => reply.name.toLowerCase().includes(lowerCaseQuery) || (reply.type === 'TEXT' && (reply.message as string).toLowerCase().includes(lowerCaseQuery)), ) }, [quickReplies, searchQuery]) const handleDelete = async (reply: QuickReply) => { if (!window.confirm(`Are you sure you want to delete "${reply.name}"?`)) { return } try { await db.transaction('rw', db.quickReplies, db.media, async () => { await db.quickReplies.delete(reply.id) await db.media .where({ parentId: reply.id, type: Media.QUICK_REPLY }) .delete() }) toast.success(`"${reply.name}" was deleted.`) } catch (error) { console.error('Failed to delete quick reply:', error) toast.error('Could not delete the reply.') } } const handleTogglePin = async (reply: QuickReply) => { await db.quickReplies.update(reply.id, { isPinned: reply.isPinned ? 0 : 1, }) } return ( <> <Popover width={350} shadow="md" position="top-start"> <Popover.Target> <Tooltip label="Quick Replies" position="top" withArrow> <ActionIcon variant="subtle"> <Icon fontSize={24} icon={'tabler:replace'} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown> <Stack> <TextInput placeholder="Search..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="xs" onChange={(event) => setSearchQuery(event.currentTarget.value)} /> <ScrollArea h={300}> {filteredReplies.length > 0 ? ( <Stack> {filteredReplies.map((reply) => ( <QuickReplyItem key={reply.id} reply={reply} onDelete={handleDelete} onTogglePin={handleTogglePin} /> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed" size="sm" ta="center"> No replies found. <br /> Try a different search or create one! </Text> </Center> )} </ScrollArea> <Button variant="light" size="xs" fullWidth onClick={() => page.goTo(Page.QUICK_REPLY)} leftSection={<Icon icon="tabler:settings" fontSize={16} />} > Manage Quick Replies </Button> </Stack> </Popover.Dropdown> </Popover> <ModalCreateUpdateQuickReply opened={showCreateModal} onClose={createModalHandlers.close} /> </> ) } export default PopoverQuickReplies
```

# src/features/quick-reply/components/Popover/QuickReplyItem.tsx

```tsx
// src/features/quick-reply/components/Popover/QuickReplyItem.tsx import { Media, Message } from '@/constants' import db, { type QuickReply } from '@/libs/db' import { useAppStore } from '@/stores/app' import toast from '@/utils/toast' import { generateVideoThumbnail } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Group, HoverCard, Image, Loader, Paper, Stack, Text, Tooltip, } from '@mantine/core' import React, { useEffect, useState } from 'react' import MessageType from '../../../broadcast/components/Datatable/MessageType' import { getQuickReplyMessagePreview } from '../../helpers/preview' import { sendQuickReply } from '../../helpers/sender' interface Props { reply: QuickReply onDelete: (reply: QuickReply) => void onTogglePin: (reply: QuickReply) => void } const QuickReplyItem: React.FC<Props> = ({ reply, onDelete, onTogglePin }) => { const [isSending, setIsSending] = useState(false) const [previewUrl, setPreviewUrl] = useState<string | null>(null) const { activeChat } = useAppStore() useEffect(() => { let isMounted = true const generatePreview = async () => { if (reply.type === Message.IMAGE || reply.type === Message.VIDEO) { const media = await db.media .where({ parentId: reply.id, type: Media.QUICK_REPLY }) .first() if (media?.file && isMounted) { try { if (reply.type === Message.IMAGE) { const url = URL.createObjectURL(media.file) setPreviewUrl(url) } else if (reply.type === Message.VIDEO) { const thumbnailUrl = await generateVideoThumbnail(media.file) setPreviewUrl(thumbnailUrl) } } catch (error) { console.error('Failed to generate preview:', error) setPreviewUrl(null) // Fallback to no preview on error } } } } generatePreview() return () => { isMounted = false if (previewUrl && previewUrl.startsWith('blob:')) { URL.revokeObjectURL(previewUrl) } } }, [reply]) const handleSend = async () => { if (!activeChat?.number) { toast.error('No active chat selected.') return } setIsSending(true) try { await sendQuickReply(reply, activeChat.number) toast.success(`Replied with "${reply.name}"`) } catch (error: any) { console.error('Failed to send quick reply:', error) toast.error(error.message || 'Failed to send reply.') } finally { setIsSending(false) } } // Get the preview for the item display (truncated) const itemPreview = getQuickReplyMessagePreview(reply, 40) // Get the full preview for the hover card const fullPreview = reply.type === Message.TEXT ? (reply.message as string) : getQuickReplyMessagePreview(reply, 300) return ( <HoverCard shadow="md" position="left-start" withArrow openDelay={500}> <HoverCard.Target> <Paper withBorder p="xs" radius="sm"> <Group justify="space-between" wrap="nowrap"> <Group gap="xs" style={{ flex: 1, overflow: 'hidden' }}> {previewUrl ? ( <Image src={previewUrl} w={40} h={40} radius="sm" fit="cover" alt={`${reply.name} preview`} /> ) : ( <MessageType type={reply.type} /> )} <Stack gap={0} style={{ flex: 1, overflow: 'hidden' }}> <Text fw={500} size="sm" truncate> {reply.name} </Text> <Text c="dimmed" size="xs" truncate> {itemPreview} </Text> </Stack> </Group> <Group gap={2} wrap="nowrap"> {isSending ? ( <Loader size={20} /> ) : ( <Tooltip label="Send" position="top"> <ActionIcon variant="subtle" color="blue" onClick={handleSend} loading={isSending} > <Icon icon="tabler:send" /> </ActionIcon> </Tooltip> )} <Tooltip label={reply.isPinned ? 'Unpin' : 'Pin to Top'} position="top" > <ActionIcon variant="subtle" color={reply.isPinned ? 'yellow' : 'gray'} onClick={() => onTogglePin(reply)} disabled={isSending} > <Icon icon={reply.isPinned ? 'tabler:pin-filled' : 'tabler:pin'} /> </ActionIcon> </Tooltip> <Tooltip label="Delete" position="top"> <ActionIcon variant="subtle" color="red" onClick={() => onDelete(reply)} disabled={isSending} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> </Group> </Paper> </HoverCard.Target> <HoverCard.Dropdown> <Text size="sm" style={{ whiteSpace: 'pre-wrap', maxWidth: 300 }}> {fullPreview} </Text> </HoverCard.Dropdown> </HoverCard> ) } export default QuickReplyItem
```

# src/features/quick-reply/helpers/preview.ts

```ts
// src/features/quick-reply/helpers/preview.ts import { Message } from '@/constants' import type { QuickReply } from '@/libs/db' import { truncate } from '@/utils/util' /** * @description Generates a consistent text preview for a quick reply based on its type and content. * @param {QuickReply} reply - The quick reply object. * @param {number} [length=50] - The maximum length for the preview string before truncation. * @returns {string} A descriptive string preview of the message content. */ export const getQuickReplyMessagePreview = ( reply: QuickReply, length: number = 50, ): string => { const { type, message } = reply if (!message) return `[${type}]` let previewText: string switch (type) { case Message.TEXT: previewText = message as string break case Message.IMAGE: case Message.VIDEO: previewText = (message as { caption?: string }).caption || `[${type}]` break case Message.FILE: // The message for a file is its caption, stored as a string. previewText = (message as string) || `[${type}]` break case Message.LOCATION: previewText = (message as { name?: string; address?: string }).name || (message as { name?: string; address?: string }).address || 'Location' break case Message.POLL: previewText = (message as { name: string }).name || 'Poll' break case Message.VCARD: const count = Array.isArray(message) ? (message as any[]).length : 0 previewText = `Contact Card (${count} contact${count !== 1 ? 's' : ''})` break default: previewText = `[Unsupported Type: ${type}]` break } return truncate(previewText, length) }
```

# src/features/quick-reply/helpers/sender.ts

```ts
// src/features/quick-reply/helpers/sender.ts import { Media, Message } from '@/constants' import type { QuickReply } from '@/libs/db' import wa from '@/libs/wa' import MediaModel from '@/models/MediaModel' import parse from '@/utils/parse' import throwError from '@/utils/throwError' /** * @description Returns the appropriate sending function based on the quick reply type. * @param {QuickReply} reply - The quick reply record. * @param {string} chatId - The target chat ID. * @returns {Function} The async function to send the message. */ export const sendQuickReply = async (reply: QuickReply, chatId: string) => { const { type, message } = reply switch (type) { case Message.TEXT: { const parsedText = await parse.text(message as string, chatId) return wa.send.text(chatId, parsedText) } case Message.IMAGE: { const file = await MediaModel.findFirstByParent( reply.id, Media.QUICK_REPLY, ) if (!file) throwError.mediaNotFound() const parsedCaption = await parse.text( (message as { caption?: string }).caption || '', chatId, ) return wa.send.file(chatId, file.file, { type: 'image', caption: parsedCaption, }) } case Message.VIDEO: { const file = await MediaModel.findFirstByParent( reply.id, Media.QUICK_REPLY, ) if (!file) throwError.mediaNotFound() const parsedCaption = await parse.text( (message as { caption?: string }).caption || '', chatId, ) return wa.send.file(chatId, file.file, { type: 'video', caption: parsedCaption, }) } case Message.FILE: { const file = await MediaModel.findFirstByParent( reply.id, Media.QUICK_REPLY, ) if (!file) throwError.mediaNotFound() const parsedCaption = await parse.text(message as string, chatId) return wa.send.file(chatId, file.file, { type: 'document', caption: parsedCaption, }) } case Message.LOCATION: { return wa.send.location(chatId, message as any) } case Message.POLL: { const { name, choices } = message as any return wa.send.poll(chatId, name, choices) } case Message.VCARD: { const contactIdsToSend = (message as any[]).map((c) => c.id._serialized) if (contactIdsToSend.length === 0) throw new Error('No contact selected for VCard.') return wa.send.vcard(chatId, contactIdsToSend) } default: throw new Error(`Unsupported quick reply message type: ${type}`) } }
```

# src/features/quick-reply/PageQuickReply.tsx

```tsx
// src/features/quick-reply/PageQuickReply.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Media } from '@/constants' import MessageType from '@/features/broadcast/components/Datatable/MessageType' import useDataQuery from '@/hooks/useDataQuery' import db, { type QuickReply } from '@/libs/db' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Stack, TextInput, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import MediaPreviewCell from './components/MediaPreviewCell' import ModalCreateUpdateQuickReply from './components/Modal/ModalCreateUpdateQuickReply' const PageQuickReply: React.FC = () => { const dataQuery = useDataQuery<QuickReply>({ table: db.quickReplies, }) const [editingTemplate, setEditingTemplate] = useState<Partial<QuickReply> | null>(null) const [showModal, modalHandlers] = useDisclosure(false) const [selectedRecords, setSelectedRecords] = useState<QuickReply[]>([]) const handleEdit = (template: QuickReply) => { setEditingTemplate(template) modalHandlers.open() } const handleDelete = async (template: QuickReply) => { if ( confirm( `Are you sure you want to delete the template "${template.name}"?`, ) ) { await db.media .where({ parentId: template.id, type: Media.QUICK_REPLY }) .delete() await db.quickReplies.delete(template.id) toast.success(`Template "${template.name}" deleted.`) } } // Clones a quick reply by creating a copy and opening the editor modal. const handleClone = (template: QuickReply) => { const { id, ...rest } = template const clonedTemplate = { ...rest, name: `${template.name} (Copy)`, } setEditingTemplate(clonedTemplate) modalHandlers.open() } // Deletes all selected quick replies and their associated media. const handleBulkDelete = async () => { if (!selectedRecords.length) return if ( !confirm( `Are you sure you want to delete ${selectedRecords.length} selected quick replies?`, ) ) { return } try { const idsToDelete = selectedRecords.map((reply) => reply.id) await db.transaction('rw', db.quickReplies, db.media, async () => { // Delete associated media files for all selected replies await db.media .where('parentId') .anyOf(idsToDelete) .and((media) => media.type === Media.QUICK_REPLY) .delete() // Bulk delete the quick replies themselves await db.quickReplies.bulkDelete(idsToDelete) }) toast.success(`${selectedRecords.length} quick replies deleted.`) setSelectedRecords([]) // Clear selection after deletion } catch (error) { console.error('Failed to bulk delete quick replies:', error) toast.error('An error occurred during bulk deletion.') } } const handleCreate = () => { setEditingTemplate(null) modalHandlers.open() } return ( <> <LayoutPage title="Quick Reply"> <Stack> <Group justify="space-between"> <TextInput placeholder="Search by name..." size="sm" value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} /> <Group> <Button size="sm" color="red" variant="outline" leftSection={<Icon icon="tabler:trash" fontSize={20} />} onClick={handleBulkDelete} disabled={selectedRecords.length === 0} > Delete Selected ({selectedRecords.length}) </Button> <Button size="sm" leftSection={<Icon icon="tabler:plus" fontSize={20} />} onClick={handleCreate} > Add New </Button> </Group> </Group> <DataTable records={dataQuery?.data} totalRecords={dataQuery?.totalRecords} recordsPerPage={dataQuery?.pageSize} page={dataQuery?.page} onPageChange={dataQuery?.setPage} minHeight={400} noRecordsText="No quick reply templates found." selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} idAccessor="id" columns={[ { accessor: 'isPinned', title: <Icon icon="tabler:pin" />, width: 60, render: (template) => template.isPinned ? ( <Center> <Icon icon="tabler:pin-filled" color="var(--mantine-color-yellow-6)" /> </Center> ) : null, }, { accessor: 'name' }, { accessor: 'type', render: (record) => <MessageType type={record.type} />, }, { accessor: 'message', title: 'Content', render: (template) => <MediaPreviewCell reply={template} />, }, { accessor: 'actions', title: 'Actions', textAlign: 'right', width: '0%', render: (template) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Clone Template"> <ActionIcon variant="subtle" color="teal" onClick={() => handleClone(template)} > <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> <Tooltip label="Edit Template"> <ActionIcon variant="subtle" color="blue" onClick={() => handleEdit(template)} > <Icon icon="tabler:edit" /> </ActionIcon> </Tooltip> <Tooltip label="Delete Template"> <ActionIcon variant="subtle" color="red" onClick={() => handleDelete(template)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ]} /> </Stack> </LayoutPage> <ModalCreateUpdateQuickReply opened={showModal} onClose={() => { modalHandlers.close() setEditingTemplate(null) }} data={editingTemplate} /> </> ) } export default PageQuickReply
```

# src/features/tools/backup-chat/components/BackupOptions.tsx

```tsx
// src/features/tools/backup-chat/components/BackupOptions.tsx import useWa from '@/hooks/useWa' import { getContactName } from '@/utils/util' import { Icon } from '@iconify/react' import { Alert, Avatar, Button, Checkbox, Group, Loader, Radio, Select, Stack, TagsInput, Text, } from '@mantine/core' import { DatePickerInput } from '@mantine/dates' import React, { useEffect, useState } from 'react' import type { useChatBackup } from '../hooks/useChatBackup' interface Props { // Pass the entire hook's return object for cleaner prop management. backupHook: ReturnType<typeof useChatBackup> onStart: () => void } const BackupOptions: React.FC<Props> = ({ backupHook, onStart }) => { const { form, backupPreview, isPreparing, SUPPORTED_MESSAGE_TYPES, estimatedTime, } = backupHook const wa = useWa() const [chatOptions, setChatOptions] = useState<{ label: string; value: string; avatar: string }[]>() useEffect(() => { if (!wa.isReady) return // Fetch all user chats for the selector. wa.chat.list({ onlyUsers: true }).then((chats) => { const labelValueChats = chats.map((chat: any) => ({ label: getContactName(chat.contact), value: chat.id, avatar: chat.contact.avatar, })) setChatOptions(labelValueChats) }) }, [wa.isReady]) // Helper to format bytes into KB, MB, GB. const formatBytes = (bytes: number, decimals = 2) => { if (bytes === 0) return '0 Bytes' const k = 1024 const dm = decimals < 0 ? 0 : decimals const sizes = ['Bytes', 'KB', 'MB', 'GB'] const i = Math.floor(Math.log(bytes) / Math.log(k)) return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i] } // Custom renderer for select options to display avatars. const renderSelectOption = ({ option, }: { option: { value: string; label: string; avatar: string } }) => ( <Group> <Avatar src={option.avatar} size="md" radius="xl" /> <div> <Text size="sm">{option.label}</Text> </div> </Group> ) return ( <Stack> <Select label="Select chat" data={chatOptions ?? []} searchable clearable required renderOption={renderSelectOption} {...form.getInputProps('chatId')} /> <TagsInput label="Filter by Keywords (Optional)" placeholder="Add keywords and press Enter" description="Only export messages containing any of these keywords. Case-insensitive." {...form.getInputProps('keywords')} clearable /> {/* MODIFIED: Replaced preset buttons with a Select component. */} <Select label="Date Range" data={[ { value: 'all', label: 'All Time' }, { value: 'today', label: 'Today' }, { value: 'yesterday', label: 'Yesterday' }, { value: 'last7', label: 'Last 7 Days' }, { value: 'last30', label: 'Last 30 Days' }, { value: 'thisMonth', label: 'This Month' }, { value: 'lastMonth', label: 'Last Month' }, { value: 'custom', label: 'Custom Range...' }, ]} {...form.getInputProps('datePreset')} /> {/* MODIFIED: Conditionally show DatePickerInput only for 'custom' preset. */} {form.values.datePreset === 'custom' && ( <DatePickerInput type="range" label="Custom Date Range" placeholder="Pick a start and end date" {...form.getInputProps('dateRange')} required /> )} <Checkbox.Group label="Include Message Types" description="Select the types of messages to include in the backup." {...form.getInputProps('messageTypes')} > <Group mt="xs"> {SUPPORTED_MESSAGE_TYPES.map((type) => ( <Checkbox key={type} value={type} label={type.charAt(0).toUpperCase() + type.slice(1)} /> ))} </Group> </Checkbox.Group> <Radio.Group label="Format" {...form.getInputProps('exportFormat')}> <Group mt="xs"> <Radio size="sm" value="html" label="HTML (.zip)" /> <Radio size="sm" value="pdf" label="PDF" /> {/* ++ ADDED: New export format options */} <Radio size="sm" value="txt" label="TXT" /> <Radio size="sm" value="json" label="JSON" /> <Radio size="sm" value="md" label="Markdown" /> </Group> </Radio.Group> {isPreparing && ( <Group> <Loader size="xs" /> <Text size="sm" c="dimmed"> {' '} Preparing preview...{' '} </Text> </Group> )} {backupPreview && !isPreparing && ( <Alert variant="light" color="blue" icon={<Icon icon="tabler:info-circle" />} > <Stack gap="xs"> <Text size="sm"> {' '} You are about to export{' '} <b>{backupPreview.messageCount} message(s)</b>.{' '} </Text> {form.values.messageTypes.length > 0 && backupPreview.estimatedMediaSize > 0 && form.values.exportFormat === 'html' && ( <Text size="sm"> {' '} Estimated media download size:{' '} <b>{formatBytes(backupPreview.estimatedMediaSize)}</b>.{' '} </Text> )} {estimatedTime && ( <Text size="sm"> {' '} <b>Estimated Completion Time:</b> {estimatedTime}{' '} </Text> )} </Stack> </Alert> )} <Group justify="flex-end" mt="lg"> <Button leftSection={<Icon icon="tabler:download" />} onClick={onStart} disabled={!form.values.chatId || isPreparing} > {' '} Start Backup{' '} </Button> </Group> </Stack> ) } export default BackupOptions
```

# src/features/tools/backup-chat/components/BackupProgress.tsx

```tsx
// src/features/tools/chat-backup/components/BackupProgress.tsx import { Button, Center, Group, Progress, Stack, Text } from '@mantine/core' import React from 'react' interface Props { progress: { value: number label: string } onCancel: () => void } const BackupProgress: React.FC<Props> = ({ progress, onCancel }) => { return ( <Center h={250}> <Stack w="100%" align="center"> <Text size="lg" fw={500}> Backup in Progress... </Text> <Progress value={progress.value} animated size="lg" w="100%" /> <Text c="dimmed" size="sm"> {progress.label} </Text> <Button mt="lg" variant="outline" color="red" onClick={onCancel}> Cancel </Button> </Stack> </Center> ) } export default BackupProgress
```

# src/features/tools/backup-chat/helpers/exportUtils.ts

```ts
// src/features/tools/backup-chat/helpers/exportUtils.ts import wa from '@/libs/wa' import { getContactName } from '@/utils/util' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import jsPDF from 'jspdf' import JSZip from 'jszip' import _ from 'lodash' interface ExporterParams { messages: any[] chat: any filename: string // Updated to be an array of media types to be included includeMediaTypes: string[] setProgress: (progress: { value: number; label: string }) => void validationRef: React.MutableRefObject<boolean> } // ++ ADDED: Helper function to generate the HTML for a quoted message block. const renderQuotedMessage = (quotedMsg: any): string => { if (!quotedMsg) return '' const quotedSenderName = quotedMsg.sender.isMe ? 'You' : getContactName(quotedMsg.sender) let quotedContent = '' // Determine the content preview for the quoted message switch (quotedMsg.type) { case 'chat': quotedContent = _.escape(quotedMsg.body) break case 'image': quotedContent = '📷 Photo' break case 'video': quotedContent = '🎥 Video' break case 'document': quotedContent = `📄 ${_.escape(quotedMsg.filename) || 'Document'}` break case 'ptt': quotedContent = '🎤 Voice Message' break default: quotedContent = `[Unsupported message type: ${quotedMsg.type}]` } // The entire block is a link to the original message's ID. return ` <a href="#message-${quotedMsg.id}" class="quoted-message-link"> <div class="quoted-message"> <div class="quoted-sender">${_.escape(quotedSenderName)}</div> <div class="quoted-content">${quotedContent}</div> </div> </a> ` } // ++ ADDED: Centralized HTML body generation to avoid duplication. // This function creates the core HTML content and gathers media files. const generateHtmlBody = async ({ messages, chat, includeMediaTypes, setProgress, validationRef, isForPdf = false, // Added flag to slightly alter output for PDF }: ExporterParams & { isForPdf?: boolean }): Promise<{ htmlBody: string mediaMap: Map<string, Blob> }> => { const headerHtml = ` <div class="export-header"> <p><b>Chat With:</b> ${_.escape(getContactName(chat.data.contact))}</p> <p><b>Export Date:</b> ${new Date().toLocaleString()}</p> <p><b>Total Messages Exported:</b> ${messages.length}</p> </div> ` let messagesHtml = '' const mediaMap = new Map<string, Blob>() for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] if (!['chat', 'image', 'video', 'document', 'ptt'].includes(msg.type)) continue const progressValue = ((i + 1) / messages.length) * 90 // Reserve last 10% setProgress({ value: progressValue, label: `Processing message ${i + 1} of ${messages.length}...`, }) const direction = msg.contact.isMe ? 'out' : 'in' const senderName = !msg.fromMe && chat.data.isGroup ? msg.contact?.pushname || msg.contact?.formattedName || 'Unknown' : '' let mediaHtml = '' const isMediaMessage = ['image', 'video', 'document', 'ptt'].includes( msg.type, ) const shouldIncludeThisMedia = includeMediaTypes.includes(msg.type) if (isMediaMessage && shouldIncludeThisMedia && !mediaMap.has(msg.id)) { setProgress({ value: progressValue, label: `Downloading media for message ${ i + 1 }... (${msg.filename || msg.type})`, }) const blob = await wa.chat.downloadMedia(msg.id) if (blob) { mediaMap.set(msg.id, blob) const mediaType = msg.type as 'image' | 'video' | 'document' | 'ptt' const extension = blob.type.split('/')[1] || 'bin' const mediaFilename = `${msg.id}.${extension}` const folderName = mediaType === 'ptt' ? 'audio' : `${mediaType}s` const filePath = `./${folderName}/${mediaFilename}` const blobUrl = URL.createObjectURL(blob) switch (msg.type) { case 'image': mediaHtml = `<img src="${ isForPdf ? blobUrl : filePath }" alt="Image" />` break case 'video': mediaHtml = `<video controls src="${ isForPdf ? blobUrl : filePath }"></video>` break case 'ptt': mediaHtml = `<audio controls src="${ isForPdf ? blobUrl : filePath }"></audio>` break case 'document': mediaHtml = `<a href="${ isForPdf ? '#' : filePath }" target="_blank">Download: ${ _.escape(msg.filename) || 'Document' }</a>` break } } } else if (isMediaMessage) { const mediaType = msg.type === 'ptt' ? 'Audio' : msg.type mediaHtml = `<div class="media-placeholder">[${ mediaType.charAt(0).toUpperCase() + mediaType.slice(1) } not included]</div>` } const quotedHtml = renderQuotedMessage(msg.quotedMsg) messagesHtml += ` <div class="message-cluster message-${direction}" id="message-${ msg.id }"> <div class="message"> <div class="message-bubble"> ${ senderName ? `<div class="sender-name">${_.escape(senderName)}</div>` : '' } <div class="message-content"> ${quotedHtml} ${mediaHtml} <span>${ _.escape(msg.type === 'chat' ? msg.body : msg.caption) ?? '' }</span> <span class="timestamp">${new Date( msg.timestamp, ).toLocaleTimeString([], { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', })}</span> </div> </div> </div> </div> ` } return { htmlBody: headerHtml + messagesHtml, mediaMap } } // Function to get the full HTML document string const getFullHtmlDocument = (bodyContent: string, chat: any) => { const styles = ` <style> body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; margin: 0; background-color: #E5DDD5; } .chat-container { max-width: 800px; margin: auto; padding: 20px; } .export-header { background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #dee2e6; font-size: 0.9em; } .export-header h1 { margin: 0 0 10px 0; font-size: 1.5em; color: #005c4b; } .export-header p { margin: 2px 0; color: #333; } .export-header b { color: #111; } .message-cluster { display: flex; flex-direction: column; margin-bottom: 2px; padding: 0 9%; scroll-margin-top: 20px; } .message-cluster.message-out { align-items: flex-end; } .message-cluster.message-in { align-items: flex-start; } .message { max-width: 65%; word-wrap: break-word; margin-bottom: 10px; } .message-bubble { padding: 6px 9px; border-radius: 7.5px; box-shadow: 0 1px 0.5px rgba(11,20,26,.13); position: relative; } .message-out .message-bubble { background-color: #d9fdd3; color: #0f1010; } .message-in .message-bubble { background-color: #fff; color: #111b21; } .message-out .message-bubble::after { content: ''; position: absolute; top: 0px; right: -4px; width: 0px; height: 0px; border-top: 0px solid transparent; border-left: 8px solid #d9fdd3; border-bottom: 10px solid transparent; } .message-in .message-bubble::before { content: ''; position: absolute; top: 0px; left: -4px; width: 0px; height: 0px; border-top: 0px solid transparent; border-right: 8px solid #fff; border-bottom: 10px solid transparent; } .sender-name { font-size: 0.8rem; font-weight: 500; color: #028a76; margin-bottom: 4px; } .message-content img, .message-content video { width: 100%; max-width: 300px; border-radius: 6px; margin-top: 5px; display: block; } .message-content a { color: #0088cc; } .timestamp { font-size: 0.7rem; color: #667781; display: flex; justify-content: flex-end; padding-top: 4px; } .media-placeholder { padding: 10px; background-color: #f0f0f0; border: 1px dashed #ccc; border-radius: 6px; color: #888; font-style: italic; font-size: 0.9em; margin-top: 5px; text-align: center; } .quoted-message-link { text-decoration: none; color: inherit; } .quoted-message { background-color: #f0f2f5; border-left: 4px solid #4CAF50; padding: 8px 10px; margin-bottom: 5px; border-radius: 4px; opacity: 0.85; transition: opacity 0.2s; } .quoted-message:hover { opacity: 1; } .quoted-sender { font-weight: bold; font-size: 0.85em; color: #4CAF50; } .quoted-content { font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; } </style> <script> document.addEventListener('DOMContentLoaded', () => { document.querySelectorAll('a[href^="#"]').forEach(anchor => { anchor.addEventListener('click', function (e) { e.preventDefault(); const targetElement = document.querySelector(this.getAttribute('href')); if (targetElement) { targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); targetElement.style.transition = 'none'; targetElement.style.backgroundColor = 'rgba(255, 255, 0, 0.4)'; setTimeout(() => { targetElement.style.transition = 'background-color 0.5s'; targetElement.style.backgroundColor = ''; }, 1500); } }); }); }); </script> ` return ` <html> <head> <meta charset="UTF-8"> <title>Chat with ${_.escape(getContactName(chat.data.contact))}</title> ${styles} </head> <body><div class="chat-container">${bodyContent}</div></body> </html> ` } // Main HTML Exporter export const exportToHtml = async (params: ExporterParams) => { const { filename, setProgress } = params const { htmlBody, mediaMap } = await generateHtmlBody(params) const fullHtml = getFullHtmlDocument(htmlBody, params.chat) // Clean up blob URLs created for HTML generation mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) { URL.revokeObjectURL(url) } }) if (mediaMap.size > 0 && params.includeMediaTypes.length > 0) { const zip = new JSZip() const mediaFolders: { [key: string]: JSZip | null } = { image: zip.folder('images'), video: zip.folder('videos'), document: zip.folder('documents'), ptt: zip.folder('audio'), } for (const [msgId, blob] of mediaMap.entries()) { const msg = params.messages.find((m) => m.id === msgId) if (msg && msg.type !== 'chat') { const mediaType = msg.type as 'image' | 'video' | 'document' | 'ptt' const folder = mediaFolders[mediaType] const extension = blob.type.split('/')[1] || 'bin' const mediaFilename = `${msg.id}.${extension}` folder?.file(mediaFilename, blob) } } zip.file(`${filename}.html`, fullHtml) setProgress({ value: 98, label: 'Compressing files...' }) const zipBlob = await zip.generateAsync({ type: 'blob' }) FileSaver.saveAs(zipBlob, `${filename}.zip`) } else { const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' }) FileSaver.saveAs(blob, `${filename}.html`) } } // ++ ADDED: New PDF Exporter export const exportToPdf = async (params: ExporterParams) => { const { filename, setProgress, validationRef } = params // Generate HTML with blob URLs for rendering, but don't include media for download const { htmlBody, mediaMap } = await generateHtmlBody({ ...params, includeMediaTypes: ['image'], // PDF generation works best with just images isForPdf: true, }) const fullHtml = getFullHtmlDocument(htmlBody, params.chat) if (!validationRef.current) { // Clean up blobs if cancelled during generation mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) return } setProgress({ value: 92, label: 'Generating PDF document...' }) // Create a temporary, off-screen div to render the HTML for capturing const container = document.createElement('div') container.style.position = 'absolute' container.style.left = '-9999px' // Position off-screen container.style.width = '800px' // Set a fixed width for consistent rendering document.body.appendChild(container) container.innerHTML = fullHtml try { const canvas = await html2canvas(container, { useCORS: true, // Important for images from blob URLs scale: 2, // Increase resolution }) // Clean up the off-screen container and blob URLs document.body.removeChild(container) mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) if (!validationRef.current) return setProgress({ value: 95, label: 'Formatting PDF pages...' }) const imgData = canvas.toDataURL('image/png') const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4', }) const pdfWidth = pdf.internal.pageSize.getWidth() const pdfHeight = pdf.internal.pageSize.getHeight() const canvasWidth = canvas.width const canvasHeight = canvas.height const ratio = canvasWidth / pdfWidth const canvasHeightInPdf = canvasHeight / ratio let heightLeft = canvasHeightInPdf let position = 0 // Add the first page pdf.addImage( imgData, 'PNG', 0, position, pdfWidth, canvasHeightInPdf, undefined, 'FAST', ) heightLeft -= pdfHeight // Add new pages if content is longer than one page while (heightLeft > 0) { position = heightLeft - canvasHeightInPdf pdf.addPage() pdf.addImage( imgData, 'PNG', 0, position, pdfWidth, canvasHeightInPdf, undefined, 'FAST', ) heightLeft -= pdfHeight } setProgress({ value: 98, label: 'Saving PDF file...' }) pdf.save(`${filename}.pdf`) } catch (error) { console.error('Error generating PDF:', error) if (document.body.contains(container)) { document.body.removeChild(container) } mediaMap.forEach((blob, url) => { if (url.startsWith('blob:')) URL.revokeObjectURL(url) }) throw new Error('Failed to generate PDF from chat content.') } } /** * ++ ADDED: Exports messages to a plain text file. * @param {ExporterParams} params - The parameters for the export operation. */ export const exportToTxt = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef } = params let textContent = `Chat With: ${getContactName(chat.data.contact)}\r\n` textContent += `Export Date: ${new Date().toLocaleString()}\r\n` textContent += `Total Messages Exported: ${messages.length}\r\n\r\n` for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const sender = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toLocaleString() let content = msg.body || msg.caption || `[${msg.type}]` if (msg.quotedMsg) { const quotedSender = msg.quotedMsg.sender.isMe ? 'You' : getContactName(msg.quotedMsg.sender) const quotedContent = _.truncate( msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, { length: 40 }, ) content = `[Quoting ${quotedSender}: "${quotedContent}"]\r\n${content}` } textContent += `[${timestamp}] ${sender}: ${content}\r\n\r\n` } if (validationRef.current) { const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' }) FileSaver.saveAs(blob, `${filename}.txt`) } } /** * ++ ADDED: Exports messages to a JSON file. * @param {ExporterParams} params - The parameters for the export operation. */ export const exportToJson = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef } = params const messageList: object[] = [] for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) messageList.push({ id: msg.id, timestamp: new Date(msg.timestamp).toISOString(), sender: { name: msg.contact.isMe ? 'You' : getContactName(msg.contact), id: msg.from, isMe: msg.contact.isMe, }, type: msg.type, body: msg.body || null, caption: msg.caption || null, filename: msg.filename || null, quotedMessage: msg.quotedMsg ? { id: msg.quotedMsg.id, sender: getContactName(msg.quotedMsg.sender), body: msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, } : null, }) } if (validationRef.current) { const finalJson = { metadata: { chatWith: getContactName(chat.data.contact), chatId: chat.data.id, exportDate: new Date().toISOString(), totalMessages: messages.length, }, messages: messageList, } const jsonString = JSON.stringify(finalJson, null, 2) const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8', }) FileSaver.saveAs(blob, `${filename}.json`) } } /** * ++ ADDED: Exports messages to a Markdown file. * @param {ExporterParams} params - The parameters for the export operation. */ export const exportToMarkdown = async (params: ExporterParams) => { const { messages, chat, filename, setProgress, validationRef } = params let mdContent = `# Chat with: ${getContactName(chat.data.contact)}\n\n` mdContent += `**Export Date:** ${new Date().toLocaleString()}\n` mdContent += `**Total Messages:** ${messages.length}\n\n---\n\n` for (let i = 0; i < messages.length; i++) { if (!validationRef.current) break const msg = messages[i] setProgress({ value: ((i + 1) / messages.length) * 100, label: `Processing message ${i + 1} of ${messages.length}...`, }) const senderName = msg.contact.isMe ? 'You' : getContactName(msg.contact) const timestamp = new Date(msg.timestamp).toLocaleString() mdContent += `**${_.escape(senderName)}** (*${timestamp}*)\n\n` if (msg.quotedMsg) { const quotedSenderName = msg.quotedMsg.sender.isMe ? 'You' : getContactName(msg.quotedMsg.sender) const quotedBody = _.truncate( msg.quotedMsg.body || `[${msg.quotedMsg.type}]`, { length: 80 }, ) mdContent += `> > **${_.escape(quotedSenderName)}**: ${_.escape( quotedBody, )}\n\n` } let mdMessageContent = '' switch (msg.type) { case 'chat': mdMessageContent = msg.body.replace(/\n/g, ' \n') // Markdown line breaks break case 'image': mdMessageContent = `*Image* ${ msg.caption ? `\n> ${_.escape(msg.caption)}` : '' }` break case 'video': mdMessageContent = `*Video* ${ msg.caption ? `\n> ${_.escape(msg.caption)}` : '' }` break case 'document': mdMessageContent = `*Document*: \`${_.escape(msg.filename)}\`${ msg.caption ? `\n> ${_.escape(msg.caption)}` : '' }` break case 'ptt': mdMessageContent = `*Voice Message*` break default: mdMessageContent = `*[Unsupported message type: ${msg.type}]*` } mdContent += `${mdMessageContent}\n\n---\n` } if (validationRef.current) { const blob = new Blob([mdContent], { type: 'text/markdown;charset=utf-8', }) FileSaver.saveAs(blob, `${filename}.md`) } }
```

# src/features/tools/backup-chat/hooks/useChatBackup.ts

```ts
// src/features/tools/backup-chat/hooks/useChatBackup.ts import wa from '@/libs/wa' import toast from '@/utils/toast' import { getContactName } from '@/utils/util' import { useForm } from '@mantine/form' import { endOfDay, endOfMonth, isWithinInterval, startOfDay, startOfMonth, subDays, subMonths, } from 'date-fns' import _ from 'lodash' import { useEffect, useRef, useState } from 'react' import { exportToHtml, exportToJson, exportToMarkdown, exportToPdf, exportToTxt, } from '../helpers/exportUtils' // Supported message types for export options. const SUPPORTED_MESSAGE_TYPES = ['chat', 'image', 'video', 'document', 'ptt'] // Interface for the backup preview data. interface BackupPreview { messageCount: number estimatedMediaSize: number // in bytes } export const useChatBackup = () => { const [isBackingUp, setIsBackingUp] = useState(false) const [isPreparing, setIsPreparing] = useState(false) const [progress, setProgress] = useState({ value: 0, label: 'Initializing...', }) const [backupPreview, setBackupPreview] = useState<BackupPreview | null>(null) const [filteredMessages, setFilteredMessages] = useState<any[]>([]) const [estimatedTime, setEstimatedTime] = useState('') const validationRef = useRef(true) const form = useForm({ initialValues: { chatId: '', exportFormat: 'html', messageTypes: SUPPORTED_MESSAGE_TYPES, keywords: [] as string[], // MODIFIED: Added a preset field for the new dropdown. datePreset: 'all', dateRange: [null, null] as [Date | null, Date | null], }, validate: { chatId: (value) => (value ? null : 'A chat must be selected.'), // MODIFIED: Validate custom date range only when 'custom' is selected. dateRange: (value, values) => { if (values.datePreset === 'custom' && (!value[0] || !value[1])) { return 'A start and end date are required for a custom range.' } return null }, }, }) // This effect calculates the backup preview whenever filter criteria change. useEffect(() => { const calculatePreview = async () => { // MODIFIED: Destructure 'datePreset' from form values. const { chatId, dateRange, keywords, messageTypes, datePreset } = form.values if (!chatId) { setBackupPreview(null) setFilteredMessages([]) setEstimatedTime('') return } setIsPreparing(true) // MODIFIED: Derive the effective date range from the selected preset. let effectiveDateRange: [Date | null, Date | null] = [null, null] if (datePreset === 'custom') { effectiveDateRange = dateRange } else if (datePreset !== 'all') { const now = new Date() let start: Date | null = null let end: Date | null = null switch (datePreset) { case 'today': start = startOfDay(now) end = endOfDay(now) break case 'yesterday': const yesterday = subDays(now, 1) start = startOfDay(yesterday) end = endOfDay(yesterday) break case 'last7': start = startOfDay(subDays(now, 6)) end = endOfDay(now) break case 'last30': start = startOfDay(subDays(now, 29)) end = endOfDay(now) break case 'thisMonth': start = startOfMonth(now) end = endOfMonth(now) break case 'lastMonth': const lastMonthDate = subMonths(now, 1) start = startOfMonth(lastMonthDate) end = endOfMonth(lastMonthDate) break } effectiveDateRange = [start, end] } try { const allMessages = await wa.chat.getMessages(chatId, { count: -1 }) // MODIFIED: Use the derived date range for filtering. const [startDate, endDate] = effectiveDateRange const lowercasedKeywords = keywords .map((k) => k.toLowerCase().trim()) .filter(Boolean) const messages = allMessages.filter((msg) => { const dateMatch = !startDate || !endDate || isWithinInterval(new Date(msg.timestamp), { start: startDate, end: endDate, }) const keywordMatch = lowercasedKeywords.length === 0 || lowercasedKeywords.some( (k) => (msg.body && msg.body.toLowerCase().includes(k)) || (msg.caption && msg.caption.toLowerCase().includes(k)), ) const typeMatch = messageTypes.includes(msg.type) return dateMatch && keywordMatch && typeMatch }) const estimatedMediaSize = messages .filter((msg) => messageTypes.includes(msg.type) && msg.size) .reduce((acc, msg) => acc + msg.size, 0) setFilteredMessages(messages) setBackupPreview({ messageCount: messages.length, estimatedMediaSize }) if (messages.length > 0) { const timeForMessages = messages.length * 0.05 const mediaToDownload = messages.filter( (msg) => messageTypes.includes(msg.type) && msg.size, ).length const timeForMedia = mediaToDownload * 1.5 const totalSeconds = timeForMessages + timeForMedia if (totalSeconds < 60) { setEstimatedTime('Less than a minute.') } else { const minutes = Math.floor(totalSeconds / 60) const seconds = Math.round(totalSeconds % 60) let timeString = `About ${minutes} minute${minutes > 1 ? 's' : ''}` if (seconds > 0) { timeString += ` and ${seconds} second${seconds > 1 ? 's' : ''}` } setEstimatedTime(`${timeString}.`) } } else { setEstimatedTime('') } } catch (error) { console.error('Failed to calculate backup preview:', error) toast.error('Could not fetch messages to prepare the backup.') setBackupPreview(null) setFilteredMessages([]) } finally { setIsPreparing(false) } } const handler = setTimeout(() => { calculatePreview() }, 500) // Debounce for 500ms return () => { clearTimeout(handler) } }, [ form.values.chatId, form.values.dateRange, form.values.keywords, form.values.messageTypes, form.values.datePreset, // MODIFIED: Added preset to dependency array. ]) const cancelBackup = () => { validationRef.current = false } const startBackup = async () => { if (form.validate().hasErrors) return if (filteredMessages.length === 0) { toast.info('No messages found matching your criteria to export.') return } setIsBackingUp(true) validationRef.current = true setProgress({ value: 0, label: 'Initializing backup...' }) try { const chat = await wa.chat.find(form.values.chatId) // @ts-ignore const filename = `backup_chat_${_.snakeCase( getContactName(chat.data.contact), )}_${new Date().toISOString().slice(0, 10)}` const exporterParams = { messages: filteredMessages, chat, filename, // Only include media for HTML format; other formats are text-based. includeMediaTypes: form.values.exportFormat === 'html' ? form.values.messageTypes : [], setProgress, validationRef, } // ++ MODIFIED: Use a switch statement to call the appropriate exporter. switch (form.values.exportFormat) { case 'pdf': await exportToPdf(exporterParams) break case 'txt': await exportToTxt(exporterParams) break case 'json': await exportToJson(exporterParams) break case 'md': await exportToMarkdown(exporterParams) break case 'html': default: await exportToHtml(exporterParams) break } if (validationRef.current) { toast.success('Backup completed successfully!') } else { toast.info('Backup cancelled by user.') } } catch (error: any) { console.error('Backup failed:', error) toast.error(error.message || 'An unknown error occurred during backup.') } finally { setIsBackingUp(false) } } return { form, isBackingUp, isPreparing, progress, startBackup, cancelBackup, backupPreview, SUPPORTED_MESSAGE_TYPES, estimatedTime, } }
```

# src/features/tools/backup-chat/PageChatBackup.tsx

```tsx
// src/features/tools/chat-backup/PageChatBackup.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Icon } from '@iconify/react' import { Alert, Box, Card, Stack, Text, Title } from '@mantine/core' import React from 'react' import BackupOptions from './components/BackupOptions' import BackupProgress from './components/BackupProgress' import { useChatBackup } from './hooks/useChatBackup' const PageChatBackup: React.FC = () => { const backup = useChatBackup() return ( <LayoutPage title="Chat Backup & Export"> <Stack> {backup.isBackingUp ? ( <BackupProgress progress={backup.progress} onCancel={backup.cancelBackup} /> ) : ( // Pass the entire hook object as a single prop <BackupOptions backupHook={backup} onStart={backup.startBackup} /> )} <Box mt="md"> <Alert variant="light" color="orange" title="Important Considerations" icon={<Icon icon="tabler:alert-triangle" />} > - Backing up chats with many media files can be slow and consume significant memory. <br />- For very large chats, consider exporting without media or using a date range. <br />- Ensure you have a stable internet connection during the process. </Alert> </Box> </Stack> </LayoutPage> ) } export default PageChatBackup
```

# src/features/tools/direct-chat/PageDirectChat.tsx

```tsx
import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import LayoutPage from '@/components/Layout/LayoutPage' import { Message } from '@/constants' import wa from '@/libs/wa' import toast from '@/utils/toast' import { formHasErrors } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Group, Stack, Text, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' const defaultValues = { number: '', } /** * @component PageDirectChat * @description Allows users to start a chat without saving the number, now with support for sending text, media, and VCards. */ const PageDirectChat: React.FC = () => { const { form: inputMessageForm, getMessage } = useInputMessage() const form = useForm({ initialValues: defaultValues, validate: { number: (value) => _.isEmpty(value) ? 'The phone number is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) // Handles sending the message directly using wa-js functions const handleSubmit = async () => { // Validate both the number input form and the message input form if (formHasErrors(form, inputMessageForm)) { return } setLoading(true) form.clearErrors() try { const fullNumber = form.values.number.replace(/\D/g, '') // Remove non-numeric chars const chatId = `${fullNumber}@c.us` // Check if the number exists on WhatsApp. const isExist = await wa.contact.isExist(chatId) if (!isExist) { form.setFieldError( 'number', 'This number is not registered on WhatsApp.', ) setLoading(false) return } const { type } = inputMessageForm.values const message = getMessage() let result switch (type) { case Message.TEXT: result = await wa.send.text(chatId, message as string) break case Message.IMAGE: if (!inputMessageForm.values.inputImage.file) throw new Error('Image file is required.') result = await wa.send.file( chatId, inputMessageForm.values.inputImage.file, { type: 'image', caption: (message as { caption: string }).caption, }, ) break case Message.VIDEO: if (!inputMessageForm.values.inputVideo.file) throw new Error('Video file is required.') result = await wa.send.file( chatId, inputMessageForm.values.inputVideo.file, { type: 'video', caption: (message as { caption: string }).caption, }, ) break case Message.FILE: if (!inputMessageForm.values.inputFile.file) throw new Error('File is required.') result = await wa.send.file( chatId, inputMessageForm.values.inputFile.file, { type: 'document', caption: message as string, }, ) break case Message.LOCATION: //@ts-ignore result = await wa.send.location(chatId, message) break case Message.POLL: const { name, choices } = message as { name: string choices: string[] } result = await wa.send.poll(chatId, name, choices) break case Message.VCARD: // Extract the serialized ID from each selected contact object const contactIdsToSend = (message as any[]).map( (c) => c.id._serialized, ) if (contactIdsToSend.length === 0) throw new Error('No contact selected to send.') result = await wa.send.vcard(chatId, contactIdsToSend) break default: toast.error('Unsupported message type for Direct Chat.') setLoading(false) return } if (result.status === 'SUCCESS') { toast.success('Message sent successfully!') // Open the chat to see the sent message await wa.chat.openChatBottom(chatId) // Reset message form, but keep the number inputMessageForm.reset() } else { toast.error(result.error || 'Failed to send message.') } } catch (error: any) { console.error('Failed to send direct chat:', error) toast.error(error.message || 'An unexpected error occurred.') } finally { setLoading(false) } } return ( <> <LayoutPage title="Direct Chat"> <Stack> <Stack align="center" gap={4} mb={'xl'}> <Icon icon="tabler:message-circle-plus" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> Direct Chat </Title> <Text c="dimmed" size="sm" ta="center"> Start a conversation without saving the number to your contacts. </Text> </Stack> <TextInput label="WhatsApp Number" placeholder="e.g., 6281234567890" description="Enter the full number with country code, without '+' or spaces." required {...form.getInputProps('number')} /> {/* Use InputMessage component for message composition */} <Stack gap="xs" mt="md"> <InputMessage form={inputMessageForm} /> </Stack> <Group justify="flex-end" mt="md"> <Button loading={loading} onClick={handleSubmit} leftSection={<Icon icon="tabler:brand-whatsapp" fontSize={20} />} > Send Message </Button> </Group> </Stack> </LayoutPage> </> ) } export default PageDirectChat
```

# src/features/tools/group-link-generator/PageGroupLinkGenerator.tsx

```tsx
import LayoutPage from '@/components/Layout/LayoutPage' import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Card, Group, Select, Stack, Text, TextInput, Title, Tooltip, } from '@mantine/core' import { useClipboard } from '@mantine/hooks' import React, { useMemo, useState } from 'react' import { When } from 'react-if' /** * @component PageGroupLinkGenerator * @description A tool to select a WhatsApp group and generate its invite link. */ const PageGroupLinkGenerator: React.FC = () => { const { groups } = useAppStore() const [selectedGroupId, setSelectedGroupId] = useState<string | null>(null) const [generatedLink, setGeneratedLink] = useState('') const [isLoading, setIsLoading] = useState(false) const clipboard = useClipboard({ timeout: 1000 }) // Format the group list from the store for the Select component const groupOptions = useMemo(() => { return ( groups?.map((group: any) => ({ label: `${group.name}`, value: group.id, })) || [] ) }, [groups]) /** * @description Fetches the invite link for the selected group. */ const handleGenerateLink = async () => { if (!selectedGroupId) { toast.error('Please select a group first.') return } setIsLoading(true) setGeneratedLink('') try { // Fetch the invite link using the wa-js wrapper const link = await wa.group.getInviteLink(selectedGroupId) if (link) { setGeneratedLink(link) toast.success('Invite link generated successfully!') } else { toast.error( 'Could not generate an invite link. You may not be an admin of this group.', ) } } catch (error: any) { console.error('Failed to generate group link:', error) toast.error(error.message || 'An unexpected error occurred.') } finally { setIsLoading(false) } } return ( <LayoutPage title="Group Invite Link Generator"> <Stack> <Stack align="center" gap={4} mb="xl"> <Icon icon="tabler:ticket" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> Group Invite Link Generator </Title> <Text c="dimmed" size="sm" ta="center"> Quickly get the invite link for any of your WhatsApp groups. </Text> </Stack> <Card withBorder p="lg" radius="md" shadow="none"> <Stack> <Select label="Select a Group" placeholder="Choose a group from the list" data={groupOptions} value={selectedGroupId} onChange={setSelectedGroupId} searchable nothingFoundMessage="No groups found" disabled={isLoading || groups.length === 0} /> <Group justify="flex-end" mt="md"> <Button onClick={handleGenerateLink} loading={isLoading} disabled={!selectedGroupId} leftSection={<Icon icon="tabler:refresh-dot" fontSize={20} />} > Generate Link </Button> </Group> </Stack> </Card> {/* This section appears only after a link has been generated */} <When condition={generatedLink}> <Card withBorder p="lg" radius="md" mt="lg"> <Stack align="center"> <Title order={4}>Your Invite Link is Ready!</Title> <TextInput w="100%" readOnly label="Generated Link" value={generatedLink} rightSection={ <Tooltip label={clipboard.copied ? 'Copied!' : 'Copy Link'} position="left" withArrow > <ActionIcon variant="subtle" onClick={() => clipboard.copy(generatedLink)} > <Icon icon={clipboard.copied ? 'tabler:check' : 'tabler:copy'} /> </ActionIcon> </Tooltip> } /> </Stack> </Card> </When> </Stack> </LayoutPage> ) } export default PageGroupLinkGenerator
```

# src/features/tools/number-validator/components/InputSection.tsx

```tsx
// src/features/Tools/NumberValidator/components/InputSection.tsx import { Icon } from '@iconify/react' import { Button, Group, ScrollArea, Textarea, Title } from '@mantine/core' import React from 'react' interface Props { numbers: string[] setNumbers: (numbers: string[]) => void isValidating: boolean onImportExcel: () => void onImportGroups: () => void } const InputSection: React.FC<Props> = ({ numbers, setNumbers, isValidating, onImportExcel, onImportGroups, }) => { return ( <> <Title order={4}>1. Input Numbers</Title> <ScrollArea h={250}> <Textarea label="Manual Input" value={numbers.join('\n')} onChange={(e) => { setNumbers(e.currentTarget.value.split('\n')) }} placeholder="Paste numbers here, one per line, with country code. E.g., 6281234567890" minRows={8} disabled={isValidating} autosize /> </ScrollArea> <Group> <Button variant="outline" leftSection={<Icon icon="tabler:file-type-xls" />} onClick={onImportExcel} disabled={isValidating} > Import from Excel </Button> <Button variant="outline" leftSection={<Icon icon="tabler:users" />} onClick={onImportGroups} disabled={isValidating} > Import from Groups </Button> </Group> </> ) } export default InputSection
```

# src/features/tools/number-validator/components/ResultsSection.tsx

```tsx
// src/features/Tools/NumberValidator/components/ResultsSection.tsx import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Badge, Button, Card, Group, Menu, Progress, ScrollArea, SegmentedControl, Stack, Text, Title, } from '@mantine/core' import { useClipboard } from '@mantine/hooks' import _ from 'lodash' import React, { useMemo, useState } from 'react' import type { useNumberValidator } from '../hooks/useNumberValidator' import ResultTable from './ResultTable' interface Props { validator: ReturnType<typeof useNumberValidator> } const ResultsSection: React.FC<Props> = ({ validator }) => { const [filter, setFilter] = useState('All') const [sortStatus, setSortStatus] = useState({ columnAccessor: 'number', direction: 'asc', }) const clipboard = useClipboard({ timeout: 1000 }) const stats = useMemo(() => { if (validator.results.length === 0) return { total: 0, valid: 0, invalid: 0 } return { total: validator.results.length, valid: validator.results.filter((r) => r.status === 'Valid').length, invalid: validator.results.filter((r) => r.status === 'Invalid').length, } }, [validator.results]) const displayedResults = useMemo(() => { let filtered = validator.results if (filter !== 'All') { filtered = validator.results.filter((r) => r.status === filter) } return _.orderBy( filtered, [sortStatus.columnAccessor], //@ts-ignore [sortStatus.direction], ) }, [validator.results, filter, sortStatus]) const handleCopyToClipboard = (copyType: 'all' | 'valid' | 'invalid') => { const numbersToCopy = copyType === 'all' ? displayedResults.map((r) => r.number) : displayedResults .filter( (r) => r.status === (copyType === 'valid' ? 'Valid' : 'Invalid'), ) .map((r) => r.number) if (numbersToCopy.length === 0) { toast.info(`No ${copyType} numbers to copy.`) return } clipboard.copy(numbersToCopy.join('\n')) toast.success(`${numbersToCopy.length} number(s) copied to clipboard!`) } return ( <Card withBorder p="lg" radius="md"> <Stack> <Group justify="space-between"> <Title order={4}>Results</Title> <Group> <Menu shadow="md" width={200}> <Menu.Target> <Button variant="light" leftSection={<Icon icon="tabler:copy" />} disabled={ displayedResults.length === 0 || validator.isValidating } > Copy Results </Button> </Menu.Target> <Menu.Dropdown> <Menu.Item onClick={() => handleCopyToClipboard('all')}> Copy All </Menu.Item> <Menu.Item onClick={() => handleCopyToClipboard('valid')}> Copy Valid </Menu.Item> <Menu.Item onClick={() => handleCopyToClipboard('invalid')}> Copy Invalid </Menu.Item> </Menu.Dropdown> </Menu> <Menu shadow="md" width={200}> <Menu.Target> <Button variant="light" leftSection={<Icon icon="tabler:download" />} disabled={ displayedResults.length === 0 || validator.isValidating } > Export Results </Button> </Menu.Target> <Menu.Dropdown> <Menu.Item onClick={() => validator.handleExport(displayedResults, 'csv') } > Export as CSV </Menu.Item> <Menu.Item onClick={() => validator.handleExport(displayedResults, 'xlsx') } > Export as Excel </Menu.Item> </Menu.Dropdown> </Menu> </Group> </Group> {!validator.isValidating && validator.results.length > 0 && ( <Group justify="space-between"> <Group> <Badge size="lg">Total: {stats.total}</Badge> <Badge color="green" size="lg"> Valid: {stats.valid} </Badge> <Badge color="red" size="lg"> Invalid: {stats.invalid} </Badge> </Group> <SegmentedControl value={filter} onChange={setFilter} data={['All', 'Valid', 'Invalid']} /> </Group> )} {validator.isValidating && ( <Stack> <Text> Validating {validator.progress.current} of{' '} {validator.progress.total}... </Text> <Progress value={ (validator.progress.current / validator.progress.total) * 100 } animated /> </Stack> )} <ScrollArea h={350}> <ResultTable records={displayedResults} //@ts-ignore sortStatus={sortStatus} onSortStatusChange={setSortStatus} /> </ScrollArea> </Stack> </Card> ) } export default ResultsSection
```

# src/features/tools/number-validator/components/ResultTable.tsx

```tsx
import wa from '@/libs/wa' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Group, Tooltip } from '@mantine/core' import { DataTable, type DataTableColumn, type DataTableSortStatus, } from 'mantine-datatable' import React from 'react' import type { ValidationResult } from '../hooks/useNumberValidator' interface Props { records: ValidationResult[] sortStatus: DataTableSortStatus onSortStatusChange: (status: DataTableSortStatus) => void } const ResultTable: React.FC<Props> = ({ records, sortStatus, onSortStatusChange, }) => { const handleStartChat = async (number: string) => { await wa.chat.openChatBottom(`${number}@c.us`) } const columns: DataTableColumn<ValidationResult>[] = [ { accessor: 'number', title: 'Phone Number', sortable: true, }, { accessor: 'status', title: 'Status', sortable: true, render: ({ status }) => { const color = status === 'Valid' ? 'green' : status === 'Invalid' ? 'red' : 'yellow' return <Badge color={color}>{status}</Badge> }, }, { accessor: 'actions', title: 'Actions', textAlign: 'right', render: (record) => ( <Group gap={4} justify="right" wrap="nowrap"> {record.status === 'Valid' && ( <Tooltip label="Start Chat"> <ActionIcon size="sm" variant="subtle" color="blue" onClick={() => handleStartChat(record.number)} > <Icon icon="tabler:brand-whatsapp" /> </ActionIcon> </Tooltip> )} </Group> ), }, ] return ( <DataTable records={records} columns={columns} minHeight={150} noRecordsText="No results to display yet." withTableBorder striped highlightOnHover //@ts-ignore sortStatus={sortStatus} //@ts-ignore onSortStatusChange={onSortStatusChange} /> ) } export default ResultTable
```

# src/features/tools/number-validator/components/SettingsSection.tsx

```tsx
// src/features/Tools/NumberValidator/components/SettingsSection.tsx import { Fieldset, Group, NumberInput, Switch, Text, Title, } from '@mantine/core' import React from 'react' import type { useNumberValidator } from '../hooks/useNumberValidator' interface Props { validator: ReturnType<typeof useNumberValidator> isValidating: boolean } const SettingsSection: React.FC<Props> = ({ validator, isValidating }) => { return ( <> <Title order={4} mt="md"> 2. Configure Settings </Title> <Fieldset legend="Randomized Delay"> <Text size="sm" c="dimmed" mb="xs"> Using a random delay between checks helps mimic human behavior. </Text> <Group grow> <NumberInput label="Min Delay (sec)" description="Minimum time between checks." value={validator.delayMin} onChange={(value) => validator.setDelayMin(Number(value))} min={1} step={1} disabled={isValidating} /> <NumberInput label="Max Delay (sec)" description="Maximum time between checks." value={validator.delayMax} onChange={(value) => validator.setDelayMax(Number(value))} min={1} step={1} disabled={isValidating} /> </Group> </Fieldset> <Fieldset legend="Batch Processing"> <Switch checked={validator.isBatchingEnabled} onChange={(event) => validator.setIsBatchingEnabled(event.currentTarget.checked) } label="Process numbers in batches" description="For large lists, this pauses validation periodically." disabled={isValidating} /> {validator.isBatchingEnabled && ( <Group grow mt="md"> <NumberInput label="Batch Size" description="Numbers to check before pausing." value={validator.batchSize} onChange={(value) => validator.setBatchSize(Number(value))} min={1} step={10} disabled={isValidating} /> <NumberInput label="Pause Duration (minutes)" description="How long to pause after each batch." value={validator.batchPause} onChange={(value) => validator.setBatchPause(Number(value))} min={1} step={1} disabled={isValidating} /> </Group> )} </Fieldset> </> ) } export default SettingsSection
```

# src/features/tools/number-validator/hooks/useNumberValidator.ts

```ts
// src/features/Tools/NumberValidator/useNumberValidator.ts import useFile from '@/hooks/useFile' import wa from '@/libs/wa' import toast from '@/utils/toast' import { delay as sleep } from '@/utils/util' import _ from 'lodash' import { useCallback, useMemo, useRef, useState } from 'react' export interface ValidationResult { number: string status: 'Valid' | 'Invalid' | 'Checking' } /** * @hook useNumberValidator * @description Manages the state and logic for the WhatsApp number validation feature. */ export const useNumberValidator = () => { const [numbers, setNumbers] = useState<string[]>([]) const [results, setResults] = useState<ValidationResult[]>([]) const [delayMin, setDelayMin] = useState(2) const [delayMax, setDelayMax] = useState(5) const [isBatchingEnabled, setIsBatchingEnabled] = useState(false) const [batchSize, setBatchSize] = useState(50) const [batchPause, setBatchPause] = useState(1) const [progress, setProgress] = useState({ current: 0, total: 0 }) const [isValidating, setIsValidating] = useState(false) const validationRef = useRef(false) const fileExporter = useFile() const addNumbers = (newNumbers: string[]) => { const combined = [...numbers, ...newNumbers] const unique = _.uniq(combined.map((n) => n.trim()).filter(Boolean)) setNumbers(unique) toast.success(`${newNumbers.length} numbers added. Duplicates removed.`) } const handleStopValidation = useCallback(() => { validationRef.current = false setIsValidating(false) toast.info('Validation stopped by user.') }, []) const estimatedTime = useMemo(() => { const cleanedNumbers = _.uniq(numbers.map((n) => n.trim()).filter(Boolean)) const numberCount = cleanedNumbers.length if (numberCount === 0) return '' const averageDelay = (delayMin + delayMax) / 2 let totalSeconds = numberCount * averageDelay if (isBatchingEnabled && batchSize > 0 && batchPause > 0) { const numberOfPauses = Math.floor((numberCount - 1) / batchSize) if (numberOfPauses > 0) { totalSeconds += numberOfPauses * batchPause * 60 } } const minutes = Math.floor(totalSeconds / 60) const seconds = Math.round(totalSeconds % 60) if (minutes > 0) { return `About ${minutes} minute(s) and ${seconds} second(s).` } return `About ${seconds} second(s).` }, [numbers, delayMin, delayMax, isBatchingEnabled, batchSize, batchPause]) const handleStartValidation = useCallback(async () => { const cleanedNumbers = _.uniq( numbers.map((n) => n.replace(/\D/g, '')).filter(Boolean), ) if (cleanedNumbers.length === 0) { toast.error('Please add numbers to validate.') return } if (delayMin > delayMax) { toast.error('Minimum delay cannot be greater than maximum delay.') return } validationRef.current = true setIsValidating(true) setResults(cleanedNumbers.map((number) => ({ number, status: 'Checking' }))) setProgress({ current: 0, total: cleanedNumbers.length }) for (let i = 0; i < cleanedNumbers.length; i++) { if (!validationRef.current) break const currentNumberIndex = i + 1 if ( isBatchingEnabled && currentNumberIndex % batchSize === 0 && currentNumberIndex < cleanedNumbers.length ) { toast.info( `Batch of ${batchSize} completed. Pausing for ${batchPause} minute(s).`, ) await sleep(batchPause * 60 * 1000) if (!validationRef.current) break } const number = cleanedNumbers[i] try { const isExist = await wa.contact.isExist(`${number}@c.us`) setResults((prev) => prev.map((res) => res.number === number ? { ...res, status: isExist ? 'Valid' : 'Invalid' } : res, ), ) } catch (error) { setResults((prev) => prev.map((res) => res.number === number ? { ...res, status: 'Invalid' } : res, ), ) } setProgress({ current: currentNumberIndex, total: cleanedNumbers.length }) const randomDelay = Math.random() * (delayMax - delayMin) + delayMin await sleep(1000 * randomDelay) } setIsValidating(false) if (validationRef.current) { toast.success('Validation complete!') } }, [numbers, delayMin, delayMax, isBatchingEnabled, batchSize, batchPause]) const handleClear = () => { setNumbers([]) setResults([]) setProgress({ current: 0, total: 0 }) } // Refactored to use the centralized hook const handleExport = ( records: ValidationResult[], format: 'csv' | 'xlsx', ) => { if (records.length === 0) { toast.info('No results to export.') return } const dataToExport = records.map(({ number, status }) => ({ Number: number, Status: status, })) const filename = `number-validator-results_${new Date() .toISOString() .slice(0, 10)}` fileExporter.saveAs(format, dataToExport, filename) } return { numbers, setNumbers, delayMin, setDelayMin, delayMax, setDelayMax, isBatchingEnabled, setIsBatchingEnabled, batchSize, setBatchSize, batchPause, setBatchPause, results, progress, isValidating, estimatedTime, handleStartValidation, handleStopValidation, handleClear, addNumbers, handleExport, } }
```

# src/features/tools/number-validator/PageNumberValidator.tsx

```tsx
// src/features/Tools/NumberValidator/PageNumberValidator.tsx import LayoutPage from '@/components/Layout/LayoutPage' import ModalSourceExcel from '@/components/Modal/ModalSourceExcel' import { Icon } from '@iconify/react' import { Button, Card, Group, Stack, Text, Title } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import React from 'react' import { When } from 'react-if' import InputSection from './components/InputSection' import ResultsSection from './components/ResultsSection' import SettingsSection from './components/SettingsSection' import { useNumberValidator } from './hooks/useNumberValidator' const PageNumberValidator: React.FC = () => { const [showExcelModal, excelModalHandlers] = useDisclosure(false) const [showGroupsModal, groupsModalHandlers] = useDisclosure(false) const validator = useNumberValidator() const handleAddFromSource = (newRecipients: any[]) => { const newNumbers = newRecipients.map((r) => r.number || r) validator.addNumbers(newNumbers) excelModalHandlers.close() groupsModalHandlers.close() } return ( <LayoutPage title="Number Validator"> <Stack> <Title order={3}>WhatsApp Number Validator</Title> <Text c="dimmed" size="sm"> Check if phone numbers are registered on WhatsApp. Paste numbers, upload a file, or import from your groups. </Text> <Card withBorder p="lg" radius="md"> <Stack> <InputSection numbers={validator.numbers} setNumbers={validator.setNumbers} isValidating={validator.isValidating} onImportExcel={excelModalHandlers.open} onImportGroups={groupsModalHandlers.open} /> <SettingsSection validator={validator} isValidating={validator.isValidating} /> <Title order={4} mt="md"> 3. Start Validation </Title> <When condition={!validator.isValidating && validator.estimatedTime} > <Text size="sm" c="dimmed"> <b>Estimated Completion Time:</b> {validator.estimatedTime} </Text> </When> <Group justify="space-between" mt="sm"> <Text c="dimmed" size="sm"> Total numbers to check:{' '} {validator.numbers.filter(Boolean).length} </Text> <Group> <Button variant="outline" color="red" onClick={validator.handleClear} disabled={validator.isValidating} leftSection={<Icon icon="tabler:x" />} > Clear All </Button> {validator.isValidating ? ( <Button variant="filled" color="red" onClick={validator.handleStopValidation} leftSection={<Icon icon="tabler:player-stop" />} > Stop </Button> ) : ( <Button onClick={validator.handleStartValidation} disabled={validator.numbers.filter(Boolean).length === 0} leftSection={<Icon icon="tabler:player-play" />} > Start Validation </Button> )} </Group> </Group> </Stack> </Card> <When condition={validator.isValidating || validator.results.length > 0} > <ResultsSection validator={validator} /> </When> </Stack> <ModalSourceExcel opened={showExcelModal} onClose={excelModalHandlers.close} onSubmit={handleAddFromSource} /> {/* <ModalSourceMemberGroups opened={showGroupsModal} onClose={groupsModalHandlers.close} onSubmit={handleAddFromSource} /> */} </LayoutPage> ) } export default PageNumberValidator
```

# src/features/tools/PageTools.tsx

```tsx
// src/features/Tools/PageTools.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Page } from '@/constants' import page from '@/utils/page' import { Icon } from '@iconify/react' import { SimpleGrid, Stack, Text, Tooltip, UnstyledButton } from '@mantine/core' import React from 'react' /** * @description Defines a single tool item for the grid display. */ interface ToolItem { key: string title: string description: string icon: string } const PageTools: React.FC = () => { const toolList: ToolItem[] = [ { key: Page.DIRECT_CHAT, title: 'Direct Chat', description: 'Start a chat without saving the number to your contacts.', icon: 'tabler:message-circle-plus', }, { key: Page.NUMBER_VALIDATOR, title: 'Number Validator', description: 'Check if WhatsApp numbers are valid.', icon: 'tabler:checks', }, { key: Page.CHAT_BACKUP, // ++ ADDED title: 'Chat Backup', description: 'Export and backup individual or group chats.', icon: 'tabler:database-export', }, { key: Page.PRIVACY, title: 'Privacy', description: 'Blur messages, names, and photos for enhanced privacy.', icon: 'tabler:eye-off', }, { key: Page.EXPORT, title: 'Export Contacts', description: 'Export contacts, chats, and group members.', icon: 'tabler:download', }, { key: Page.WA_ME_GENERATOR, title: 'WA.me Generator', description: 'Create a WhatsApp click-to-chat link instantly.', icon: 'tabler:link', }, { key: Page.GROUP_LINK_GENERATOR, title: 'Group Link Generator', description: 'Get an invite link for any of your groups.', icon: 'tabler:ticket', }, ] const handleToolClick = (key: ToolItem['key']) => { switch (key) { case Page.DIRECT_CHAT: page.goTo(Page.DIRECT_CHAT) break case Page.NUMBER_VALIDATOR: page.goTo(Page.NUMBER_VALIDATOR) break case Page.PRIVACY: page.goTo(Page.PRIVACY) break case Page.EXPORT: page.goTo(Page.EXPORT) break case Page.WA_ME_GENERATOR: page.goTo(Page.WA_ME_GENERATOR) break case Page.GROUP_LINK_GENERATOR: page.goTo(Page.GROUP_LINK_GENERATOR) break case Page.CHAT_BACKUP: // ++ ADDED page.goTo(Page.CHAT_BACKUP) break default: break } } const renderGrid = () => ( <SimpleGrid cols={3} spacing="lg"> {toolList.map((tool) => ( <Tooltip key={tool.key} label={tool.description} position="top" withArrow > <UnstyledButton onClick={() => handleToolClick(tool.key)}> <Stack align="center" gap="sm"> <Icon icon={tool.icon} fontSize={32} color="var(--mantine-color-teal-6)" /> <Text fw={500}>{tool.title}</Text> </Stack> </UnstyledButton> </Tooltip> ))} </SimpleGrid> ) return ( <LayoutPage title="Tools"> <Stack p="md">{renderGrid()}</Stack> </LayoutPage> ) } export default PageTools
```

# src/features/tools/privacy/components/PagePrivacy.tsx

```tsx
import LayoutPage from '@/components/Layout/LayoutPage' import { Setting } from '@/constants' import { Card, Divider, Group, Stack, Switch, Text, Title } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' const PagePrivacy: React.FC = () => { const [blurProfilePictures, setBlurProfilePictures] = useStorage( Setting.BLUR_PROFILE_PICTURES, false, ) const [blurMessages, setBlurMessages] = useStorage( Setting.BLUR_MESSAGES, false, ) const [blurUserGroupNames, setBlurUserGroupNames] = useStorage( Setting.BLUR_USER_GROUP_NAMES, false, ) const [blurRecentMessages, setBlurRecentMessages] = useStorage( Setting.BLUR_RECENT_MESSAGES, false, ) const [allSwitchesEnabled, setAllSwitchesEnabled] = useState(false) useEffect(() => { const allEnabled = blurProfilePictures && blurMessages && blurUserGroupNames && blurRecentMessages setAllSwitchesEnabled(allEnabled) }, [ blurProfilePictures, blurMessages, blurUserGroupNames, blurRecentMessages, ]) const handleToggleAll = async (checked: boolean) => { setAllSwitchesEnabled(checked) await Promise.all([ setBlurProfilePictures(checked), setBlurMessages(checked), setBlurUserGroupNames(checked), setBlurRecentMessages(checked), ]) } const handleIndividualSwitchChange = async ( setter: (value: boolean) => Promise<void>, checked: boolean, ) => { await setter(checked) if (!checked) { setAllSwitchesEnabled(false) } } const privacyOptions = [ { label: 'Profile Pictures', description: 'Blur all contact and group profile pictures.', checked: blurProfilePictures, setter: setBlurProfilePictures, }, { label: 'User/Group Names', description: 'Blur names in the chat list and chat header.', checked: blurUserGroupNames, setter: setBlurUserGroupNames, }, { label: 'Recent Messages', description: 'Blur the last message preview in the chat list.', checked: blurRecentMessages, setter: setBlurRecentMessages, }, { label: 'Messages', description: 'Blur all messages in the active chat view.', checked: blurMessages, setter: setBlurMessages, }, ] return ( <LayoutPage title="Privacy"> <Stack> <Card withBorder radius="md" shadow="none"> <Stack> <Title order={4}>Content Blurring</Title> <Text c="dimmed" size="sm"> Enhance your privacy by blurring different parts of the WhatsApp interface. </Text> <Divider my="sm" /> <Group justify="space-between"> <Text fw={500}>Blur Everything</Text> <Switch aria-label="Toggle all privacy settings" checked={allSwitchesEnabled} onChange={async (event) => { await handleToggleAll(event.currentTarget.checked) }} /> </Group> <Divider my="sm" /> <Stack gap="md"> {privacyOptions.map((option, index) => ( <Group justify="space-between" key={index} wrap="nowrap"> <Stack gap={0}> <Text fw={500}>{option.label}</Text> <Text size="xs" c="dimmed"> {option.description} </Text> </Stack> <Switch aria-label={`Toggle ${option.label}`} checked={option.checked} onChange={async (event) => { await handleIndividualSwitchChange( option.setter, event.currentTarget.checked, ) }} /> </Group> ))} </Stack> </Stack> </Card> </Stack> </LayoutPage> ) } export default PagePrivacy
```

# src/features/tools/privacy/components/PrivacyListener.tsx

```tsx
import { Setting } from '@/constants' import useWa from '@/hooks/useWa' import privacy from '@/utils/privacy' import { useMutationObserver } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import $ from 'jquery' import React, { useEffect } from 'react' const PrivacyListener: React.FC = () => { const wa = useWa() const [blurProfilePictures] = useStorage(Setting.BLUR_PROFILE_PICTURES) const [blurMessages] = useStorage(Setting.BLUR_MESSAGES) const [blurUserGroupNames] = useStorage(Setting.BLUR_USER_GROUP_NAMES) const [blurRecentMessages] = useStorage(Setting.BLUR_RECENT_MESSAGES) useMutationObserver( (mutations) => { privacy.blurProfilePictures().then().catch(console.error) privacy.blurUserGroupNames().then().catch(console.error) privacy.blurRecentMessages().then().catch(console.error) }, { attributes: true, childList: true, }, () => $('div[class="x1y332i5 x1n2onr6 x6ikm8r x10wlt62 xjwt4uw"]')[0], ) useMutationObserver( (mutations) => { privacy.blurMessages() }, { attributes: true, childList: true, }, () => $( 'div[class="x3psx0u xwib8y2 xkhd6sd xrmvbpv xh8yej3 xquzyny x1gryazu xkrivgy"]', )[0], ) useEffect(() => { if (!wa.isReady) return privacy.blurProfilePictures().then().catch(console.error) }, [wa.isReady, blurProfilePictures]) useEffect(() => { if (!wa.isReady) return privacy.blurUserGroupNames().then().catch(console.error) }, [wa.isReady, blurUserGroupNames]) useEffect(() => { if (!wa.isReady) return privacy.blurRecentMessages().then().catch(console.error) }, [wa.isReady, blurRecentMessages]) useEffect(() => { if (!wa.isReady) return if (!wa.activeChat) return privacy.blurMessages() }, [wa.isReady, wa.activeChat, blurMessages]) useEffect(() => { if (!wa.activeChat) return }, [wa.activeChat]) return null } export default PrivacyListener
```

# src/features/tools/wa-me/PageWaMeGenerator.tsx

```tsx
// src/features/Tools/WaMeGenerator/PageWaMeGenerator.tsx import LayoutPage from '@/components/Layout/LayoutPage' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Card, Center, Group, Stack, Text, Textarea, TextInput, Title, Tooltip, } from '@mantine/core' import { useClipboard } from '@mantine/hooks' import React, { useState } from 'react' import { When } from 'react-if' /** * @component PageWaMeGenerator * @description A tool to generate WhatsApp "wa.me" click-to-chat links and corresponding QR codes. */ const PageWaMeGenerator: React.FC = () => { const [number, setNumber] = useState('') const [message, setMessage] = useState('') const [generatedLink, setGeneratedLink] = useState('') const clipboard = useClipboard({ timeout: 1000 }) /** * @description Handles the link generation logic. * It cleans the phone number, encodes the message, and constructs the final URL. */ const handleGenerateLink = () => { if (!number) { toast.error('Phone number is required.') return } // Remove any non-digit characters from the number. const cleanedNumber = number.replace(/\D/g, '') // Encode the message for use in a URL. const encodedMessage = encodeURIComponent(message) const link = `https://wa.me/${cleanedNumber}?text=${encodedMessage}` setGeneratedLink(link) toast.success('Link generated successfully!') } return ( <LayoutPage title="WA.me Link Generator"> <Stack> <Stack align="center" gap={4} mb="xl"> <Icon icon="tabler:link" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> WA.me Link Generator </Title> <Text c="dimmed" size="sm" ta="center"> Create a WhatsApp click-to-chat link with a pre-filled message. </Text> </Stack> <Card withBorder p="lg" radius="md" shadow="none"> <Stack> <TextInput label="WhatsApp Number" placeholder="e.g., 6281234567890" description="Enter the full number with country code, without '+' or spaces." value={number} onChange={(event) => setNumber(event.currentTarget.value)} required /> <Textarea label="Pre-filled Message (Optional)" placeholder="Enter the message you want to pre-fill." value={message} onChange={(event) => setMessage(event.currentTarget.value)} minRows={4} autosize /> <Group justify="flex-end" mt="md"> <Button onClick={handleGenerateLink} leftSection={<Icon icon="tabler:refresh-dot" fontSize={20} />} > Generate Link </Button> </Group> </Stack> </Card> <When condition={generatedLink}> <Card withBorder p="lg" radius="md" mt="lg"> <Stack align="center"> <Title order={4}>Your Link is Ready!</Title> <TextInput w="100%" readOnly label="Generated Link" value={generatedLink} rightSection={ <Tooltip label={clipboard.copied ? 'Copied!' : 'Copy Link'} position="left" withArrow > <ActionIcon variant="subtle" onClick={() => clipboard.copy(generatedLink)} > <Icon icon={clipboard.copied ? 'tabler:check' : 'tabler:copy'} /> </ActionIcon> </Tooltip> } /> </Stack> </Card> </When> </Stack> </LayoutPage> ) } export default PageWaMeGenerator
```

# src/hooks/useAi.ts

```ts
// src/hooks/useAi.ts import { AI } from '@/constants/action' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' const useAi = () => { const rewriteMessage = async ( prompt: string, message: string, system: | string | null = 'You are an expert copywriter. Your task is to rewrite the user message based on their instruction.', ): Promise<Response<string>> => { // Send the request to the background relay defined in `ai.relay.ts` return await sendToBackgroundViaRelay({ //@ts-ignore name: 'ai', body: { prompt, message, system }, }) } return { rewriteMessage, } } export default useAi
```

# src/hooks/useDataQuery.ts

```ts
import type { EntityTable } from 'dexie' import { useLiveQuery } from 'dexie-react-hooks' import { useMemo, useState } from 'react' type SortDirection = 'asc' | 'desc' interface Sort { field: string direction: SortDirection } type SortState = Sort | null type FilterOperator = | 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'between' interface Filter { field: string operator: FilterOperator value: any secondValue?: any } interface useDataQueryOptions<T> { //@ts-ignore table: EntityTable<T, 'id'> initialPageSize?: number searchField?: string initialSort?: Sort initialFilters?: Filter[] } export const useDataQuery = <T>(options: useDataQueryOptions<T>) => { const { table, initialPageSize = 10, searchField = 'name', initialSort = { field: 'id', direction: 'desc' }, initialFilters = [], } = options const [page, setPage] = useState(1) const [pageSize, setPageSize] = useState(initialPageSize) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<T[]>([]) const [sort, setSort] = useState<SortState>(initialSort) const [filters, setFilters] = useState<Filter[]>(initialFilters) const applyFilter = (query: any, filter: Filter) => { const { field, operator, value, secondValue } = filter switch (operator) { case 'equals': return query.filter((item: any) => item[field] === value) case 'contains': return query.filter((item: any) => String(item[field]) .toLowerCase() .includes(String(value).toLowerCase()), ) case 'startsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .startsWith(String(value).toLowerCase()), ) case 'endsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .endsWith(String(value).toLowerCase()), ) case 'greaterThan': return query.filter((item: any) => item[field] > value) case 'lessThan': return query.filter((item: any) => item[field] < value) case 'between': return query.filter( (item: any) => item[field] >= value && item[field] <= (secondValue ?? value), ) default: return query } } const data = useLiveQuery(async () => { if (pageSize <= 0) return { data: [], totalItems: 0, hasMore: false } const startIndex = (page - 1) * pageSize let query = search ? table.where(searchField).startsWithIgnoreCase(search) : table.toCollection() let results = await query.toArray() filters.forEach((filter) => { results = applyFilter(results, filter) }) if (sort) { results.sort((a: any, b: any) => { const aValue = a[sort.field] const bValue = b[sort.field] if (aValue === bValue) return 0 const comparison = aValue > bValue ? 1 : -1 return sort.direction === 'asc' ? comparison : -comparison }) } const paginatedResults = results.slice(startIndex, startIndex + pageSize) return { data: paginatedResults, totalItems: results.length, hasMore: startIndex + paginatedResults.length < results.length, } }, [page, pageSize, search, sort, filters]) const _delete = async (id: any) => { if (confirm('Are you sure?')) { await table.delete(id) } } const toggleSort = (field: string) => { setSort((currentSort) => { // Case 1: No current sort, or a new column is clicked. Start with 'asc'. if (!currentSort || currentSort.field !== field) { return { field, direction: 'asc' } } // Case 2: Currently sorted 'asc'. Switch to 'desc'. if (currentSort.direction === 'asc') { return { field, direction: 'desc' } } // Case 3: Currently sorted 'desc'. Switch to null to remove sorting. if (currentSort.direction === 'desc') { return null } // Fallback, should not be reached. return currentSort }) } const addFilter = (filter: Filter) => { setFilters((prev) => [...prev, filter]) setPage(1) } const removeFilter = (index: number) => { setFilters((prev) => prev.filter((_, i) => i !== index)) setPage(1) } const updateFilter = (index: number, filter: Filter) => { setFilters((prev) => prev.map((f, i) => (i === index ? filter : f))) setPage(1) } const clearFilters = () => { setFilters([]) setPage(1) } const derivedData = useMemo( () => ({ data: data?.data ?? [], totalRecords: data?.totalItems ?? 0, hasMore: data?.hasMore ?? false, }), [data], ) return { ...derivedData, selectedRecords, page, pageSize, search, sort, filters, setPage, setPageSize, setSelectedRecords, setSearch, toggleSort, addFilter, removeFilter, updateFilter, clearFilters, _delete, searchField, } } export default useDataQuery
```

# src/hooks/useFile.ts

```ts
// src/utils/file.ts import { SaveAs, Setting } from '@/constants' import { storage } from '@/libs/storage' import FileSaver from 'file-saver' import _ from 'lodash' import * as XLSX from 'xlsx' import useLicense from './useLicense' const useFile = () => { const license = useLicense() const getSelectedColumns = async () => { return ( (await storage.get<Record<string, boolean>>(Setting.EXPORT_COLUMNS)) || { phoneNumber: true, publicName: true, savedName: true, isBlocked: true, isBusiness: true, isMyContact: true, } ) } const serializeData = async (data: any[]) => { const selectedColumns = await getSelectedColumns() let filteredData = data.map((item: any) => _.pickBy(item, (_, key) => selectedColumns[key] === true), ) if (license.isFree() && filteredData.length > 10) { filteredData = filteredData.map((item, index) => index >= 10 ? _.mapValues(item, () => '********') : item, ) } return filteredData } const defaultFilename = () => { return `export_${new Date().toISOString().slice(0, 10)}` } const saveAsCSV = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } const saveAsExcel = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet 1') XLSX.writeFile(workbook, `${filename}.xlsx`) } const saveAsJson = (data: any[], filename: string) => { const json = JSON.stringify(data, null, 2) const blob = new Blob([json], { type: 'application/json' }) FileSaver.saveAs(blob, `${filename}.json`) } const saveAsVCard = (data: any[]) => { const vcardContent = data .map((contact) => { const name = contact.savedName || contact.publicName || 'Unknown' const phone = contact.phoneNumber ? `+${contact.phoneNumber}` : '' return `BEGIN:VCARD\nVERSION:3.0\nFN:${name}\nTEL;TYPE=CELL:${phone}\nEND:VCARD` }) .join('\n') const blob = new Blob([vcardContent], { type: 'text/vcard' }) FileSaver.saveAs(blob, `${defaultFilename()}.vcf`) } /** * Main function to save data in various formats. * @param fileType The format to save as (e.g., 'csv', 'xlsx'). * @param data The array of data objects to save. * @param filename (Optional) The base name for the file, without extension. */ const saveAs = async (fileType: string, data: any[], filename?: string) => { const processedData = await serializeData(data) const finalFilename = filename || defaultFilename() switch (fileType) { case SaveAs.CSV: saveAsCSV(processedData, finalFilename) break case SaveAs.EXCEL: saveAsExcel(processedData, finalFilename) break case SaveAs.JSON: saveAsJson(processedData, finalFilename) break case SaveAs.VCARD: saveAsVCard(processedData) // VCard has its own filename logic break // Other formats like Markdown and HTML can be added here. default: console.error(`Unsupported file type: ${fileType}`) break } } return { saveAs } } export default useFile
```

# src/hooks/useLicense.ts

```ts
// src/hooks/useLicense.ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import type { License } from '@/types' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { sendToBackground } from '@plasmohq/messaging' import { isPast } from 'date-fns' const useLicense = () => { const { license, setLicense } = useAppStore() const callLemonSqueezyApi = async (action: string, body: any) => { return await sendToBackground({ name: 'lemonsqueezy', body: { action, body, }, }) } const init = async () => { // First, check for a cached, valid license to avoid unnecessary API calls. const cachedLicense = await storage.get<License | null>( Setting.LICENSE_DATA_CACHE, ) if (cachedLicense?.license_key?.status === 'active') { setLicense(cachedLicense) return } // If no valid cache, proceed with the standard validation flow. const licenseKey = await storage.get<string | null>(Setting.LICENSE_KEY) if (!licenseKey) { setLicense(null) await storage.remove(Setting.LICENSE_DATA_CACHE) return } const response = await callLemonSqueezyApi('validateLicense', { licenseKey, }) if (response.error) { // Validation failed, clear all license-related storage. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is invalid or has been deactivated. You have been switched to the Free plan.', 'License Invalid', ) return } if (response.data.meta.store_id.toString() !== getStoreId()) { await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is for a different product. You have been switched to the Free plan.', 'License Error', ) return } // Validation successful, update app state and cache the license data if active. setLicense(response.data) if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } if ( response.data.license_key.expires_at && isPast(new Date(response.data.license_key.expires_at)) ) { toast.info( 'Your license has expired. You have been switched to the Free plan.', 'License Expired', ) await storage.remove(Setting.LICENSE_DATA_CACHE) } } const isFree = (): boolean => { if (!license) { return true } return license.license_key.status !== 'active' } const isPro = () => { if (!license) { return false } return license.license_key.status === 'active' } const isExpired = () => { // For lifetime licenses, 'expires_at' might be null. // The most reliable check is the status. If no expiration date exists, it's not expired. if (!license || !license.license_key.expires_at) { return false } return isPast(new Date(license.license_key.expires_at)) } const getLicense = () => { return license } const activate = async (licenseKey: string) => { const response = await callLemonSqueezyApi('activateLicense', { licenseKey, }) if (!response.error) { setLicense(response.data) await storage.set(Setting.LICENSE_KEY, licenseKey) await storage.set(Setting.LICENSE_INSTANCE_ID, response.data.instance.id) // Cache the license data immediately on successful activation. if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } } return response } const deactivate = async () => { const licenseKey = await storage.get(Setting.LICENSE_KEY) const instanceId = await storage.get(Setting.LICENSE_INSTANCE_ID) try { const response = await callLemonSqueezyApi('deactivateLicense', { licenseKey, instanceId, }) if (response.data.deactivated) { // Clear all license-related data from storage on deactivation. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.success('Your license has been deactivated from this device.') } else { toast.error('Failed to deactivate the license. Please contact support.') } } catch (e) { toast.error('An error occurred during deactivation.') } } const goToMyOrders = async () => { if (!license?.meta?.customer_id) { toast.error('Could not find customer information.') return } try { const response = await callLemonSqueezyApi('getCustomer', { customerId: license.meta.customer_id, }) if (response.error) { toast.error('Could not retrieve customer portal link.') return } window.open( response.data.data.attributes.urls.customer_portal, '_blank', 'noopener,noreferrer', ) } catch (e) { toast.error('An error occurred while fetching your subscription details.') } } return { init, isFree, isPro, isExpired, activate, getLicense, goToMyOrders, deactivate, } } export default useLicense
```

# src/hooks/useRuntimeMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = ( message: T, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void, ) => void | boolean /** * A React hook for handling Chrome runtime messages * @param listener The callback function to handle incoming messages * @returns void * * @example * useRuntimeMessage((message, sender, sendResponse) => { * if (message.type === 'getData') { * sendResponse({ data: 'example' }) * } * // Return true to keep the message channel open for async responses * return true * }) */ const useRuntimeMessage = <T = any>(listener: MessageListener<T>): void => { const memoizedHandler = useCallback<MessageListener<T>>( (message, sender, sendResponse) => { return listener(message, sender, sendResponse) }, [listener], ) useEffect(() => { chrome.runtime.onMessage.addListener(memoizedHandler) return () => { chrome.runtime.onMessage.removeListener(memoizedHandler) } }, [memoizedHandler]) } export default useRuntimeMessage
```

# src/hooks/useWa.ts

```ts
import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' const useWa = () => { const { isReady, activeChat } = useAppStore() return { isReady, activeChat, ...wa, } } export default useWa
```

# src/hooks/useWindowMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = (event: MessageEvent<T>) => void const useWindowMessage = <T = any>(listener: MessageListener<T>): void => { const handleMessage = useCallback<MessageListener<T>>( (event) => { listener(event) }, [listener], ) useEffect(() => { window.addEventListener('message', handleMessage) return () => window.removeEventListener('message', handleMessage) }, [handleMessage]) } export default useWindowMessage
```

# src/libs/db.ts

```ts
// src/libs/db.ts import Dexie, { type EntityTable } from 'dexie' import packageJson from '../../package.json' export interface Media { id: number parentId: number type: string name: string file: File ext: string } export interface Broadcast { id: number name?: string | null type: string message: any isTyping: number isScheduler: number status: string delayMin?: number delayMax?: number pauseEnabled?: number pauseAfter?: number pauseDuration?: number pausedUntil?: Date | null } export interface BroadcastContact { id: number broadcastId: number number: string name?: string | null status: string error?: string | null scheduledAt?: Date | null sendAt?: Date | null } export interface BroadcastTemplate { id: number name: string type: string message: any } export interface BroadcastRecipient { id: number name: string recipients: { name: string; number: string; source: string }[] createdAt: Date } export interface Label { id: number label: string value: string show: number custom: number numbers?: any[] color?: string group?: string isPinned?: number } export interface DirectChatTemplate { id: number name: string message: string } export interface QuickReply { id: number name: string type: string message: any isPinned?: number createdAt?: Date } const db = new Dexie(packageJson.name) as Dexie & { media: EntityTable<Media, 'id'> broadcasts: EntityTable<Broadcast, 'id'> broadcastContacts: EntityTable<BroadcastContact, 'id'> broadcastTemplates: EntityTable<BroadcastTemplate, 'id'> broadcastRecipients: EntityTable<BroadcastRecipient, 'id'> labels: EntityTable<Label, 'id'> directChatTemplates: EntityTable<DirectChatTemplate, 'id'> quickReplies: EntityTable<QuickReply, 'id'> } // NOTE: Dexie cannot index boolean values. Fields intended for use in `where()` clauses // have been changed from `boolean` to `number` (0 for false, 1 for true). db.version(1).stores({ media: '++id, parentId, type, name, file, ext', broadcasts: '++id, name, type, message, isTyping, isScheduler, status, delayMin, delayMax, pauseEnabled, pauseAfter, pauseDuration, pausedUntil', broadcastContacts: '++id, broadcastId, number, name, status, error, scheduledAt, sendAt, [broadcastId+status]', broadcastTemplates: '++id, name, type, message', broadcastRecipients: '++id, name, createdAt', labels: '++id, label, value, show, custom, color, group, isPinned, *numbers', directChatTemplates: '++id, name', quickReplies: '++id, name, type, isPinned, createdAt', }) export default db
```

# src/libs/http.ts

```ts
import fetchAdapter from '@haverstack/axios-fetch-adapter' import axios from 'axios' const http = axios.create({ adapter: fetchAdapter, }) export default http
```

# src/libs/ls.ts

```ts
import * as lemon from '@lemonsqueezy/lemonsqueezy.js' lemon.lemonSqueezySetup({}) const lemonSqueezy = lemon export default lemonSqueezy
```

# src/libs/storage.ts

```ts
import { Storage } from '@plasmohq/storage' export const storage = new Storage({})
```

# src/libs/theme.ts

```ts
import { Button, createTheme, FileInput, Menu, Modal, MultiSelect, NumberInput, Popover, Radio, Select, Switch, TagsInput, Text, Textarea, TextInput, Tooltip, } from '@mantine/core' const theme = createTheme({ colors: { emerald: [ '#effbf3', '#ddf4e5', '#b6eac7', '#8cdfa7', '#6bd68c', '#56d07b', '#4acd72', '#3bb560', '#31a154', '#145229', ], }, primaryColor: 'teal', cursorType: 'pointer', components: { Button: Button.extend({ defaultProps: { size: 'sm', }, }), FileInput: FileInput.extend({ defaultProps: { size: 'md', }, }), Menu: Menu.extend({ defaultProps: { withinPortal: false } }), Modal: Modal.extend({ defaultProps: { size: 'xl', withCloseButton: false, withOverlay: false, withinPortal: false, }, }), NumberInput: NumberInput.extend({ defaultProps: { size: 'md' } }), MultiSelect: MultiSelect.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Popover: Popover.extend({ defaultProps: { withinPortal: false, }, }), Radio: Radio.extend({ defaultProps: { size: 'md', }, }), Select: Select.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Switch: Switch.extend({ defaultProps: { size: 'md', }, }), TagsInput: TagsInput.extend({ defaultProps: { size: 'md', }, }), Text: Text.extend({ defaultProps: { size: 'md', }, }), Textarea: Textarea.extend({ defaultProps: { size: 'md', }, }), TextInput: TextInput.extend({ defaultProps: { size: 'md', }, }), Tooltip: Tooltip.extend({ defaultProps: { position: 'left', withinPortal: false, withArrow: true, }, }), }, }) export default theme
```

# src/libs/wa/blocklist.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' export const all = async (): Promise<Wid[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.ALL, body: {}, }) } export const blockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.BLOCK_CONTACT, body: chatId, }) } export const isBlocked = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.IS_BLOCKED, body: chatId, }) } export const unblockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.UNBLOCK_CONTACT, body: chatId, }) }
```

# src/libs/wa/cart.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { SendMessageOptions } from '@wppconnect/wa-js/dist/chat' /** * Add product in cart * * @example * \`\`\`javascript * const cart = wa.cart.add('[number]@c.us', [ * { id: 'productId', qnt: 2 }, * ]); * \`\`\` */ export const add = async ( chatId: string, products: { id: string qnt: number }[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.ADD, body: { chatId, products }, }) } /** * Clear all items of cart * */ export const clear = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.CLEAR, body: wid, }) } /** * Get products in cart chat * * @example * \`\`\`javascript * const cart = wa.cart.get('[number]@c.us'); * \`\`\` */ export const get = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET, body: wid, }) } /** * Get thumb of a cart * * @example * \`\`\`javascript * const cart = wa.cart.getThumbFromCart('[number]@c.us'); * \`\`\` */ export const getThumbFromCart = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET_THUMB_FROM_CART, body: wid, }) } /** * Remove a product in cart * * @example * \`\`\`javascript * const cart = wa.cart.remove('[number]@c.us', '6987301181294productId'); * \`\`\` */ export const remove = async ( chatId: string, productId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.REMOVE, body: { chatId, productId }, }) } /** * Send a request order to business chat * * @example * \`\`\`javascript * const cart = wa.cart.submit('[number]@c.us'); * \`\`\` * * @example * \`\`\`javascript * // Send cart with a custom message * const cart = wa.cart.submit('[number]@c.us', 'Custom message here'); * \`\`\` */ export const submit = async ( wid: string, msg?: string, options?: SendMessageOptions, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.SUBMIT, body: { wid, msg, options }, }) } /** * Update product in cart * * @example * \`\`\`javascript * const cart = wa.cart.update('[number]@c.us', '6987301181294productId', { quantity: 12 }); * \`\`\` */ export const update = async ( chatId: string, productId: string, options: { quantity: number }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.UPDATE, body: { chatId, productId, options }, }) }
```

# src/libs/wa/catalog.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { createProductParams } from '@wppconnect/wa-js/dist/catalog/functions/createProduct' import type { editProductParams } from '@wppconnect/wa-js/dist/catalog/functions/editProduct' /** * Add image on product * This function include additional images on product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.addProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const addProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.ADD_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Add image on product * This function change main image of product * for change additional images use @addProductImage * * @example * \`\`\`javascript * await wa.catalog.changeProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const changeProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CHANGE_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Create new collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.createCollection('Collection Name', ['565656589898']); * \`\`\` */ export const createCollection = async ( collectionName: string, productsId: string[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_COLLECTION, body: { collectionName, productsId }, }) } /** * Create new product * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.addProduct( { name: 'Product name', image: 'base64 image string', description: 'product description', price: '89.90', isHidden: false, url: 'https://wppconnect.io', retailerId: 'AKA001', } ); * \`\`\` */ export const createProduct = async ( params: createProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_PRODUCT, body: params, }) } /** * Delete a collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.deleteCollection("377095767832354"); * \`\`\` * * @return Return sucess or error */ export const deleteCollection = async (collectionId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_COLLECTION, body: collectionId, }) } /** * @example * \`\`\`javascript * * // Delete various products * const myCatalog = await wa.catalog.delProducts(['6104203702939361', '6104289702939361']); * \`\`\` */ export const deleteProduct = async (productsIds: string[]): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_PRODUCT, body: productsIds, }) } /** * @example * \`\`\`javascript * const myCatalog = await wa.catalog.EditCollection('565656589898', { collectionName: 'New Name for collection', productsToAdd: ['5656523223'], productsToRemove: ['5656523232']}); * \`\`\` */ interface paramsEditCollection { name?: string productsToAdd?: string[] productsToRemove?: string[] } export const editCollection = async ( collectionId: string, params: paramsEditCollection, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_COLLECTION, body: { collectionId, params }, }) } /** * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = wa.catalog.editProduct('5498255476885590', {name: 'Plano 01', price: '89990', description: 'Insert description for your product', isHidden: true, url: 'http://www.wppconnect.io', retailerId: 'AKA001'}); * \`\`\` */ export const editProduct = async ( productId: string, params: editProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_PRODUCT, body: { productId, params }, }) } /** * Get collections of catalog * * @example * \`\`\`javascript * // Retrieve 20 collections of chat * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20'); * * // Retrieve 20 collections of chat and products arrays limit with 10 products * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20', '10'); * \`\`\` */ export const getCollections = async ( chatId: string, qnt?: number, productsCount?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_COLLECTIONS, body: { chatId, qnt, productsCount }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ export const getMyCatalog = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_MY_CATALOG, body: {}, }) } /** * Retrieves product by id * * @example * \`\`\`javascript * // Retrieve data of product * await wa.catalog.getProductById('5521985565656@c.us', '68685985868923'); * \`\`\` */ export const getProductById = async ( chatId: string, productId: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCT_BY_ID, body: { chatId, productId }, }) } /** * Retrieves product by contact id * * @example * Get products of catalogs * \`\`\`javascript * await wa.catalog.getProducts('5521985625689@c.us', 10); * \`\`\` */ export const getProducts = async (chatId: string, qnt: number): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCTS, body: { chatId, qnt }, }) } /** * Remove image on product * This function remove additional images of product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.removeProductImage('68685985868923', '0'); * \`\`\` */ export const removeProductImage = async ( productId: string, index: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.REMOVE_PRODUCT_IMAGE, body: { productId, index }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` */ export const setProductVisibility = async ( productId: any, isHidden: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.SET_PRODUCT_VISIBILITY, body: { productId, isHidden }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` * * @return Return sucess of product visibility set */ export const updateCartEnabled = async (enabled: boolean): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.UPDAGE_CART_ENABLED, body: enabled, }) }
```

# src/libs/wa/chat.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions, DeleteMessageReturn, ForwardMessagesOptions, GetMessagesOptions, RawMessage, } from '@wppconnect/wa-js/dist/chat' import type { ParticipantStatusACK } from '@wppconnect/wa-js/dist/chat/functions/getMessageACK' import type { Stringable } from '@wppconnect/wa-js/dist/types' import type { MsgKey, MsgModel, Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { ACK } from '@wppconnect/wa-js/dist/whatsapp/enums' /** * Archive a chat * * @example * // Archive a chat * wa.chat.archive('[number]@c.us'); * * // Unarchive a chat * wa.chat.archive('[number]@c.us', false); * \`\`\` */ export const archive = async ( chatId: string | Wid, archive = true, ): Promise<{ wid: Wid archive: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.ARCHIVE, body: { chatId, archive }, }) } /** * Get if message can played * * @example * \`\`\`javascript * wa.chat.canMarkPlayed('[message_id]'); * \`\`\` */ export const canMarkPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MARK_PLAYED, body: messageId, }) } /** * Check if is possible to mute this chat * * @example * \`\`\`javascript * const canMute = wa.chat.canMute('[number]@c.us'); * \`\`\` */ export const canMute = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MUTE, body: chatId, }) } /** * Get if message can reply * * @example * \`\`\`javascript * wa.chat.canReply('[message_id]'); * \`\`\` */ export const canReply = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_REPLY, body: messageId, }) } /** * Clear a chat message * */ export const clear = async ( chatId: string | Wid, keepStarred = true, ): Promise<{ wid: Wid status: number keepStarred: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLEAR, body: { chatId, keepStarred }, }) } /** * Close the chat tab * * @example * \`\`\`javascript * await wa.chat.closeChat(); * \`\`\` * */ export const closeChat = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLOSE_CHAT, body: {}, }) } /** * Delete a chat * */ export const _delete = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE, body: chatId, }) } /** * Delete a message * * @example * \`\`\`javascript * // Delete a message * wa.chat.deleteMessage('[number]@c.us', 'msgid'); * // Delete a list of messages * wa.chat.deleteMessage('[number]@c.us', ['msgid1', 'msgid2]); * // Delete a message and delete media * wa.chat.deleteMessage('[number]@c.us', 'msgid', true); * // Revoke a message * wa.chat.deleteMessage('[number]@c.us', 'msgid', true, true); * \`\`\` * */ export const deleteMessage = async ( chatId: string | Wid, ids: string | string[], deleteMediaInDevice = false, revoke = false, ): Promise<DeleteMessageReturn | DeleteMessageReturn[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE_MESSAGE, body: { chatId, ids, deleteMediaInDevice, revoke }, }) } /** * Downloads media from a message * * @example * \`\`\`javascript * await wa.chat.downloadMedia('messageId'); * \`\`\` */ export const downloadMedia = async ( messageId: string | MsgKey, ): Promise<Blob | null> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DOWNLOAD_MEDIA, body: messageId, }) } export const find = async (chatId: string | Wid): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FIND, body: chatId, }) } /** * Forward messages to a chat * * @example * \`\`\`javascript * // Forward messages * wa.chat.forwardMessage('[number]@c.us', 'true_[number]@c.us_ABCDEF'); * \`\`\` */ export const forwardMessage = async ( toChatId: string | Wid, msgId: string | MsgKey, options: ForwardMessagesOptions = {}, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FORWARD_MESSAGE, body: { toChatId, msgId, options }, }) } /** * Find a chat by id * */ export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET, body: chatId, }) } export const getActiveChat = async () => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_ACTIVE_CHAT, body: {}, }) } /** * Get timestamp of last seen * @example * \`\`\`javascript * wa.chat.getLastSeen('[number]@c.us'); * \`\`\` */ export const getLastSeen = async ( chatId: string | Wid, ): Promise<number | boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_LAST_SEEN, body: chatId, }) } /** * Get message ACK from a message * * @example * \`\`\`javascript * // Get message ACK * const ackInfo = await WPP.chat.getMessageACK('true_[number]@c.us_ABCDEF'); * * console.log(ackInfo.deliveryRemaining); // Delivery Remaining * console.log(ackInfo.readRemaining); // Read Remaining * console.log(ackInfo.playedRemaining); // PlayedRemaining, for audio(ptt) only * * console.log(ackInfo.participants[0].deliveredAt); // Delivered At, in timestamp format * console.log(ackInfo.participants[0].readAt); // Read At, in timestamp format * console.log(ackInfo.participants[0].playedAt); // Played At, in timestamp format, for audio(ptt) only * * //To get only how was received * const received = ackInfo.participants.filter(p => p.deliveredAt || p.readAt || p.playedAt); * * //To get only how was read * const read = ackInfo.participants.filter(p => p.readAt || p.playedAt); * * //To get only how was played * const played = ackInfo.participants.filter(p => p.playedAt); * \`\`\` */ export const getMessageACK = async ( msgId: string | MsgKey, ): Promise<{ ack: ACK fromMe: boolean deliveryRemaining: number readRemaining: number playedRemaining: number participants: ParticipantStatusACK[] }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGE_ACK, body: msgId, }) } /** * Fetch messages from a chat * * @example * \`\`\`javascript * // Some messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * }); * * // All messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * }); * * // Last 20 unread messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * onlyUnread: true, * }); * * // All unread messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * onlyUnread: true, * }); * * // 20 messages before specific message * wa.chat.getMessages('[number]@c.us', { * count: 20, * direction: 'before', * id: '<full message id>' * }); * * // Only media messages (url, document and links) * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'all', * }); * * // Only image messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'image', * }); * * // Only document messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'document', * }); * * // Only link (url) messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'url', * }); * \`\`\` */ export const getMessages = async ( chatId: string | Wid, options: GetMessagesOptions = {}, ): Promise<any[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGES, body: { chatId, options }, }) } /** * Get notes from a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.getNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const getNotes = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_NOTES, body: chatId, }) } /** * Get the platform message from message ID * * The platform can be: * * android * * iphone * * web * * unknown * * @example * \`\`\`javascript * // to get platform from a message * const platform = wa.chat.getPlatformFromMessage('[message_id]'); * \`\`\` */ export const getPlatformFromMessage = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<'android' | 'iphone' | 'web' | 'unknown'> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_PLATFORM_MESSAGE, body: messageId, }) } /** * Return a list of chats * * @example * \`\`\`javascript * // All chats * const chats = await wa.chat.list(); * * // Some chats * const chats = wa.chat.list({count: 20}); * * // 20 chats before specific chat * const chats = wa.chat.list({count: 20, direction: 'before', id: '[number]@c.us'}); * * // Only users chats * const chats = await wa.chat.list({onlyUsers: true}); * * // Only groups chats * const chats = await wa.chat.list({onlyGroups: true}); * * // Only communities chats * const chats = await wa.chat.list({onlyCommunities: true}); * * // Only Newsletter * const chats = await wa.chat.list({onlyNewsletter: true}); * * // Only with label Text * const chats = await wa.chat.list({withLabels: ['Test']}); * * // Only with label id * const chats = await wa.chat.list({withLabels: ['1']}); * * // Only with label with one of text or id * const chats = await wa.chat.list({withLabels: ['Alfa','5']}); * \`\`\` * */ export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.LIST, body: options, }) } /** * Mark a chat to composing state * and keep sending "is writting a message" * * @example * \`\`\`javascript * // Mark is composing * wa.chat.markIsComposing('[number]@c.us'); * * // Mark is composing for 5 seconds * wa.chat.markIsComposing('[number]@c.us', 5000); * \`\`\` */ export const markIsComposing = async ( chatId: string | Wid, duration?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_COMPOSING, body: { chatId, duration }, }) } /** * Mark a chat is paused state * * @example * \`\`\`javascript * // Mark as recording * wa.chat.markIsPaused('[number]@c.us'); * \`\`\` */ export const markIsPaused = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_PAUSED, body: chatId, }) } /** * Mark a chat as read and send SEEN event * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsRead('[number]@c.us'); * \`\`\` */ export const markIsRead = async ( chatId: string, ): Promise<{ wid: Wid unreadCount: number }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_READ, body: chatId, }) } /** * Mark a chat to recording state * and keep sending "is recording" * * @example * \`\`\`javascript * // Mark is recording * wa.chat.markIsRecording('[number]@c.us'); * * // Mark is recording for 5 seconds * wa.chat.markIsRecording('[number]@c.us', 5000); * \`\`\` */ export const markIsRecording = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_RECORDING, body: chatId, }) } /** * Mark a chat as unread * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsUnread('[number]@c.us'); * \`\`\` */ export const markIsUnread = async ( chatId: string | Wid, ): Promise<{ wid: Wid }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_UNREAD, body: chatId, }) } /** * Mark message as played * * @example * \`\`\`javascript * wa.chat.markPlayed('[message_id]'); * \`\`\` */ export const markPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_PLAYED, body: messageId, }) } /** * Mute a chat, you can use duration or expiration * For expiration, use unix timestamp (seconds only) * For duration, use seconds * * @example * \`\`\`javascript * // Mute for 60 seconds * wa.chat.mute('[number]@c.us', {duration: 60}); * * // Mute util 2021-01-01 * wa.chat.mute('[number]@c.us', {expiration: 1641006000}); * * // or using date * const expiration = new Date('2022-01-01 00:00:00'); * wa.chat.mute('[number]@c.us', {expiration: expiration}); * \`\`\` * */ export const mute = async ( chatId: string | Wid, time: { expiration: number | Date } | { duration: number }, ): Promise<{ wid: Wid expiration: number isMuted: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MUTE, body: { chatId, time }, }) } /** * Open the chat in the WhatsApp interface in a specific message * * @example * \`\`\`javascript * await wa.chat.openChatAt('[number]@c.us', <message_id>); * \`\`\` * */ export const openChatAt = async ( chatId: string | Wid, messageId: string, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_AT, body: { chatId, messageId }, }) } /** * Open the chat in the WhatsApp interface in bottom position * * @example * \`\`\`javascript * await wa.chat.openChatBottom('[number]@c.us'); * \`\`\` * */ export const openChatBottom = async ( chatId: string, ): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_BOTTOM, body: chatId, }) } /** * Open the chat in the WhatsApp interface from first unread message * * @example * \`\`\`javascript * await wa.chat.openChatFromUnread('[number]@c.us'); * \`\`\` * */ export const openChatFromUnread = async ( chatId: string | Wid, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_FROM_UNREAD, body: chatId, }) } /** * Pin a message in chat * * @example * \`\`\`javascript * // Pin a message in chat * wa.chat.pinMsg('true_[number]@c.us_ABCDEF'); * * // Pin a message in chat for 30 days * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', 2592000); * * // Unpin a message * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', false); * \`\`\` */ export const pinMsg = async ( msgId: string | MsgKey, pin = true, seconds = 604800, // default 7 days ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN_MSG, body: { msgId, pin, seconds }, }) } /** * Set custom Chat list in panel of whatsapp * * @example * \`\`\`javascript * // Your custom list * wa.chat.setChatList('custom', ['number@c.us', 'number2@c.us']); * * // List only with unread chats * wa.chat.setChatList('unread'); * * // List only with favorites chats * wa.chat.setChatList('favorites'); * * // List only with groups chats * wa.chat.setChatList('group'); * * // List only labels chat * wa.chat.setChatList('labels', '454545_labelId'); * \`\`\` */ export const setChatList = async (type: string, ids?: string | string[]) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_CHAT_LIST, body: { type, ids }, }) } export const setInputText = async (text: string, chatId?: string | Wid) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_INPUT_TEXT, body: { text, chatId }, }) } /** * Set notes for a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.setNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const setNotes = async ( chatId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_NOTES, body: { chatId, content }, }) }
```

# src/libs/wa/conn.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Alternative login method using code * Get the Link Device Code for Authentication using the phone number * * @example * \`\`\`javascript * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]'); * * // Disable push notification * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]', false); * \`\`\` */ export const genLinkDeviceCodeForPhoneNumber = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }) } /** * Return the current auth code * * @example * \`\`\`javascript * const authCode = await wa.conn.getAuthCode(); * console.log(authCode.fullCode); // Output: a long string to generate a QRCode * \`\`\` */ export const getAuthCode = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_AUTH_CODE, }) } export const getMyUserId = async (): Promise<Wid | undefined> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_MY_USER_ID, }) }
```

# src/libs/wa/contact.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ContactListOptions } from '@wppconnect/wa-js/dist/contact' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Get a contact by id * * @example * \`\`\`javascript * await wa.contact.get('[number]@c.us'); * \`\`\` * */ export const get = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET, body: contactId, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getBusinessProfile('[number]@c.us'); * \`\`\` * */ export const getBusinessProfile = async ( contactId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_BUSINESS_PROFILE, body: contactId, }) } /** * Get all commons groups for the contact * * @example * \`\`\`javascript * const groups_ids = await wa.contact.getCommonGroups('[number]@c.us'); * \`\`\` * */ export const getCommonGroups = async (wid: Wid | string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_COMMON_GROUPS, body: wid, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getProfilePictureUrl('[number]@c.us'); * \`\`\` * */ export const getProfilePictureUrl = async ( contactId: string | Wid, full = true, ): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_PROFILE_PICTURE_URL, body: { contactId, full }, }) } /** * Get the current text status * * @example * \`\`\`javascript * await wa.contact.getStatus('[number]@c.us'); * \`\`\` */ export const getStatus = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_STATUS, body: contactId, }) } export const list = async (options: ContactListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.LIST, body: options, }) } export const isExist = async (contactId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.IS_EXIST, body: contactId, }) }
```

# src/libs/wa/group.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions } from '@wppconnect/wa-js/dist/chat' import type { GroupProperty } from '@wppconnect/wa-js/dist/group' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Add one or more participants to a group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.addParticipants('[group@g.us]', [number@c.us]); * * // Get participant result: * console.log(result['123@c.us'].code); * console.log(result['123@c.us'].invite_code); * console.log(result['123@c.us'].invite_code_exp); * console.log(result['123@c.us'].message); * console.log(result['123@c.us'].wid); * * const memberResult = result['123@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['123@c.us'].invite_code; * console.log(link); * \`\`\` */ export const addParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.ADD_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Approve a membership request to group * * @example * \`\`\`javascript * await wa.group.approve(12345645@g.us, 5554999999999@c.us); * \`\`\` * */ export const approve = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.APPROVE, body: { groupId, membershipIds }, }) } /** * Check if your account is allowed to add new participants * * @example * \`\`\`javascript * const result = await wa.group.canAdd('group@g.us'); * console.log(result); * \`\`\` */ export const canAdd = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_ADD, body: groupId, }) } /** * Check if your account is allowed to demote participants * * @example * \`\`\`javascript * await wa.group.canDemote('group@g.us'); * console.log(result); * \`\`\` */ export const canDemote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_DEMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to promote participants * * @example * \`\`\`javascript * await WPP.group.canPromote('group@g.us'); * console.log(result); * \`\`\` * */ export const canPromote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_PROMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to remove participants * * @example * \`\`\`javascript * const result = await wa.group.canRemove('group@g.us'); * console.log(result); * \`\`\` */ export const canRemove = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_REMOVE, body: { groupId, participantsIds }, }) } /** * Create a new group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.create('Test Group', ['number@c.us']); * * console.log(result.gid.toString()); // Get the group ID * * // Get participant result: * console.log(result['number@c.us'].code); * console.log(result['number@c.us'].invite_code); * console.log(result['number@c.us'].invite_code_exp); * console.log(result['number@c.us'].message); * console.log(result['number@c.us'].wid); * * const memberResult = result['number@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['number@c.us'].invite_code; * console.log(link); * * // Create a Subgroup for a community * const result = await wa.group.create('Test Group', ['number@c.us'], 'communit@g.us'); * \`\`\` */ export const create = async ( groupName: string, participantsIds: (string | Wid) | (string | Wid)[], parentGroup: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CREATE, body: { groupName, participantsIds, parentGroup }, }) } /** * @example * \`\`\`javascript * // One member * await wa.group.demoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.demoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const demoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.DEMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Get group info from an inviteCode * * @example * \`\`\`javascript * await wa.group.getGroupInfoFromInviteCode('<inviteCode>'); * \`\`\` */ export const getGroupInfoFromInviteCode = async ( inviteCode: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, body: inviteCode, }) } /** * Get the max number of participants for a group * * @example * \`\`\`javascript * const limit = await wa.group.getGroupSizeLimit(); * console.log(limit); * \`\`\` */ export const getGroupSizeLimit = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_SIZE_LIMIT, body: {}, }) } export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LIST, }) } /** * @description Sends a request to the background script to get a group's invite link. * @param groupId The ID of the group (e.g., '1234567890@g.us'). * @returns A promise that resolves with the invite link string. */ export const getInviteLink = async (groupId: string): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_INVITE_LINK, body: { groupId }, }) } /** * Retrieve a lista of a membership approval requests * * @example * \`\`\`javascript * await wa.group.getMembershipRequests(12345645@g.us); * \`\`\` */ export const getMembershipRequests = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_MEMBERSHIP_REQUESTS, body: groupId, }) } /** * Get an array of participants of a group * * @example * \`\`\`javascript * wa.group.getParticipants('[group-id]@g.us'); * \`\`\` */ export const getParticipants = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_PARTICIPANTS, body: groupId, }) } export const iAmAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_ADMIN, body: groupId, }) } export const iAmMember = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_MEMBER, body: groupId, }) } export const iAmRestrictedMember = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_RESTRICTED_MEMBER, body: groupId, }) } export const iAmSuperAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_SUPER_ADMIN, body: groupId, }) } /** * Join in a group from an invite code. * * @example * \`\`\`javascript * await wa.group.join('abcde....'); * \`\`\` */ export const join = async (inviteCode: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.JOIN, body: inviteCode, }) } /** * Leave from a group. * * @example * \`\`\`javascript * await wa.group.leave('[number]@g.us'); * \`\`\` */ export const leave = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LEAVE, body: groupId, }) } /** * Promote group member to admin * * @example * \`\`\`javascript * // One member * await wa.group.promoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.promoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` * * @category Group */ export const promoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.PROMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Reject a membership request to group * * @example * \`\`\`javascript * await wa.group.reject(12345645@g.us, 5554999999999@c.us); * \`\`\` */ export const reject = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REJECT, body: { groupId, membershipIds }, }) } /** * Remove the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.removeIcon('[group@g.us]'); * \`\`\` */ export const removeIcon = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_ICON, body: groupId, }) } /** * Remove participants of a group * * @example * \`\`\`javascript * // One member * await wa.group.removeParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.removeParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const removeParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Revoke the current invite code and generate new one. * * @example * \`\`\`javascript * const code = WPP.group.revokeInviteCode('[group-id]@g.us'); * const link = 'https://chat.whatsapp.com/' + code; * \`\`\` */ export const revokeInviteCode = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REVOKE_INVITE_CODE, body: groupId, }) } /** * Define the group description * * @example * \`\`\`javascript * await wa.group.setDescription('[group-id]@g.us', 'new group description'); * \`\`\` */ export const setDescription = async ( groupId: string | Wid, description: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_DESCRIPTION, body: { groupId, description }, }) } /** * Set the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.setIcon('[group@g.us]', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const setIcon = async ( groupId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_ICON, body: { groupId, content }, }) } /** * Set the group property * * @example * \`\`\`javascript * // Only admins can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', true); * * // All can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', false); * * // Disatble temporary messages * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 0); * * // Enable temporary messages for 24 hours * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 86400); * * // Enable temporary messages for 7 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 604800); * * // Enable temporary messages for 90 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 7776000); * * // Only admins can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', true); * * // All can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', false); * \`\`\` */ export const setProperty = async ( groupId: string | Wid, property: GroupProperty, value: 0 | 1 | 86400 | 604800 | 7776000 | boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_PROPERTY, body: { groupId, property, value }, }) } /** * Define the group subject * * @example * \`\`\`javascript * await wa.group.setSubject('[group-id]@g.us', 'new group subject'); * \`\`\` */ export const setSubject = async ( groupId: string | Wid, subject: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_SUBJECT, body: { groupId, subject }, }) }
```

# src/libs/wa/index.ts

```ts
import * as chat from './chat' import * as conn from './conn' import * as contact from './contact' import * as group from './group' import * as on from './on' import * as send from './send' export default { on, conn, send, contact, chat, group, }
```

# src/libs/wa/newsletter.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' /** * Create a newsletter * * @example * \`\`\`javascript * // To edit name * wa.newsletter.create('Name for your newsletter', { * description: 'Description for that', * picture: '<base64_string', * }); * \`\`\` */ export const create = async ( name: string, opts: { description?: string; picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.CREATE, body: { name, opts }, }) } /** * Delete a newsletter * * @example * \`\`\`javascript * const code = wa.newsletter.destroy('[newsletter-id]@newsletter'); * \`\`\` */ export const destroy = async (id: string): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.DESTROY, body: id, }) } /** * Edit the newsletter data * * @example * \`\`\`javascript * // To edit name * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * name: 'New Name' * }); * * // To edit description * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * description: 'New description' * }); * * // To change picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: '<base64_image>' * }); * * // To remove picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: null * }); * \`\`\` */ export const edit = async ( newsletterId: string, opts: { name?: string description?: string picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.EDIT, body: { newsletterId, opts }, }) } /** * Get subscribers of a newsletters * * @example * \`\`\`javascript * const code = wa.newsletter.getSubscribers('[newsletter-id]@newsletter'); * \`\`\` */ export const getSubscribers = async (id: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.GET_SUBSCRIBERS, body: id, }) } /** * Mute and unmute a newsletter * * @example * // Mute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', true); * \`\`\` * * // Unmute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', false); * \`\`\` */ export const mute = async ( newsletterId: string, value?: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.MUTE, body: { newsletterId, value }, }) }
```

# src/libs/wa/on.ts

```ts
export const ready = (callback = () => {}) => { const targetSelector = '#side' // WhatsApp left-panel root const node = document.querySelector(targetSelector) if (node) { require('@wppconnect/wa-js/dist/wppconnect-wa') callback() return } // Wait for the node to appear only once const observer = new MutationObserver(() => { const el = document.querySelector(targetSelector) if (el) { console.log('✅✅✅✅✅') observer.disconnect() // stop watching require('@wppconnect/wa-js/dist/wppconnect-wa') callback() } }) observer.observe(document.body, { childList: true, subtree: true, }) }
```

# src/libs/wa/profile.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { BusinessProfileModel } from '@wppconnect/wa-js/dist/whatsapp' /** * Update your business profile * * @example * \`\`\`javascript * await wa.profile.editBusinessProfile({description: 'New description for profile'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({categories: { id: "133436743388217", localized_display_name: "Artes e entretenimento", not_a_biz: false, }}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({email: 'test@test.com.br'}); * \`\`\` * * Change website of profile (max 2 sites) * \`\`\`javascript * await wa.profile.editBusinessProfile({website: [ "https://www.wppconnect.io", "https://www.teste2.com.br", ]}); * \`\`\` * * Change businessHours for Specific Hours * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { * { tue: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, wed: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, thu: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, fri: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sat: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sun: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, } }, timezone: "America/Sao_Paulo" }); * * Change businessHours for Always Opened * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "open_24h", }, tue: { mode: "open_24h", }, wed: { mode: "open_24h", }, thu: { mode: "open_24h", }, fri: { mode: "open_24h", }, sat: { mode: "open_24h", }, sun: { mode: "open_24h", }, } timezone: "America/Sao_Paulo" }); * * Change businessHours for Appointment Only * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "appointment_only", }, tue: { mode: "appointment_only", }, wed: { mode: "appointment_only", }, thu: { mode: "appointment_only", }, fri: { mode: "appointment_only", }, sat: { mode: "appointment_only", }, sun: { mode: "appointment_only", }, } timezone: "America/Sao_Paulo" }); * * */ export const editBusinessProfile = async ( params: BusinessProfileModel, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.EDIT_BUSINESS_PROFILE, body: params, }) } /** * Get your current profile name * * @example * \`\`\`javascript * const myProfileName = wa.profile.getMyProfileName(); * \`\`\` */ export const getMyProfileName = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_NAME, body: {}, }) } /** * Get your current profile picture * * @example * \`\`\`javascript * await wa.profile.getMyProfilePicture(); * \`\`\` */ export const getMyProfilePicture = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_PICTURE, body: {}, }) } /** * Get your current text status * * @example * \`\`\`javascript * await wa.profile.getMyStatus(); * \`\`\` */ export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_STATUS, body: {}, }) } /** * Return the current logged user is Bussiness or not * * @example * \`\`\`javascript * wa.profile.isBusiness(); * \`\`\` */ export const isBusiness = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.IS_BUSINESS, body: {}, }) } /** * Remove your profile picture * * @example * \`\`\`javascript * await wa.profile.removeMyProfilePicture(); * \`\`\` */ export const removeMyProfilePicture = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.REMOVE_MY_PROFILE_PICTURE, body: {}, }) } /** * Update your current profile name * * @example * \`\`\`javascript * await wa.profile.setMyProfileName('My new name'); * \`\`\` */ export const setMyProfileName = async (name: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_NAME, body: {}, }) } /** * Update your profile picture * * @example * \`\`\`javascript * await wa.profile.setMyProfilePicture('data:image/jpeg;base64,.....'); * \`\`\` */ export const setMyProfilePicture = async (content: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_PICTURE, body: content, }) } /** * Update your current text status * * @example * \`\`\`javascript * await wa.profile.setMyStatus('Example text'); * \`\`\` */ export const setMyStatus = async (statusText: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_STATUS, body: statusText, }) }
```

# src/libs/wa/send.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { AudioMessageOptions, AutoDetectMessageOptions, DocumentMessageOptions, ImageMessageOptions, LocationMessageOptions, PoolMessageOptions, SendMessageOptions, StickerMessageOptions, TextMessageOptions, VCardContact, VideoMessageOptions, } from '@wppconnect/wa-js/dist/chat' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { SendMsgResult } from '@wppconnect/wa-js/dist/whatsapp/enums' export const text = async ( chatId: any, content: any, options: TextMessageOptions = {}, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.TEXT, body: { chatId, content, options, }, }) } export const file = async ( chatId: string | Wid, content: string | Blob | File, options: | AutoDetectMessageOptions | AudioMessageOptions | DocumentMessageOptions | ImageMessageOptions | VideoMessageOptions | StickerMessageOptions | TextMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.FILE, body: { chatId, content, options, }, }) } export const location = async ( chatId: string | Wid, options: LocationMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.LOCATION, body: { chatId, options, }, }) } export const poll = async ( chatId: any, name: string, choices: string[], options?: PoolMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.POLL, body: { chatId, name, choices, options, }, }) } export const vcard = async ( chatId: string | Wid, contacts: string | Wid | VCardContact | (string | Wid | VCardContact)[], options?: SendMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.VCARD, body: { chatId, contacts, options, }, }) }
```

# src/libs/wa/status.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ImageStatusOptions, TextStatusOptions, VideoStatusOptions, } from '@wppconnect/wa-js/dist/status' import type { MsgKey, Wid } from '@wppconnect/wa-js/dist/whatsapp' export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET, body: chatId, }) } export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET_MY_STATUS, body: {}, }) } export const remove = async (msgId: string | MsgKey): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.REMOVE, body: msgId, }) } /** * Send a image message to status stories * * @example * \`\`\`javascript * wa.status.sendImageStatus('data:image/jpeg;base64,<a long base64 file...>'); * \`\`\` */ export const sendImageStatus = async ( content: any, options: ImageStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_IMAGE_STATUS, body: { content, options }, }) } /** * Mark status as read/seen * * @example * \`\`\`javascript * wa.status.sendReadStatus('[phone_number]@c.us', 'false_status@broadcast_3A169E0FD4BC6E92212F_5521526232927@c.us'); * \`\`\` */ export const sendReadStatus = async ( chatId: string | Wid, statusId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_READ_STATUS, body: { chatId, statusId }, }) } /** * Send a text message to status stories * * @example * \`\`\`javascript * wa.status.sendTextStatus(`Bootstrap primary color: #0275d8`, { backgroundColor: '#0275d8', font: 2}); * \`\`\` */ export const sendTextStatus = async ( content: any, options: TextStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_TEXT_STATUS, body: { content, options }, }) } /** * Send a video message to status stories * * @example * \`\`\`javascript * wa.status.sendVideoStatus('data:video/mp4;base64,<a long base64 file...>'); * \`\`\` */ export const sendVideoStatus = async ( content: any, options: VideoStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_VIDEO_STATUS, body: { content, options }, }) } /** * Define a custom list of participants to send the status message * * @example * \`\`\`javascript * // Use a custom list * await wa.status.updateParticipants(['123@c.us', '456@c.us']); * // Use the contacts by default * await wa.status.updateParticipants(null); * \`\`\` */ export const updateParticipants = async ( ids?: (string | Wid)[] | null, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.UPDATE_PARTICIPANTS, body: ids, }) }
```

# src/models/BroadcastContactModel.ts

```ts
// src/models/BroadcastContactModel.ts import { Status } from '@/constants' import db from '@/libs/db' const success = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.SUCCESS, sendAt: new Date(), }) } const running = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.RUNNING }) } const pending = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.PENDING }) } const failed = async (id: number, message: string | null = null) => { return await db.broadcastContacts.update(id, { status: Status.FAILED, error: message, }) } // This reduces the number of database queries in the main processing loop. const getStatusPendingBatch = async (limit: number = 20) => { return await db.broadcastContacts .where('status') .equals(Status.PENDING) .limit(limit) .toArray() } const resetRunningStatuses = async () => { const updatedContacts = await db.broadcastContacts .where('status') .equals(Status.RUNNING) .modify({ status: Status.PENDING }) if (updatedContacts > 0) { await db.broadcasts .where('status') .equals(Status.RUNNING) .modify({ status: Status.PENDING }) console.log( `Reset ${updatedContacts} contacts and potentially their broadcasts.`, ) } else { console.log('No stuck RUNNING statuses found.') } } export default { getStatusPendingBatch, success, failed, running, pending, resetRunningStatuses, }
```

# src/models/BroadcastModel.ts

```ts
import { Status } from '@/constants' import db, { type Broadcast } from '@/libs/db' const running = async (id: number) => { await db.broadcasts.update(id, { status: Status.RUNNING, }) } const success = async (id: number) => { await db.broadcasts.update(id, { status: Status.SUCCESS, }) } const cancel = async (id: number) => { await db.broadcasts.update(id, { status: Status.CANCELLED, }) } const pause = async (id: number) => { await db.broadcasts.update(id, { status: Status.CANCELLED, }) } const pending = async (id: number) => { await db.broadcasts.update(id, { status: Status.PENDING, }) } const get = async (id: number): Promise<Broadcast> => { return await db.broadcasts.get(id) } export default { get, running, success, pause, cancel, pending, }
```

# src/models/MediaModel.ts

```ts
// src/models/MediaModel.ts import db from '@/libs/db' /** * Finds the first media record matching a parent ID and a specific media type. * @param {number} parentId The ID of the parent record (e.g., broadcastId, quickReplyId). * @param {string} mediaType The type of media to find (e.g., Media.BROADCAST, Media.QUICK_REPLY). * @returns The first matching media record or undefined. */ const findFirstByParent = async (parentId: number, mediaType: string) => { return await db.media.where({ parentId: parentId, type: mediaType }).first() } export default { findFirstByParent, }
```

# src/relays/blocklist.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const blockContact = () => { relay( { name: Action.Blocklist.BLOCK_CONTACT, }, async ({ body }) => { return await WPP.blocklist.blockContact(body) }, ) } const isBlocked = () => { relay( { name: Action.Blocklist.IS_BLOCKED, }, async ({ body }) => { return WPP.blocklist.isBlocked(body) }, ) } const unblockContact = () => { relay( { name: Action.Blocklist.UNBLOCK_CONTACT, }, async ({ body }) => { return WPP.blocklist.unblockContact(body) }, ) } const initBlocklistRelays = () => { all() blockContact() isBlocked() unblockContact() } export default initBlocklistRelays
```

# src/relays/cart.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const add = () => { relay( { name: Action.Cart.ADD, }, async ({ body }) => { const { chatId, products } = body return await WPP.cart.add(chatId, products) }, ) } const clear = () => { relay( { name: Action.Cart.CLEAR, }, async ({ body }) => { return await WPP.cart.clear(body) }, ) } const get = () => { relay( { name: Action.Cart.GET, }, async ({ body }) => { return WPP.cart.get(body) }, ) } const getThumbFromCart = () => { relay( { name: Action.Cart.GET_THUMB_FROM_CART, }, async ({ body }) => { return await WPP.cart.getThumbFromCart(body) }, ) } const remove = () => { relay( { name: Action.Cart.REMOVE, }, async ({ body }) => { const { chatId, productId } = body return WPP.cart.remove(chatId, productId) }, ) } const submit = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { wid, msg, options } = body return WPP.cart.submit(wid, msg, options) }, ) } const update = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { chatId, productId, options } = body return WPP.cart.update(chatId, productId, options) }, ) } const initCartRelays = () => { add() clear() get() getThumbFromCart() remove() submit() update() } export default initCartRelays
```

# src/relays/catalog.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const addProductImage = () => { relay( { name: Action.Catalog.ADD_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.addProductImage(productId, content) }, ) } const changeProductImage = () => { relay( { name: Action.Catalog.CHANGE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.changeProductImage(productId, content) }, ) } const createCollection = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { const { collectionName, productsId } = body return await WPP.catalog.createCollection(collectionName, productsId) }, ) } const createProduct = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.createProduct(body) }, ) } const deleteCollection = () => { relay( { name: Action.Catalog.DELETE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.deleteCollection(body) }, ) } const deleteProduct = () => { relay( { name: Action.Catalog.DELETE_PRODUCT, }, async ({ body }) => { return await WPP.catalog.delProducts(body) }, ) } const editCollection = () => { relay( { name: Action.Catalog.EDIT_COLLECTION, }, async ({ body }) => { const { collectionId, params } = body return await WPP.catalog.editCollection(collectionId, params) }, ) } const editProduct = () => { relay( { name: Action.Catalog.EDIT_PRODUCT, }, async ({ body }) => { const { productId, params } = body return await WPP.catalog.editProduct(productId, params) }, ) } const getCollections = () => { relay( { name: Action.Catalog.GET_COLLECTIONS, }, async ({ body }) => { const { chatId, qnt, productsCount } = body return await WPP.catalog.getCollections(chatId, qnt, productsCount) }, ) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ const getMyCatalog = () => { relay( { name: Action.Catalog.GET_MY_CATALOG, }, async ({ body }) => { return await WPP.catalog.getMyCatalog() }, ) } const getProductById = () => { relay( { name: Action.Catalog.GET_PRODUCT_BY_ID, }, async ({ body }) => { const { chatId, productId } = body return await WPP.catalog.getProductById(chatId, productId) }, ) } const getProducts = () => { relay( { name: Action.Catalog.GET_PRODUCTS, }, async ({ body }) => { const { chatId, qnt } = body return await WPP.catalog.getProducts(chatId, qnt) }, ) } const removeProductImage = () => { relay( { name: Action.Catalog.REMOVE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, index } = body return await WPP.catalog.removeProductImage(productId, index) }, ) } const setProductVisibility = () => { relay( { name: Action.Catalog.SET_PRODUCT_VISIBILITY, }, async ({ body }) => { const { productId, isHidden } = body return await WPP.catalog.setProductVisibility(productId, isHidden) }, ) } const updateCartEnabled = () => { relay( { name: Action.Catalog.UPDAGE_CART_ENABLED, }, async ({ body }) => { return await WPP.catalog.updateCartEnabled(body) }, ) } const initCatalogRelays = () => { addProductImage() changeProductImage() createCollection() createProduct() deleteCollection() deleteProduct() editCollection() editProduct() getCollections() getMyCatalog() getProductById() getProducts() removeProductImage() setProductVisibility() updateCartEnabled() } export default initCatalogRelays
```

# src/relays/chat.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const archive = () => { relay( { name: Action.Chat.ARCHIVE, }, async ({ body }) => { return await WPP.chat.archive(body) }, ) } const canMarkPlayed = () => { relay( { name: Action.Chat.CAN_MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.canMarkPlayed(body) }, ) } const canMute = () => { relay( { name: Action.Chat.CAN_MUTE, }, async ({ body }) => { return WPP.chat.canMute(body) }, ) } const canReply = () => { relay( { name: Action.Chat.CAN_REPLY, }, async ({ body }) => { return await WPP.chat.canReply(body) }, ) } const clear = () => { relay( { name: Action.Chat.CLEAR, }, async ({ body }) => { return await WPP.chat.clear(body) }, ) } const closeChat = () => { relay( { name: Action.Chat.CLOSE_CHAT, }, async ({ body }) => { return await WPP.chat.closeChat() }, ) } const _delete = () => { relay( { name: Action.Chat.DELETE, }, async ({ body }) => { return await WPP.chat.delete(body) }, ) } const deleteMessage = () => { relay( { name: Action.Chat.DELETE_MESSAGE, }, async ({ body }) => { const { chatId, ids, deleteMediaInDevice, revoke } = body return await WPP.chat.deleteMessage( chatId, ids, deleteMediaInDevice, revoke, ) }, ) } const list = () => { relay( { name: Action.Chat.LIST, }, async ({ body }) => { console.log('body', body) return (await WPP.chat.list(body)).map(serialize.chat) }, ) } const find = () => { relay( { name: Action.Chat.FIND, }, async (req) => { try { const chatId = req.body const chat = await WPP.chat.find(chatId) return response.success(serialize.chat(chat)) } catch (error) { return response.error(error.message) } }, ) } const forwardMessage = () => { relay( { name: Action.Chat.FORWARD_MESSAGE, }, async ({ body }) => { const { toChatId, msgId, options } = body return await WPP.chat.forwardMessage(toChatId, msgId, options) }, ) } const get = () => { relay( { name: Action.Chat.GET, }, async ({ body }) => { try { const chat = WPP.chat.get(body) return serialize.chat(chat) } catch (error) {} }, ) } const getActiveChat = () => { relay( { name: Action.Chat.GET_ACTIVE_CHAT, }, async (req) => { try { const chat = WPP.chat.getActiveChat() if (!chat) { return null } return serialize.chat(chat) } catch (error) { return null } }, ) } const getLastSeen = () => { relay( { name: Action.Chat.GET_LAST_SEEN, }, async ({ body }) => { return await WPP.chat.getLastSeen(body) }, ) } const getMessageACK = () => { relay( { name: Action.Chat.GET_MESSAGE_ACK, }, async ({ body }) => { return await WPP.chat.getMessageACK(body) }, ) } const getMessages = () => { relay( { name: Action.Chat.GET_MESSAGES, }, async ({ body }) => { const { chatId, options } = body const messages = await WPP.chat.getMessages(chatId, options) return messages.map(serialize.message) }, ) } const getNotes = () => { relay( { name: Action.Chat.GET_NOTES, }, async ({ body }) => { return await WPP.chat.getNotes(body) }, ) } const getPlatformFromMessage = () => { relay( { name: Action.Chat.GET_PLATFORM_MESSAGE, }, async ({ body }) => { return WPP.chat.getPlatformFromMessage(body) }, ) } const markIsComposing = () => { relay( { name: Action.Chat.MARK_IS_COMPOSING, }, async ({ body }) => { const { chatId, duration } = body return WPP.chat.markIsComposing(chatId, duration) }, ) } const markIsPaused = () => { relay( { name: Action.Chat.MARK_IS_PAUSED, }, async ({ body }) => { return await WPP.chat.markIsPaused(body) }, ) } const markIsRead = () => { relay( { name: Action.Chat.MARK_IS_READ, }, async ({ body }) => { return await WPP.chat.markIsRead(body) }, ) } const markIsRecording = () => { relay( { name: Action.Chat.MARK_IS_RECORDING, }, async ({ body }) => { return await WPP.chat.markIsRecording(body) }, ) } const markIsUnread = () => { relay( { name: Action.Chat.MARK_IS_UNREAD, }, async ({ body }) => { return await WPP.chat.markIsUnread(body) }, ) } const markPlayed = () => { relay( { name: Action.Chat.MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.markPlayed(body) }, ) } const mute = () => { relay( { name: Action.Chat.MUTE, }, async ({ body }) => { const { chatId, time } = body return await WPP.chat.mute(chatId, time) }, ) } const openChatAt = () => { relay( { name: Action.Chat.OPEN_CHAT_AT, }, async ({ body }) => { const { chatId, messageId } = body return await WPP.chat.openChatAt(chatId, messageId) }, ) } const openChatFromUnread = () => { relay( { name: Action.Chat.OPEN_CHAT_FROM_UNREAD, }, async ({ body }) => { return await WPP.chat.openChatFromUnread(body) }, ) } const pinMsg = () => { relay( { name: Action.Chat.PIN_MSG, }, async ({ body }) => { const { msgId, pin, seconds } = body return await WPP.chat.pinMsg(msgId, pin, seconds) }, ) } const openChatBottom = () => { relay( { name: Action.Chat.OPEN_CHAT_BOTTOM, }, async (req) => { try { const chatId = req.body return await WPP.chat.openChatBottom(chatId) } catch (error) { return false } }, ) } const setChatList = () => { relay( { name: Action.Chat.SET_CHAT_LIST, }, async (req) => { try { const { type, ids } = req.body await WPP.chat.setChatList(type, ids) } catch (error) { console.error(`setChatList: ${error}`) } }, ) } const setInputText = () => { relay( { name: Action.Chat.SET_INPUT_TEXT, }, async ({ body }) => { const { text, chatId } = body return await WPP.chat.setInputText(text, chatId) }, ) } const setNotes = () => { relay( { name: Action.Chat.SET_NOTES, }, async ({ body }) => { const { chatId, content } = body return await WPP.chat.setNotes(chatId, content) }, ) } const downloadMedia = () => { relay( { name: Action.Chat.DOWNLOAD_MEDIA, }, async ({ body: messageId }) => { try { const media = await Promise.race([ WPP.chat.downloadMedia(messageId), new Promise((_, reject) => setTimeout(() => reject(new Error('Error download media')), 3000), ), ]) return media } catch (error) { return null } }, ) } const initChatRelay = () => { archive() canMarkPlayed() canMute() canReply() clear() closeChat() _delete() deleteMessage() downloadMedia() find() forwardMessage() get() getActiveChat() getLastSeen() getMessageACK() getMessages() getNotes() getPlatformFromMessage() markIsComposing() markIsPaused() markIsRead() markIsRecording() markIsUnread() markPlayed() mute() list() openChatBottom() openChatAt() openChatFromUnread() pinMsg() setChatList() setInputText() setNotes() } export default initChatRelay
```

# src/relays/community.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const initCommunityRelays = () => { all() } export default initCommunityRelays
```

# src/relays/conn.relay.ts

```ts
import { Account, Action } from '@/constants' import country from '@/utils/country' import { delay } from '@/utils/util' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const genLinkDeviceCodeForPhoneNumber = () => { relay( { name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }, async ({ body }) => { const { phone, sendPushNotification } = body return await WPP.conn.genLinkDeviceCodeForPhoneNumber( phone, sendPushNotification, ) }, ) } const getAuthCode = () => { relay( { name: Action.Conn.GET_AUTH_CODE, }, async ({ body }) => { return await WPP.conn.getAuthCode() }, ) } const getMyUserId = () => { relay( { name: Action.Conn.GET_MY_USER_ID, }, async (req) => { return WPP.conn.getMyUserId() }, ) } const getProfile = () => { relay( { name: Action.Conn.GET_PROFILE, }, async (req) => { await delay(1000) const { user: number } = WPP.conn.getMyUserId() const contact = await WPP.contact.get(`${number}@c.us`) const countryCode = await WPP.whatsapp.functions.getCountryShortcodeByPhone(contact.id.user) const selectedCountry = country.getCountryByCode(countryCode) return { name: contact.pushname || contact.formattedName || contact.name || contact.verifiedName, number, type: contact.isBusiness ? Account.BUSINESS : Account.PERSONAL, country: selectedCountry.label, } }, ) } const initConnRelays = () => { genLinkDeviceCodeForPhoneNumber() getAuthCode() getMyUserId() getProfile() } export default initConnRelays
```

# src/relays/contact.relay.ts

```ts
import { Action } from '@/constants' import filterBy from '@/utils/filterBy' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Contact.GET, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getBusinessProfile = () => { relay( { name: Action.Contact.GET_BUSINESS_PROFILE, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getCommonGroups = () => { relay( { name: Action.Contact.GET_COMMON_GROUPS, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getProfilePictureUrl = () => { relay( { name: Action.Contact.GET_PROFILE_PICTURE_URL, }, async ({ body }) => { const { contactId, full } = body return await WPP.contact.getProfilePictureUrl(contactId, full) }, ) } const getStatus = () => { relay( { name: Action.Contact.GET_STATUS, }, async ({ body }) => { return await WPP.contact.getStatus(body) }, ) } const list = () => { relay( { name: Action.Contact.LIST, }, async (req) => { const options = req.body const contacts = ((await WPP.contact.list(options)) ?? []) .filter(filterBy.dontIncludeLid) .map(serialize.contact) return contacts }, ) } const isExist = () => { relay( { name: Action.Contact.IS_EXIST, }, async (req) => { try { const contactId = req.body const result = await WPP.contact.queryExists(contactId) return !!result } catch (error) { return false } }, ) } const initContactRelay = () => { get() getBusinessProfile() getCommonGroups() getProfilePictureUrl() getStatus() isExist() list() } export default initContactRelay
```

# src/relays/group.relay.ts

```ts
import { Action } from '@/constants' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const addParticipants = () => { relay( { name: Action.Group.ADD_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.addParticipants(groupId, participantsIds) }, ) } const approve = () => { relay( { name: Action.Group.APPROVE, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.approve(groupId, membershipIds) }, ) } const canAdd = () => { relay( { name: Action.Group.CAN_ADD, }, async ({ body }) => { return await WPP.group.canAdd(body) }, ) } const canDemote = () => { relay( { name: Action.Group.CAN_DEMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canDemote(groupId, participantsIds) }, ) } const canPromote = () => { relay( { name: Action.Group.CAN_PROMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canPromote(groupId, participantsIds) }, ) } const canRemove = () => { relay( { name: Action.Group.CAN_REMOVE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canRemove(groupId, participantsIds) }, ) } const create = () => { relay( { name: Action.Group.CREATE, }, async ({ body }) => { const { groupName, participantsIds, parentGroup } = body return await WPP.group.create(groupName, participantsIds, parentGroup) }, ) } const demoteParticipants = () => { relay( { name: Action.Group.DEMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.demoteParticipants(groupId, participantsIds) }, ) } const getGroupInfoFromInviteCode = () => { relay( { name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, }, async ({ body }) => { return await WPP.group.getGroupInfoFromInviteCode(body) }, ) } const getGroupSizeLimit = () => { relay( { name: Action.Group.GET_GROUP_SIZE_LIMIT, }, async ({ body }) => { return await WPP.group.getGroupSizeLimit() }, ) } const list = () => { relay( { name: Action.Group.LIST, }, async ({ body }) => { const list = await WPP.chat.list(body) if (!list) { return [] } return list.map(serialize.chat) }, ) } const getInviteLink = () => { relay( { name: Action.Group.GET_INVITE_LINK, }, async (req) => { try { const { groupId } = req.body const link = await WPP.group.getInviteCode(groupId) return `https://chat.whatsapp.com/${link}` } catch (error) { console.error(`getInviteLink relay error: ${error}`) return null } }, ) } const getMembershipRequests = () => { relay( { name: Action.Group.GET_MEMBERSHIP_REQUESTS, }, async ({ body }) => { return await WPP.group.getMembershipRequests(body) }, ) } const getParticipants = () => { relay( { name: Action.Group.GET_PARTICIPANTS, }, async ({ body }) => { try { const participants = await WPP.group.getParticipants(body) return participants.map(serialize.participant) } catch (error) { return [] } }, ) } const iAmAdmin = () => { relay( { name: Action.Group.IAM_ADMIN, }, async ({ body }) => { return await WPP.group.iAmAdmin(body) }, ) } const iAmMember = () => { relay( { name: Action.Group.IAM_MEMBER, }, async ({ body }) => { return await WPP.group.iAmMember(body) }, ) } const iAmRestrictedMember = () => { relay( { name: Action.Group.IAM_RESTRICTED_MEMBER, }, async ({ body }) => { return await WPP.group.iAmRestrictedMember(body) }, ) } const iAmSuperAdmin = () => { relay( { name: Action.Group.IAM_SUPER_ADMIN, }, async ({ body }) => { return await WPP.group.iAmSuperAdmin(body) }, ) } const join = () => { relay( { name: Action.Group.JOIN, }, async ({ body }) => { return await WPP.group.join(body) }, ) } const leave = () => { relay( { name: Action.Group.LEAVE, }, async ({ body }) => { return await WPP.group.leave(body) }, ) } const promoteParticipants = () => { relay( { name: Action.Group.PROMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.promoteParticipants(groupId, participantsIds) }, ) } const reject = () => { relay( { name: Action.Group.REJECT, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.reject(groupId, membershipIds) }, ) } const removeIcon = () => { relay( { name: Action.Group.REMOVE_ICON, }, async ({ body }) => { return await WPP.group.removeIcon(body) }, ) } const removeParticipants = () => { relay( { name: Action.Group.REMOVE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.removeParticipants(groupId, participantsIds) }, ) } const revokeInviteCode = () => { relay( { name: Action.Group.REVOKE_INVITE_CODE, }, async ({ body }) => { return await WPP.group.revokeInviteCode(body) }, ) } const setDescription = () => { relay( { name: Action.Group.SET_DESCRIPTION, }, async ({ body }) => { const { groupId, description } = body return await WPP.group.setDescription(groupId, description) }, ) } const setIcon = () => { relay( { name: Action.Group.SET_ICON, }, async ({ body }) => { const { groupId, content } = body return await WPP.group.setIcon(groupId, content) }, ) } const setProperty = () => { relay( { name: Action.Group.SET_PROPERTY, }, async ({ body }) => { const { groupId, property, value } = body return await WPP.group.setProperty(groupId, property, value) }, ) } const setSubject = () => { relay( { name: Action.Group.SET_SUBJECT, }, async ({ body }) => { const { groupId, subject } = body return await WPP.group.setSubject(groupId, subject) }, ) } const initGroupRelay = () => { addParticipants() approve() canAdd() canDemote() canPromote() canRemove() create() demoteParticipants() getInviteLink() getGroupInfoFromInviteCode() getGroupSizeLimit() getMembershipRequests() getParticipants() list() iAmAdmin() iAmMember() iAmRestrictedMember() iAmSuperAdmin() join() leave() promoteParticipants() reject() removeIcon() removeParticipants() revokeInviteCode() setDescription() setIcon() setProperty() setSubject() } export default initGroupRelay
```

# src/relays/index.ts

```ts
import initBlocklistRelays from './blocklist.relay' import initCartRelays from './cart.relay' import initChatRelay from './chat.relay' import initConnRelays from './conn.relay' import initContactRelay from './contact.relay' import initGroupRelay from './group.relay' import initSendRelay from './send.relay' import initStatusRelay from './status.relay' export const initInjectScriptRelays = () => { initBlocklistRelays() initCartRelays() initChatRelay() initConnRelays() initContactRelay() initGroupRelay() initSendRelay() initStatusRelay() }
```

# src/relays/newsletter.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const create = () => { relay( { name: Action.Newsletter.CREATE, }, async ({ body }) => { const { name, opts } = body return await WPP.newsletter.create(name, opts) }, ) } const destroy = () => { relay( { name: Action.Newsletter.DESTROY, }, async ({ body }) => { return await WPP.newsletter.destroy(body) }, ) } const edit = () => { relay( { name: Action.Newsletter.EDIT, }, async ({ body }) => { const { newsletterId, opts } = body return await WPP.newsletter.edit(newsletterId, opts) }, ) } const getSubscribers = () => { relay( { name: Action.Newsletter.GET_SUBSCRIBERS, }, async ({ body }) => { return await WPP.newsletter.getSubscribers(body) }, ) } const mute = () => { relay( { name: Action.Newsletter.MUTE, }, async ({ body }) => { const { newsletterId, value } = body return await WPP.newsletter.mute(newsletterId, value) }, ) } const initNewsletterRelay = () => { create() destroy() edit() getSubscribers() mute() } export default initNewsletterRelay
```

# src/relays/profile.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Profile.EDIT_BUSINESS_PROFILE, }, async ({ body }) => { return WPP.status.get(body) }, ) } const initProfileRelays = () => { get() } export default initProfileRelays
```

# src/relays/send.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const sendText = () => { relay( { name: Action.Send.TEXT, }, async (req) => { try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendTextMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendFile = () => { relay( { name: Action.Send.FILE, }, async (req) => { console.log('req', req) try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendFileMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendLocation = () => { relay( { name: Action.Send.LOCATION, }, async (req) => { try { const { chatId, options } = req.body const { sendMsgResult } = await WPP.chat.sendLocationMessage( chatId, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendPoll = () => { relay( { name: Action.Send.POLL, }, async (req) => { try { const { chatId, name, choices, options } = req.body const { sendMsgResult } = await WPP.chat.sendCreatePollMessage( chatId, name, choices, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendVCard = () => { relay( { name: Action.Send.VCARD, }, async (req) => { try { const { chatId, contacts, options } = req.body const { sendMsgResult } = await WPP.chat.sendVCardContactMessage( chatId, contacts, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const initSendRelay = () => { sendText() sendFile() sendLocation() sendPoll() sendVCard() } export default initSendRelay
```

# src/relays/status.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Status.GET, }, async ({ body }) => { return WPP.status.get(body) }, ) } const getMyStatus = () => { relay( { name: Action.Status.GET_MY_STATUS, }, async ({ body }) => { return await WPP.status.getMyStatus() }, ) } const remove = () => { relay( { name: Action.Status.REMOVE, }, async ({ body }) => { return await WPP.status.remove(body) }, ) } const sendImageStatus = () => { relay( { name: Action.Status.SEND_IMAGE_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendImageStatus(content, options) }, ) } const sendReadStatus = () => { relay( { name: Action.Status.SEND_READ_STATUS, }, async ({ body }) => { const { chatId, statusId } = body return await WPP.status.sendReadStatus(chatId, statusId) }, ) } const sendTextStatus = () => { relay( { name: Action.Status.SEND_TEXT_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendTextStatus(content, options) }, ) } const sendVideoStatus = () => { relay( { name: Action.Status.SEND_VIDEO_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendVideoStatus(content, options) }, ) } const updateParticipants = () => { relay( { name: Action.Status.UPDATE_PARTICIPANTS, }, async ({ body }) => { return await WPP.status.updateParticipants(body) }, ) } const initStatusRelay = () => { get() getMyStatus() remove() sendImageStatus() sendReadStatus() sendTextStatus() sendVideoStatus() updateParticipants() } export default initStatusRelay
```

# src/stores/app.ts

```ts
import type { License } from '@/types' import { create } from 'zustand' interface AppState { isReady: boolean setIsReady: (isReady: boolean) => void profile: any setProfile: (profile: any) => void license?: License | null setLicense: (license: any) => void groups: any[] setGroups: (groups: []) => void isLoading: boolean setIsLoading: (state: boolean) => void activeChat: any setActiveChat: (chat: any) => void } export const useAppStore = create<AppState>((set) => ({ isReady: false, setIsReady: (isReady: boolean) => set({ isReady }), license: null, setLicense: (license: any) => set({ license: license }), groups: [], setGroups: (groups: []) => set({ groups }), profile: {}, setProfile: (profile: any) => set({ profile }), isLoading: false, setIsLoading: (state: any) => set({ isLoading: state }), activeChat: {}, setActiveChat: (chat: any) => set({ activeChat: chat }), }))
```

# src/stores/toast.ts

```ts
import { create } from 'zustand' export interface Toast { id: number type: 'success' | 'error' | 'info' title: string message: string duration?: number } interface ToastState { toasts: Toast[] addToast: (toast: Omit<Toast, 'id'>) => void removeToast: (id: number) => void } export const useToastStore = create<ToastState>((set) => ({ toasts: [], addToast: (toast) => set((state) => ({ toasts: [...state.toasts, { ...toast, id: Date.now() }], })), removeToast: (id) => set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id), })), }))
```

# src/styles/globals.css

```css
div.plasmo-csui-container { margin: 0; color-scheme: var(--mantine-color-scheme); font-family: var(--mantine-font-family); font-size: var(--mantine-font-size-md); line-height: var(--mantine-line-height); background-color: var(--mantine-color-body); color: var(--mantine-color-text); -webkit-font-smoothing: var(--mantine-webkit-font-smoothing); -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing); right: 0px; left: auto !important; } .root { position: fixed; top: '30%'; left: '50%'; transform: 'translate(-50%, -50%)'; z-index: 1001; background-color: red; } #plasmo-inline { background: transparent; }
```

# src/types/globals.d.ts

```ts
import type * as wajs from '@wppconnect/wa-js' declare global { interface Window { WPP: typeof wajs } const WPP: typeof wajs }
```

# src/types/index.d.ts

```ts
import type { Status } from '@/constants' export interface Response<T> { status: keyof typeof Status | string data?: T | null error?: string | null } interface LicenseInstance { createt_at: Date id: string name: string } interface LicenseKey { activation_limit: number activation_usage: number create_at: Date expires_at: Date id: number status: string test_mode: boolean } interface LicenseMeta { customer_email: string customer_id: number customer_name: string order_id: number order_item_id: number product_id: number store_id: number variant_id: number variant_name: string } export interface License { activated?: boolean | null valid?: boolean | null instance?: LicenseInstance | null license_key: LicenseKey meta: LicenseMeta }
```

# src/utils/country.ts

```ts
const countries = { AD: { label: '🇦🇩 Andorra', phone: '376' }, AE: { label: '🇦🇪 United Arab Emirates', phone: '971' }, AF: { label: '🇦🇫 Afghanistan', phone: '93' }, AG: { label: '🇦🇬 Antigua and Barbuda', phone: '1-268' }, AI: { label: '🇦🇮 Anguilla', phone: '1-264' }, AL: { label: '🇦🇱 Albania', phone: '355' }, AM: { label: '🇦🇲 Armenia', phone: '374' }, AO: { label: '🇦🇴 Angola', phone: '244' }, AQ: { label: '🇦🇶 Antarctica', phone: '672' }, AR: { label: '🇦🇷 Argentina', phone: '54' }, AS: { label: '🇦🇸 American Samoa', phone: '1-684' }, AT: { label: '🇦🇹 Austria', phone: '43' }, AU: { label: '🇦🇺 Australia', phone: '61' }, AW: { label: '🇦🇼 Aruba', phone: '297' }, AX: { label: '🇦🇽 Alland Islands', phone: '358' }, AZ: { label: '🇦🇿 Azerbaijan', phone: '994' }, BA: { label: '🇧🇦 Bosnia and Herzegovina', phone: '387' }, BB: { label: '🇧🇧 Barbados', phone: '1-246' }, BD: { label: '🇧🇩 Bangladesh', phone: '880' }, BE: { label: '🇧🇪 Belgium', phone: '32' }, BF: { label: '🇧🇫 Burkina Faso', phone: '226' }, BG: { label: '🇧🇬 Bulgaria', phone: '359' }, BH: { label: '🇧🇭 Bahrain', phone: '973' }, BI: { label: '🇧🇮 Burundi', phone: '257' }, BJ: { label: '🇧🇯 Benin', phone: '229' }, BL: { label: '🇧🇱 Saint Barthelemy', phone: '590' }, BM: { label: '🇧🇲 Bermuda', phone: '1-441' }, BN: { label: '🇧🇳 Brunei Darussalam', phone: '673' }, BO: { label: '🇧🇴 Bolivia', phone: '591' }, BR: { label: '🇧🇷 Brazil', phone: '55' }, BS: { label: '🇧🇸 Bahamas', phone: '1-242' }, BT: { label: '🇧🇹 Bhutan', phone: '975' }, BV: { label: '🇧🇻 Bouvet Island', phone: '47' }, BW: { label: '🇧🇼 Botswana', phone: '267' }, BY: { label: '🇧🇾 Belarus', phone: '375' }, BZ: { label: '🇧🇿 Belize', phone: '501' }, CA: { label: '🇨🇦 Canada', phone: '1' }, CC: { label: '🇨🇨 Cocos (Keeling) Islands', phone: '61' }, CD: { label: '🇨🇩 Congo, Democratic Republic of the', phone: '243' }, CF: { label: '🇨🇫 Central African Republic', phone: '236' }, CG: { label: '🇨🇬 Congo, Republic of the', phone: '242' }, CH: { label: '🇨🇭 Switzerland', phone: '41' }, CI: { label: "🇨🇮 Cote d'Ivoire", phone: '225' }, CK: { label: '🇨🇰 Cook Islands', phone: '682' }, CL: { label: '🇨🇱 Chile', phone: '56' }, CM: { label: '🇨🇲 Cameroon', phone: '237' }, CN: { label: '🇨🇳 China', phone: '86' }, CO: { label: '🇨🇴 Colombia', phone: '57' }, CR: { label: '🇨🇷 Costa Rica', phone: '506' }, CU: { label: '🇨🇺 Cuba', phone: '53' }, CV: { label: '🇨🇻 Cape Verde', phone: '238' }, CW: { label: '🇨🇼 Curacao', phone: '599' }, CX: { label: '🇨🇽 Christmas Island', phone: '61' }, CY: { label: '🇨🇾 Cyprus', phone: '357' }, CZ: { label: '🇨🇿 Czech Republic', phone: '420' }, DE: { label: '🇩🇪 Germany', phone: '49' }, DJ: { label: '🇩🇯 Djibouti', phone: '253' }, DK: { label: '🇩🇰 Denmark', phone: '45' }, DM: { label: '🇩🇲 Dominica', phone: '1-767' }, DO: { label: '🇩🇴 Dominican Republic', phone: '1-809' }, DZ: { label: '🇩🇿 Algeria', phone: '213' }, EC: { label: '🇪🇨 Ecuador', phone: '593' }, EE: { label: '🇪🇪 Estonia', phone: '372' }, EG: { label: '🇪🇬 Egypt', phone: '20' }, EH: { label: '🇪🇭 Western Sahara', phone: '212' }, ER: { label: '🇪🇷 Eritrea', phone: '291' }, ES: { label: '🇪🇸 Spain', phone: '34' }, ET: { label: '🇪🇹 Ethiopia', phone: '251' }, FI: { label: '🇫🇮 Finland', phone: '358' }, FJ: { label: '🇫🇯 Fiji', phone: '679' }, FK: { label: '🇫🇰 Falkland Islands (Malvinas)', phone: '500' }, FM: { label: '🇫🇲 Micronesia, Federated States of', phone: '691' }, FO: { label: '🇫🇴 Faroe Islands', phone: '298' }, FR: { label: '🇫🇷 France', phone: '33' }, GA: { label: '🇬🇦 Gabon', phone: '241' }, GB: { label: '🇬🇧 United Kingdom', phone: '44' }, GD: { label: '🇬🇩 Grenada', phone: '1-473' }, GE: { label: '🇬🇪 Georgia', phone: '995' }, GF: { label: '🇬🇫 French Guiana', phone: '594' }, GG: { label: '🇬🇬 Guernsey', phone: '44' }, GH: { label: '🇬🇭 Ghana', phone: '233' }, GI: { label: '🇬🇮 Gibraltar', phone: '350' }, GL: { label: '🇬🇱 Greenland', phone: '299' }, GM: { label: '🇬🇲 Gambia', phone: '220' }, GN: { label: '🇬🇳 Guinea', phone: '224' }, GP: { label: '🇬🇵 Guadeloupe', phone: '590' }, GQ: { label: '🇬🇶 Equatorial Guinea', phone: '240' }, GR: { label: '🇬🇷 Greece', phone: '30' }, GS: { label: '🇬🇸 South Georgia and the South Sandwich Islands', phone: '500', }, GT: { label: '🇬🇹 Guatemala', phone: '502' }, GU: { label: '🇬🇺 Guam', phone: '1-671' }, GW: { label: '🇬🇼 Guinea-Bissau', phone: '245' }, GY: { label: '🇬🇾 Guyana', phone: '592' }, HK: { label: '🇭🇰 Hong Kong', phone: '852' }, HM: { label: '🇭🇲 Heard Island and McDonald Islands', phone: '672' }, HN: { label: '🇭🇳 Honduras', phone: '504' }, HR: { label: '🇭🇷 Croatia', phone: '385' }, HT: { label: '🇭🇹 Haiti', phone: '509' }, HU: { label: '🇭🇺 Hungary', phone: '36' }, ID: { label: '🇮🇩 Indonesia', phone: '62' }, IE: { label: '🇮🇪 Ireland', phone: '353' }, IL: { label: '🇮🇱 Israel', phone: '972' }, IM: { label: '🇮🇲 Isle of Man', phone: '44' }, IN: { label: '🇮🇳 India', phone: '91' }, IO: { label: '🇮🇴 British Indian Ocean Territory', phone: '246' }, IQ: { label: '🇮🇶 Iraq', phone: '964' }, IR: { label: '🇮🇷 Iran, Islamic Republic of', phone: '98' }, IS: { label: '🇮🇸 Iceland', phone: '354' }, IT: { label: '🇮🇹 Italy', phone: '39' }, JE: { label: '🇯🇪 Jersey', phone: '44' }, JM: { label: '🇯🇲 Jamaica', phone: '1-876' }, JO: { label: '🇯🇴 Jordan', phone: '962' }, JP: { label: '🇯🇵 Japan', phone: '81' }, KE: { label: '🇰🇪 Kenya', phone: '254' }, KG: { label: '🇰🇬 Kyrgyzstan', phone: '996' }, KH: { label: '🇰🇭 Cambodia', phone: '855' }, KI: { label: '🇰🇮 Kiribati', phone: '686' }, KM: { label: '🇰🇲 Comoros', phone: '269' }, KN: { label: '🇰🇳 Saint Kitts and Nevis', phone: '1-869' }, KP: { label: "🇰🇵 Korea, Democratic People's Republic of", phone: '850' }, KR: { label: '🇰🇷 Korea, Republic of', phone: '82' }, KW: { label: '🇰🇼 Kuwait', phone: '965' }, KY: { label: '🇰🇾 Cayman Islands', phone: '1-345' }, KZ: { label: '🇰🇿 Kazakhstan', phone: '7' }, LA: { label: "🇱🇦 Lao People's Democratic Republic", phone: '856' }, LB: { label: '🇱🇧 Lebanon', phone: '961' }, LC: { label: '🇱🇨 Saint Lucia', phone: '1-758' }, LI: { label: '🇱🇮 Liechtenstein', phone: '423' }, LK: { label: '🇱🇰 Sri Lanka', phone: '94' }, LR: { label: '🇱🇷 Liberia', phone: '231' }, LS: { label: '🇱🇸 Lesotho', phone: '266' }, LT: { label: '🇱🇹 Lithuania', phone: '370' }, LU: { label: '🇱🇺 Luxembourg', phone: '352' }, LV: { label: '🇱🇻 Latvia', phone: '371' }, LY: { label: '🇱🇾 Libya', phone: '218' }, MA: { label: '🇲🇦 Morocco', phone: '212' }, MC: { label: '🇲🇨 Monaco', phone: '377' }, MD: { label: '🇲🇩 Moldova, Republic of', phone: '373' }, ME: { label: '🇲🇪 Montenegro', phone: '382' }, MF: { label: '🇲🇫 Saint Martin (French part)', phone: '590' }, MG: { label: '🇲🇬 Madagascar', phone: '261' }, MH: { label: '🇲🇭 Marshall Islands', phone: '692' }, MK: { label: '🇲🇰 Macedonia, the Former Yugoslav Republic of', phone: '389' }, ML: { label: '🇲🇱 Mali', phone: '223' }, MM: { label: '🇲🇲 Myanmar', phone: '95' }, MN: { label: '🇲🇳 Mongolia', phone: '976' }, MO: { label: '🇲🇴 Macao', phone: '853' }, MP: { label: '🇲🇵 Northern Mariana Islands', phone: '1-670' }, MQ: { label: '🇲🇶 Martinique', phone: '596' }, MR: { label: '🇲🇷 Mauritania', phone: '222' }, MS: { label: '🇲🇸 Montserrat', phone: '1-664' }, MT: { label: '🇲🇹 Malta', phone: '356' }, MU: { label: '🇲🇺 Mauritius', phone: '230' }, MV: { label: '🇲🇻 Maldives', phone: '960' }, MW: { label: '🇲🇼 Malawi', phone: '265' }, MX: { label: '🇲🇽 Mexico', phone: '52' }, MY: { label: '🇲🇾 Malaysia', phone: '60' }, MZ: { label: '🇲🇿 Mozambique', phone: '258' }, NA: { label: '🇳🇦 Namibia', phone: '264' }, NC: { label: '🇳🇨 New Caledonia', phone: '687' }, NE: { label: '🇳🇪 Niger', phone: '227' }, NF: { label: '🇳🇫 Norfolk Island', phone: '672' }, NG: { label: '🇳🇬 Nigeria', phone: '234' }, NI: { label: '🇳🇮 Nicaragua', phone: '505' }, NL: { label: '🇳🇱 Netherlands', phone: '31' }, NO: { label: '🇳🇴 Norway', phone: '47' }, NP: { label: '🇳🇵 Nepal', phone: '977' }, NR: { label: '🇳🇷 Nauru', phone: '674' }, NU: { label: '🇳🇺 Niue', phone: '683' }, NZ: { label: '🇳🇿 New Zealand', phone: '64' }, OM: { label: '🇴🇲 Oman', phone: '968' }, PA: { label: '🇵🇦 Panama', phone: '507' }, PE: { label: '🇵🇪 Peru', phone: '51' }, PF: { label: '🇵🇫 French Polynesia', phone: '689' }, PG: { label: '🇵🇬 Papua New Guinea', phone: '675' }, PH: { label: '🇵🇭 Philippines', phone: '63' }, PK: { label: '🇵🇰 Pakistan', phone: '92' }, PL: { label: '🇵🇱 Poland', phone: '48' }, PM: { label: '🇵🇲 Saint Pierre and Miquelon', phone: '508' }, PN: { label: '🇵🇳 Pitcairn', phone: '870' }, PR: { label: '🇵🇷 Puerto Rico', phone: '1' }, PS: { label: '🇵🇸 Palestine, State of', phone: '970' }, PT: { label: '🇵🇹 Portugal', phone: '351' }, PW: { label: '🇵🇼 Palau', phone: '680' }, PY: { label: '🇵🇾 Paraguay', phone: '595' }, QA: { label: '🇶🇦 Qatar', phone: '974' }, RE: { label: '🇷🇪 Reunion', phone: '262' }, RO: { label: '🇷🇴 Romania', phone: '40' }, RS: { label: '🇷🇸 Serbia', phone: '381' }, RU: { label: '🇷🇺 Russian Federation', phone: '7' }, RW: { label: '🇷🇼 Rwanda', phone: '250' }, SA: { label: '🇸🇦 Saudi Arabia', phone: '966' }, SB: { label: '🇸🇧 Solomon Islands', phone: '677' }, SC: { label: '🇸🇨 Seychelles', phone: '248' }, SD: { label: '🇸🇩 Sudan', phone: '249' }, SE: { label: '🇸🇪 Sweden', phone: '46' }, SG: { label: '🇸🇬 Singapore', phone: '65' }, SH: { label: '🇸🇭 Saint Helena', phone: '290' }, SI: { label: '🇸🇮 Slovenia', phone: '386' }, SJ: { label: '🇸🇯 Svalbard and Jan Mayen', phone: '47' }, SK: { label: '🇸🇰 Slovakia', phone: '421' }, SL: { label: '🇸🇱 Sierra Leone', phone: '232' }, SM: { label: '🇸🇲 San Marino', phone: '378' }, SN: { label: '🇸🇳 Senegal', phone: '221' }, SO: { label: '🇸🇴 Somalia', phone: '252' }, SR: { label: '🇸🇷 Suriname', phone: '597' }, SS: { label: '🇸🇸 South Sudan', phone: '211' }, ST: { label: '🇸🇹 Sao Tome and Principe', phone: '239' }, SV: { label: '🇸🇻 El Salvador', phone: '503' }, SX: { label: '🇸🇽 Sint Maarten (Dutch part)', phone: '1-721' }, SY: { label: '🇸🇾 Syrian Arab Republic', phone: '963' }, SZ: { label: '🇸🇿 Swaziland', phone: '268' }, TC: { label: '🇹🇨 Turks and Caicos Islands', phone: '1-649' }, TD: { label: '🇹🇩 Chad', phone: '235' }, TF: { label: '🇹🇫 French Southern Territories', phone: '262' }, TG: { label: '🇹🇬 Togo', phone: '228' }, TH: { label: '🇹🇭 Thailand', phone: '66' }, TJ: { label: '🇹🇯 Tajikistan', phone: '992' }, TK: { label: '🇹🇰 Tokelau', phone: '690' }, TL: { label: '🇹🇱 Timor-Leste', phone: '670' }, TM: { label: '🇹🇲 Turkmenistan', phone: '993' }, TN: { label: '🇹🇳 Tunisia', phone: '216' }, TO: { label: '🇹🇴 Tonga', phone: '676' }, TR: { label: '🇹🇷 Turkey', phone: '90' }, TT: { label: '🇹🇹 Trinidad and Tobago', phone: '1-868' }, TV: { label: '🇹🇻 Tuvalu', phone: '688' }, TW: { label: '🇹🇼 Taiwan, Province of China', phone: '886' }, TZ: { label: '🇹🇿 United Republic of Tanzania', phone: '255' }, UA: { label: '🇺🇦 Ukraine', phone: '380' }, UG: { label: '🇺🇬 Uganda', phone: '256' }, US: { label: '🇺🇸 United States', phone: '1' }, UY: { label: '🇺🇾 Uruguay', phone: '598' }, UZ: { label: '🇺🇿 Uzbekistan', phone: '998' }, VA: { label: '🇻🇦 Holy See (Vatican City State)', phone: '379' }, VC: { label: '🇻🇨 Saint Vincent and the Grenadines', phone: '1-784' }, VE: { label: '🇻🇪 Venezuela', phone: '58' }, VG: { label: '🇻🇬 British Virgin Islands', phone: '1-284' }, VI: { label: '🇻🇮 US Virgin Islands', phone: '1-340' }, VN: { label: '🇻🇳 Vietnam', phone: '84' }, VU: { label: '🇻🇺 Vanuatu', phone: '678' }, WF: { label: '🇼🇫 Wallis and Futuna', phone: '681' }, WS: { label: '🇼🇸 Samoa', phone: '685' }, XK: { label: '🇽🇰 Kosovo', phone: '383' }, YE: { label: '🇾🇪 Yemen', phone: '967' }, YT: { label: '🇾🇹 Mayotte', phone: '262' }, ZA: { label: '🇿🇦 South Africa', phone: '27' }, ZM: { label: '🇿🇲 Zambia', phone: '260' }, ZW: { label: '🇿🇼 Zimbabwe', phone: '263' }, } const getCountryByCode = (code: string) => { return countries[code] ?? { label: '-', phone: '-' } } export default { getCountryByCode, countries, }
```

# src/utils/env.ts

```ts
const isProduction = () => { return process.env.NODE_ENV === 'production' } const isDevelopment = () => { return process.env.NODE_ENV === 'development' } export const isStaging = () => { return process.env.PLASMO_PUBLIC_STAGING === 'true' } export default { isProduction, isDevelopment, isStaging, }
```

# src/utils/ext.ts

```ts
import type { Tabs } from 'webextension-polyfill' import browser from 'webextension-polyfill' export async function getCurrentTab(): Promise<Tabs.Tab> { const queryOptions = { active: true, currentWindow: true } const [tab] = await browser.tabs.query(queryOptions) return tab } export async function getTabs(): Promise<Tabs.Tab[]> { return new Promise(async (resolve, reject) => { try { const tabs = await browser.tabs.query({ currentWindow: true }) const filteredTabs = tabs.filter( (tab) => !tab.url?.startsWith('chrome://'), ) return resolve(filteredTabs) } catch (error) { reject(error) } }) } export async function getTabByUrl(url: string): Promise<Tabs.Tab | null> { const queryOptions = { url: url } const tabs = await browser.tabs.query(queryOptions) return tabs.length > 0 ? tabs[0] : null } export const openWa = async () => { await browser.tabs.create({ url: 'https://web.whatsapp.com' }) } export const isWaTabActive = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return result?.active } export const isWaTabAvailable = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return !!result }
```

# src/utils/filterBy.ts

```ts
import { AccountType, ContactType, MessageType } from '@/constants' import type { ContactModel } from '@wppconnect/wa-js/dist/whatsapp' const dontIncludeLid = (contact: ContactModel) => contact.id.server !== 'lid' const dontIncludeMe = (contact: any, number: any) => contact.phoneNumber !== number const accountType = (contact: any, type: string) => { switch (type) { case AccountType.ALL: return true case AccountType.PERSONAL: return contact.isBusiness === false case AccountType.BUSINESS: return contact.isBusiness === true default: return true } } const contactType = (contact: any, type: string): boolean => { switch (type) { case ContactType.ALL: return true case ContactType.SAVED_CONTACTS: return contact.isMyContact === true case ContactType.UNSAVED_CONTACTS: return contact.isMyContact === false default: return true } } const includeAdmin = (data: any, isIncludeAdmin: boolean) => { if (isIncludeAdmin) { if (data.isAdmin) { return true } } else { if (data.isAdmin) return false } return true } const onlyMyContact = (data: any, onlyMyContact: boolean) => { if (onlyMyContact) { return data.isMyContact === true } else { return data.isMyContact !== true } } const messageType = (contact: any, type: string): boolean => { switch (type) { case MessageType.ALL: return true case MessageType.HAVE_UNREAD_MESSAGES: return contact.hasUnread === true case MessageType.NO_UNREAD_MESSAGES: return contact.hasUnread === false default: return true } } const country = (contact: any, country: string) => { const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) return countryCode === country } export default { dontIncludeLid, dontIncludeMe, accountType, includeAdmin, onlyMyContact, contactType, messageType, country, }
```

# src/utils/mock.ts

```ts
// src/utils/mock.ts import type { License } from '@/types' /** * @description Generates a fake license object that mimics a valid "Pro" license. * This is used for the bypass feature to enable Pro features persistently. * @returns {License} A mock License object. */ export const getFakeProLicense = (): License => { return { valid: true, license_key: { status: 'active', //@ts-ignore expires_at: '2099-12-31T23:59:59Z', // A far future expiration date. activation_limit: 999, activation_usage: 1, test_mode: false, created_at: new Date().toISOString(), id: 0, }, instance: { id: 'bypass-instance', name: 'Bypass User', createt_at: new Date(), }, meta: { store_id: 0, product_id: 0, order_id: 0, order_item_id: 0, customer_id: 0, customer_name: 'Bypass User', customer_email: 'bypass@example.com', variant_id: 0, variant_name: 'Pro (Bypassed)', }, } }
```

# src/utils/page.ts

```ts
import { Action } from '@/constants' import { postMessage } from './util' const goTo = (page: string) => { postMessage(Action.Window.GO_TO_PAGE, page) } export default { goTo, }
```

# src/utils/parse.ts

```ts
// src/utils/parse.ts import wa from '@/libs/wa' import { format } from 'date-fns' import _ from 'lodash' /** * @description New function to process Spintax. * It finds patterns like {option1|option2|etc}, randomly selects one option, * and replaces the pattern with the chosen option. * This process repeats until no Spintax patterns are left, supporting nested spintax. * @param {string} text The text containing Spintax format. * @returns {string} The processed text with variations. */ const processSpintax = (text: string): string => { const spintaxRegex = /{([^{}]*)}/ let processedText = text let match = spintaxRegex.exec(processedText) while (match) { // Split options by the '|' separator const options = match[1].split('|') // Select one option randomly from the array const randomIndex = Math.floor(Math.random() * options.length) const chosenOption = options[randomIndex] // Replace the spintax block with the chosen option processedText = processedText.replace(match[0], chosenOption) // Find the next spintax block (to handle nested patterns) match = spintaxRegex.exec(processedText) } return processedText } const text = async (message: string, number: string) => { const chat = (await wa.chat.find(number)).data // 1. Process Spintax first to generate the message variation const spintaxedMessage = processSpintax(message) // 2. Then, process variables like {name}, {number}, and dates on the varied message return _.chain(spintaxedMessage) .thru((str) => _.includes(str, '{name}') ? _.replace(str, '{name}', chat.name) : str, ) .thru((str) => _.includes(str, '{number}') ? _.replace(str, '{number}', chat.number) : str, ) .thru((str) => _.includes(str, '{date}') ? _.replace(str, '{date}', format(new Date(), 'yyyy-MM-dd')) : str, ) .thru((str) => _.includes(str, '{time}') ? _.replace(str, '{time}', format(new Date(), 'HH:mm:ss')) : str, ) .value() } export default { text }
```

# src/utils/privacy.ts

```ts
import { Setting } from '@/constants' import { storage } from '@/libs/storage' import $ from 'jquery' const init = async () => {} const blurProfilePictures = async () => { const state = ((await storage.get(Setting.BLUR_PROFILE_PICTURES)) ?? false) as boolean $('div[class="x1n2onr6 x14yjl9h xudhj91 x18nykt9 xww2gxu"]').css( 'filter', state ? 'blur(3px)' : '', ) $('span[data-icon="default-contact-refreshed"]').css( 'filter', state ? 'blur(3px)' : '', ) } const blurMessages = () => { setTimeout(async () => { const state = ((await storage.get(Setting.BLUR_MESSAGES)) ?? false) as boolean $( 'div[class="_amkz message-in focusable-list-item _amjy _amjz _amjw"]', ).css('filter', state ? 'blur(3px)' : '') $('div[class="message-in focusable-list-item _amjy _amjz _amjw"]').css( 'filter', state ? 'blur(3px)' : '', ) $('div[class="message-out focusable-list-item _amjy _amjz _amjw"]').css( 'filter', state ? 'blur(3px)' : '', ) $('div[class="_aml8"]').css('filter', state ? 'blur(3px)' : '') }, 200) } const blurUserGroupNames = async () => { const state = ((await storage.get(Setting.BLUR_USER_GROUP_NAMES)) ?? false) as boolean $('div[class="_ak8q"]').css('filter', state ? 'blur(3px)' : '') } const blurRecentMessages = async () => { const state = ((await storage.get(Setting.BLUR_RECENT_MESSAGES)) ?? false) as boolean $('div[class="_ak8j"]').css('filter', state ? 'blur(3px)' : '') } export default { init, blurProfilePictures, blurMessages, blurUserGroupNames, blurRecentMessages, }
```

# src/utils/response.ts

```ts
import { Status } from '@/constants' import type { Response } from '@/types' const success = <T = any>(data?: T | null): Response<T | undefined | null> => { return { status: Status.SUCCESS, data: data, } } const error = (error: string | undefined | null): Response<null> => { return { status: Status.FAILED, error: error, } } export const response = { success, error, }
```

# src/utils/serialize.ts

```ts
import type { ChatModel, ContactModel, GroupMetadataModel, MediaDataModel, MsgModel, ParticipantModel, } from '@wppconnect/wa-js/dist/whatsapp' import _ from 'lodash' import country from './country' const button = (buttons: any[]) => { return buttons .map(({ type, label, value }) => { switch (type) { case 'text': return { text: value } case 'url': return { text: label, url: value } case 'phoneNumber': return { text: label, phoneNumber: value } default: break } }) .filter((button) => !!button) } const list = (rows: any[]) => { return rows.filter((row) => row.title !== '') } const contact = (contact: ContactModel) => { if (!contact) return {} const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) const hasUnread = WPP.chat.get(contact.id._serialized)?.hasUnread ?? false const selectedCountry = country.getCountryByCode(countryCode) return { id: contact.id._serialized, avatar: contact.getProfilePicThumb().__x_eurl, country: selectedCountry.label, name: contact.name, pushname: contact.pushname, shortname: contact.shortName, notifyName: contact.notifyName, formattedName: contact.formattedName, formattedPhone: contact.formattedPhone, formattedShortName: contact.formattedShortName, formattedShortNameWithNonBreakingSpaces: contact.formattedShortNameWithNonBreakingSpaces, formattedUser: contact.formattedUser, isBusiness: contact.isBusiness, isContactBlocked: contact.isContactBlocked, //@ts-ignore isFavorite: contact.isFavorite, isGroup: contact.isGroup, isMe: contact.isMe, isMyContact: contact.isMyContact, isUser: contact.isUser, isWaContact: contact.isWAContact, labels: contact.labels, hasUnread, } } const mediaData = (data?: MediaDataModel) => { if (!data) return {} return { mimeType: data?.mimetype, size: data?.size, base64: data?.preview?.base64, height: data?.fullHeight, width: data?.fullWidth, } } const message = (msgModel: MsgModel) => { return { id: msgModel.id._serialized, ack: msgModel.ack, body: msgModel.body, from: msgModel.from, isViewOnce: msgModel.isViewOnce, timestamp: msgModel.t * 1000, to: msgModel.to, type: msgModel.type, mimetype: msgModel.mimetype, size: msgModel.size, filename: msgModel.filename, caption: msgModel.caption, duration: msgModel.duration, height: msgModel.height, width: msgModel.width, quotedMessage: msgModel.quotedMsg, contact: contact(msgModel.senderObj), } } const groupMetadata = (data: GroupMetadataModel) => { return { id: data?.id?._serialized, description: data?.desc, size: data?.size, subject: data?.subject, creation: data?.creation * 1000, participants: data?.participants?.getModelsArray().map(participant), } } const chat = (chat: ChatModel) => { return { id: chat.id._serialized, name: chat.name, messages: chat.msgs.getModelsArray().map(message), contact: contact(chat.contact), groupMetadata: groupMetadata(chat.groupMetadata), } } const participant = (participant: ParticipantModel) => { return { id: participant.id, isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, contact: contact(participant.contact), } } export default { button, list, contact, chat, participant, message, }
```

# src/utils/style.ts

```ts
import appStyle from 'data-text:@/components/App.module.css' import layoutStyle from 'data-text:@/components/Layout/LayoutPage.module.css' import toastStyle from 'data-text:@/components/Toast/Toast.module.css' import globalsStyle from 'data-text:@/styles/globals.css' import coreStyle from 'data-text:@mantine/core/styles.css' import dateStyle from 'data-text:@mantine/dates/styles.css' import dropzoneStyle from 'data-text:@mantine/dropzone/styles.css' import tableStyle from 'data-text:mantine-datatable/styles.layer.css' const styles = [ coreStyle, dateStyle, dropzoneStyle, tableStyle, toastStyle, globalsStyle, layoutStyle, appStyle, ] const generate = () => { return styles.join('') } export default { generate }
```

# src/utils/throwError.ts

```ts
const broadcastNotFound = () => { throw new Error('Broadcast not found') } const mediaNotFound = () => { throw new Error('Media not found') } const contactNotExist = () => { throw new Error('Contact not exist') } export default { broadcastNotFound, mediaNotFound, contactNotExist, }
```

# src/utils/toast.ts

```ts
import { useToastStore } from '@/stores/toast' const showSuccess = (message: string, title: string = 'Success') => { useToastStore.getState().addToast({ type: 'success', title, message, }) } const showError = (message: string, title: string = 'Error') => { useToastStore.getState().addToast({ type: 'error', title, message, }) } const showInfo = (message: string, title: string = 'Information') => { useToastStore.getState().addToast({ type: 'info', title, message, }) } export default { success: showSuccess, error: showError, info: showInfo, }
```

# src/utils/util.ts

```ts
// src/utils/util.ts import { Action, Message } from '@/constants' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' export async function delay(timeoutMs = 1000) { await new Promise((resolve) => setTimeout(resolve, timeoutMs)) } export const generateRandomDelay = (min: number, max: number) => { // Calculate the range of multiples of 1000 const minThousand = Math.ceil(min / 1000) const maxThousand = Math.floor(max / 1000) // Generate a random integer in that range and multiply by 1000 const randomThousand = Math.floor(Math.random() * (maxThousand - minThousand + 1)) + minThousand return randomThousand * 1000 } export const truncate = (data: string, length: number = 30) => { return _.chain(data) .thru((str) => (str.length > length ? `${str.slice(0, length)}...` : str)) .value() } export const postMessage = (action: string, body: any = null) => { window.postMessage({ action, body }) } export const showModalUpgrade = () => { postMessage(Action.Window.SHOW_MODAL_UPGRADE) } export const showModalMain = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } export const showModalActivation = () => { postMessage(Action.Window.SHOW_MODAL_ACTIVATION) } export const getStoreId = () => { return process.env.PLASMO_PUBLIC_STORE_ID } export const isTypeMessageMedia = (type: string) => { return [Message.MEDIA, Message.IMAGE, Message.VIDEO, Message.FILE].includes( type, ) } export const formHasErrors = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ): boolean => { let hasError = false if (form1.validate().hasErrors) { hasError = true } if (form2.validate().hasErrors) { hasError = true } return hasError } export const resetForms = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ) => { form1.reset() form2.reset() } /** * @description Generates a thumbnail from a video file. * @param {File} file The video file. * @returns {Promise<string>} A promise that resolves with a base64 data URL of the thumbnail. */ export const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve, reject) => { try { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.muted = true video.playsInline = true video.onloadeddata = () => { canvas.width = video.videoWidth canvas.height = video.videoHeight video.currentTime = 1 // Seek to 1 second to get a good frame video.onseeked = () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up memory resolve(thumbnailUrl) } else { reject(new Error('Could not get canvas context.')) } } } video.onerror = () => { URL.revokeObjectURL(video.src) reject(new Error('Failed to load video file for thumbnail.')) } video.src = URL.createObjectURL(file) } catch (error) { reject(error) } }) } export const getContactName = (contact: any) => { return ( contact.name || contact.pushname || contact.notifyName || contact.formattedName || '-' ) }
```

# tsconfig.json

```json
{ "extends": "plasmo/templates/tsconfig.base", "exclude": ["node_modules"], "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"], "compilerOptions": { "paths": { "@/*": ["src/*"] }, "baseUrl": "." } }
```

