# assets/icon.png

This is a binary file of the type: Image

# package.json

```json
{ "name": "whats-direct", "displayName": "WA Direct Chat for WhatsApp", "version": "1.0.0", "description": "Start WhatsApp Chat Without Saving Numbers with Media and Templates", "author": "Extninja", "scripts": { "dev": "plasmo dev --no-cs-reload", "build": "plasmo build", "package": "plasmo package" }, "dependencies": { "@haverstack/axios-fetch-adapter": "^0.12.0", "@lemonsqueezy/lemonsqueezy.js": "^4.0.0", "@mantine/core": "^8.2.2", "@mantine/dates": "^8.2.2", "@mantine/dropzone": "^8.2.2", "@mantine/form": "^8.2.2", "@mantine/hooks": "^8.2.2", "@plasmohq/messaging": "0.7.1", "@plasmohq/storage": "^1.15.0", "@wppconnect/wa-js": "^3.18.6", "axios": "^1.11.0", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dayjs": "^1.11.13", "dexie": "^4.0.11", "dexie-react-hooks": "^1.1.7", "emoji-picker-react": "^4.13.2", "file-saver": "^2.0.5", "html2canvas": "^1.4.1", "jquery": "^3.7.1", "jszip": "^3.10.1", "lodash": "^4.17.21", "mantine-datatable": "^8.2.0", "plasmo": "0.90.5", "qrcode.react": "^4.2.0", "react": "18.2.0", "react-dom": "18.2.0", "react-if": "^4.1.6", "webextension-polyfill": "^0.12.0", "xlsx": "^0.18.5", "zustand": "^5.0.7" }, "devDependencies": { "@ianvs/prettier-plugin-sort-imports": "4.1.1", "@iconify/react": "^6.0.0", "@types/chrome": "0.0.258", "@types/file-saver": "^2.0.7", "@types/jquery": "^3.5.32", "@types/lodash": "^4.17.20", "@types/node": "20.11.5", "@types/react": "18.2.48", "@types/react-dom": "18.2.18", "@types/webextension-polyfill": "^0.12.3", "postcss": "^8.5.6", "postcss-preset-mantine": "1.17.0", "postcss-simple-vars": "^7.0.1", "prettier": "3.2.4", "typescript": "5.3.3" }, "manifest": { "host_permissions": [ "https://web.whatsapp.com/*", "https://api.lemonsqueezy.com/*" ], "permissions": [], "default_locale": "en" } }
```

# postcss.config.cjs

```cjs
module.exports = { plugins: { 'postcss-preset-mantine': {}, 'postcss-simple-vars': { variables: { 'mantine-breakpoint-xs': '36em', 'mantine-breakpoint-sm': '48em', 'mantine-breakpoint-md': '62em', 'mantine-breakpoint-lg': '75em', 'mantine-breakpoint-xl': '88em', }, }, }, }
```

# README.md

```md
This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo). ## Getting Started First, run the development server: \`\`\`bash pnpm dev # or npm run dev \`\`\` Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`. You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser. For further guidance, [visit our Documentation](https://docs.plasmo.com/) ## Making production build Run the following: \`\`\`bash pnpm build # or npm run build \`\`\` This should create a production bundle for your extension, ready to be zipped and published to the stores. ## Submit to the webstores The easiest way to deploy your Plasmo extension is to use the built-in [bpp](https://bpp.browser.market) GitHub action. Prior to using this action however, make sure to build your extension and upload the first version to the store to establish the basic credentials. Then, simply follow [this setup instruction](https://docs.plasmo.com/framework/workflows/submit) and you should be on your way for automated submission!
```

# src/background/index.ts

```ts
import { Action, Setting } from '@/constants' import { storage } from '@/libs/storage' import { getTabByUrl, openWa } from '@/utils/ext' import { sendToContentScript } from '@plasmohq/messaging' import browser from 'webextension-polyfill' browser.runtime.onInstalled.addListener(async (details) => { if (details.reason === 'install') { await storage.set(Setting.LICENSE_KEY, null) await storage.set(Setting.IS_FIRST_TIME, true) await storage.set(Setting.NEED_TO_OPEN, true) await openWa() } }) browser.action.onClicked.addListener(async () => { const waTab = await getTabByUrl('https://web.whatsapp.com/') if (waTab?.active) { sendToContentScript({ name: Action.Window.SHOW_MODAL_MAIN, }) return } await storage.set(Setting.NEED_TO_OPEN, true) await openWa() })
```

# src/background/messages/http.ts

```ts
import http from '@/libs/http' import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { url, method, data, config } = req.body const httpInstance = { POST: () => { return http.post(url, data, config) }, GET: () => { return http.get(url, config) }, } const result = await httpInstance[method]?.() return res.send(result.data) } export default handler
```

# src/background/messages/lemonsqueezy.ts

```ts
import lemonSqueezy from '@/libs/ls' import type { PlasmoMessaging } from '@plasmohq/messaging' import pkg from '../../../package.json' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body try { let response switch (action) { case 'validateLicense': response = await lemonSqueezy.validateLicense(body.licenseKey) break case 'activateLicense': response = await lemonSqueezy.activateLicense(body.licenseKey, pkg.name) break case 'deactivateLicense': response = await lemonSqueezy.deactivateLicense( body.licenseKey, body.instanceId, ) break case 'getCustomer': response = await lemonSqueezy.getCustomer(body.customerId) break default: return res.send({ error: 'Invalid Lemon Squeezy action' }) } res.send(response) } catch (error) { // Tangani error yang mungkin dilempar oleh SDK Lemon Squeezy res.send({ error: true, message: error.message || 'An unknown error occurred.', }) } } export default handler
```

# src/background/messages/resource-page.ts

```ts
import type { PlasmoMessaging } from '@plasmohq/messaging' import browser from 'webextension-polyfill' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const url = browser.runtime.getURL('tabs/resource-page.html') await browser.tabs.create({ url }) return res.send({}) } export default handler
```

# src/components/App.module.css

```css
.tab { &:hover, &[data-active] { background-color: var(--mantine-primary-color-filled-hover); } }
```

# src/components/App.tsx

```tsx
import { Action, Page, PRIMARY_ICON } from '@/constants' import BroadcastListener from '@/features/broadcast/components/Listeners/BroadcastListener' import PageBroadcast from '@/features/broadcast/PageBroadcast' import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import env from '@/utils/env' import { Icon } from '@iconify/react' import { Box, Group, Paper, Stack, Tabs, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import React, { useEffect, useState } from 'react' import { When } from 'react-if' import classes from './App.module.css' import ModalActivation from './Modal/ModalActivation' import ModalFaq from './Modal/ModalFaq' import ModalPricing from './Modal/ModalPricing' import ModalProfile from './Modal/ModalProfile' import ModalUpgrade from './Modal/ModalUpgrade' const App: React.FC = () => { const wa = useWa() const { setIsReady, setGroups, setProfile } = useAppStore() const license = useLicense() const [showModalActivation, modalActivation] = useDisclosure(false) const [showModalFaq, modalFaq] = useDisclosure(false) const [showModalProfile, modalProfile] = useDisclosure(false) const [showModalPricing, modalPricing] = useDisclosure(false) const [activeTab, setActiveTab] = useState<string | null>(null) const [showModalUpgrade, modalUpgradeHandlers] = useDisclosure(false) const [upgradeInfo, setUpgradeInfo] = useState({ featureName: '', featureBenefit: '', }) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.GO_TO_PAGE: setActiveTab(body) break case Action.Window.SHOW_MODAL_UPGRADE: setUpgradeInfo({ featureName: body.featureName, featureBenefit: body.featureBenefit, }) modalUpgradeHandlers.open() break case Action.Window.CLOSE_PAGE: setActiveTab(null) break case Action.Window.SHOW_MODAL_PRICING: modalPricing.toggle() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break case Action.Window.SHOW_MODAL_FAQ: modalFaq.toggle() break case Action.Window.SHOW_MODAL_PROFILE: modalProfile.toggle() break default: break } }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { ;(async function () { if (!wa.isReady) return setTimeout(async () => { const groups = await wa.group.list() setGroups(groups) }, 3000) })() }, [wa.isReady]) const handleChangeTab = (value: string) => { if (Page.UPGRADE === value) { modalPricing.toggle() return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } if (Page.FAQ === value) { modalFaq.toggle() return } if (Page.PROFILE === value) { modalProfile.toggle() return } setActiveTab(value) } const renderTabList = ( <Tabs.List style={{ gap: 10, height: '100%', flexDirection: 'row', background: 'var(--mantine-primary-color-filled)', }} > <Stack justify="space-between"> <Box> <Tabs.Tab value={Page.HOME} className={classes.tab}> <Tooltip label="Broadcast"> <Icon icon={PRIMARY_ICON} color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> <Box> <Tabs.Tab value={Page.FAQ} className={classes.tab}> <Tooltip label="Faqs"> <Icon icon="tabler:world-question" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.UPGRADE} className={classes.tab}> <Tooltip label="Upgrade"> <Icon icon="tabler:crown" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab}> <Tooltip label="Activate"> <Icon icon="tabler:key" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PROFILE} className={classes.tab}> <Tooltip label="Profile"> <Icon icon="tabler:user-square-rounded" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> </Stack> </Tabs.List> ) const renderTabPanel = ( <> <Tabs.Panel value={Page.HOME}> <PageBroadcast /> </Tabs.Panel> </> ) return ( <> <When condition={wa.isReady}> <Group> <Tabs inverted orientation="vertical" variant="pills" radius={0} value={activeTab} onChange={handleChangeTab} style={{ height: '100vh', }} > {renderTabPanel} <Paper shadow="xl">{renderTabList}</Paper> </Tabs> </Group> </When> <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <ModalFaq opened={showModalFaq} onClose={modalFaq.close} /> <ModalProfile opened={showModalProfile} onClose={modalProfile.close} /> <ModalPricing opened={showModalPricing} onClose={modalPricing.close} /> <ModalUpgrade opened={showModalUpgrade} onClose={modalUpgradeHandlers.close} featureName={upgradeInfo.featureName} featureBenefit={upgradeInfo.featureBenefit} /> <BroadcastListener /> </> ) } export default App
```

# src/components/AppMenu.module.css

```css
.tab { &:hover, &[data-active] { background-color: var(--mantine-primary-color-filled-hover); } }
```

# src/components/AppMenu.tsx

```tsx
// src/components/AppMenu.tsx import { Action, Page, Setting } from '@/constants' import BroadcastListener from '@/features/broadcast/components/Listeners/BroadcastListener' import PageBroadcast from '@/features/broadcast/PageBroadcast' import useLicense from '@/hooks/useLicense' import useRuntimeMessage from '@/hooks/useRuntimeMessage' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import env from '@/utils/env' import { Icon } from '@iconify/react' import { Box, Stack, Tabs, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' import classes from './AppMenu.module.css' import Modal from './Modal/Modal' import ModalActivation from './Modal/ModalActivation' import ModalFaq from './Modal/ModalFaq' import ModalPricing from './Modal/ModalPricing' import ModalProfile from './Modal/ModalProfile' import ModalUpgrade from './Modal/ModalUpgrade' const AppMenu: React.FC = () => { const { setIsReady, setActiveChat, setGroups } = useAppStore() const wa = useWa() const license = useLicense() const [showModalMain, modalMain] = useDisclosure(env.isDevelopment()) const [showModalActivation, modalActivation] = useDisclosure(false) const [showModalFaq, modalFaq] = useDisclosure(false) const [showModalProfile, modalProfile] = useDisclosure(false) const [showModalPricing, modalPricing] = useDisclosure(false) const [showModalUpgrade, modalUpgradeHandlers] = useDisclosure(false) const [upgradeInfo, setUpgradeInfo] = useState({ featureName: '', featureBenefit: '', }) const [needToOpen, setNeedToOpen] = useStorage(Setting.NEED_TO_OPEN, false) const [activeTab, setActiveTab] = useState<string | null>(Page.HOME) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.ACTIVE_CHAT: setActiveChat(body) break case Action.Window.GO_TO_PAGE: setActiveTab(body) break case Action.Window.SHOW_MODAL_UPGRADE: setUpgradeInfo({ featureName: body.featureName, featureBenefit: body.featureBenefit, }) modalUpgradeHandlers.open() break case Action.Window.SHOW_MODAL_PRICING: modalPricing.toggle() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break case Action.Window.SHOW_MODAL_FAQ: modalFaq.toggle() break case Action.Window.SHOW_MODAL_PROFILE: modalProfile.toggle() break default: break } }) useRuntimeMessage((message, sender, sendResponse) => { switch (message.name) { case Action.Window.SHOW_MODAL_MAIN: modalMain.toggle() sendResponse() break default: break } // Return true to keep the message channel open for async responses return true }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { if (needToOpen) { modalMain.open() setNeedToOpen(false).then().catch(console.error) } }, [needToOpen]) useEffect(() => { ;(async function () { if (!wa.isReady) return setTimeout(async () => { const groups = await wa.group.list() setGroups(groups) }, 3000) })() }, [wa.isReady]) const handleChangeTab = (value: string | null) => { if (Page.UPGRADE === value) { modalPricing.toggle() return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } if (Page.FAQ === value) { modalFaq.toggle() return } if (Page.PROFILE === value) { modalProfile.toggle() return } setActiveTab(value) } const renderTabList = () => { return ( <Tabs.List style={{ gap: 10, background: 'linear-gradient(180deg, var(--mantine-color-teal-7) 0%, var(--mantine-color-teal-9) 100%)', }} > <Stack justify="space-between" gap={0} style={{ height: '100%' }}> <Box> <Tabs.Tab value={Page.HOME} className={classes.tab}> <Tooltip label="Broadcast" position="left"> <Icon icon="tabler:broadcast" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> </Box> <Box> <Tabs.Tab value={Page.FAQ} className={classes.tab}> <Tooltip label="Faqs"> <Icon icon="tabler:world-question" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.UPGRADE} className={classes.tab}> <Tooltip label="Upgrade"> <Icon icon="tabler:crown" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab}> <Tooltip label="Activate"> <Icon icon="tabler:key" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PROFILE} className={classes.tab}> <Tooltip label="Profile"> <Icon icon="tabler:user-square-rounded" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> </Stack> </Tabs.List> ) } const renderTabPanel = () => { return ( <> <Tabs.Panel value={Page.HOME}> <PageBroadcast /> </Tabs.Panel> </> ) } return ( <> <Modal opened={showModalMain} onClose={modalMain.close} p={0}> <Tabs value={activeTab} onChange={handleChangeTab} variant="pills" orientation="vertical" radius={0} keepMounted={false} > {renderTabList()} {renderTabPanel()} </Tabs> </Modal> <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <ModalFaq opened={showModalFaq} onClose={modalFaq.close} /> <ModalProfile opened={showModalProfile} onClose={modalProfile.close} /> <ModalPricing opened={showModalPricing} onClose={modalPricing.close} /> <ModalUpgrade opened={showModalUpgrade} onClose={modalUpgradeHandlers.close} featureName={upgradeInfo.featureName} featureBenefit={upgradeInfo.featureBenefit} /> <BroadcastListener /> </> ) } export default AppMenu
```

# src/components/Layout/LayoutPage.module.css

```css
.header { border-bottom: 1px solid var(--mantine-color-gray-3); } .footer { border-top: 2px solid var(--mantine-color-gray-3); }
```

# src/components/Layout/LayoutPage.tsx

```tsx
// src/components/Layout/LayoutPage.tsx import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import env from '@/utils/env' import { closePage, goToResourcePage, showModalPricing } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Loader, ScrollArea, Stack, Text, Title, type MantineSpacing, type StyleProp, } from '@mantine/core' import icon from 'data-base64:../../../assets/icon.png' import { When } from 'react-if' import packageJson from '../../../package.json' import classes from './LayoutPage.module.css' interface Props { width?: StyleProp<React.CSSProperties['width']> | null height?: StyleProp<React.CSSProperties['height']> | null p?: StyleProp<MantineSpacing> title?: string | null children: React.ReactNode } const LayoutPage: React.FC<Props> = ({ width = 900, height = 700, p = 'xl', children, title = null, }: Props) => { const wa = useWa() const license = useLicense() const renderBody = () => { return ( <Stack p={'xl'} w={width}> {children} </Stack> ) } return ( <> <Stack w={width} gap={0}> <Group justify="space-between" px={'lg'} py={'xs'} className={classes.header} > <Group gap={6}> <img width={32} height={32} src={icon} style={{ borderRadius: 10, }} /> <Title order={4} ml={2}> {title ? title : packageJson.displayName} </Title> <When condition={env.isDevelopment()}> <Button variant="filled" color="blue" size="xs" radius="md" onClick={goToResourcePage} > RS </Button> </When> </Group> <Group> <When condition={license.isFree() ?? true}> <Button variant="filled" color="yellow" size="xs" radius="md" leftSection={<Icon icon="tabler:crown" fontSize={16} />} onClick={showModalPricing} > Upgrade Now </Button> </When> <ActionIcon variant="transparent" color="red" onClick={closePage}> <Icon icon="tabler:x" /> </ActionIcon> </Group> </Group> {wa.isReady ? ( <ScrollArea h={height}>{renderBody()}</ScrollArea> ) : ( <Center h={height}> <Loader /> </Center> )} </Stack> </> ) } export default LayoutPage
```

# src/components/Modal/Modal.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Card, Paper, type MantineSpacing, type StyleProp, } from '@mantine/core' import React, { type CSSProperties } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void height?: string | number width?: string | number style?: CSSProperties withCloseButton?: boolean | false h?: StyleProp<React.CSSProperties['height']> w?: StyleProp<React.CSSProperties['width']> p?: StyleProp<MantineSpacing> children: React.ReactNode } const Modal: React.FC<Props> = ({ opened, onClose, style = {}, withCloseButton = false, p = 'lg', h, w, children, ...rest }: Props) => { if (!opened) return null return ( <> <div style={{ position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, zIndex: 399, width: '100%', height: '100%', backgroundColor: 'black', opacity: '0.15', }} onClick={onClose} ></div> <Box style={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 1050, ...style, }} {...rest} > <Card shadow={'xs'} p={p} w={w} h={h} radius={'md'}> <When condition={withCloseButton}> <ActionIcon onClick={onClose} color="red" variant="transparent" style={{ position: 'absolute', right: 3, top: 1, }} > <Icon icon="tabler:x" fontSize={16} /> </ActionIcon> <Box mb={'md'} /> </When> {children} </Card> </Box> </> ) } export default Modal
```

# src/components/Modal/ModalActivation.tsx

```tsx
// src/components/Modal/ModalActivation.tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, rem, Stack, Text, TextInput, ThemeIcon, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalActivation: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const form = useForm({ initialValues: defaultValues, validate: { license: (value) => _.isEmpty(value) ? 'A license key is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) const handleOnClose = () => { form.reset() onClose() } const handleSubmit = async () => { const { hasErrors } = form.validate() if (hasErrors) { return } setLoading(true) form.clearErrors() try { const response = await license.activate(form.values.license) if (response.data.error) { form.setFieldError('license', response.data.error.replace(/_/g, ' ')) setLoading(false) return } if (response.data.meta.store_id.toString() !== getStoreId()) { form.setFieldError( 'license', 'This license key is not valid for this product.', ) setLoading(false) return } toast.success('Successfully activated! 🎉') handleOnClose() } catch (err) { console.error('Activation error:', err) form.setFieldError( 'license', 'An unexpected error occurred. Please try again.', ) } finally { setLoading(false) } } return ( <Modal opened={opened} onClose={handleOnClose} w={500} p="xl" withCloseButton > <Stack gap="lg"> <Stack align="center" gap="xs"> <ThemeIcon color="teal" size={rem(60)} radius="xl"> <Icon icon="tabler:key" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> {' '} License Activation{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Enter your license key below to unlock all Pro features.{' '} </Text> </Stack> <Stack> <TextInput label="License Key" placeholder="xxxx-xxxx-xxxx-xxxx" required leftSection={<Icon icon="tabler:key" fontSize={18} />} {...form.getInputProps('license')} /> {/* MODIFIED: Replaced text with more reassuring microcopy. */} <Text size="xs" c="dimmed"> {' '} Your license key validates your purchase, ensuring you receive lifetime access and all future updates.{' '} </Text> </Stack> <Button loading={loading} onClick={handleSubmit} fullWidth size="md" mt="md" leftSection={<Icon icon="tabler:circle-check" fontSize={20} />} > {' '} Activate License{' '} </Button> </Stack> </Modal> ) } export default ModalActivation
```

# src/components/Modal/ModalFaq.tsx

```tsx
// src/components/Modal/ModalFaq.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Accordion, Anchor, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const faqData = [ { icon: 'tabler:key', question: 'Where can I find my license key?', answer: 'You will receive an email from Lemon Squeezy after making a purchase. This email usually contains your purchase details and your license key.', }, { icon: 'tabler:shield-lock', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our priority. This extension does not collect, store, or share any personal data from your WhatsApp account. All processes occur locally on your device.', }, { icon: 'tabler:mail-question', question: 'How can I get more help and support?', answer: 'If you have other questions or need assistance, please feel free to email us at extdotninja@gmail.com. Our team will be happy to help you.', }, ] const ModalFaq: React.FC<Props> = ({ opened, onClose }: Props) => { const handleOnClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleOnClose} withCloseButton w={700}> <Stack> <Stack align="center" gap={4} mb={'xl'}> <Icon icon="tabler:world-question" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> Frequently Asked Questions </Title> </Stack> {/* Accordion */} <Accordion variant="separated" radius="md"> {faqData.map((item) => ( <Accordion.Item key={item.question} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > {/* MODIFIED: Changed the answer to markdown-like bolding for emphasis. */} <Text fw={500} dangerouslySetInnerHTML={{ __html: item.question.replace( /\*\*(.*?)\*\*/g, '<b>$1</b>', ), }} ></Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} ></Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> {/* Contact Support */} <Paper withBorder p="md" shadow="none" radius="md" mt="xl"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still have questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us via email. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Paper> </Stack> </Modal> ) } export default ModalFaq
```

# src/components/Modal/ModalPricing.tsx

```tsx
// src/components/Modal/ModalUpgrade.tsx import Modal from '@/components/Modal/Modal' import plans from '@/config/plans' import { Icon } from '@iconify/react' import { Badge, Box, Button, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const ModalPricing: React.FC<Props> = ({ opened, onClose }) => { return ( <Modal opened={opened} onClose={onClose} w={1000} withCloseButton={false}> <Stack py={'md'}> <Stack align="center" ta="center"> <Title order={1}>Simple, transparent pricing</Title> <Text size={'xl'} c="dimmed"> {' '} Choose the perfect plan for your needs.{' '} </Text> </Stack> <Group justify="center" align="stretch" mt="sm" gap="lg"> {plans.map((plan, index) => ( <Paper key={index} withBorder radius={'lg'} px={50} py={36} style={{ border: !plan.isFree ? '2px solid var(--mantine-color-teal-6)' : undefined, boxShadow: !plan.isFree ? 'var(--mantine-shadow-lg)' : 'var(--mantine-shadow-sm)', position: 'relative', }} > {/* ADDED: Urgency badge for the Pro plan */} {!plan.isFree && ( <Badge variant="gradient" gradient={{ from: 'yellow', to: 'orange' }} size="xl" style={{ position: 'absolute', top: -15, left: '50%', transform: 'translateX(-50%)', }} > Limited Time Offer </Badge> )} <Stack justify="space-between" style={{ height: '100%' }}> <Box ta="center"> <Title order={2}>{plan.name}</Title> <Text mt={4} size="sm"> {' '} {plan.description}{' '} </Text> </Box> {/* MODIFIED: Wrapped price section in a Stack to add the savings badge */} <Stack align="center" gap={4}> <Group gap={8} align={'baseline'} justify="center"> {!plan.isFree && plan.placeholderPrice && ( <Text component="span" c="dimmed" fz={32} fw={500} td="line-through" > {plan.placeholderPrice} </Text> )} <Title order={1} fz={52}> {' '} {plan.price}{' '} </Title> {plan.priceSuffix && ( <Text component="span" c="dimmed" fz="xl" fw={500}> {plan.priceSuffix} </Text> )} </Group> {/* ADDED: Savings badge to explicitly highlight the discount */} {!plan.isFree && ( <Badge variant="filled" size="lg"> Save over 78% </Badge> )} </Stack> <Stack gap="sm"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="sm" align="flex-start"> <ThemeIcon variant="transparent" color={plan.isFree ? 'gray' : 'teal'} size="sm" radius="xl" > {plan.isFree ? ( <Icon icon="tabler:circle-check" fontSize={16} /> ) : ( <Icon icon="tabler:star-filled" fontSize={16} color="orange" /> )} </ThemeIcon> <Text size="sm" fw={500}> {' '} {feature}{' '} </Text> </Group> ))} </Stack> <Box mt="md"> {plan.isFree ? ( <Button size="md" variant="default" fullWidth disabled> {' '} Your Current Plan{' '} </Button> ) : ( <Stack gap="xs"> <Button size="lg" component="a" href={plan.link} target="_blank" fullWidth leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Upgrade now </Button> </Stack> )} </Box> </Stack> </Paper> ))} </Group> </Stack> </Modal> ) } export default ModalPricing
```

# src/components/Modal/ModalProfile.tsx

```tsx
// src/features/profile/PageProfile.tsx import { Setting } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import { showModalActivation, showModalPricing } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' import packageJson from '../../../package.json' import Modal from './Modal' interface Props { opened: boolean onClose: () => void } const ModalProfile: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const { profile, license: licenseData } = useAppStore() const [licenseKey] = useStorage(Setting.LICENSE_KEY) const handleDeactivate = async () => { if ( confirm( 'Are you sure you want to deactivate your license on this device?', ) ) { await license.deactivate() } } const handleUpgrade = () => { showModalPricing() } const handleActivate = () => { showModalActivation() } const maskLicenseKey = (key: string | undefined | null) => { if (!key) return 'N/A' const keyParts = key.split('-') if (keyParts.length > 1) { return `****-****-****-${keyParts[keyParts.length - 1]}` } return '****' + key.slice(-4) } const InfoItem = ({ icon, label, value, }: { icon: string label: string value: React.ReactNode }) => ( <Group wrap="nowrap" gap="lg"> <ThemeIcon variant="light" size={36} radius="md"> <Icon icon={icon} fontSize={20} /> </ThemeIcon> <div> <Text size="xs" c="dimmed"> {label} </Text> <Text size="sm" fw={500}> {value || '-'} </Text> </div> </Group> ) return ( <Modal opened={opened} onClose={onClose} withCloseButton w={700}> <Stack> {/* Account Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Title order={5}>Account Details</Title> <Divider /> <InfoItem icon="tabler:info-circle" label="App Version" value={packageJson.version} /> </Stack> </Card> {/* License Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>License Status</Title> <Badge color={license.isPro() ? 'teal' : 'gray'} size="lg" variant="filled" > {license.isPro() ? 'Pro' : 'Free'} </Badge> </Group> <Divider /> <When condition={license.isPro()}> <Stack my="xs" gap="sm"> <InfoItem icon="tabler:user" label="Licensed To" value={licenseData?.meta.customer_name} /> <InfoItem icon="tabler:mail" label="Email" value={licenseData?.meta.customer_email} /> <InfoItem icon="tabler:key" label="License Key" value={maskLicenseKey(licenseKey)} /> <InfoItem icon="tabler:calendar-event" label="Expires On" value={ licenseData?.license_key.expires_at ? dayjs(licenseData.license_key.expires_at).format( 'DD MMMM YYYY', ) : 'Lifetime' } /> </Stack> </When> <Text size="sm" c="dimmed"> {license.isPro() ? 'Thank you for being a Pro user! You have access to all features.' : 'Upgrade to Pro to unlock all features.'} </Text> <Group justify="flex-end" mt="md"> <When condition={license.isFree()}> <Button onClick={handleUpgrade} color="teal" leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Pro </Button> <Button onClick={handleActivate} variant="outline" leftSection={<Icon icon="tabler:key" fontSize={18} />} > Activate License </Button> </When> <When condition={license.isPro()}> <Button onClick={license.goToMyOrders} variant="outline" leftSection={<Icon icon="tabler:credit-card" fontSize={18} />} > Manage Subscription </Button> <Button onClick={handleDeactivate} color="red" variant="light" leftSection={<Icon icon="tabler:key-off" fontSize={18} />} > Deactivate License </Button> </When> </Group> </Stack> </Card> <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>Data Privacy Guarantee</Title> <ThemeIcon variant="light" color="teal"> <Icon icon="tabler:shield-check" fontSize={20} /> </ThemeIcon> </Group> <Divider /> <Text size="sm" c="dimmed"> All your data is stored only on your computer and is never sent to our servers. You have 100% control over your data. </Text> </Stack> </Card> </Stack> </Modal> ) } export default ModalProfile
```

# src/components/Modal/ModalQRCode.tsx

```tsx
// src/components/Modal/ModalQRCode.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Center, Stack, Title } from '@mantine/core' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import { QRCodeCanvas } from 'qrcode.react' import React, { useRef } from 'react' interface Props { opened: boolean onClose: () => void link: string groupName: string } /** * @component ModalQRCode * @description A modal to display and download a QR code for a given link. */ const ModalQRCode: React.FC<Props> = ({ opened, onClose, link, groupName }) => { const qrCodeRef = useRef<HTMLDivElement>(null) /** * @description Generates a canvas from the QR code element and triggers a download. */ const handleDownload = async () => { if (!qrCodeRef.current) return try { const canvas = await html2canvas(qrCodeRef.current, { scale: 4, // Higher scale for better resolution backgroundColor: 'white', }) canvas.toBlob((blob) => { if (blob) { // Sanitize the group name to create a safe filename const safeFilename = groupName .replace(/[^a-z0-9]/gi, '_') .toLowerCase() FileSaver.saveAs(blob, `whatsapp_group_qr_${safeFilename}.png`) } }) } catch (error) { console.error('Failed to generate QR code image:', error) } } if (!link) return null return ( <Modal opened={opened} onClose={onClose} withCloseButton w={400}> <Stack align="center" p="md"> <Title order={4} ta="center"> QR Code for "{groupName}" </Title> <Center p="md" mt="md" style={{ border: '1px solid var(--mantine-color-gray-3)', borderRadius: 'var(--mantine-radius-md)', }} > <div ref={qrCodeRef} style={{ background: 'white', padding: '16px' }}> <QRCodeCanvas value={link} size={200} level="H" /> </div> </Center> <Button mt="lg" onClick={handleDownload} leftSection={<Icon icon="tabler:download" fontSize={18} />} > Download Image </Button> </Stack> </Modal> ) } export default ModalQRCode
```

# src/components/Modal/ModalSelectContacts.tsx

```tsx
import Modal from '@/components/Modal/Modal' import wa from '@/libs/wa' import { getContactName } from '@/utils/util' import { Icon } from '@iconify/react' import { Avatar, Button, Group, Stack, Text, TextInput, Title, } from '@mantine/core' import { DataTable, type DataTableColumn } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (contacts: any[]) => void } /** * @component ModalSelectContacts * @description A modal for fetching, displaying, and selecting from a user's contact list. */ const ModalSelectContacts: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const [contacts, setContacts] = useState<any[]>([]) const [loading, setLoading] = useState(true) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<any[]>([]) useEffect(() => { if (opened) { const fetchContacts = async () => { setLoading(true) try { const contactList = await wa.contact.list({ onlyMyContacts: true }) setContacts(contactList) } catch (error) { console.error('Failed to fetch contacts:', error) } finally { setLoading(false) } } fetchContacts() } else { // Reset state when modal is closed setContacts([]) setSelectedRecords([]) setSearch('') } }, [opened]) const filteredContacts = useMemo(() => { if (!search) return contacts return contacts.filter( (c) => // -- MODIFIED: Corrected typo from `publictName` to `publicName`. c.publicName?.toLowerCase().includes(search.toLowerCase()) || c.savedName?.toLowerCase().includes(search.toLowerCase()) || c.phoneNumber.includes(search), ) }, [contacts, search]) const handleSubmit = () => { onSubmit(selectedRecords) onClose() } const columns: DataTableColumn<any>[] = [ { accessor: 'name', title: 'Name', // ++ MODIFIED: Added Avatar to display the contact's profile picture. render: (record) => ( <Group gap="sm"> <Avatar src={record.avatar} size="md" radius="xl" /> <Text size="sm">{getContactName(record)}</Text> </Group> ), }, { accessor: 'number', title: 'Number', render: (record) => record.phoneNumber, }, ] return ( <Modal opened={opened} onClose={onClose} w={700} withCloseButton> <Stack h={500} p="sm"> <Title order={4}>Select Contact(s) to Send</Title> <TextInput placeholder="Search contacts by name or number..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={search} onChange={(e) => setSearch(e.currentTarget.value)} disabled={loading} /> <DataTable height="100%" withTableBorder borderRadius="sm" striped highlightOnHover records={filteredContacts} columns={columns} fetching={loading} minHeight={150} noRecordsText="No contacts found" selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} selectionCheckboxProps={{ 'aria-label': 'Select row' }} // ++ ADDED: Provide the 'id' accessor to the table. // This tells the DataTable to use the `id` field of each record object // as its unique identifier, which fixes the selection bug. idAccessor="id" /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedRecords.length === 0} > Add {selectedRecords.length} Contact(s) </Button> </Group> </Stack> </Modal> ) } export default ModalSelectContacts
```

# src/components/Modal/ModalUpgrade.tsx

```tsx
// src/components/Modal/ModalUpgrade.tsx import Modal from '@/components/Modal/Modal' import { showModalPricing } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Group, rem, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void featureName: string featureBenefit: string } /** * English: A modal to inform free users about a Pro feature they've tried to access. * It provides context about the feature's benefits and offers a clear path to upgrade. */ const ModalUpgrade: React.FC<Props> = ({ opened, onClose, featureName, featureBenefit, }) => { const handleUpgrade = () => { showModalPricing() onClose() } return ( <Modal opened={opened} onClose={onClose} w={500} p="xl" withCloseButton> <Stack gap="lg" align="center"> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} size={rem(60)} radius="xl" > <Icon icon="tabler:rocket" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> Unlock: {featureName} </Title> <Text size="sm" ta="center"> {featureBenefit} </Text> <Text size="sm" ta="center" fw={500}> Upgrade to Pro to unlock this feature and many more! </Text> <Stack align="center" gap="xs" mt="md" w="100%"> <Group justify="center" style={{ width: '100%' }}> <Button variant="outline" onClick={onClose}> Maybe Later </Button> <Button onClick={handleUpgrade} leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > Upgrade Now </Button> </Group> </Stack> </Stack> </Modal> ) } export default ModalUpgrade
```

# src/components/Promo/PromoIcon.tsx

```tsx
// English: A simple, professional icon wrapper for branding. // This component is reusable for generating different icon sizes and types. import { Icon } from '@iconify/react' import { ThemeIcon } from '@mantine/core' import React from 'react' interface Props { size: number icon: string } const PromoIcon: React.FC<Props> = ({ size, icon }) => { return ( <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius={100} size={size} > {/* Use the Icon component for dynamic icon rendering */} <Icon icon={icon} style={{ width: '70%', height: '70%', color: 'white' }} /> </ThemeIcon> ) } export default PromoIcon
```

# src/components/Promo/ScreenshotWrapper.tsx

```tsx
// src/components/Promo/ScreenshotWrapper.tsx // English: A reusable wrapper to handle screenshot generation and download logic. // It takes a title, a child component to render, and a filename. import { Icon } from '@iconify/react' import { Button, Card, Group, Stack, Text, Title } from '@mantine/core' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import React, { useRef, useState } from 'react' interface Props { title: string filename: string children: React.ReactNode } const ScreenshotWrapper: React.FC<Props> = ({ title, filename, children }) => { const screenshotRef = useRef<HTMLDivElement>(null) const [isLoading, setIsLoading] = useState(false) const handleDownload = async () => { if (!screenshotRef.current) return setIsLoading(true) try { const canvas = await html2canvas(screenshotRef.current, { scale: 2, // Higher scale for better resolution useCORS: true, // Use component's own background and handle transparency correctly. backgroundColor: null, }) canvas.toBlob((blob) => { if (blob) { FileSaver.saveAs(blob, filename) } }) } catch (error) { console.error('Failed to generate screenshot:', error) } finally { setIsLoading(false) } } return ( <Card withBorder radius="md"> <Stack> <Group justify="space-between"> <Title order={4}>{title}</Title> <Button size="xs" variant="light" onClick={handleDownload} loading={isLoading} leftSection={<Icon icon="tabler:download" fontSize={16} />} > Download </Button> </Group> <div ref={screenshotRef} style={{ alignSelf: 'flex-start', }} > {children} </div> </Stack> </Card> ) } export default ScreenshotWrapper
```

# src/components/Toast/Toast.module.css

```css
@keyframes fadeIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .toast { animation: fadeIn 0.3s ease-out forwards; }
```

# src/components/Toast/Toast.tsx

```tsx
import { type Toast } from '@/stores/toast' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Text, ThemeIcon } from '@mantine/core' import { useEffect } from 'react' import classes from './Toast.module.css' interface ToastProps extends Toast { onClose: () => void } const ToastComponent: React.FC<ToastProps> = ({ id, type, title, message, duration = 2000, onClose, }) => { useEffect(() => { const timer = setTimeout(() => { onClose() }, duration) return () => clearTimeout(timer) }, [id, duration, onClose]) const toastConfig = { success: { icon: 'tabler:check', color: 'teal' }, error: { icon: 'tabler:x', color: 'red' }, info: { icon: 'tabler:info-circle', color: 'blue' }, // ADDED: Configuration for the new 'warning' type. warning: { icon: 'tabler:alert-triangle', color: 'orange' }, } const { icon, color } = toastConfig[type] return ( <Paper shadow="lg" p="sm" radius="md" withBorder className={classes.toast} style={{ minWidth: 350, maxWidth: 400 }} > <Group align="flex-start" wrap="nowrap"> <ThemeIcon color={color} size={36} radius="xl" mt={4}> <Icon icon={icon} fontSize={22} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Text fw={600} size="md"> {title} </Text> <Text size="sm" c="dimmed"> {message} </Text> </Stack> <ActionIcon variant="transparent" color="gray" onClick={onClose}> <Icon icon="tabler:x" /> </ActionIcon> </Group> </Paper> ) } export default ToastComponent
```

# src/components/Toast/ToastProvider.tsx

```tsx
import { useToastStore } from '@/stores/toast' import { Box } from '@mantine/core' import React from 'react' import ToastComponent from './Toast' const ToastProvider: React.FC = () => { const { toasts, removeToast } = useToastStore() return ( <Box style={{ position: 'fixed', top: 20, right: 20, zIndex: 2000, display: 'flex', flexDirection: 'column', gap: '10px', }} > {toasts.map((toast) => ( <ToastComponent key={toast.id} id={toast.id} type={toast.type} title={toast.title} message={toast.message} duration={toast.duration} onClose={() => removeToast(toast.id)} /> ))} </Box> ) } export default ToastProvider
```

# src/config/plans.ts

```ts
// src/config/plans.ts // English: Define a structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // English: Centralized list of features for easy management and comparison export const features: PlanFeature[] = [ { feature: 'Message Backups', free: 'Up to 10 messages', pro: 'Unlimited', }, { feature: 'Backup Media (Images, Videos, Docs)', free: false, pro: true, }, { feature: 'Advanced Date Range Filtering', free: 'Last 7 days only', pro: true, }, { feature: 'Multiple Keyword Filtering', free: '1 keyword', // MODIFIED: Changed from `false` to specify the limit. pro: 'Unlimited', // MODIFIED: Changed from `true` to be more descriptive. }, { feature: 'Export to Multiple Formats', free: 'HTML only', pro: 'PDF, CSV, Excel, JSON, TXT', }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, ] // English: Define plan objects for the pricing cards. // This array structure allows for easy side-by-side comparison in the UI. const plans = [ { name: 'Free', isFree: true, description: 'For basic needs.', price: '$0', priceSuffix: null, // <-- priceSuffix ditambahkan di sini link: '#', features: [ 'Start unlimited chats', 'No need to save contacts', 'Send text messages only', ], }, { name: 'Lifetime', isFree: false, description: 'Pay once, access forever, no monthly fees.', placeholderPrice: '$89', price: '$19', priceSuffix: 'one-time', link: 'https://extdotninja.lemonsqueezy.com/buy/53f1c17b-8636-49cf-b454-ab0ad2700418?logo=0', features: [ 'Start unlimited chats', 'No need to save contacts', 'Send Image, Video, File, Location and Text', 'Save Unlimited Message Templates', 'No monthly fees, No subscription', 'Pay once, access forever', ], }, ] export default plans
```

# src/constants/action.ts

```ts
export const App = { HTTP: 'App.HTPP', AI: 'App.AI', } export const Blocklist = { ALL: 'Blocklist.ALL', BLOCK_CONTACT: 'Blocklist.BLOCK_CONTACT', IS_BLOCKED: 'Blocklist.IS_BLOCKED', UNBLOCK_CONTACT: 'Blocklist.UNBLOCK_CONTACT', } export const Cart = { ADD: 'Cart.ADD', CLEAR: 'Cart.CLEAR', GET: 'Cart.GET', GET_THUMB_FROM_CART: 'Cart.GET_THUMB_FROM_CART', REMOVE: 'Cart.REMOVE', SUBMIT: 'Cart.SUBMIT', UPDATE: 'Cart.UPDATE', } export const Catalog = { ADD_PRODUCT_IMAGE: 'Catalog.ADD_PRODUCT_IMAGE', CHANGE_PRODUCT_IMAGE: 'Catalog.CHANGE_PRODUCT_IMAGE', CREATE_COLLECTION: 'Catalog.CREATE_COLLECTION', CREATE_PRODUCT: 'Catalog.CREATE_PRODUCT', DELETE_COLLECTION: 'Catalog.DELETE_COLLECTION', DELETE_PRODUCT: 'Catalog.DELETE_PRODUCT', EDIT_COLLECTION: 'Catalog.EDIT_COLLECTION', EDIT_PRODUCT: 'Catalog.EDIT_PRODUCT', GET_COLLECTIONS: 'Catalog.GET_COLLECTIONS', GET_MY_CATALOG: 'Catalog.GET_MY_CATALOG', GET_PRODUCT_BY_ID: 'Catalog.GET_PRODUCT_BY_ID', GET_PRODUCTS: 'Catalog.GET_PRODUCTS', REMOVE_PRODUCT_IMAGE: 'Catalog.REMOVE_PRODUCT_IMAGE', SET_PRODUCT_VISIBILITY: 'Catalog.SET_PRODUCT_VISIBILITY', UPDAGE_CART_ENABLED: 'Catalog.UPDAGE_CART_ENABLED', } export const Community = { ADD_SUB_GROUPS: 'Community.ADD_SUB_GROUPS', } export const Chat = { ARCHIVE: 'Chat.ARCHIVE', CAN_MARK_PLAYED: 'Chat.CAN_MARK_PLAYED', CAN_MUTE: 'Chat.CAN_MUTE', CAN_REPLY: 'Chat.CAN_REPLY', CLEAR: 'Chat.CLEAR', CLOSE_CHAT: 'Chat.CLOSE_CHAT', DELETE: 'Chat.DELETE', DELETE_MESSAGE: 'Chat.DELETE_MESSAGE', DOWNLOAD_MEDIA: 'Chat.DOWNLOAD_MEDIA', // ++ ADDED FIND: 'Chat.FIND', FORWARD_MESSAGE: 'Chat.FORWARD_MESSAGE', GET: 'Chat.GET', GET_ACTIVE_CHAT: 'Chat.GET_ACTIVE_CHAT', GET_LAST_SEEN: 'Chat.GET_LAST_SEEN', GET_MESSAGE_ACK: 'Chat.GET_MESSAGE_ACK', GET_MESSAGES: 'Chat.GET_MESSAGES', GET_NOTES: 'Chat.GET_NOTES', GET_PLATFORM_MESSAGE: 'Chat.GET_PLATFORM_MESSAGE', MARK_IS_COMPOSING: 'Chat.MARK_IS_COMPOSING', MARK_IS_PAUSED: 'Chat.MARK_IS_PAUSED', MARK_IS_READ: 'Chat.MARK_IS_READ', MARK_IS_RECORDING: 'Chat.MARK_IS_RECORDING', MARK_IS_UNREAD: 'Chat.MARK_IS_UNREAD', MARK_PLAYED: 'Chat.MARK_PLAYED', MUTE: 'Chat.MUTE', OPEN_CHAT_AT: 'Chat.OPEN_CHAT_AT', OPEN_CHAT_BOTTOM: 'Chat.OPEN_CHAT_BOTTOM', OPEN_CHAT_FROM_UNREAD: 'Chat.OPEN_CHAT_FROM_UNREAD', PIN_MSG: 'Chat.PIN_MSG', LIST: 'Chat.LIST', SET_CHAT_LIST: 'Chat.SET_CHAT_LIST', SET_INPUT_TEXT: 'Chat.SET_INPUT_TEXT', SET_NOTES: 'Chat.SET_NOTES', } export const Contact = { GET: 'Contact.GET', GET_BUSINESS_PROFILE: 'Contact.GET_BUSINESS_PROFILE', GET_COMMON_GROUPS: 'Contact.GET_COMMON_GROUPS', GET_PROFILE_PICTURE_URL: 'Contact.GET_PROFILE_PICTURE_URL', GET_STATUS: 'Contact.GET_STATUS', LIST: 'Contact.LIST', LIST_CONTACT_BY_COUNTRY: 'Contact.LIST_CONTACT_BY_COUNTRY', IS_EXIST: 'Contact.IS_EXIST', REMOVE: 'Contact.REMOVE', } export const Conn = { GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER: 'Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER', GET_AUTH_CODE: 'Conn.GET_AUTH_CODE', GET_PROFILE: 'Conn.GET_PROFILE', GET_MY_USER_ID: 'Conn.GET_MY_USER_ID', } export const Group = { ADD_PARTICIPANTS: 'Group.ADD_PARTICIPANTS', APPROVE: 'Group.APPROVE', LIST: 'Group.LIST', CAN_ADD: 'Group.CAN_ADD', CAN_DEMOTE: 'Group.CAN_DEMOTE', CAN_PROMOTE: 'Group.CAN_PROMOTE', CAN_REMOVE: 'Group.CAN_REMOVE', CREATE: 'Group.CREATE', DEMOTE_PARTICIPANTS: 'Group.DEMOTE_PARTICIPANTS', GET_GROUP_INFO_FROM_INVITE_CODE: 'Group.GET_GROUP_INFO_FROM_INVITE_CODE', GET_GROUP_SIZE_LIMIT: 'Group.GET_GROUP_SIZE_LIMIT', GET_INVITE_LINK: 'Group.GET_INVITE_LINK', GET_MEMBERSHIP_REQUESTS: 'Group.GET_MEMBERSHIP_REQUESTS', GET_PARTICIPANTS: 'Group.GET_PARTICIPANTS', IAM_ADMIN: 'Group.IAM_ADMIN', IAM_MEMBER: 'Group.IAM_MEMBER', IAM_RESTRICTED_MEMBER: 'Group.IAM_RESTRICTED_MEMBER', IAM_SUPER_ADMIN: 'Group.IAM_SUPER_ADMIN', JOIN: 'Group.JOIN', LEAVE: 'Group.LEAVE', PROMOTE_PARTICIPANTS: 'Group.PROMOTE_PARTICIPANTS', REJECT: 'Group.REJECT', REMOVE_ICON: 'Group.REMOVE_ICON', REMOVE_PARTICIPANTS: 'Group.REMOVE_PARTICIPANTS', REVOKE_INVITE_CODE: 'Group.REVOKE_INVITE_CODE', SET_DESCRIPTION: 'Group.SET_DESCRIPTION', SET_ICON: 'Group.SET_ICON', SET_PROPERTY: 'Group.SET_PROPERTY', SET_SUBJECT: 'Group.SET_SUBJECT', } export const Newsletter = { CREATE: 'Newsletter.CREATE', DESTROY: 'Newsletter.DESTROY', EDIT: 'Newsletter.EDIT', GET_SUBSCRIBERS: 'Newsletter.GET_SUBSCRIBERS', MUTE: 'Newsletter.MUTE', } export const Send = { TEXT: 'Send.TEXT', IMAGE: 'Send.IMAGE', LOCATION: 'Send.LOCATION', DOCUMENT: 'Send.DOCUMENT', FILE: 'Send.FILE', POLL: 'Send.POLL', VCARD: 'Send.VCARD', } export const Status = { GET: 'Status.GET', GET_MY_STATUS: 'Status.GET_MY_STATUS', REMOVE: 'Status.REMOVE', SEND_IMAGE_STATUS: 'Status.SEND_IMAGE_STATUS', SEND_READ_STATUS: 'Status.SEND_READ_STATUS', SEND_TEXT_STATUS: 'Status.SEND_TEXT_STATUS', SEND_VIDEO_STATUS: 'Status.SEND_VIDEO_STATUS', UPDATE_PARTICIPANTS: 'Status.UPDATE_PARTICIPANTS', } export const Profile = { EDIT_BUSINESS_PROFILE: 'Profile.EDIT_BUSINESS_PROFILE', GET_MY_PROFILE_NAME: 'Profile.GET_MY_PROFILE_NAME', GET_MY_PROFILE_PICTURE: 'Profile.GET_MY_PROFILE_PICTURE', GET_MY_STATUS: 'Profile.GET_MY_STATUS', IS_BUSINESS: 'Profile.IS_BUSINESS', REMOVE_MY_PROFILE_PICTURE: 'Profile.REMOVE_MY_PROFILE_PICTURE', SET_MY_PROFILE_NAME: 'Profile.SET_MY_PROFILE_NAME', SET_MY_PROFILE_PICTURE: 'Profile.SET_MY_PROFILE_PICTURE', SET_MY_STATUS: 'Profile.SET_MY_STATUS', } export const AI = { REWRITE_MESSAGE: 'AI.REWRITE_MESSAGE', } export const Window = { READY: 'Window.READY', ACTIVE_CHAT: 'Window.ACTIVE_CHAT', GO_TO_PAGE: 'Window.GO_TO_PAGE', CLOSE_PAGE: 'Window.CLOSE_PAGE', SHOW_MODAL_MAIN: 'Window.SHOW_MODAL_MAIN', SHOW_MODAL_PRICING: 'Window.SHOW_MODAL_PRICING', SHOW_MODAL_UPGRADE: 'Window.SHOW_MODAL_UPGRADE', SHOW_MODAL_ACTIVATION: 'Window.SHOW_MODAL_ACTIVATION', SHOW_MODAL_PROFILE: 'Window.SHOW_MODAL_PROFILE', SHOW_MODAL_FAQ: 'Window.SHOW_MODAL_FAQ', SEND_BROADCAST: 'Window.SEND_BROADCAST', }
```

# src/constants/index.ts

```ts
// src/constants/index.ts export * as Action from './action' export * as Setting from './setting' export const PRIMARY_ICON = 'tabler:message-2-down' export const Status = { SUCCESS: 'SUCCESS', IDLE: 'IDLE', PENDING: 'PENDING', FAILED: 'FAILED', RUNNING: 'RUNNING', SCHEDULER: 'SCHEDULER', CANCELLED: 'CANCELLED', PAUSED: 'PAUSED', DRAFT: 'DRAFT', POSTED: 'POSTED', } export const Page = { HOME: 'Page.HOME', DIRECT_CHAT: 'Page.DIRECT_CHAT', PRIVACY: 'Page.PRIVACY', EXPORT: 'Page.EXPORT', FAQ: 'Page.FAQ', UPGRADE: 'Page.UPGRADE', ACTIVATE: 'Page.ACTIVATE', PROFILE: 'Page.PROFILE', } export const Account = { BUSINESS: 'BUSINESS', PERSONAL: 'PERSONAL', } export const Message = { TEXT: 'TEXT', MEDIA: 'MEDIA', IMAGE: 'IMAGE', VIDEO: 'VIDEO', AUDIO: 'AUDIO', FILE: 'FILE', LOCATION: 'LOCATION', VCARD: 'VCARD', BUTTON: 'BUTTON', LIST: 'LIST', POLL: 'POLL', } export const Media = { BROADCAST: 'BROADCAST', BROADCAST_TEMPLATE: 'BROADCAST_TEMPLATE', STATUS_CONTENT: 'STATUS_CONTENT', QUICK_REPLY: 'QUICK_REPLY', } export const ContactType = { ALL: 'CONTACT_TYPE_ALL', SAVED_CONTACTS: 'CONTACT_TYPE_SAVED_CONTACTS', UNSAVED_CONTACTS: 'CONTACT_TYPE_UNSAVED_CONTACTS', } export const AccountType = { ALL: 'ACCOUNT_TYPE_ALL', PERSONAL: 'ACCOUNT_TYPE_PERSONAL', BUSINESS: 'ACCOUNT_TYPE_BUSINESS', } export const MessageType = { ALL: 'MESSAGE_TYPE_ALL', HAVE_UNREAD_MESSAGES: 'MESSAGE_TYPE_HAVE_UNREAD_MESSAGES', NO_UNREAD_MESSAGES: 'MESSAGE_TYPE_NO_UNREAD_MESSAGES', } export const SaveAs = { CSV: 'SAVE_AS_CSV', EXCEL: 'SAVE_AS_EXCEL', PDF: 'SAVE_AS_PDF', JSON: 'SAVE_AS_JSON', MARKDOWN: 'SAVE_AS_MARKDOWN', HTML: 'SAVE_AS_HTML', VCARD: 'SAVE_AS_VCARD', }
```

# src/constants/setting.ts

```ts
// src/constants/setting.ts export const LICENSE_KEY = 'SETTING_LICENSE_KEY' export const LICENSE_INSTANCE_ID = 'SETTING_LICENSE_INSTANCE_ID' export const LICENSE_DATA_CACHE = 'SETTING_LICENSE_DATA_CACHE' export const IS_FIRST_TIME = 'SETTING_IS_FIRST_TIME' export const NEED_TO_OPEN = 'SETTING_NEED_TO_OPEN' export const HAS_ACKNOWLEDGED_BROADCAST_WARNING = 'SETTING.HAS_ACKNOWLEDGED_BROADCAST_WARNING' export const BLUR_PROFILE_PICTURES = 'SETTING.BLUR_PROFILE_PICTURES' export const BLUR_MESSAGES = 'SETTING.BLUR_MESSAGES' export const BLUR_USER_GROUP_NAMES = 'SETTING.BLUR_USER_GROUP_NAMES' export const BLUR_RECENT_MESSAGES = 'SETTING.BLUR_RECENT_MESSAGES' export const EXPORT_COLUMNS = 'SETTING_EXPORT_COLUMNS' // MODIFIED: Removed SIGNATURE_ENABLED and SIGNATURE_TEXT export const SPINTAX_TIP_DISMISSED = 'SETTING.SPINTAX_TIP_DISMISSED'
```

# src/contents/inject-script.ts

```ts
import { Action } from '@/constants' import wa from '@/libs/wa' import { initInjectScriptRelays } from '@/relays' import { postMessage } from '@/utils/util' import type { PlasmoCSConfig } from 'plasmo' export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], world: 'MAIN', } initInjectScriptRelays() wa.on.ready(() => { setTimeout(() => { onReady() }, 2000) }) const onReady = () => { setTimeout(() => { window.postMessage({ action: Action.Window.READY, body: {}, }) WPP.on('chat.active_chat', (chat) => { const body = { name: chat.contact?.__x_pushname || chat.contact?.__x_verifiedName || chat.name || chat.formattedTitle, number: chat.id.user, formattedNumber: chat.id._serialized, isUser: chat.id._serialized.includes('@c.us'), isGroup: chat.id._serialized.includes('@g.us'), isBusiness: chat.contact?.__x_isBusiness, } postMessage(Action.Window.ACTIVE_CHAT, body) }) }, 1000) }
```

# src/contents/main.tsx

```tsx
import App from '@/components/App' import AppMenu from '@/components/AppMenu' import ToastProvider from '@/components/Toast/ToastProvider' import theme from '@/libs/theme' import style from '@/utils/style' import { MantineProvider } from '@mantine/core' import type { PlasmoCSConfig, PlasmoGetShadowHostId } from 'plasmo' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-main` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Main = () => { return ( <> <MantineProvider theme={theme} //@ts-ignore cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-main') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <App /> <ToastProvider /> </MantineProvider> </> ) } export default Main
```

# src/features/broadcast/components/Datatable/BroadcastColumns.tsx

```tsx
// src/features/broadcast/components/Datatable/BroadcastColumns.tsx import { Message, Status } from '@/constants' import type { Broadcast } from '@/libs/db' import { truncate } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Box, Group, Menu, Progress, Stack, Text, Tooltip, } from '@mantine/core' import dayjs from 'dayjs' import relativeTime from 'dayjs/plugin/relativeTime' import type { DataTableColumn } from 'mantine-datatable' import React from 'react' import MessageStatus from './MessageStatus' import MessageType from './MessageType' dayjs.extend(relativeTime) interface ColumnActions { onViewDetails: (broadcast: Broadcast) => void onClone: (broadcast: Broadcast) => void onExport: (broadcast: Broadcast, format: string) => void onCancel: (broadcastId: number) => void onDelete: (broadcast: Broadcast) => void onEditSchedule: (broadcast: Broadcast) => void } type BroadcastStatsMap = Map< number, { total: number success: number pending: number running: number failed: number scheduled: number cancelled: number firstError?: string scheduledAt?: Date } > const renderMessagePreview = (broadcast: Broadcast) => { const { type, message } = broadcast if (!message) return 'N/A' switch (type) { case Message.TEXT: return typeof message === 'string' ? message : JSON.stringify(message) case Message.IMAGE: case Message.VIDEO: case Message.FILE: return (message as any).caption || `Media File (${type})` case Message.LOCATION: return (message as any).name || (message as any).address || 'Location' case Message.POLL: return (message as any).name || 'Poll' case Message.VCARD: return 'Contact Card' default: return `Unsupported type: ${type}` } } export const getBroadcastColumns = ( actions: ColumnActions, broadcastStatsMap: BroadcastStatsMap, ): DataTableColumn<Broadcast>[] => { const defaultStats = { total: 0, success: 0, pending: 0, running: 0, failed: 0, scheduled: 0, cancelled: 0, } return [ { accessor: 'name', title: 'Name', sortable: true, width: 150, render: (broadcast) => <Text truncate>{broadcast.name || 'N/A'}</Text>, }, { accessor: 'type', title: 'Type', render: (broadcast) => <MessageType type={broadcast.type} />, width: 130, }, { accessor: 'message', title: 'Content Preview', render: (broadcast) => { const fullMessage = renderMessagePreview(broadcast) return ( <Tooltip label={fullMessage} multiline w={220} withArrow position="top-start" disabled={fullMessage.length <= 50} > <Text truncate>{truncate(fullMessage, 50)}</Text> </Tooltip> ) }, ellipsis: true, }, { accessor: 'tags', title: 'Tags', width: 150, render: (broadcast) => { return broadcast.tags && broadcast.tags.length > 0 ? ( <Group gap={4}> {broadcast.tags.map((tag) => ( <Badge key={tag} variant="light" size="sm"> {tag} </Badge> ))} </Group> ) : ( <Text c="dimmed" fs="italic" size="xs"> No tags </Text> ) }, }, { accessor: 'status', title: 'Status', render: (broadcast) => { const stats = broadcastStatsMap.get(broadcast.id) let overallError = broadcast.status === Status.FAILED ? 'Broadcast failed' : undefined if (!overallError && stats?.failed > 0) { overallError = stats.firstError || 'Some recipients failed' } let overrideText: string | null = null let tooltip: string | null = null if (broadcast.status === Status.PAUSED) { if (broadcast.resumeAt) { overrideText = 'Paused (Batching)' tooltip = `Resuming ${dayjs(broadcast.resumeAt).fromNow()}` } else if (broadcast.smartPauseEnabled) { overrideText = 'Paused (Working Hours)' tooltip = `Will resume at ${broadcast.smartPauseStart} on the next working day.` } } return ( <MessageStatus status={broadcast.status} error={overallError} overrideText={overrideText} tooltip={tooltip} /> ) }, width: 180, sortable: true, }, { accessor: 'stats', title: 'Recipients', render: (broadcast) => { const stats: any = broadcastStatsMap.get(broadcast.id) || defaultStats const isProcessing = broadcast.status === Status.RUNNING const processed = stats.success + stats.failed + stats.cancelled const progress = stats.total > 0 ? Math.round((processed / stats.total) * 100) : 0 return ( <Stack gap={4}> {isProcessing && stats.total > 0 && ( <Box mb={4}> <Text size="xs" fw={500}> Sending: {processed} of {stats.total} </Text> <Progress value={progress} size="sm" striped animated mt={2} /> </Box> )} <Text size="xs">Total: {stats.total}</Text> {stats.success > 0 && ( <Text size="xs" c="green"> Success: {stats.success} </Text> )} {(stats.pending > 0 || stats.running > 0) && ( <Text size="xs" c="yellow"> In Progress: {stats.pending + stats.running} </Text> )} {stats.failed > 0 && ( <Text size="xs" c="red"> Failed: {stats.failed} </Text> )} {stats.cancelled > 0 && ( <Text size="xs" c="gray"> Cancelled: {stats.cancelled} </Text> )} {stats.scheduled > 0 && ( <Text size="xs" c="blue"> Scheduled: {stats.scheduled} </Text> )} {stats.scheduledAt && ( <Text size="xs" c="dimmed"> On: {dayjs(stats.scheduledAt).format('DD MMM, HH:mm')} </Text> )} </Stack> ) }, width: 150, }, { accessor: 'actions', title: <Box mr="xs">Actions</Box>, textAlign: 'right', width: '0%', render: (broadcast) => { const isFinished = [ Status.SUCCESS, Status.FAILED, Status.CANCELLED, ].includes(broadcast.status) const isRunning = [Status.PENDING, Status.RUNNING].includes( broadcast.status, ) const isScheduled = broadcast.status === Status.SCHEDULER return ( <Group gap={4} justify="flex-end" wrap="nowrap"> <Tooltip label="View Details"> <ActionIcon variant="subtle" color="blue" onClick={() => actions.onViewDetails(broadcast)} > <Icon icon="tabler:eye" /> </ActionIcon> </Tooltip> {!isRunning && ( <Tooltip label="Clone Broadcast"> <ActionIcon variant="subtle" color="teal" onClick={() => actions.onClone(broadcast)} > <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> )} {isScheduled && ( <Tooltip label="Edit Schedule"> <ActionIcon variant="subtle" color="cyan" onClick={() => actions.onEditSchedule(broadcast)} > <Icon icon="tabler:clock-edit" /> </ActionIcon> </Tooltip> )} <Menu shadow="md" position="left" withArrow> <Menu.Target> <ActionIcon variant="subtle"> <Icon icon="tabler:download" /> </ActionIcon> </Menu.Target> <Menu.Dropdown> <Menu.Item onClick={() => actions.onExport(broadcast, 'csv')}> <Text>Export as CSV</Text> </Menu.Item> <Menu.Item onClick={() => actions.onExport(broadcast, 'xlsx')}> <Text>Export as XLSX</Text> </Menu.Item> </Menu.Dropdown> </Menu> {(isRunning || isScheduled) && ( <Tooltip label="Cancel Broadcast"> <ActionIcon variant="subtle" color="orange" onClick={() => actions.onCancel(broadcast.id)} > <Icon icon="tabler:player-stop" /> </ActionIcon> </Tooltip> )} {isFinished && ( <Tooltip label="Delete Broadcast"> <ActionIcon variant="subtle" color="red" onClick={() => actions.onDelete(broadcast)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> )} </Group> ) }, }, ] }
```

# src/features/broadcast/components/Datatable/MessageStatus.tsx

```tsx
// src/features/broadcast/components/Datatable/MessageStatus.tsx import { Status } from '@/constants' import { Icon } from '@iconify/react' import { Group, Loader, Text, Tooltip } from '@mantine/core' import React from 'react' interface Props { status: string error?: string | null overrideText?: string | null tooltip?: string | null } const MessageStatus: React.FC<Props> = ({ status, error = null, overrideText = null, tooltip = null, }: Props) => { const statusConfig: { [key: string]: { color: string; icon: React.ReactNode; text: string } } = { [Status.RUNNING]: { color: 'yellow', icon: <Loader color="yellow" size={16} />, text: 'Running', }, [Status.PENDING]: { color: 'blue', icon: <Icon icon="tabler:clock" fontSize={18} />, text: 'Pending', }, [Status.SUCCESS]: { color: 'green', icon: <Icon icon="tabler:checks" fontSize={18} />, text: 'Done', }, [Status.CANCELLED]: { color: 'gray', icon: <Icon icon="tabler:cancel" fontSize={18} />, text: 'Cancelled', }, [Status.FAILED]: { color: 'red', icon: <Icon icon="tabler:x" fontSize={18} />, text: 'Failed', }, [Status.PAUSED]: { color: 'gray', icon: <Icon icon="tabler:player-pause" fontSize={18} />, text: 'Paused', }, [Status.SCHEDULER]: { color: 'cyan', icon: <Icon icon="tabler:calendar-time" fontSize={18} />, text: 'Scheduled', }, } const config = statusConfig[status] if (!config) { return <Text size="sm">{status}</Text> } const displayText = overrideText || config.text const content = ( <Group gap="xs" wrap="nowrap" align="center"> <Group gap={4} wrap="nowrap" align="center"> {config.icon} <Text size="sm" c={config.color} fw={500}> {displayText} </Text> </Group> </Group> ) const tooltipContent = error || tooltip return tooltipContent ? ( <Tooltip label={tooltipContent} position="top-start" multiline w={220} withArrow > {content} </Tooltip> ) : ( content ) } export default MessageStatus
```

# src/features/broadcast/components/Datatable/MessageType.tsx

```tsx
import { Message } from '@/constants' import { Icon } from '@iconify/react' import { Group, Text } from '@mantine/core' import _ from 'lodash' import React from 'react' interface Props { type: string } const MessageType: React.FC<Props> = ({ type }: Props) => { const icons = { [Message.TEXT]: 'tabler:text-size', [Message.MEDIA]: 'tabler:library-photo', [Message.BUTTON]: 'tabler:hand-finger', [Message.LIST]: 'tabler:list', [Message.LOCATION]: 'tabler:map-pin', [Message.POLL]: 'tabler:list-details', [Message.VCARD]: 'tabler:user-square', } const icon = icons[type] ?? 'tabler:text-size' return ( <Group gap={4}> <Icon icon={icon} fontSize={18} /> <Text>{_.startCase(type?.toLowerCase())}</Text> </Group> ) } export default MessageType
```

# src/features/broadcast/components/Excel/ExcelUploader.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Button, FileInput, Group, ScrollArea, Stack, Table, Text, } from '@mantine/core' import FileSaver from 'file-saver' import React, { useState } from 'react' import * as XLSX from 'xlsx' interface Props { onConfirm: (data: any[]) => void onClose: () => void } /** * @component ExcelUploader * @description A generic component for uploading, parsing, previewing, and confirming Excel data. * It encapsulates the core logic previously duplicated in ModalSourceExcel and ExcelUploadPopover. */ const ExcelUploader: React.FC<Props> = ({ onConfirm, onClose }) => { const [parsedData, setParsedData] = useState<any[]>([]) const [excelFile, setExcelFile] = useState<File | null>(null) // Function to download a sample Excel template const handleDownloadSample = () => { const sampleData = [{ number: '6281234567890', name: 'John Doe' }] const worksheet = XLSX.utils.json_to_sheet(sampleData) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Contacts') const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array', }) const data = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8', }) FileSaver.saveAs(data, 'sample_contacts.xlsx') } // Handles file selection and parsing const handleFileChange = (file: File | null) => { if (!file) { setParsedData([]) setExcelFile(null) return } setExcelFile(file) const reader = new FileReader() reader.onload = (event) => { const data = new Uint8Array(event.target?.result as ArrayBuffer) const workbook = XLSX.read(data, { type: 'array' }) const sheetName = workbook.SheetNames[0] const worksheet = workbook.Sheets[sheetName] const json = XLSX.utils.sheet_to_json(worksheet) setParsedData(json) } reader.readAsArrayBuffer(file) } // Removes a specific row from the preview data const handleDeleteRow = (indexToRemove: number) => { setParsedData((currentData) => currentData.filter((_, index) => index !== indexToRemove), ) } // Confirms the upload, passes the data to the parent, and calls the parent's close handler const handleConfirmUpload = () => { onConfirm(parsedData) onClose() } // Resets state and calls the parent's close handler const handleClose = () => { setParsedData([]) setExcelFile(null) onClose() } return ( <> <Text size="xs" c="dimmed" mt={-10}> File must contain a 'number' column. </Text> <Group justify="center"> <Button variant="light" size="xs" onClick={handleDownloadSample} leftSection={<Icon icon="tabler:download" />} > Download Sample </Button> </Group> <FileInput placeholder="Choose file" onChange={handleFileChange} accept=".xlsx, .xls, .csv" clearable value={excelFile} /> {parsedData.length > 0 && ( <> <Text size="sm">Data Preview:</Text> <ScrollArea h={150}> <Table striped highlightOnHover withTableBorder withColumnBorders fz="xs" > <Table.Thead> <Table.Tr> <Table.Th>Number</Table.Th> <Table.Th>Name</Table.Th> <Table.Th></Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {parsedData.map((row, index) => ( <Table.Tr key={index}> <Table.Td>{row.number}</Table.Td> <Table.Td>{row.name}</Table.Td> <Table.Td> <ActionIcon color="red" variant="transparent" onClick={() => handleDeleteRow(index)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </ScrollArea> </> )} <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleConfirmUpload} disabled={parsedData.length === 0} > Add {parsedData.length} Numbers </Button> </Group> </> ) } export default ExcelUploader
```

# src/features/broadcast/components/Excel/ExcelUploadPopover.tsx

```tsx
import { Icon } from '@iconify/react' import { Button, Popover, Stack, Text, Tooltip } from '@mantine/core' import React, { useState } from 'react' import ExcelUploader from './ExcelUploader' interface Props { onConfirm: (data: any[]) => void } /** * @component ExcelUploadPopover * @description A popover component for Excel uploads, now refactored to use the generic ExcelUploader. * It acts as a lightweight wrapper, placing the uploader logic inside a Mantine Popover. */ const ExcelUploadPopover: React.FC<Props> = ({ onConfirm }) => { const [popoverOpened, setPopoverOpened] = useState(false) return ( <Popover opened={popoverOpened} onChange={setPopoverOpened} withArrow shadow="md" position="bottom-end" > <Popover.Target> <Tooltip label="Upload excel" position="top"> <Button size={'compact-sm'} variant="outline" onClick={() => setPopoverOpened((o) => !o)} > <Icon icon={'tabler:file-type-xls'} fontSize={24} /> </Button> </Tooltip> </Popover.Target> <Popover.Dropdown w={350}> <Stack> <Text size="sm" fw={500}> Upload Excel File </Text> <ExcelUploader onConfirm={onConfirm} onClose={() => setPopoverOpened(false)} /> </Stack> </Popover.Dropdown> </Popover> ) } export default ExcelUploadPopover
```

# src/features/broadcast/components/Form/AntiBlockingSettings.tsx

```tsx
// src/features/broadcast/components/Form/AntiBlockingSettings.tsx import useLicense from '@/hooks/useLicense' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Grid, Group, NumberInput, Stack, Switch, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' import InputTyping from '../Input/InputTyping' import SmartPauseSettings from './SmartPauseSettings' interface Props { form: UseFormReturnType<any> } /** * @component AntiBlockingSettings * @description A sub-component for ModalCreateBroadcast that groups all anti-blocking settings. * Pro features like Warm-up Mode and Batch Sending are now disabled for free users. */ const AntiBlockingSettings: React.FC<Props> = ({ form }) => { const license = useLicense() const handleProFeatureClick = ( featureName: string, featureBenefit: string, ) => { if (license.isFree()) { showModalUpgrade(featureName, featureBenefit) } } return ( <Stack gap="lg" pt="sm"> <Grid> <Grid.Col span={{ base: 12, md: 6 }}> <NumberInput label={ <Group gap={4} wrap="nowrap"> <Text size="sm" fw={500}> Min Delay (sec) </Text> <Tooltip label="Pausing between messages mimics human behavior and significantly reduces the risk of your account being flagged as spam by WhatsApp." position="top-start" multiline withArrow w={300} > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } description="Minimum time between messages." size="sm" min={3} {...form.getInputProps('delayMin')} /> </Grid.Col> <Grid.Col span={{ base: 12, md: 6 }}> <NumberInput label="Max Delay (sec)" description="Maximum time between messages." min={5} size="sm" {...form.getInputProps('delayMax')} /> </Grid.Col> </Grid> <Grid> <Grid.Col span={{ base: 12, md: 6 }}> <InputTyping form={form} /> </Grid.Col> <Grid.Col span={{ base: 12, md: 6 }}> <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Only send to valid numbers</Text> <Tooltip label="Before sending, check if each number is a valid WhatsApp account and reduce the risk of being flagged." position="top-start" multiline w={300} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('validateNumbers', { type: 'checkbox' })} /> </Grid.Col> </Grid> <Grid> {/* MODIFIED: Warm-up Mode Toggle */} <Grid.Col span={{ base: 12, md: 6 }}> <div> <Switch label={ <Group gap={8} wrap="nowrap"> <Text fw={500}>Warm-up Mode</Text> <Tooltip label="Automatically sends the first 20 messages with a longer, more random delay to simulate natural activity and enhance account safety." position="top-start" multiline w={300} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('warmupMode.enabled', { type: 'checkbox', })} /> </div> </Grid.Col> <Grid.Col span={{ base: 12, md: 6 }}> <Stack> <div onClick={() => handleProFeatureClick( 'Batch Sending', 'Splitting a large broadcast into smaller batches with a pause in between simulates human behavior, reducing the risk of being flagged for spam.', ) } style={{ cursor: license.isFree() ? 'not-allowed' : 'pointer' }} > <Switch label={ <Group gap={8} wrap="nowrap"> <Text fw={500}>Batch sending</Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="sm"> Pro </Badge> )} <Tooltip label="Splitting a large broadcast into smaller batches with a pause in between simulates human behavior, reducing the risk of being flagged for spam." position="top-start" multiline w={300} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('batch.enabled', { type: 'checkbox' })} /> </div> <When condition={form.values.batch.enabled}> <Group grow align="flex-start" style={{ opacity: license.isFree() ? 0.5 : 1 }} > <NumberInput label="Messages per batch" min={1} {...form.getInputProps('batch.size')} /> <NumberInput label="Wait time (minutes)" min={1} {...form.getInputProps('batch.delay')} /> </Group> {form.errors['batch'] && ( <Text c="red" size="xs"> {form.errors['batch']} </Text> )} </When> </Stack> </Grid.Col> </Grid> </Stack> ) } export default AntiBlockingSettings
```

# src/features/broadcast/components/Form/BroadcastActions.tsx

```tsx
// src/features/broadcast/components/Form/BroadcastActions.tsx import { Icon } from '@iconify/react' import { Button, Group } from '@mantine/core' import { isFuture } from 'date-fns' import React from 'react' interface Props { onSend: () => void isScheduled: boolean scheduledAt: Date | null } /** * @component BroadcastActions * @description A sub-component for ModalCreateBroadcast that holds the main action buttons. * It displays a dynamic "Send/Schedule Broadcast" button. */ const BroadcastActions: React.FC<Props> = ({ onSend, isScheduled, scheduledAt, }: Props) => { const isScheduledForFuture = isScheduled && scheduledAt && isFuture(new Date(scheduledAt)) return ( <Group justify="flex-end" mt="lg"> <Button leftSection={<Icon icon="tabler:send" fontSize={18} />} onClick={onSend} > {isScheduledForFuture ? 'Schedule Broadcast' : 'Send Broadcast'} </Button> </Group> ) } export default BroadcastActions
```

# src/features/broadcast/components/Form/BroadcastScheduler.tsx

```tsx
import { Icon } from '@iconify/react' import { Group, Stack, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputSendLater from '../Input/InputSendLater' interface Props { form: UseFormReturnType<any> } /** * @component BroadcastScheduler * @description A sub-component for ModalCreateBroadcast that handles scheduling. * It contains the "Send Later" switch and date/time picker. */ const BroadcastScheduler: React.FC<Props> = ({ form }) => { return ( <Stack> <InputSendLater form={form} /> </Stack> ) } export default BroadcastScheduler
```

# src/features/broadcast/components/Form/RecipientManager.tsx

```tsx
// src/features/broadcast/components/Form/RecipientManager.tsx import useLicense from '@/hooks/useLicense' import { Icon } from '@iconify/react' import { Button, Group, Stack, Text, Tooltip } from '@mantine/core' import React from 'react' interface Props { recipientCount: number error?: string | any onClear: () => void onManage: () => void onLoad: () => void } /** * @component RecipientManager * @description A sub-component for ModalCreateBroadcast that handles the UI for managing recipients. * It displays the recipient count and provides buttons to clear or manage the recipient list. */ const RecipientManager: React.FC<Props> = ({ recipientCount, error, onClear, onManage, onLoad, }) => { const license = useLicense() // The Manage button is defined once to avoid code duplication. const manageButton = ( <Button variant="outline" size="compact-sm" onClick={onManage} leftSection={<Icon icon="tabler:users-plus" fontSize={16} />} > Manage </Button> ) return ( <Stack gap="xs"> <Group justify="space-between"> <Text fw={500}>Recipients ({recipientCount})</Text> <Group> <Button variant="outline" color="red" size="compact-sm" onClick={onClear} disabled={recipientCount === 0} leftSection={<Icon icon="tabler:x" fontSize={16} />} > Clear </Button> <Button variant="outline" size="compact-sm" onClick={onLoad} leftSection={<Icon icon="tabler:database-import" fontSize={16} />} > Load </Button> {/* MODIFIED: Conditionally wrap the Manage button with a Tooltip for free users */} {license.isFree() ? ( <Tooltip label="Free plan is limited to 5 recipients. Upgrade to Pro for unlimited contacts!" position="top" withArrow > {manageButton} </Tooltip> ) : ( manageButton )} </Group> </Group> {error && ( <Text c="red" size="sm"> {error} </Text> )} </Stack> ) } export default RecipientManager
```

# src/features/broadcast/components/Form/SmartPauseSettings.tsx

```tsx
// src/features/broadcast/components/Form/SmartPauseSettings.tsx import useLicense from '@/hooks/useLicense' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Group, Stack, Switch, Text, Tooltip } from '@mantine/core' import { TimeInput } from '@mantine/dates' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } /** * @component SmartPauseSettings * @description A sub-component for managing Smart Pause settings, allowing users * to define working hours during which broadcasts can be sent. */ const SmartPauseSettings: React.FC<Props> = ({ form }) => { const license = useLicense() return ( <Stack onClick={() => { if (license.isFree()) { showModalUpgrade( 'Smart Pause', 'Automatically pause the broadcast outside of specified hours and resume the next day. This helps simulate human behavior and avoid sending messages at inappropriate times.', ) } }} > <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Smart Pause</Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="sm"> Pro </Badge> )} <Tooltip label="Automatically pause the broadcast outside of specified hours and resume the next day. This helps simulate human behavior and avoid sending messages at inappropriate times." position="top-start" multiline w={300} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('smartPause.enabled', { type: 'checkbox' })} /> <When condition={form.values.smartPause.enabled}> <Stack gap={4}> <Group grow align="flex-start"> <TimeInput label="Send between" description="Start time" {...form.getInputProps('smartPause.start')} /> <TimeInput label="And" description="End time" {...form.getInputProps('smartPause.end')} /> </Group> {form.errors['smartPause'] && ( <Text c="red" size="xs"> {' '} {form.errors['smartPause']}{' '} </Text> )} </Stack> </When> </Stack> ) } export default SmartPauseSettings
```

# src/features/broadcast/components/Input/InputContact.tsx

```tsx
import { Group, TagsInput, Text, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import ExcelUploadPopover from '../../../features/broadcast/components/Excel/ExcelUploadPopover' interface Props { form: UseFormReturnType<any> } const InputContact: React.FC<Props> = ({ form }) => { const handleAddNumbers = (newNumbers: (string | number)[]) => { const currentValues = form.values.numbers const uniqueNumbers = [ ...new Set([...currentValues, ...newNumbers.map(String)]), ] form.setFieldValue('numbers', uniqueNumbers) } // This function is passed to the ExcelUploadPopover to handle the data once confirmed. const handleConfirmExcelUpload = (parsedData: any[]) => { const newNumbers = parsedData .map((item) => item.number?.toString()) .filter(Boolean) if (newNumbers.length > 0) { handleAddNumbers(newNumbers) } } return ( <> <TagsInput label={ <Group justify="space-between" w={687}> <Text fw={500}> Numbers{' '} {form.values.numbers.length ? `(${form.values.numbers.length})` : ''} </Text> <Group mb={6}> <ExcelUploadPopover onConfirm={handleConfirmExcelUpload} /> </Group> </Group> } placeholder="Number with country code, Press Enter to submit" {...form.getInputProps('numbers')} clearable /> </> ) } export default InputContact
```

# src/features/broadcast/components/Input/InputSendLater.tsx

```tsx
// src/features/broadcast/components/Input/InputSendLater.tsx import useLicense from '@/hooks/useLicense' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Group, Stack, Switch, Text, TextInput, Tooltip, } from '@mantine/core' import { DateTimePicker } from '@mantine/dates' import type { UseFormReturnType } from '@mantine/form' import { endOfDay } from 'date-fns' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputSendLater: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <Stack onClick={() => { if (license.isFree()) { showModalUpgrade( 'Schedule for Later', 'Schedule your broadcasts to be sent at a specific date and time in the future.', ) } }} > <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Send later</Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="sm"> Pro </Badge> )} <Tooltip label="Schedule your broadcast to be sent at a specific date and time in the future." position="top-start" multiline w={350} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('scheduler.enabled', { type: 'checkbox' })} /> <When condition={form.values.scheduler.enabled}> <TextInput label="Date time" size="md" type="datetime-local" {...form.getInputProps('scheduler.scheduledAt')} /> </When> </Stack> ) } export default InputSendLater
```

# src/features/broadcast/components/Input/InputTextarea.tsx

```tsx
// src/features/broadcast/components/Input/InputTextarea.tsx import { Status } from '@/constants' import useAi from '@/hooks/useAi' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Box, Button, Group, LoadingOverlay, Menu, Popover, Stack, Text, Textarea, Tooltip, } from '@mantine/core' import EmojiPicker from 'emoji-picker-react' import React, { useRef, useState } from 'react' interface Props { value: string onChange: (value: string) => void error?: any placeholder?: string | null variables?: { label: string; variable: string; tooltip?: string }[] } const InputTextarea: React.FC<Props> = ({ value, onChange, error = null, placeholder = 'Enter your message here', variables = [], }) => { const textareaRef = useRef<HTMLTextAreaElement>(null) const [emojiPickerOpened, setEmojiPickerOpened] = useState<boolean>(false) const ai = useAi() const [isRewriting, setIsRewriting] = useState(false) const applyFormat = (startTag: string, endTag: string = '') => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const selectedText = value.substring(start, end) const newText = value.substring(0, start) + startTag + (selectedText || '') + endTag + value.substring(end) onChange(newText) setTimeout(() => { if (textarea) { const newPosition = start + startTag.length + (selectedText.length || 0) textarea.focus() textarea.setSelectionRange(newPosition, newPosition) } }, 0) } const handleEmojiSelect = (emojiData: any) => { applyFormat(emojiData.emoji) setEmojiPickerOpened(false) } const insertVariable = (variable: string) => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const newText = value.substring(0, start) + variable + value.substring(end) onChange(newText) setTimeout(() => { if (textarea) { const newPosition = start + variable.length textarea.focus() textarea.setSelectionRange(newPosition, newPosition) } }, 0) } const handleAiRewrite = async (rewriteType: string) => { if (!value) { toast.error('Please enter a message to rewrite.') return } const prompts: Record<string, string> = { professional: 'Rewrite the following message to be more professional', friendly: 'Rewrite the following message to be more friendly and casual', fix_grammar: 'Correct any spelling and grammar mistakes in the following message', } const prompt = prompts[rewriteType] if (!prompt) return setIsRewriting(true) try { const result = await ai.rewriteMessage(prompt, value) if (result.status === Status.SUCCESS && result.data) { onChange(result.data) } else { toast.error(result.error || 'Failed to rewrite message.') } } catch (error: any) { toast.error(error.message || 'An error occurred.') } finally { setIsRewriting(false) } } const renderEmojiToolbar = () => { return ( <Popover opened={emojiPickerOpened} onChange={setEmojiPickerOpened} position="right-end" > <Popover.Target> <Tooltip label="Emoji" position="top"> <ActionIcon onClick={() => setEmojiPickerOpened((o) => !o)} variant="subtle" > <Icon icon="tabler:mood-smile" width={16} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown p={0}> <EmojiPicker width={350} height={370} onEmojiClick={handleEmojiSelect} searchDisabled skinTonesDisabled previewConfig={{ showPreview: false }} /> </Popover.Dropdown> </Popover> ) } return ( <Stack gap={3} mt={'sm'}> <Group justify="space-between"> <Group gap={6}> <Tooltip label="Italic" position="top"> <ActionIcon onClick={() => applyFormat('_', '_')} variant="subtle"> <Icon icon="tabler:italic" fontSize={18} /> </ActionIcon> </Tooltip> <Tooltip label="Bold" position="top"> <ActionIcon onClick={() => applyFormat('*', '*')} variant="subtle"> <Icon icon="tabler:bold" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Strikethrough" position="top"> <ActionIcon onClick={() => applyFormat('~', '~')} variant="subtle"> <Icon icon="tabler:strikethrough" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Monospace" position="top"> <ActionIcon onClick={() => applyFormat('\`\`\`', '\`\`\`')} variant="subtle" > <Icon icon="tabler:code" width={18} /> </ActionIcon> </Tooltip> {renderEmojiToolbar()} </Group> </Group> <Box style={{ position: 'relative' }}> <LoadingOverlay visible={isRewriting} zIndex={1000} overlayProps={{ radius: 'sm', blur: 1 }} /> <Stack gap={8}> <Textarea ref={textareaRef} value={value} onChange={(event) => onChange(event.currentTarget.value)} placeholder={ placeholder || 'Write a message... You can use {name} to personalize.' } minRows={6} autosize styles={{ input: { ...(error ? { borderColor: 'red', borderWidth: '1px' } : {}), transition: 'border-color 0.3s ease', }, }} /> {variables.length > 0 && ( <Group mb={4}> {variables.map((variable, index) => variable.tooltip ? ( <Tooltip key={index} label={variable.tooltip} withArrow position="top" multiline w={220} > <Button variant="outline" size="compact-xs" onClick={() => insertVariable(variable.variable)} > {variable.label} </Button> </Tooltip> ) : ( <Button key={index} variant="outline" size="compact-xs" onClick={() => insertVariable(variable.variable)} > {variable.label} </Button> ), )} </Group> )} </Stack> </Box> {error && ( <Text c="red" size="sm"> {' '} {error}{' '} </Text> )} </Stack> ) } export default InputTextarea
```

# src/features/broadcast/components/Input/InputTyping.tsx

```tsx
// src/features/broadcast/components/Input/InputTyping.tsx import useLicense from '@/hooks/useLicense' import { Icon } from '@iconify/react' import { Badge, Group, Switch, Text, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputTyping: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Typing effect</Text> <Tooltip label='Show "Typing..." status to the recipient to mimic human behavior and reduce the risk of being flagged.' position="top-start" multiline w={300} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('isTyping', { type: 'checkbox' })} /> ) } export default InputTyping
```

# src/features/broadcast/components/Input/Message/FormFile.tsx

```tsx
// src/features/broadcast/components/Input/Message/FormFile.tsx import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> variables: { label: string; variable: string; tooltip?: string }[] } const FormFile: React.FC<Props> = ({ form, variables }) => { return ( <> <Upload type="file" value={form.values.inputFile.file} onDrop={(file) => { form.setFieldValue('inputFile.file', file) }} onRemove={() => form.setFieldValue('inputFile.file', null)} /> <InputTextarea value={form.values.inputFile.caption} onChange={(data) => form.setFieldValue('inputFile.caption', data)} placeholder="Enter your caption here" variables={variables} /> </> ) } export default FormFile
```

# src/features/broadcast/components/Input/Message/FormImage.tsx

```tsx
// src/features/broadcast/components/Input/Message/FormImage.tsx import type { UseFormReturnType } from '@mantine/form' import React, { useEffect, useState } from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> variables: { label: string; variable: string; tooltip?: string }[] } const FormImage: React.FC<Props> = ({ form, variables }) => { const [preview, setPreview] = useState<string | null>(null) useEffect(() => { return () => { if (preview) { URL.revokeObjectURL(preview) } } }, [preview]) return ( <> <Upload type="image" value={form.values.inputImage.file} onDrop={(file) => { form.setFieldValue('inputImage.file', file) }} onRemove={() => form.setFieldValue('inputImage.file', null)} /> <InputTextarea value={form.values.inputImage.caption} onChange={(data) => form.setFieldValue('inputImage.caption', data)} placeholder="Enter your caption here" variables={variables} /> </> ) } export default FormImage
```

# src/features/broadcast/components/Input/Message/FormLocation.tsx

```tsx
import { Group, TextInput } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' interface Props { form: UseFormReturnType<any> } const FormLocation: React.FC<Props> = ({ form }: Props) => { return ( <> <Group grow> <TextInput required label="Latitude" placeholder="-22.95201" {...form.getInputProps('inputLocation.lat')} /> <TextInput required label="Longitude" placeholder="-43.2102601" {...form.getInputProps('inputLocation.lng')} /> </Group> <TextInput label="Name" {...form.getInputProps('inputLocation.name')} /> <TextInput label="Address" {...form.getInputProps('inputLocation.address')} /> <TextInput label="Url" {...form.getInputProps('inputLocation.url')} /> </> ) } export default FormLocation
```

# src/features/broadcast/components/Input/Message/FormPoll.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Button, Fieldset, Group, Stack, Text, TextInput, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const FormPoll: React.FC<Props> = ({ form }: Props) => { const handleInsert = () => { form.insertListItem('inputPoll.choices', '') } const handleRemove = (index: number) => { form.removeListItem('inputPoll.choices', index) } return ( <> <TextInput required label="Name" {...form.getInputProps('inputPoll.name')} /> <Fieldset legend={<Text fw={500}>Choices</Text>}> <Stack> {form.values.inputPoll.choices.map((button: any, index: number) => ( <Group key={index}> <TextInput style={{ flexGrow: 1, }} {...form.getInputProps(`inputPoll.choices.${index}`)} /> <When condition={index !== 0}> <ActionIcon color="red" onClick={() => handleRemove(index)}> <Icon icon={'tabler:trash'} fontSize={24} /> </ActionIcon> </When> </Group> ))} <Box> <Button size="xs" onClick={handleInsert}> Add </Button> </Box> </Stack> </Fieldset> </> ) } export default FormPoll
```

# src/features/broadcast/components/Input/Message/FormText.tsx

```tsx
// src/features/broadcast/components/Input/Message/FormText.tsx import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' interface Props { form: UseFormReturnType<any> variables: { label: string; variable: string; tooltip?: string }[] } const FormText: React.FC<Props> = ({ form, variables }) => { return ( <InputTextarea value={form.values.inputText} onChange={(data) => form.setFieldValue('inputText', data)} error={form.errors.inputText} variables={variables} /> ) } export default FormText
```

# src/features/broadcast/components/Input/Message/FormVCard.tsx

```tsx
import ModalSelectContacts from '@/components/Modal/ModalSelectContacts' import { Icon } from '@iconify/react' import { ActionIcon, Button, Card, Group, ScrollArea, Stack, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import React from 'react' interface Props { form: UseFormReturnType<any> } /** * @component FormVCard * @description Renders the UI for selecting one or more contacts to send as a VCard. */ const FormVCard: React.FC<Props> = ({ form }) => { const [showModal, modalHandlers] = useDisclosure(false) const selectedContacts = form.values.inputVCard.contacts // Handler to add contacts from the modal to the form state const handleSelectContacts = (newContacts: any[]) => { // Store the full contact objects; the sender function will extract the ID. form.setFieldValue('inputVCard.contacts', newContacts) modalHandlers.close() } // Handler to remove a contact from the list const handleRemoveContact = (contactId: string) => { // -- MODIFIED: Changed filter logic to use the correct unique identifier `id`. form.setFieldValue( 'inputVCard.contacts', selectedContacts.filter((c: any) => c.id !== contactId), ) } return ( <> <Stack> <Group justify="space-between"> <Text fw={500}>Selected Contacts ({selectedContacts.length})</Text> <Button size="xs" variant="outline" leftSection={<Icon icon="tabler:address-book" fontSize={16} />} onClick={modalHandlers.open} > Select Contact(s) </Button> </Group> {/* Display selected contacts */} <ScrollArea h={150} style={{ border: '1px solid #dee2e6', borderRadius: '4px' }} > <Stack gap="xs" p="xs"> {selectedContacts.length > 0 ? ( selectedContacts.map((contact: any) => ( // -- MODIFIED: Changed key to use `contact.id` for unique identification. <Card withBorder p="xs" radius="sm" key={contact.id}> <Group justify="space-between"> <Text size="sm"> {/* -- MODIFIED: Updated to use the correct properties for displaying the contact's name or number. */} {contact.savedName || contact.publicName || contact.phoneNumber} </Text> <Tooltip label="Remove"> {/* -- MODIFIED: Pass `contact.id` to the remove handler. */} <ActionIcon color="red" variant="transparent" onClick={() => handleRemoveContact(contact.id)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Tooltip> </Group> </Card> )) ) : ( <Text c="dimmed" ta="center" pt="xl"> No contacts selected. </Text> )} </Stack> </ScrollArea> {form.errors['inputVCard.contacts'] && ( <Text c="red" size="xs"> {form.errors['inputVCard.contacts']} </Text> )} </Stack> <ModalSelectContacts opened={showModal} onClose={modalHandlers.close} onSubmit={handleSelectContacts} /> </> ) } export default FormVCard
```

# src/features/broadcast/components/Input/Message/FormVideo.tsx

```tsx
// src/features/broadcast/components/Input/Message/FormVideo.tsx import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> variables: { label: string; variable: string; tooltip?: string }[] } const FormVideo: React.FC<Props> = ({ form, variables }) => { return ( <> <Upload type="video" value={form.values.inputVideo.file} onDrop={(file) => { form.setFieldValue('inputVideo.file', file) }} onRemove={() => form.setFieldValue('inputVideo.file', null)} /> <InputTextarea value={form.values.inputVideo.caption} onChange={(data) => form.setFieldValue('inputVideo.caption', data)} placeholder="Enter your caption here" variables={variables} /> </> ) } export default FormVideo
```

# src/features/broadcast/components/Input/Message/InputMessage.tsx

```tsx
// src/features/broadcast/components/Input/Message/InputMessage.tsx import { Media, Message } from '@/constants' import useLicense from '@/hooks/useLicense' import db, { type BroadcastTemplate } from '@/libs/db' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Popover, Select, SimpleGrid, Stack, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo } from 'react' import { When } from 'react-if' import ModalCreateUpdateTemplate from '../../Modal/ModalCreateUpdateTemplate' import ModalManageTemplate from '../../Modal/ModalManageTemplate' import FormDocument from './FormFile' import FormImage from './FormImage' import FormLocation from './FormLocation' import FormPoll from './FormPoll' import FormText from './FormText' import FormVCard from './FormVCard' import FormVideo from './FormVideo' import ProFeatureButton from './ProFeatureButton' interface Props { form: UseFormReturnType<any> disabledTemplateButton?: boolean } const InputMessage: React.FC<Props> = ({ form, disabledTemplateButton = false, }) => { const license = useLicense() const templates = useLiveQuery(async () => await db.broadcastTemplates.toArray()) || [] const [showModalManageTemplate, modalManageTemplate] = useDisclosure(false) const [showModalSaveTemplate, modalSaveTemplateHandlers] = useDisclosure(false) const personalizationVariables = [ { label: 'Spintax', variable: '{Hi|Hello}', tooltip: 'Use Spintax to create message variations. The system will randomly pick one option. e.g., {Hi|Hello|Hola}', }, { label: 'Name', variable: '{name}' }, { label: 'Number', variable: '{number}' }, ] const labelValueTemplates = useMemo(() => { return templates?.map((template: BroadcastTemplate, index) => ({ label: template.name, value: index.toString(), })) }, [templates]) const handleSelectTemplate = async (index: string) => { const { id, message, type } = templates![parseInt(index, 10)] const dataByMessageTypes: { [key: string]: () => any } = { [Message.TEXT]: () => ({ type, inputText: message }), [Message.IMAGE]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputImage: { file: broadcastFile?.file, ...(message as object) }, } }, [Message.VIDEO]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputVideo: { file: broadcastFile?.file, ...(message as object) }, } }, [Message.FILE]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputFile: { file: broadcastFile?.file, caption: message }, } }, [Message.LOCATION]: () => ({ type, inputLocation: { ...(message as object) }, }), [Message.POLL]: () => ({ type, inputPoll: { ...(message as object) } }), } const data = await dataByMessageTypes[type]?.() form.setValues(data) } const renderInputMessage = () => { switch (form.values.type) { case Message.TEXT: return <FormText form={form} variables={personalizationVariables} /> case Message.IMAGE: return <FormImage form={form} variables={personalizationVariables} /> case Message.VIDEO: return <FormVideo form={form} variables={personalizationVariables} /> case Message.FILE: return <FormDocument form={form} variables={personalizationVariables} /> case Message.LOCATION: return <FormLocation form={form} /> case Message.POLL: return <FormPoll form={form} /> case Message.VCARD: return <FormVCard form={form} /> default: return null } } const renderMenuMessage = () => { return ( <SimpleGrid cols={5}> <Tooltip label="Text" position="top"> <Button size="sm" variant={form.values.type === Message.TEXT ? 'filled' : 'default'} onClick={() => form.setFieldValue('type', Message.TEXT)} > <Icon icon={'tabler:text-size'} fontSize={24} /> </Button> </Tooltip> <ProFeatureButton form={form} label="Image" icon="tabler:photo" messageType={Message.IMAGE} /> <ProFeatureButton form={form} label="Video" icon="tabler:video" messageType={Message.VIDEO} /> <ProFeatureButton form={form} label="File" icon="tabler:file" messageType={Message.FILE} /> <ProFeatureButton form={form} label="Location" icon="tabler:map-pin" messageType={Message.LOCATION} /> </SimpleGrid> ) } const isMessageEmpty = () => { const { type, inputText, inputImage, inputVideo, inputFile, inputLocation, inputPoll, inputVCard, } = form.values switch (type) { case Message.TEXT: return !inputText case Message.IMAGE: return !inputImage.file case Message.VIDEO: return !inputVideo.file case Message.FILE: return !inputFile.file case Message.LOCATION: return !inputLocation.lat || !inputLocation.lng case Message.POLL: return !inputPoll.name case Message.VCARD: return inputVCard.contacts.length === 0 default: return true } } // ++ MODIFIED: Logic to handle template limits for free users. const isTemplateLimitReached = license.isFree() && templates.length >= 1 const handleSaveTemplateClick = () => { if (isTemplateLimitReached) { showModalUpgrade( 'Unlimited Templates', 'The free plan allows 1 template. Upgrade to Pro to save and reuse unlimited messages!', ) return } modalSaveTemplateHandlers.open() } const saveTemplateTooltipLabel = isTemplateLimitReached ? 'Upgrade to Pro for unlimited templates' : 'Save as Template' // -- END MODIFICATION return ( <> <Stack> <Group justify="space-between"> <Group gap="xs" align="center"> <Text fw={500}>Message</Text> <When condition={!disabledTemplateButton}> {/* MODIFIED: Updated Tooltip label and onClick handler */} <Tooltip label={saveTemplateTooltipLabel}> <ActionIcon size="sm" variant="subtle" onClick={handleSaveTemplateClick} disabled={isMessageEmpty()} > <Icon icon="tabler:device-floppy" fontSize={18} /> </ActionIcon> </Tooltip> </When> </Group> <When condition={!disabledTemplateButton}> <Popover width={300} position="top-end" withArrow shadow="md"> <Popover.Target> <Tooltip label="Load template" position="top"> <Button size={'compact-sm'} variant="outline"> <Icon icon={'tabler:template'} fontSize={26} /> </Button> </Tooltip> </Popover.Target> <Popover.Dropdown> <Stack> <Select label={ <Group justify="space-between" w={270}> <Text>Use a template</Text> <Tooltip label="Manage Templates"> <ActionIcon variant="transparent" onClick={modalManageTemplate.toggle} > <Icon icon={'tabler:settings'} fontSize={18} /> </ActionIcon> </Tooltip> </Group> } searchable placeholder="Select a template to use" data={labelValueTemplates} onChange={(value) => handleSelectTemplate(value!)} comboboxProps={{ withinPortal: false }} /> </Stack> </Popover.Dropdown> </Popover> </When> </Group> </Stack> {renderMenuMessage()} {renderInputMessage()} <ModalManageTemplate opened={showModalManageTemplate} onClose={modalManageTemplate.close} /> <ModalCreateUpdateTemplate opened={showModalSaveTemplate} onClose={modalSaveTemplateHandlers.close} initialData={form.values} /> </> ) } export default InputMessage
```

# src/features/broadcast/components/Input/Message/ProFeatureButton.tsx

```tsx
import { Message } from '@/constants' import useLicense from '@/hooks/useLicense' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' const PRO_MESSAGE_TYPES = [ Message.IMAGE, Message.VIDEO, Message.FILE, Message.LOCATION, Message.POLL, ] interface ProFeatureInfo { name: string benefit: string } const featureNameMap: Record<string, ProFeatureInfo> = { [Message.IMAGE]: { name: 'Sending Images', benefit: 'Share photos and screenshots directly in your messages.', }, [Message.VIDEO]: { name: 'Sending Videos', benefit: 'Send video files to your contacts.', }, [Message.FILE]: { name: 'Sending Files', benefit: 'Attach documents, archives, and other files to your messages.', }, [Message.LOCATION]: { name: 'Sending Locations', benefit: 'Share a map with a specific location.', }, [Message.POLL]: { name: 'Creating Polls', benefit: 'Create polls to easily gather opinions from a contact.', }, [Message.VCARD]: { name: 'Sending Contacts (VCard)', benefit: 'Share contact information quickly and easily.', }, } const ProFeatureButton = ({ form, label, icon, messageType, }: { form: UseFormReturnType<any> label: string icon: string messageType: string }) => { const license = useLicense() return ( <Tooltip label={label} position="top"> <Button size="sm" variant={form.values.type === messageType ? 'filled' : 'default'} onClick={() => { const featureInfo = featureNameMap[messageType] if (featureInfo && license.isFree()) { showModalUpgrade(featureInfo.name, featureInfo.benefit) return } form.setFieldValue('type', messageType) }} > <Icon icon={icon} fontSize={24} /> </Button> </Tooltip> ) } export default ProFeatureButton
```

# src/features/broadcast/components/Input/Message/Upload.tsx

```tsx
// src/features/broadcast/components/Input/Message/Upload.tsx import { Icon } from '@iconify/react' import { Box, Stack, Text } from '@mantine/core' import { Dropzone, IMAGE_MIME_TYPE, type FileRejection, } from '@mantine/dropzone' import React, { useEffect, useRef, useState } from 'react' interface Props { type: 'image' | 'video' | 'file' value: File | null onDrop: (file: File) => void onReject?: (fileRejections: FileRejection[]) => void | null } const Upload: React.FC<Props> = ({ type, value, onDrop, onReject = () => {}, }) => { const [preview, setPreview] = useState<string | null>(null) const [fileInfo, setFileInfo] = useState<{ name: string size: string } | null>(null) const dropzoneRef = useRef<any>(null) const mimes = { image: IMAGE_MIME_TYPE, video: ['video/mp4'], audio: [], file: [], } const maxSizes = { image: 3 * 1024 * 1024, // 3MB video: 8 * 1024 * 1024, // 8MB file: 8 * 1024 * 1024, // 8MB } const idleDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } const rejectDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } useEffect(() => { return () => { if (preview) { URL.revokeObjectURL(preview) } } }, [preview]) useEffect(() => { if (value) { if (type === 'image') { const previewUrl = URL.createObjectURL(value) setPreview(previewUrl) } else if (type === 'video') { generateVideoThumbnail(value).then((thumbnail) => setPreview(thumbnail)) } else if (type === 'file') { const sizeInMB = (value.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: value.name, size: `${sizeInMB} MB` }) } } else { setPreview(null) setFileInfo(null) } }, [value, type]) const handleDrop = async (files: File[]) => { if (files.length > 0) { const file = files[0] onDrop(file) if (type === 'video') { const thumbnail = await generateVideoThumbnail(file) setPreview(thumbnail) } else if (type === 'image') { const previewUrl = URL.createObjectURL(file) setPreview(previewUrl) } else if (type === 'file') { const sizeInMB = (file.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: file.name, size: `${sizeInMB} MB` }) } } } const handleReject = (fileRejections: FileRejection[]) => { onReject(fileRejections) console.log(fileRejections) } const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve) => { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.src = URL.createObjectURL(file) video.addEventListener('loadeddata', () => { canvas.width = 200 canvas.height = 150 video.currentTime = 0 video.addEventListener('seeked', () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) resolve(thumbnailUrl) } }) }) }) } const renderContent = () => { const isFileSelected = (type === 'file' && fileInfo) || preview if (isFileSelected) { return ( <Box pos="relative" style={{ minHeight: 120, display: 'flex', alignItems: 'center', justifyContent: 'center', }} > {type === 'file' && fileInfo ? ( <Stack justify="center" align="center" ta="center"> <Icon icon="tabler:file-text" fontSize={50} /> <Text>File: {fileInfo.name}</Text> <Text size="sm">Size: {fileInfo.size}</Text> </Stack> ) : ( preview && ( <img src={preview} alt="Preview" style={{ maxWidth: '100%', height: 100, objectFit: 'contain', }} /> ) )} </Box> ) } return ( <> <Dropzone.Idle> <Stack justify="center" align="center"> <Icon icon={ type === 'image' ? 'tabler:photo' : type === 'video' ? 'tabler:video' : type === 'file' ? 'tabler:file-text' : 'tabler:file' } fontSize={50} /> <Text>Drag & drop here or click to select a file</Text> <Text size="xs" c="dimmed"> {idleDescriptions[type]} </Text> </Stack> </Dropzone.Idle> <Dropzone.Accept> <Stack justify="center" align="center"> <Icon icon={'tabler:upload'} fontSize={50} /> <Text>Drop the file here...</Text> </Stack> </Dropzone.Accept> <Dropzone.Reject> <Stack justify="center" align="center"> <Icon icon={'tabler:x'} fontSize={50} /> <Text>{rejectDescriptions[type]}</Text> </Stack> </Dropzone.Reject> </> ) } return ( <Dropzone ref={dropzoneRef} onDrop={handleDrop} onReject={handleReject} maxSize={maxSizes[type]} accept={mimes[type]} multiple={false} > {renderContent()} </Dropzone> ) } export default Upload
```

# src/features/broadcast/components/Input/Message/useInputMessage.ts

```ts
import { Message } from '@/constants' import db from '@/libs/db' import { useForm } from '@mantine/form' import _ from 'lodash' const defaultValues = { type: Message.TEXT, inputText: '', inputImage: { file: null, caption: '', }, inputVideo: { file: null, caption: '', }, inputAudio: { file: null, isPtt: false, caption: '', }, inputFile: { file: null, caption: '', }, inputLocation: { lat: '', lng: '', name: '', address: '', url: '', }, inputPoll: { name: '', choices: ['Choice 1'], }, // ++ MODIFIED: Default value is an empty array for storing selected contacts inputVCard: { contacts: [], }, } const useInputMessage = () => { const form = useForm({ initialValues: defaultValues, validate: { inputText: (value, parent) => { if (parent.type === Message.TEXT && _.isEmpty(value)) { return 'Required' } return null }, inputImage: { file: (value, parent) => { if (parent.type === Message.IMAGE && !value) { return 'Required' } return null }, }, inputVideo: { file: (value, parent) => { if (parent.type === Message.VIDEO && !value) { return 'Required' } return null }, }, inputAudio: { file: (value, parent) => { if (parent.type === Message.AUDIO && !value) { return 'Required' } return null }, }, inputFile: { file: (value, parent) => { if (parent.type === Message.FILE && !value) { return 'Required' } return null }, }, inputLocation: { lat: (value, parent) => { if (parent.type === Message.LOCATION && _.isEmpty(value)) { return 'Required' } return null }, lng: (value, parent) => { if (parent.type === Message.LOCATION && _.isEmpty(value)) { return 'Required' } return null }, }, // ++ ADDED: Validation rule for VCard message type inputVCard: { contacts: (value, parent) => { if (parent.type === Message.VCARD && (!value || value.length === 0)) { return 'At least one contact must be selected.' } return null }, }, }, }) const getMessage = () => { const { type, inputText, inputImage, inputVideo, inputFile, inputLocation, inputPoll, inputVCard, } = form.values const messages = { [Message.TEXT]: inputText, [Message.IMAGE]: { caption: inputImage.caption, }, [Message.VIDEO]: { caption: inputVideo.caption, }, [Message.FILE]: inputFile.caption, [Message.LOCATION]: { lat: inputLocation.lat, lng: inputLocation.lng, name: inputLocation.name, address: inputLocation.address, url: inputLocation.url, }, [Message.VCARD]: inputVCard.contacts, [Message.POLL]: { name: inputPoll.name, choices: inputPoll.choices, }, } return messages[type] ?? inputText } const insertBroadcastFile = async ( parentId: number, broadcastFileType: string, ) => { const { type, inputImage, inputVideo, inputAudio, inputFile } = form.values const inputTypes = { [Message.IMAGE]: inputImage.file, [Message.VIDEO]: inputVideo.file, [Message.AUDIO]: inputAudio.file, [Message.FILE]: inputFile.file, } const file = inputTypes[type] as File await db.media.add({ parentId, type: broadcastFileType, name: file.name, file, ext: file.type, }) } return { form, getMessage, insertBroadcastFile, } } export default useInputMessage
```

# src/features/broadcast/components/Listeners/BroadcastListener.tsx

```tsx
import { Action } from '@/constants' import useBroadcast from '@/features/broadcast/hooks/useBroadcast' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import _ from 'lodash' import { useEffect } from 'react' const BroadcastListener: React.FC = () => { const wa = useWa() const broadcast = useBroadcast() useWindowMessage(async (event: MessageEvent) => { const { data: { action }, } = event switch (action) { case Action.Window.SEND_BROADCAST: await broadcast.init() break default: break } }) useEffect(() => { if (!wa.isReady) return broadcast .init() .then(() => { console.log('Broadcast listener initialized.') }) .catch(console.error) const interval = setInterval(broadcast.checkScheduled, 5000) return () => { clearInterval(interval) } }, [wa.isReady]) return null } export default BroadcastListener
```

# src/features/broadcast/components/Modal/ModalConfirmLoad.tsx

```tsx
// src/features/broadcast/components/Modal/ModalConfirmLoad.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Center, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void onConfirm: (mode: 'merge' | 'replace') => void listName: string recipientCount: number } /** * @component ModalConfirmLoad * @description A modal asking the user whether to merge or replace the current recipient list * with a newly loaded one. */ const ModalConfirmLoad: React.FC<Props> = ({ opened, onClose, onConfirm, listName, recipientCount, }) => { return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack p="md"> <Center> <Stack align="center" gap="xs"> <ThemeIcon color="blue" size={50} radius="xl"> <Icon icon="tabler:database-import" fontSize={28} /> </ThemeIcon> <Title order={4}>Load Recipient List</Title> <Text c="dimmed" size="sm" ta="center"> You are about to load <b>{recipientCount} recipients</b> from the list "<b>{listName}</b>". </Text> <Text size="sm" ta="center" mt="sm"> How would you like to add them? </Text> </Stack> </Center> <Group justify="center" mt="lg" grow> <Button variant="outline" leftSection={<Icon icon="tabler:plus" />} onClick={() => onConfirm('merge')} > Merge </Button> <Button color="orange" leftSection={<Icon icon="tabler:replace" />} onClick={() => onConfirm('replace')} > Replace </Button> </Group> <Group justify="center" mt="sm"> <Button variant="default" onClick={onClose}> Cancel </Button> </Group> </Stack> </Modal> ) } export default ModalConfirmLoad
```

# src/features/broadcast/components/Modal/ModalCreateBroadcast.tsx

```tsx
// src/features/broadcast/components/Modal/ModalCreateBroadcast.tsx import Modal from '@/components/Modal/Modal' import { Message } from '@/constants' import type { Broadcast } from '@/libs/db' import { useBroadcastForm } from '@/models/useBroadcastForm' import toast from '@/utils/toast' import { Box, Grid, Group, ScrollArea, Stack, TagsInput, TextInput, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import React from 'react' import AntiBlockingSettings from '../Form/AntiBlockingSettings' // Import the new component import BroadcastActions from '../Form/BroadcastActions' import BroadcastScheduler from '../Form/BroadcastScheduler' import RecipientManager from '../Form/RecipientManager' import SmartPauseSettings from '../Form/SmartPauseSettings' import InputMessage from '../Input/Message/InputMessage' import MessagePreview from '../Preview/MessagePreview' import ModalDuplicateWarning from './ModalDuplicateWarning' import ModalFirstBroadcastWarning from './ModalFirstBroadcastWarning' import ModalLoadRecipientList from './ModalLoadRecipientList' import ModalManageSources from './ModalManageSources' interface Props { opened: boolean onClose: () => void onSuccess: () => void cloneData?: (Broadcast & { recipients?: any[] }) | null } const ModalCreateBroadcast: React.FC<Props> = ({ opened, onClose, onSuccess, cloneData = null, }) => { const [showWarningModal, warningModalHandlers] = useDisclosure(false) const [showSourcesModal, sourcesModalHandlers] = useDisclosure(false) const [showDuplicateWarning, duplicateWarningHandlers] = useDisclosure(false) const [showLoadListModal, loadListModalHandlers] = useDisclosure(false) const { form, inputMessageForm, handleClose, handleSendBroadcast, handleWarningAccepted, forceSendBroadcast, } = useBroadcastForm({ cloneData, onSuccess, onClose }) const handleUpdateRecipients = (newNumbers: any[]) => { form.setFieldValue('numbers', newNumbers) sourcesModalHandlers.close() } const handleLoadRecipients = (loadedRecipients: any[]) => { form.setFieldValue('numbers', loadedRecipients) loadListModalHandlers.close() toast.success(`Loaded ${loadedRecipients.length} recipients successfully.`) } const onSendClick = async () => { const result = await handleSendBroadcast() if (result === 'NEEDS_WARNING') { warningModalHandlers.open() } else if (result === 'DUPLICATE') { duplicateWarningHandlers.open() } } // Prepare the message object for the live preview component const { type, inputText, inputImage, inputVideo, inputFile } = inputMessageForm.values let messageForPreview: any switch (type) { case Message.TEXT: messageForPreview = inputText break case Message.IMAGE: messageForPreview = { caption: inputImage.caption } break case Message.VIDEO: messageForPreview = { caption: inputVideo.caption } break case Message.FILE: messageForPreview = { caption: inputFile.caption } break default: messageForPreview = null } return ( <> <Modal opened={opened} onClose={handleClose} w={920} withCloseButton> <ScrollArea h={650}> <Stack px={'md'}> <Group grow> <TextInput label="Name (Optional)" placeholder="e.g., Weekly Newsletter" {...form.getInputProps('name')} /> <TagsInput label="Tags (Optional)" placeholder="Add tags and press Enter" {...form.getInputProps('tags')} clearable /> </Group> <Grid> <Grid.Col span={6}> <Stack> <RecipientManager recipientCount={form.values.numbers.length} error={form.errors.numbers} onClear={() => form.setFieldValue('numbers', [])} onManage={sourcesModalHandlers.open} onLoad={loadListModalHandlers.open} /> <InputMessage form={inputMessageForm} /> </Stack> </Grid.Col> <Grid.Col span={6}> <MessagePreview type={type} message={messageForPreview} /> </Grid.Col> </Grid> <AntiBlockingSettings form={form} /> <Grid> <Grid.Col span={6}> <SmartPauseSettings form={form} /> </Grid.Col> <Grid.Col span={6}> <BroadcastScheduler form={form} /> </Grid.Col> </Grid> <BroadcastActions onSend={onSendClick} isScheduled={form.values.scheduler.enabled} scheduledAt={form.values.scheduler.scheduledAt} /> </Stack> </ScrollArea> </Modal> <ModalManageSources opened={showSourcesModal} onClose={sourcesModalHandlers.close} onSubmit={handleUpdateRecipients} initialRecipients={form.values.numbers} /> <ModalLoadRecipientList opened={showLoadListModal} onClose={loadListModalHandlers.close} onLoad={handleLoadRecipients} /> <ModalFirstBroadcastWarning opened={showWarningModal} onClose={warningModalHandlers.close} onConfirm={async () => { warningModalHandlers.close() await handleWarningAccepted() }} /> <ModalDuplicateWarning opened={showDuplicateWarning} onClose={duplicateWarningHandlers.close} onConfirm={async () => { duplicateWarningHandlers.close() await forceSendBroadcast() }} /> </> ) } export default ModalCreateBroadcast
```

# src/features/broadcast/components/Modal/ModalCreateUpdateTemplate.tsx

```tsx
// src/components/Modal/ModalCreateUpdateTemplate.tsx import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import db, { type BroadcastTemplate } from '@/libs/db' import { formHasErrors, isTypeMessageMedia } from '@/utils/util' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect } from 'react' import InputMessage from '../Input/Message/InputMessage' import useInputMessage from '../Input/Message/useInputMessage' interface Props { opened: boolean onClose: () => void data?: Partial<BroadcastTemplate> | null // ADDED: A new prop to accept initial form data for creating a new template. initialData?: any | null } const ModalCreateUpdateTemplate: React.FC<Props> = ({ opened, onClose, data = null, // ADDED: Destructure the new prop. initialData = null, }: Props) => { const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => (_.isEmpty(value) ? 'Required' : null), }, }) // MODIFIED: The useEffect hook is updated to prioritize `initialData` for populating the form. useEffect(() => { if (opened) { // If initialData is provided, it's a "new template from composed message" flow. if (initialData) { inputMessageForm.setValues(initialData) form.reset() // Ensure the name field is empty } else if (data) { // This is the existing "edit" or "clone" flow. form.setValues({ name: data.name }) const messageData = data.message as any const type = data.type inputMessageForm.reset() inputMessageForm.setFieldValue('type', type) switch (type) { case Message.TEXT: inputMessageForm.setFieldValue('inputText', messageData as string) break case Message.IMAGE: inputMessageForm.setFieldValue( 'inputImage.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputImage.file', null) break case Message.VIDEO: inputMessageForm.setFieldValue( 'inputVideo.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputVideo.file', null) break case Message.FILE: inputMessageForm.setFieldValue( 'inputFile.caption', messageData as string, ) inputMessageForm.setFieldValue('inputFile.file', null) break case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', messageData) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', messageData) break default: if (typeof messageData === 'string' && !isTypeMessageMedia(type)) { inputMessageForm.setFieldValue('inputText', messageData) } break } } else { // This is the "create new blank template" flow. form.reset() inputMessageForm.reset() } } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, initialData, opened]) // --- START REFACTOR --- // Separated logic for creating a new template. const handleCreate = async () => { const { type } = inputMessageForm.values const { name } = form.values const templateId = await db.broadcastTemplates.add({ name, type, message: getMessage(), }) if (isTypeMessageMedia(type)) { if (typeof templateId === 'number') { await insertBroadcastFile(templateId, Media.BROADCAST_TEMPLATE) } else { console.error('Failed to get templateId as number for media upload') } } } // Separated logic for updating an existing template. const handleUpdate = async () => { if (!data?.id) return const { type } = inputMessageForm.values const { name } = form.values const messagePayload = getMessage() await db.broadcastTemplates.update(data.id, { name, type, message: messagePayload, }) const newFileIsSelected = (type === Message.IMAGE && inputMessageForm.values.inputImage.file) || (type === Message.VIDEO && inputMessageForm.values.inputVideo.file) || (type === Message.FILE && inputMessageForm.values.inputFile.file) if (isTypeMessageMedia(type)) { if (newFileIsSelected) { // If a new file is selected, delete old media and add the new one await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() await insertBroadcastFile(data.id, Media.BROADCAST_TEMPLATE) } // If no new file is selected, and type is still media, existing media is preserved. } else if (isTypeMessageMedia(data.type) && !isTypeMessageMedia(type)) { // If type changed from media to non-media, delete old media. await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() } } // The main submit handler now decides which function to call. const handleSubmit = async () => { if (formHasErrors(form, inputMessageForm)) return if (data && data.id !== undefined) { await handleUpdate() } else { await handleCreate() } onClose() } // --- END REFACTOR --- const handleClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleClose} w={750} withCloseButton> <Stack justify="space-between"> <Stack> <Center> {/* MODIFIED: Title is now dynamic based on whether it's editing, creating from initial data, or creating new. */} <Title order={3}>{data?.id ? 'Edit' : 'Create'} Template</Title> </Center> <TextInput label="Name" required {...form.getInputProps('name')} /> <InputMessage disabledTemplateButton form={inputMessageForm} /> </Stack> <Group align="end" justify="end"> <Button onClick={handleSubmit}>Submit</Button> </Group> </Stack> </Modal> ) } export default ModalCreateUpdateTemplate
```

# src/features/broadcast/components/Modal/ModalDetailHistory.tsx

```tsx
// src/features/broadcast/components/Modal/ModalDetailHistory.tsx import Modal from '@/components/Modal/Modal' import { Status } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import { Icon } from '@iconify/react' import { Button, Card, Center, Group, Menu, SimpleGrid, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import { DataTable } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' import MessageStatus from '../Datatable/MessageStatus' const PAGE_SIZE = 15 // ++ ADDED: Prop for the new follow-up action handler. interface Props { opened: boolean onClose: () => void data?: Broadcast | null onCreateFollowUp: ( broadcast: Broadcast, type: 'SUCCESS' | 'FAILED' | 'ALL', ) => void } const ModalDetailHistory: React.FC<Props> = ({ opened, onClose, data = null, onCreateFollowUp, }) => { const contacts = useLiveQuery(async () => { if (!data?.id) return [] return await db.broadcastContacts .where({ broadcastId: data.id }) .toArray() }, [data]) || [] const [page, setPage] = useState(1) const [records, setRecords] = useState<BroadcastContact[]>([]) useEffect(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE setRecords(contacts.slice(from, to)) }, [page, contacts]) const { summaryData, scheduledAt, recipientStats } = useMemo(() => { if (!contacts || contacts.length === 0) { return { summaryData: [], scheduledAt: null, recipientStats: {} } } const scheduledAt = contacts[0]?.scheduledAt || null const stats = { success: contacts.filter((c) => c.status === Status.SUCCESS).length, failed: contacts.filter((c) => c.status === Status.FAILED).length, pending: contacts.filter((c) => c.status === Status.PENDING).length, running: contacts.filter((c) => c.status === Status.RUNNING).length, scheduled: contacts.filter((c) => c.status === Status.SCHEDULER).length, cancelled: contacts.filter((c) => c.status === Status.CANCELLED).length, } const summaryItems = [ { title: 'Success', value: stats.success, color: 'teal', icon: 'tabler:circle-check', }, { title: 'Failed', value: stats.failed, color: 'red', icon: 'tabler:circle-x', }, { title: 'Pending', value: stats.pending, color: 'yellow', icon: 'tabler:clock', }, { title: 'Running', value: stats.running, color: 'orange', icon: 'tabler:player-play', }, { title: 'Scheduled', value: stats.scheduled, color: 'blue', icon: 'tabler:calendar-event', }, { title: 'Cancelled', value: stats.cancelled, color: 'gray', icon: 'tabler:ban', }, ].filter((item) => item.value > 0) return { summaryData: summaryItems, scheduledAt, recipientStats: stats } }, [contacts]) const renderSummaryCards = () => { return summaryData.map((item) => ( <Card withBorder radius="md" p="sm" key={item.title} shadow="none"> <Group wrap="nowrap"> <ThemeIcon color={item.color} variant="light" size={40} radius="md"> <Icon icon={item.icon} fontSize={24} /> </ThemeIcon> <div> <Text c="dimmed" size="xs" tt="uppercase" fw={700}> {item.title} </Text> <Text fw={700} size="xl"> {item.value} </Text> </div> </Group> </Card> )) } return ( <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack p="md"> {contacts && contacts.length > 0 && data ? ( <> <SimpleGrid cols={{ base: 2, sm: 3 }} spacing="lg"> {renderSummaryCards()} </SimpleGrid> {scheduledAt && ( <Card withBorder radius="md" mt="md" p="xs" shadow="none"> <Center> <Group> <Icon icon="tabler:calendar-time" color="var(--mantine-color-blue-7)" /> <Text size="sm" c="blue.7" fw={500}> Scheduled for:{' '} {dayjs(scheduledAt).format('DD MMMM YYYY, HH:mm')} </Text> </Group> </Center> </Card> )} <Group justify="space-end"> {/* ++ MODIFIED: Replaced the simple "Resend" button with a more versatile "Follow-up" menu. */} <Menu shadow="md" withArrow> <Menu.Target> <Button size="xs" leftSection={<Icon icon="tabler:send" fontSize={18} />} > Create Follow-up </Button> </Menu.Target> <Menu.Dropdown> <Menu.Label>Create a new campaign for...</Menu.Label> <Menu.Item leftSection={<Icon icon="tabler:send-off" fontSize={16} />} disabled={ !recipientStats.failed || recipientStats.failed === 0 } onClick={() => onCreateFollowUp(data, 'FAILED')} > Failed Recipients ({recipientStats.failed || 0}) </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:checks" fontSize={16} />} disabled={ !recipientStats.success || recipientStats.success === 0 } onClick={() => onCreateFollowUp(data, 'SUCCESS')} > Successful Recipients ({recipientStats.success || 0}) </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:users" fontSize={16} />} onClick={() => onCreateFollowUp(data, 'ALL')} > All Recipients ({contacts.length}) </Menu.Item> </Menu.Dropdown> </Menu> </Group> <DataTable height={350} records={records} totalRecords={contacts.length} recordsPerPage={PAGE_SIZE} page={page} onPageChange={(p) => setPage(p)} noRecordsText="No recipient data available" striped highlightOnHover withTableBorder columns={[ { accessor: 'name', title: 'Name', render: (contact) => contact.name || '-', }, { accessor: 'number', title: 'Number', render: (contact) => contact.number.split('@')[0], }, { accessor: 'status', title: 'Status', render: (contact) => ( <MessageStatus status={contact.status} error={contact.error} /> ), }, { accessor: 'sentAt', title: 'Sent At', render: (contact) => contact.sendAt ? dayjs(contact.sendAt).format('DD/MM/YYYY HH:mm') : '-', }, ]} /> </> ) : ( <Center h={200}> <Stack align="center"> <Icon icon="tabler:database-off" fontSize={48} color="gray" /> <Text c="dimmed"> No recipient data found for this broadcast. </Text> </Stack> </Center> )} </Stack> </Modal> ) } export default ModalDetailHistory
```

# src/features/broadcast/components/Modal/ModalDuplicateWarning.tsx

```tsx
// src/features/broadcast/components/Modal/ModalDuplicateWarning.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Group, rem, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void onConfirm: () => void } /** * @component ModalDuplicateWarning * @description A modal that warns users when they attempt to send a broadcast * with content identical to the previous one, encouraging message variation. */ const ModalDuplicateWarning: React.FC<Props> = ({ opened, onClose, onConfirm, }) => { return ( <Modal opened={opened} onClose={onClose} w={500} p="xl" withCloseButton> <Stack gap="lg" align="center"> <ThemeIcon variant="light" color="orange" size={rem(60)} radius="xl"> <Icon icon="tabler:alert-triangle" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> Potential Duplicate Content </Title> <Text size="sm" ta="center"> This message appears to be identical to your last broadcast. We strongly recommend using Spintax or varying the content to avoid being blocked. </Text> <Group justify="center" mt="md" w="100%"> <Button variant="outline" onClick={onClose}> Edit Message </Button> <Button onClick={onConfirm} color="orange"> Send Anyway </Button> </Group> </Stack> </Modal> ) } export default ModalDuplicateWarning
```

# src/features/broadcast/components/Modal/ModalEditRecipient.tsx

```tsx
// src/features/broadcast/components/Modal/ModalEditRecipient.tsx import Modal from '@/components/Modal/Modal' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void // MODIFIED: The onSubmit signature is updated to pass the original number // along with the new data, allowing the parent to identify the correct record. onSubmit: ( originalNumber: string, updatedData: { name: string; number: string }, ) => void recipientData: { number: string; name: string } | null } const ModalEditRecipient: React.FC<Props> = ({ opened, onClose, onSubmit, recipientData, }) => { const form = useForm({ initialValues: { name: '', number: '', }, validate: { name: (value) => value.trim().length > 0 ? null : 'Name cannot be empty', // ADDED: Validation to ensure the number field is not empty. number: (value) => value.trim().length > 0 ? null : 'Number cannot be empty', }, }) useEffect(() => { if (recipientData) { form.setValues({ name: recipientData.name, number: recipientData.number, }) } else { form.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [recipientData, opened]) const handleSubmit = (values: { name: string; number: string }) => { // MODIFIED: Passes the original recipient's number to the submit handler // to ensure the correct record is updated, even if the number itself was changed. if (recipientData) { onSubmit(recipientData.number, values) } onClose() } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Edit Recipient</Title> </Center> <TextInput label="Name" placeholder="Enter contact name" {...form.getInputProps('name')} data-autofocus /> {/* MODIFIED: The `readOnly` prop has been removed to allow editing of the recipient's number. */} <TextInput label="Number" placeholder="Enter number with country code" {...form.getInputProps('number')} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Save Changes</Button> </Group> </Stack> </form> </Modal> ) } export default ModalEditRecipient
```

# src/features/broadcast/components/Modal/ModalEditSchedule.tsx

```tsx
// src/features/broadcast/components/Modal/ModalEditSchedule.tsx import Modal from '@/components/Modal/Modal' import type { Broadcast } from '@/libs/db' import toast from '@/utils/toast' import { Button, Center, Group, Stack, Title } from '@mantine/core' import { DateTimePicker } from '@mantine/dates' import { useForm } from '@mantine/form' import { isFuture } from 'date-fns' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (broadcastId: number, newScheduledAt: Date) => void broadcastData: Broadcast | null } /** * @component ModalEditSchedule * @description A modal for editing the scheduled time of a broadcast. * It ensures the new time is in the future and provides a clean interface. */ const ModalEditSchedule: React.FC<Props> = ({ opened, onClose, onSubmit, broadcastData, }) => { const form = useForm({ initialValues: { scheduledAt: null as Date | null, }, validate: { scheduledAt: (value) => { if (!value) { return 'A date and time are required.' } if (!isFuture(new Date(value))) { return 'Scheduled time must be in the future.' } return null }, }, }) useEffect(() => { // Populate form with existing scheduled time when the modal opens if (broadcastData && opened) { // @ts-ignore - scheduledAt is added dynamically in PageBroadcast if (broadcastData.scheduledAt) { // @ts-ignore form.setValues({ scheduledAt: new Date(broadcastData.scheduledAt) }) } } else if (!opened) { form.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [broadcastData, opened]) const handleSubmit = (values: { scheduledAt: Date | null }) => { if (!broadcastData || !values.scheduledAt) { toast.error('Invalid data provided.') return } onSubmit(broadcastData.id, values.scheduledAt) } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500} h={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Edit Broadcast Schedule</Title> </Center> <DateTimePicker label="New Scheduled Time" placeholder="Pick date and time" minDate={new Date()} required {...form.getInputProps('scheduledAt')} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Save Changes</Button> </Group> </Stack> </form> </Modal> ) } export default ModalEditSchedule
```

# src/features/broadcast/components/Modal/ModalFirstBroadcastWarning.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Checkbox, Group, List, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void onConfirm: () => void } const ModalFirstBroadcastWarning: React.FC<Props> = ({ opened, onClose, onConfirm, }) => { const [acknowledged, setAcknowledged] = useState(false) const handleConfirm = () => { if (acknowledged) { onConfirm() } } return ( <Modal opened={opened} onClose={onClose} w={600} withCloseButton> <Stack p="md"> <Title order={3} ta="center"> Important: Please Read Before Broadcasting </Title> <Text c="dimmed" ta="center" size="sm" mb="md"> Broadcasting on WhatsApp carries a risk of account blocking if not done carefully. To protect your account, please follow these best practices. </Text> <Stack gap="lg"> <div> <Text fw={500}>Best Practices (Do's)</Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item> <b>Warm-Up Your Account:</b> Start by sending to a small number of contacts if your account is new or rarely used. </List.Item> <List.Item> <b>Use Personalization:</b> Utilize Spintax {'{Hi|Hello}'} and variables like {'{name}'} to make each message unique. </List.Item> <List.Item> <b>Prioritize Known Contacts:</b> Sending to contacts who have saved your number is significantly safer. </List.Item> <List.Item> <b>Provide an Opt-Out:</b> Include a message like "Reply STOP to unsubscribe" to reduce spam reports. </List.Item> </List> </div> <div> <Text fw={500}>Things to Avoid (Don'ts)</Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="red" size={20} radius="xl"> <Icon icon="tabler:x" fontSize={14} /> </ThemeIcon> } > <List.Item> <b>Don't Bulk-Send to Strangers:</b> This is the fastest way to get your account banned. </List.Item> <List.Item> <b>Don't Send Identical Messages:</b> Always use message variation. </List.Item> </List> </div> </Stack> <Checkbox mt="xl" checked={acknowledged} onChange={(event) => setAcknowledged(event.currentTarget.checked)} label="I understand the risks and will use this feature responsibly." /> <Group justify="flex-end" mt="xl"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleConfirm} disabled={!acknowledged}> Continue </Button> </Group> </Stack> </Modal> ) } export default ModalFirstBroadcastWarning
```

# src/features/broadcast/components/Modal/ModalLoadRecipientList.tsx

```tsx
// src/features/broadcast/components/Modal/ModalLoadRecipientList.tsx import Modal from '@/components/Modal/Modal' import useDataQuery from '@/hooks/useDataQuery' import db, { type BroadcastRecipient } from '@/libs/db' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Stack, TextInput, Title, Tooltip, } from '@mantine/core' import dayjs from 'dayjs' import { DataTable } from 'mantine-datatable' import React from 'react' interface Props { opened: boolean onClose: () => void onLoad: (recipients: any[]) => void } const ModalLoadRecipientList: React.FC<Props> = ({ opened, onClose, onLoad, }) => { const dataQuery = useDataQuery<BroadcastRecipient>({ table: db.broadcastRecipients, searchField: 'name', initialSort: { field: 'createdAt', direction: 'desc' }, }) const handleDelete = async (list: BroadcastRecipient) => { if (confirm(`Are you sure you want to delete the list "${list.name}"?`)) { await dataQuery._delete(list.id) } } return ( <Modal opened={opened} onClose={onClose} w={750} withCloseButton> <Stack p="sm" h={500} justify="space-between"> <Stack> <Center> <Title order={4}>Load a Saved Recipient List</Title> </Center> <Group justify="flex-end"> <TextInput placeholder="Search by list name..." value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} /> </Group> <DataTable height={350} records={dataQuery.data} columns={[ { accessor: 'name', title: 'List Name' }, { accessor: 'count', title: 'Recipients', render: (list) => list.recipients.length, }, { accessor: 'createdAt', title: 'Date Saved', render: (list) => dayjs(list.createdAt).format('DD MMM YYYY, HH:mm'), }, { accessor: 'actions', title: 'Actions', textAlign: 'right', render: (list) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Load this list"> <ActionIcon variant="subtle" color="blue" onClick={() => { onLoad(list.recipients) onClose() }} > <Icon icon="tabler:upload" /> </ActionIcon> </Tooltip> <Tooltip label="Delete this list"> <ActionIcon variant="subtle" color="red" onClick={() => handleDelete(list)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ]} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} noRecordsText="No saved lists found." /> </Stack> <Group justify="flex-end"> <Button variant="default" onClick={onClose}> Close </Button> </Group> </Stack> </Modal> ) } export default ModalLoadRecipientList
```

# src/features/broadcast/components/Modal/ModalManageSources.tsx

```tsx
// src/features/broadcast/components/Modal/ModalManageSources.tsx import Modal from '@/components/Modal/Modal' import useFile from '@/hooks/useFile' import useLicense from '@/hooks/useLicense' import db from '@/libs/db' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Group, Menu, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useDebouncedValue, useDisclosure } from '@mantine/hooks' import _ from 'lodash' import { DataTable, type DataTableSortStatus } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' import ModalLoadRecipientList from './ModalLoadRecipientList' import ModalSaveRecipientList from './ModalSaveRecipientList' import ModalSourceExcel from './ModalSourceExcel' import ModalSourceGroups from './ModalSourceGroups' import ModalSourceManual from './ModalSourceManual' import ModalSourceMyContacts from './ModalSourceMyContacts' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void initialRecipients: any[] } const PAGE_SIZE = 10 const ModalManageSources: React.FC<Props> = ({ opened, onClose, onSubmit, initialRecipients, }) => { const [recipients, setRecipients] = useState<any[]>([]) const [selectedRecords, setSelectedRecords] = useState<any[]>([]) const [page, setPage] = useState(1) const [paginatedRecipients, setPaginatedRecipients] = useState<any[]>([]) const [searchQuery, setSearchQuery] = useState('') const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) const [isSaving, setIsSaving] = useState(false) const [editingCell, setEditingCell] = useState<{ recordId: string columnId: string } | null>(null) const [editValue, setEditValue] = useState('') const [sortStatus, setSortStatus] = useState<DataTableSortStatus>({ columnAccessor: 'name', direction: 'asc', }) const [showManualModal, manualModalHandlers] = useDisclosure(false) const [showExcelModal, excelModalHandlers] = useDisclosure(false) const [showGroupsModal, groupsModalHandlers] = useDisclosure(false) const [showMyContactsModal, myContactsModalHandlers] = useDisclosure(false) const [showSaveListModal, saveListModalHandlers] = useDisclosure(false) const [showLoadListModal, loadListModalHandlers] = useDisclosure(false) const license = useLicense() const fileExporter = useFile() useEffect(() => { if (opened) { setRecipients(_.cloneDeep(initialRecipients)) setSelectedRecords([]) setPage(1) setSearchQuery('') setSortStatus({ columnAccessor: 'name', direction: 'asc' }) } }, [opened, initialRecipients]) const filteredAndSortedRecipients = useMemo(() => { let data = [...recipients] if (debouncedSearchQuery) { const lowerCaseQuery = debouncedSearchQuery.toLowerCase() data = data.filter( (r) => r.name?.toLowerCase().includes(lowerCaseQuery) || r.number?.toLowerCase().includes(lowerCaseQuery), ) } const { columnAccessor, direction } = sortStatus if (columnAccessor) { data = _.orderBy(data, [columnAccessor], [direction]) } return data }, [recipients, debouncedSearchQuery, sortStatus]) useEffect(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE setPaginatedRecipients(filteredAndSortedRecipients.slice(from, to)) }, [filteredAndSortedRecipients, page]) useEffect(() => { setPage(1) }, [searchQuery, sortStatus]) const handleAddRecipients = (newRecipients: any[]) => { const formattedNewRecipients = newRecipients.map((rec) => { if (typeof rec === 'string') { return { number: rec, name: 'N/A', source: 'Manual' } } return { number: rec.number || rec.phoneNumber, name: rec.name || rec.savedName || rec.publicName || 'N/A', } }) const initialCount = recipients.length const combined = [...recipients, ...formattedNewRecipients] const uniqueRecipients = _.uniqBy(combined, 'number') const finalCount = uniqueRecipients.length setRecipients(uniqueRecipients) const addedCount = finalCount - initialCount const duplicateCount = combined.length - finalCount if (addedCount > 0 && duplicateCount > 0) { toast.info( `${addedCount} recipient(s) added. ${duplicateCount} duplicate(s) were automatically removed.`, ) } else if (addedCount > 0) { toast.success(`${addedCount} recipient(s) added successfully.`) } else if (duplicateCount > 0) { toast.info( `No new recipients added. ${duplicateCount} duplicate(s) were found.`, ) } else { toast.info('No new recipients were added.') } } const handleDeleteRecipient = (numberToDelete: string) => { setRecipients((current) => current.filter((r) => r.number !== numberToDelete), ) } const handleBulkDelete = () => { const numbersToDelete = new Set(selectedRecords.map((r) => r.number)) setRecipients((current) => current.filter((r) => !numbersToDelete.has(r.number)), ) setSelectedRecords([]) toast.success(`${numbersToDelete.size} recipient(s) deleted.`) } const handleSaveCellEdit = () => { if (!editingCell) return const { recordId, columnId } = editingCell const finalValue = editValue.trim() if (columnId === 'number') { if (finalValue === '') { toast.error('Number cannot be empty.') return } const isDuplicate = recipients.some( (r) => r.number === finalValue && r.number !== recordId, ) if (isDuplicate) { toast.error(`The number ${finalValue} already exists in the list.`) return } } setRecipients((currentRecipients) => currentRecipients.map((r) => { if (r.number === recordId) { const valueToSet = finalValue === '' && columnId === 'name' ? r.name : finalValue return { ...r, [columnId]: valueToSet } } return r }), ) setEditingCell(null) } const handleOpenSaveListModal = async () => { if (license.isFree()) { const existingListsCount = await db.broadcastRecipients.count() if (existingListsCount >= 1) { showModalUpgrade( 'Unlimited Recipient Lists', 'Upgrade to Pro to save and manage unlimited recipient lists for easy reuse.', ) return } } saveListModalHandlers.open() } const handleSaveList = async (name: string) => { if (recipients.length === 0) { toast.error('Cannot save an empty list.') return } setIsSaving(true) try { await db.broadcastRecipients.add({ name, recipients, createdAt: new Date(), }) toast.success(`List "${name}" saved successfully.`) saveListModalHandlers.close() } catch (error) { console.error('Failed to save list:', error) toast.error('Failed to save the list.') } finally { setIsSaving(false) } } const handleLoadList = (loadedRecipients: any[]) => { setRecipients(loadedRecipients) toast.success(`Loaded ${loadedRecipients.length} recipients.`) } const handleExport = async (format: string) => { if (recipients.length === 0) { toast.info('No recipients to export.') return } const dataForExport = recipients.map((r) => ({ number: r.number, name: r.name, })) const filename = `recipients_${new Date().toISOString().slice(0, 10)}` await fileExporter.saveAs(format, dataForExport, filename) } const handleClearAll = () => { if ( confirm('Are you sure you want to remove all recipients from this list?') ) { setRecipients([]) } } const handleConfirm = () => { onSubmit(recipients) onClose() } const handleExcelButtonClick = () => { if (license.isFree()) { showModalUpgrade( 'Import from Excel', 'Upgrade to Pro to bulk import recipients from an Excel or CSV file instantly.', ) return } excelModalHandlers.open() } const columns: any[] = [ { accessor: 'number', title: 'Number', sortable: true, ellipsis: true, render: (recipient) => { const isEditing = editingCell?.recordId === recipient.number && editingCell?.columnId === 'number' return isEditing ? ( <Group gap="xs" wrap="nowrap"> <TextInput value={editValue} onChange={(e) => setEditValue(e.currentTarget.value)} onBlur={handleSaveCellEdit} onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault() handleSaveCellEdit() } else if (e.key === 'Escape') { setEditingCell(null) } }} autoFocus size="xs" style={{ flexGrow: 1 }} /> <Tooltip label="Save" withArrow position="top"> <ActionIcon variant="subtle" color="teal" onClick={handleSaveCellEdit} > <Icon icon="tabler:check" /> </ActionIcon> </Tooltip> </Group> ) : ( <Tooltip label="Click to edit" withArrow position="top"> <Text onClick={() => { setEditingCell({ recordId: recipient.number, columnId: 'number', }) setEditValue(recipient.number) }} style={{ cursor: 'pointer', width: '100%', padding: '6px 0', height: '100%', }} truncate > {recipient.number} </Text> </Tooltip> ) }, }, { accessor: 'name', title: 'Name', sortable: true, render: (recipient) => { const isEditing = editingCell?.recordId === recipient.number && editingCell?.columnId === 'name' return isEditing ? ( <Group gap="xs" wrap="nowrap"> <TextInput value={editValue} onChange={(e) => setEditValue(e.currentTarget.value)} onBlur={handleSaveCellEdit} onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault() handleSaveCellEdit() } else if (e.key === 'Escape') { setEditingCell(null) } }} autoFocus size="xs" style={{ flexGrow: 1 }} /> <Tooltip label="Save" withArrow position="top"> <ActionIcon variant="subtle" color="teal" onClick={handleSaveCellEdit} > <Icon icon="tabler:check" /> </ActionIcon> </Tooltip> </Group> ) : ( <Tooltip label="Click to edit" withArrow position="top"> <Text onClick={() => { setEditingCell({ recordId: recipient.number, columnId: 'name', }) setEditValue(recipient.name) }} style={{ cursor: 'pointer', width: '100%', padding: '6px 0', height: '100%', }} truncate > {recipient.name} </Text> </Tooltip> ) }, }, { accessor: 'actions', title: <Text>Actions</Text>, textAlign: 'right', width: '0%', render: (recipient) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Delete"> <ActionIcon size="sm" variant="subtle" color="red" onClick={() => handleDeleteRecipient(recipient.number)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ] return ( <> <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack justify="space-between" h={'calc(80vh)'} p="sm"> <Stack> <Group justify="space-between"> <Group> <Text fw={500}>Current Recipients ({recipients.length})</Text> {selectedRecords.length > 0 && ( <Button size="xs" variant="light" color="red" leftSection={<Icon icon="tabler:trash" fontSize={16} />} onClick={handleBulkDelete} > Delete Selected ({selectedRecords.length}) </Button> )} </Group> <Group> <Button.Group> <Button size="xs" variant="default" leftSection={<Icon icon="tabler:keyboard" fontSize={16} />} onClick={manualModalHandlers.open} > Manual </Button> <Button size="xs" variant="default" leftSection={ <Icon icon="tabler:file-type-xls" fontSize={16} /> } onClick={handleExcelButtonClick} > <Group gap="xs" wrap="nowrap"> <Text component="span" size="xs"> Excel </Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="xs"> Pro </Badge> )} </Group> </Button> <Button size="xs" variant="default" leftSection={<Icon icon="tabler:users" fontSize={16} />} onClick={groupsModalHandlers.open} > Groups </Button> <Button size="xs" variant="default" leftSection={ <Icon icon="tabler:address-book" fontSize={16} /> } onClick={myContactsModalHandlers.open} > My Contacts </Button> <Button size="xs" variant="default" leftSection={ <Icon icon="tabler:database-import" fontSize={16} /> } onClick={loadListModalHandlers.open} > Load List </Button> </Button.Group> <Menu shadow="md" withArrow> <Menu.Target> <Button variant="default" size="xs" leftSection={ <Icon icon="tabler:settings" fontSize={16} /> } > Manage </Button> </Menu.Target> <Menu.Dropdown> <Menu.Item leftSection={ <Icon icon="tabler:device-floppy" fontSize={16} /> } onClick={handleOpenSaveListModal} disabled={recipients.length === 0} > Save Current List </Menu.Item> <Menu.Divider /> <Menu.Label>Export List</Menu.Label> <Menu.Item leftSection={ <Icon icon="tabler:file-type-csv" fontSize={16} /> } onClick={() => handleExport('csv')} disabled={recipients.length === 0} > Export as CSV </Menu.Item> <Menu.Item leftSection={ <Icon icon="tabler:file-type-xls" fontSize={16} /> } onClick={() => handleExport('xlsx')} disabled={recipients.length === 0} > Export as XLSX </Menu.Item> </Menu.Dropdown> </Menu> <Button size="xs" variant="light" color="red" leftSection={<Icon icon="tabler:x" fontSize={16} />} onClick={handleClearAll} disabled={recipients.length === 0} > Clear All </Button> </Group> </Group> <TextInput placeholder={`Search in ${recipients.length} recipients...`} leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(e) => setSearchQuery(e.currentTarget.value)} disabled={recipients.length === 0} /> <DataTable height={'calc(70vh - 160px)'} records={paginatedRecipients} columns={columns} totalRecords={filteredAndSortedRecipients.length} recordsPerPage={PAGE_SIZE} page={page} onPageChange={(p) => setPage(p)} minHeight={filteredAndSortedRecipients.length === 0 ? 150 : 0} noRecordsText={ searchQuery ? 'No recipients match your search' : 'No recipients added yet.' } withTableBorder={false} striped selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} idAccessor="number" sortStatus={sortStatus} onSortStatusChange={setSortStatus} /> </Stack> <Group justify="flex-end"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleConfirm}>Confirm & Close</Button> </Group> </Stack> </Modal> <ModalSourceManual opened={showManualModal} onClose={manualModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceExcel opened={showExcelModal} onClose={excelModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceGroups opened={showGroupsModal} onClose={groupsModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceMyContacts opened={showMyContactsModal} onClose={myContactsModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSaveRecipientList opened={showSaveListModal} onClose={saveListModalHandlers.close} onSave={handleSaveList} isSaving={isSaving} /> <ModalLoadRecipientList opened={showLoadListModal} onClose={loadListModalHandlers.close} onLoad={handleLoadList} /> </> ) } export default ModalManageSources
```

# src/features/broadcast/components/Modal/ModalManageTemplate.tsx

```tsx
// src/features/broadcast/components/Modal/ModalManageTemplate.tsx import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import useDataQuery from '@/hooks/useDataQuery' import useLicense from '@/hooks/useLicense' import type { BroadcastTemplate } from '@/libs/db' import db from '@/libs/db' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Stack, Text, TextInput, Title, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import MessageType from '../Datatable/MessageType' import ModalCreateUpdateTemplate from './ModalCreateUpdateTemplate' interface Props { opened: boolean onClose: () => void } const ModalManageTemplate: React.FC<Props> = ({ opened, onClose }) => { const license = useLicense() const dataQuery = useDataQuery<BroadcastTemplate>({ table: db.broadcastTemplates, }) const [editingTemplate, setEditingTemplate] = useState<Partial<BroadcastTemplate> | null>(null) const [showModalCreateUpdate, modalCreateUpdate] = useDisclosure(false) const handleDelete = async (template: BroadcastTemplate) => { if (!confirm('Are you sure you want to delete this template?')) return await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: template.id }) .delete() await db.broadcastTemplates.delete(template.id) } const handleEdit = (template: BroadcastTemplate) => { setEditingTemplate(template) modalCreateUpdate.open() } const handleClone = (template: BroadcastTemplate) => { const { id, ...restOfTemplate } = template const clonedTemplate = { ...restOfTemplate, name: `${template.name} (Copy)`, } setEditingTemplate(clonedTemplate) modalCreateUpdate.open() } const handleOpenCreateModal = () => { if (license.isFree() && dataQuery.totalRecords >= 1) { showModalUpgrade( 'Unlimited Templates', 'Upgrade to Pro to create and save an unlimited number of message templates.', ) return } setEditingTemplate(null) modalCreateUpdate.open() } const renderMessage = (broadcastTemplate: BroadcastTemplate) => { const { message } = broadcastTemplate if (!message) return '-' const typeContent = { [Message.TEXT]: typeof message === 'string' ? message : JSON.stringify(message), [Message.MEDIA]: (message as any).caption, [Message.IMAGE]: (message as any).caption, [Message.VIDEO]: (message as any).caption, [Message.FILE]: typeof message === 'string' ? message : (message as any).caption, [Message.BUTTON]: (message as any).title, [Message.LIST]: (message as any).title, [Message.LOCATION]: (message as any).name, [Message.POLL]: (message as any).name, [Message.VCARD]: '-', } return typeContent[broadcastTemplate.type] || JSON.stringify(message) } return ( <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack> <Center> <Title order={3}>Manage Templates</Title> </Center> <Stack gap="md" p={'md'}> {/* MODIFIED: Added a search input and grouped it with the add button */} <Group justify="space-between"> <TextInput placeholder={`Search by ${dataQuery.searchField}...`} size="sm" value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} style={{ flex: 1 }} /> <Button size="sm" leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={handleOpenCreateModal} > Add Template </Button> </Group> <DataTable records={dataQuery?.data} totalRecords={dataQuery?.totalRecords} recordsPerPage={dataQuery?.pageSize} page={dataQuery?.page} onPageChange={dataQuery?.setPage} minHeight={300} noRecordsText="No templates found" columns={[ { accessor: 'name' }, { accessor: 'type', render: (record) => <MessageType type={record.type} />, }, { accessor: 'message', title: 'Message', render: renderMessage }, { accessor: 'actions', title: <Text mr="xs">Actions</Text>, textAlign: 'right', width: '0%', render: (template: BroadcastTemplate) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Edit Template" position="top"> <ActionIcon color="blue" variant="subtle" onClick={() => handleEdit(template)} > <Icon icon="tabler:edit" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Clone Template" position="top"> <ActionIcon color="teal" variant="subtle" onClick={() => handleClone(template)} > <Icon icon="tabler:copy" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Delete Template" position="top"> <ActionIcon color="red" variant="subtle" onClick={async () => await handleDelete(template)} > <Icon icon="tabler:trash" fontSize={22} /> </ActionIcon> </Tooltip> </Group> ), }, ]} /> </Stack> <ModalCreateUpdateTemplate opened={showModalCreateUpdate} onClose={() => { modalCreateUpdate.close() setEditingTemplate(null) }} data={editingTemplate} /> </Stack> </Modal> ) } export default ModalManageTemplate
```

# src/features/broadcast/components/Modal/ModalSaveRecipientList.tsx

```tsx
// src/features/broadcast/components/Modal/ModalSaveRecipientList.tsx import Modal from '@/components/Modal/Modal' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import React from 'react' interface Props { opened: boolean onClose: () => void onSave: (name: string) => void isSaving: boolean } const ModalSaveRecipientList: React.FC<Props> = ({ opened, onClose, onSave, isSaving, }) => { const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => value.trim().length > 0 ? null : 'List name is required', }, }) const handleSubmit = (values: { name: string }) => { onSave(values.name) } const handleClose = () => { form.reset() onClose() } return ( <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Save Recipient List</Title> </Center> <TextInput label="List Name" placeholder="e.g., Weekly Newsletter Leads" {...form.getInputProps('name')} data-autofocus /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button type="submit" loading={isSaving}> Save List </Button> </Group> </Stack> </form> </Modal> ) } export default ModalSaveRecipientList
```

# src/features/broadcast/components/Modal/ModalSourceExcel.tsx

```tsx
import Modal from '@/components/Modal/Modal' import ExcelUploadPopover from '@/features/broadcast/components/Excel/ExcelUploadPopover' import { Center, Stack, Title } from '@mantine/core' import React from 'react' import ExcelUploader from '../Excel/ExcelUploader' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } const ModalSourceExcel: React.FC<Props> = ({ opened, onClose, onSubmit }) => { // This handler receives the raw parsed data from the uploader and formats it // for the broadcast recipient list before passing it up to the parent. const handleConfirmUpload = (parsedData: any[]) => { const newRecipients = parsedData .map((item) => ({ number: item.number?.toString(), name: item.name?.toString() || 'From Excel', source: 'Excel', })) .filter((item) => item.number) if (newRecipients.length > 0) { onSubmit(newRecipients) } } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Numbers From Excel</Title> </Center> <ExcelUploader onConfirm={handleConfirmUpload} onClose={onClose} /> </Stack> </Modal> ) } export default ModalSourceExcel
```

# src/features/broadcast/components/Modal/ModalSourceGroups.tsx

```tsx
// src/features/broadcast/components/Modal/ModalSourceGroups.tsx import Modal from '@/components/Modal/Modal' import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Avatar, Button, Card, Center, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' // ++ ADDED: Import useDebouncedValue for search input debouncing import { useDebouncedValue } from '@mantine/hooks' import React, { useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } /** * @component ModalSourceGroups * @description A modal component to select recipients from the user's WhatsApp groups. * It now includes a search functionality and displays group avatars for better identification. */ const ModalSourceGroups: React.FC<Props> = ({ opened, onClose, onSubmit }) => { const { groups } = useAppStore() const [selectedGroups, setSelectedGroups] = useState<string[]>([]) const [searchQuery, setSearchQuery] = useState('') // ++ ADDED: Debounce the search query with a 300ms delay to improve performance. const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) // -- MODIFIED: This improves performance by re-computing the list only when groups or the debounced search query change. const filteredGroups = useMemo(() => { if (!groups) return [] if (!debouncedSearchQuery) return groups const lowerCaseQuery = debouncedSearchQuery.toLowerCase() return groups.filter((group: any) => group.name.toLowerCase().includes(lowerCaseQuery), ) }, [groups, debouncedSearchQuery]) // ++ ADDED: Check if all currently filtered groups are selected. const allFilteredSelected = filteredGroups.length > 0 && filteredGroups.every((group) => selectedGroups.includes(group.id)) // ++ ADDED: Handler to toggle selection for all filtered groups. const handleToggleSelectAll = () => { if (allFilteredSelected) { // If all are selected, deselect only the filtered ones const filteredGroupIds = new Set(filteredGroups.map((g) => g.id)) setSelectedGroups((prev) => prev.filter((id) => !filteredGroupIds.has(id)), ) } else { // If not all are selected, add all filtered ones to the selection const filteredGroupIds = filteredGroups.map((g) => g.id) setSelectedGroups((prev) => [...new Set([...prev, ...filteredGroupIds])]) } } const handleToggleGroup = (groupId: string) => { setSelectedGroups((prev) => prev.includes(groupId) ? prev.filter((id) => id !== groupId) : [...prev, groupId], ) } const handleSubmit = () => { const finalRecipients = groups ?.filter((group: any) => selectedGroups.includes(group.id)) .map((group: any) => ({ number: group.id, // The group's ID (e.g., xxxxx@g.us) name: group.name, // The group's name source: 'Group', // The source identifier })) || [] onSubmit(finalRecipients) handleClose() } const handleClose = () => { setSelectedGroups([]) setSearchQuery('') // Reset search on close onClose() } return ( <> <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Recipients from Groups</Title> </Center> <TextInput placeholder="Search groups by name..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={groups.length === 0} /> <When condition={groups.length === 0}> <Center h={200}> <Loader /> <Text ml="md">Loading groups...</Text> </Center> </When> <When condition={groups.length > 0}> {/* ++ ADDED: "Select All" checkbox appears when there are filterable groups. */} {filteredGroups.length > 0 && ( <Checkbox label={allFilteredSelected ? 'Deselect All' : 'Select All'} checked={allFilteredSelected} onChange={handleToggleSelectAll} /> )} <ScrollArea h={300}> {filteredGroups.length > 0 ? ( <Stack> {filteredGroups.map((group: any) => ( <Card key={group.id} withBorder p="xs" radius="sm" shadow="none" style={{ cursor: 'pointer' }} onClick={() => handleToggleGroup(group.id)} > <Group wrap="nowrap"> <Checkbox checked={selectedGroups.includes(group.id)} readOnly aria-label={`Select group ${group.name}`} /> <Avatar src={group.avatar} radius="xl" variant="filled"> {group.name.charAt(0).toUpperCase()} </Avatar> <Text size="sm">{group.name}</Text> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No groups match your search.</Text> </Center> )} </ScrollArea> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedGroups.length === 0} > Add {selectedGroups.length} Group(s) </Button> </Group> </Stack> </Modal> </> ) } export default ModalSourceGroups
```

# src/features/broadcast/components/Modal/ModalSourceManual.tsx

```tsx
// src/features/broadcast/components/Modal/ModalSourceManual.tsx import Modal from '@/components/Modal/Modal' import { Button, Center, Group, ScrollArea, Stack, Textarea, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import React from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (numbers: string[]) => void } const ModalSourceManual: React.FC<Props> = ({ opened, onClose, onSubmit }) => { const form = useForm({ // MODIFIED: Changed initial value to a string to support the Textarea component. initialValues: { numbers: '', }, // MODIFIED: Adapted validation to check if the trimmed string is empty. validate: { numbers: (value) => value.trim().length === 0 ? 'Please enter at least one number.' : null, }, }) /** * English: Handles form submission by parsing the newline-separated numbers * from the textarea, cleaning them, ensuring uniqueness, and then * passing the result to the parent component. */ const handleSubmit = (values: { numbers: string }) => { // 1. Split the string by newlines. // 2. Clean each line by removing non-numeric characters (except '+') and trimming whitespace. // 3. Filter out any empty lines that might result from the split. const cleanedNumbers = values.numbers .split('\n') .map((num) => num.replace(/[^0-9+]/g, '').trim()) .filter((num) => num.length > 0) // Use a Set to automatically handle duplicates before submitting. const uniqueNumbers = [...new Set(cleanedNumbers)] onSubmit(uniqueNumbers) form.reset() onClose() } return ( <> <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Add Numbers Manually</Title> </Center> {/* MODIFIED: Replaced TagsInput with a more suitable Textarea for lists. */} <ScrollArea h={200}> <Textarea label="Phone Numbers" placeholder="Enter one number per line, including the country code." {...form.getInputProps('numbers')} autosize minRows={5} data-autofocus /> </ScrollArea> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Add Numbers</Button> </Group> </Stack> </form> </Modal> </> ) } export default ModalSourceManual
```

# src/features/broadcast/components/Modal/ModalSourceMyContacts.tsx

```tsx
// src/features/broadcast/components/Modal/ModalSourceMyContacts.tsx import Modal from '@/components/Modal/Modal' import wa from '@/libs/wa' import { getContactName } from '@/utils/util' import { Icon } from '@iconify/react' import { Avatar, Button, Card, Center, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' // ++ ADDED: Import useDebouncedValue hook import { useDebouncedValue } from '@mantine/hooks' import React, { useEffect, useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } /** * @component ModalSourceMyContacts * @description A modal for fetching, displaying, and selecting from a user's saved contact list. * It is optimized to fetch data only when opened and uses memoization for efficient searching. */ const ModalSourceMyContacts: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const [contacts, setContacts] = useState<any[]>([]) const [loading, setLoading] = useState(true) const [selectedContacts, setSelectedContacts] = useState<string[]>([]) const [searchQuery, setSearchQuery] = useState('') // ++ ADDED: Debounce the search input value to avoid excessive re-renders during typing. const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) // Fetch contacts only when the modal is opened to improve performance. useEffect(() => { if (opened) { const fetchContacts = async () => { setLoading(true) try { const contactList = await wa.contact.list({ onlyMyContacts: true }) // Sort the contact list by name in ascending order. const sortedContacts = [...contactList].sort((a, b) => getContactName(a).localeCompare(getContactName(b)), ) setContacts(sortedContacts) } catch (error) { console.error('Failed to fetch contacts:', error) setContacts([]) // Ensure contacts is an array on error } finally { setLoading(false) } } fetchContacts() } else { // Reset state when the modal is closed to ensure fresh data next time. setContacts([]) setSelectedContacts([]) setSearchQuery('') } }, [opened]) // -- MODIFIED: Memoize the filtered contacts to prevent re-calculation on every render, using the debounced value. const filteredContacts = useMemo(() => { if (!debouncedSearchQuery) return contacts const lowerCaseQuery = debouncedSearchQuery.toLowerCase() return contacts.filter( (c) => getContactName(c).toLowerCase().includes(lowerCaseQuery) || c.phoneNumber?.includes(lowerCaseQuery), ) }, [contacts, debouncedSearchQuery]) // ++ ADDED: Determines if all currently filtered contacts are selected. const allFilteredSelected = filteredContacts.length > 0 && filteredContacts.every((contact) => selectedContacts.includes(contact.id)) // ++ ADDED: Toggles the selection of all contacts visible in the filtered list. const handleToggleSelectAll = () => { if (allFilteredSelected) { // If all are selected, deselect only the filtered ones from the state const filteredContactIds = new Set(filteredContacts.map((c) => c.id)) setSelectedContacts((prev) => prev.filter((id) => !filteredContactIds.has(id)), ) } else { // Otherwise, add all filtered contacts to the selection, avoiding duplicates const filteredContactIds = filteredContacts.map((c) => c.id) setSelectedContacts((prev) => [ ...new Set([...prev, ...filteredContactIds]), ]) } } // Handles toggling the selection of a single contact. const handleToggleContact = (contactId: string) => { setSelectedContacts((prev) => prev.includes(contactId) ? prev.filter((id) => id !== contactId) : [...prev, contactId], ) } // Resets component state and calls the parent's onClose handler. const handleClose = () => { onClose() } // Submits the selected contacts to the parent component. const handleSubmit = () => { const finalRecipients = contacts .filter((c) => selectedContacts.includes(c.id)) .map((contact) => ({ number: contact.number, name: getContactName(contact), })) onSubmit(finalRecipients) handleClose() } return ( <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Recipients from My Contacts</Title> </Center> <TextInput placeholder="Search contacts by name or number..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={loading || contacts.length === 0} /> <When condition={loading}> <Center h={300}> <Loader /> <Text ml="md">Loading your contacts...</Text> </Center> </When> <When condition={!loading && contacts.length > 0}> {/* ++ ADDED: "Select All" checkbox for contacts */} {filteredContacts.length > 0 && ( <Checkbox label={allFilteredSelected ? 'Deselect All' : 'Select All'} checked={allFilteredSelected} onChange={handleToggleSelectAll} /> )} <ScrollArea h={400}> {filteredContacts.length > 0 ? ( <Stack> {filteredContacts.map((contact) => ( <Card key={contact.id} withBorder p="xs" radius="sm" shadow="none" style={{ cursor: 'pointer' }} onClick={() => handleToggleContact(contact.id)} > <Group wrap="nowrap"> <Checkbox checked={selectedContacts.includes(contact.id)} readOnly aria-label={`Select contact ${getContactName(contact)}`} /> <Avatar src={contact.avatar} radius="xl" variant="filled"> {getContactName(contact).charAt(0).toUpperCase()} </Avatar> <Stack gap={0}> <Text size="sm">{getContactName(contact)}</Text> <Text size="xs" c="dimmed"> {contact.phoneNumber} </Text> </Stack> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No contacts match your search.</Text> </Center> )} </ScrollArea> </When> <When condition={!loading && contacts.length === 0}> <Center h={300}> <Text c="dimmed">No saved contacts found.</Text> </Center> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedContacts.length === 0} > Add {selectedContacts.length} Contact(s) </Button> </Group> </Stack> </Modal> ) } export default ModalSourceMyContacts
```

# src/features/broadcast/components/Preview/MessagePreview.tsx

```tsx
// src/features/broadcast/components/Preview/MessagePreview.tsx import { Message } from '@/constants' import parse from '@/utils/parse' import { Icon } from '@iconify/react' import { Box, Group, Paper, Stack, Text, Title } from '@mantine/core' import React from 'react' interface Props { type: string message: any } // A sample contact to use for populating variables like {name} and {number}. const sampleContact = { id: '1234567890@c.us', number: '1234567890@c.us', name: 'John Doe', status: 'PENDING', broadcastId: 0, } /** * @component MessagePreview * @description Renders a real-time preview of a broadcast message, * simulating how it would look in a WhatsApp chat. */ const MessagePreview: React.FC<Props> = ({ type, message }) => { const renderContent = () => { let content: string | null = null switch (type) { case Message.TEXT: content = message break case Message.IMAGE: case Message.VIDEO: case Message.FILE: content = message?.caption || '' break default: content = null } if (content === null) { return ( <Text c="dimmed" fs="italic" size="sm"> Live preview is not available for this message type. </Text> ) } // Parse for variables and Spintax //@ts-ignore const parsedContent = parse.text(content, sampleContact) // Simple formatter for WhatsApp styling (*bold*, _italic_, ~strike~) const formattedContent = parsedContent .replace(/\*(.*?)\*/g, '<b>$1</b>') .replace(/_(.*?)_/g, '<i>$1</i>') .replace(/~(.*?)~/g, '<s>$1</s>') .replace(/\n/g, '<br />') return ( <Text size="sm" dangerouslySetInnerHTML={{ __html: formattedContent }} /> ) } const renderMediaPlaceholder = () => { const placeholders = { [Message.IMAGE]: { icon: 'tabler:photo', label: 'Image' }, [Message.VIDEO]: { icon: 'tabler:video', label: 'Video' }, [Message.FILE]: { icon: 'tabler:file-text', label: 'File' }, } const placeholder = placeholders[type] if (!placeholder) return null return ( <Box p="sm" bg="gray.1"> <Group> <Icon icon={placeholder.icon} fontSize={24} color="gray" /> <Text c="dimmed" size="sm"> {placeholder.label} Preview </Text> </Group> </Box> ) } return ( <Paper p="md" withBorder shadow="none" radius="md"> <Stack> <Group> <Icon icon="tabler:eye" /> <Title order={5}>Live Preview</Title> </Group> <Paper shadow="xs" p="sm" radius="md" style={{ backgroundColor: '#e6ffda', // WhatsApp outgoing bubble color alignSelf: 'flex-start', }} > <Stack gap={4}> {renderMediaPlaceholder()} {renderContent()} </Stack> </Paper> </Stack> </Paper> ) } export default MessagePreview
```

# src/features/broadcast/helpers/broadcastActions.ts

```ts
// src/features/Broadcast/helpers/broadcastActions.ts import { Message } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import wa from '@/libs/wa' import MediaModel from '@/models/MediaModel' import parse from '@/utils/parse' import throwError from '@/utils/throwError' import { generateRandomDelay } from '@/utils/util' /** * @description Returns the appropriate sending function based on broadcast type. * @param {Broadcast} broadcast - The parent broadcast record. * @param {BroadcastContact} contact - The recipient contact. * @returns {Function | null} The async function to send the message, or null. */ export const getBroadcastAction = ( broadcast: Broadcast, contact: BroadcastContact, ) => { const sendOptions = { ...(broadcast.isTyping && { delay: generateRandomDelay(1000, 3000) }), } const actions: { [key: string]: () => Promise<any> } = { [Message.TEXT]: async () => { // MODIFIED: Use the synchronous parse.text function, passing the full contact object. // This is more performant as it avoids an unnecessary API call. const text = parse.text(broadcast.message as string, contact) return wa.send.text(contact.number, text, sendOptions) }, [Message.IMAGE]: async () => { const file = await MediaModel.firstByBroadcastId(broadcast.id) if (!file) throwError.mediaNotFound() const message = broadcast.message as { caption?: string } return wa.send.file(contact.number, file.file, { type: 'image', caption: message.caption, ...sendOptions, }) }, [Message.VIDEO]: async () => { const file = await MediaModel.firstByBroadcastId(broadcast.id) if (!file) throwError.mediaNotFound() const message = broadcast.message as { caption?: string } return wa.send.file(contact.number, file.file, { type: 'video', caption: message.caption, ...sendOptions, }) }, [Message.FILE]: async () => { const file = await MediaModel.firstByBroadcastId(broadcast.id) if (!file) throwError.mediaNotFound() return wa.send.file(contact.number, file.file, { type: 'document', caption: broadcast.message as string, ...sendOptions, }) }, [Message.LOCATION]: async () => { const message = broadcast.message as any return wa.send.location(contact.number, { ...message, ...sendOptions }) }, [Message.POLL]: async () => { const { name, choices } = broadcast.message as any return wa.send.poll(contact.number, name, choices, sendOptions) }, [Message.VCARD]: async () => { return wa.send.vcard( contact.number, broadcast.message as any[], sendOptions, ) }, } return actions[broadcast.type] || null }
```

# src/features/broadcast/hooks/useBroadcast.ts

```ts
// src/features/Broadcast/hooks/useBroadcast.ts import { Status } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import wa from '@/libs/wa' import BroadcastContactModel from '@/models/BroadcastContactModel' import BroadcastModel from '@/models/BroadcastModel' import toast from '@/utils/toast' import { delay } from '@/utils/util' import dayjs from 'dayjs' import _ from 'lodash' import { useRef } from 'react' import { getBroadcastAction } from '../helpers/broadcastActions' /** * @hook useBroadcast * @description Manages the entire broadcast queue processing logic. * It uses a state machine ('IDLE', 'PROCESSING') to prevent concurrent runs * and processes pending messages in a linear loop. */ const useBroadcast = () => { const processingState = useRef<'IDLE' | 'PROCESSING'>('IDLE') const runBroadcast = async ( broadcast: Broadcast, contact: BroadcastContact, ) => { if (broadcast.validateNumbers) { const isValid = await wa.contact.isExist(contact.number) if (!isValid) { throw new Error('Contact does not exist on WhatsApp.') } } const action = getBroadcastAction(broadcast, contact) if (action) { await action() } else { throw new Error(`Unsupported broadcast message type: ${broadcast.type}`) } } const checkAllContactsDone = async (broadcast: Broadcast) => { const pendingCount = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.PENDING }) .count() const runningCount = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.RUNNING }) .count() if (pendingCount === 0 && runningCount === 0) { const freshBroadcast = await BroadcastModel.get(broadcast.id) if (freshBroadcast.status === Status.PAUSED) { return } await BroadcastModel.success(broadcast.id) toast.success( `Broadcast "${broadcast.name || 'Untitled'}" has been completed.`, ) } } const processBroadcastQueue = async () => { if (processingState.current === 'PROCESSING') return processingState.current = 'PROCESSING' try { while (true) { const contacts = await BroadcastContactModel.getStatusPendingBatch(20) if (!contacts.length) break const contactsByBroadcast = _.groupBy(contacts, 'broadcastId') for (const broadcastIdStr in contactsByBroadcast) { const broadcastId = parseInt(broadcastIdStr, 10) const contactGroup = contactsByBroadcast[broadcastId] const broadcast = await BroadcastModel.get(broadcastId) if (!broadcast) { const contactIds = contactGroup.map((c) => c.id) await db.broadcastContacts .bulkUpdate( contactIds.map((id) => ({ key: id, changes: { status: Status.FAILED, error: 'Broadcast record missing.', }, })), ) .catch(console.error) continue } // MODIFIED: Fetch the count of successfully sent messages for this broadcast. let successfulCountForBroadcast = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.SUCCESS }) .count() if (broadcast.smartPauseEnabled) { const now = new Date() const currentTime = now.getHours() * 60 + now.getMinutes() const [startH, startM] = broadcast.smartPauseStart .split(':') .map(Number) const [endH, endM] = broadcast.smartPauseEnd.split(':').map(Number) const startTime = startH * 60 + startM const endTime = endH * 60 + endM if (currentTime < startTime || currentTime > endTime) { if (broadcast.status !== Status.PAUSED) { await BroadcastModel.pause(broadcast.id) } continue } } if (broadcast.status !== Status.RUNNING) { await BroadcastModel.running(broadcast.id) } for (const contact of contactGroup) { if (!validationRef.current) return try { await BroadcastContactModel.running(contact.id) // MODIFIED: Implemented the core warm-up delay logic. const isWarmupPhase = broadcast.warmupModeEnabled && successfulCountForBroadcast < 20 const randomDelay = isWarmupPhase ? Math.floor(Math.random() * (30000 - 15000 + 1)) + 15000 // 15-30s delay for warm-up : Math.floor( Math.random() * (broadcast.delayMax - broadcast.delayMin + 1), ) + broadcast.delayMin // User-defined delay await delay(randomDelay) await runBroadcast(broadcast, contact) await BroadcastContactModel.success(contact.id) successfulCountForBroadcast++ // Increment count for the next message in this broadcast. } catch (error: any) { await BroadcastContactModel.failed(contact.id, error.message) } } if (broadcast.batchEnabled) { const successfulCount = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.SUCCESS }) .count() const pendingCount = await db.broadcastContacts .where({ broadcastId: broadcast.id, status: Status.PENDING }) .count() if ( successfulCount > 0 && successfulCount % broadcast.batchSize === 0 && pendingCount > 0 ) { const resumeAt = dayjs() .add(broadcast.batchDelay, 'minutes') .toDate() await db.broadcasts.update(broadcast.id, { status: Status.PAUSED, resumeAt: resumeAt, }) continue } } await checkAllContactsDone(broadcast) } } } catch (e) { console.error( 'An unexpected error occurred in the broadcast processor:', e, ) } finally { processingState.current = 'IDLE' } } const checkScheduledAndPaused = async () => { const now = new Date() await db.broadcastContacts .where('status') .equals(Status.SCHEDULER) .and((contact) => dayjs(contact.scheduledAt).isBefore(now)) .modify({ status: Status.PENDING }) const pausedBroadcasts = await db.broadcasts .where('status') .equals(Status.PAUSED) .toArray() for (const broadcast of pausedBroadcasts) { if (broadcast.smartPauseEnabled && !broadcast.resumeAt) { const currentTime = now.getHours() * 60 + now.getMinutes() const [startH, startM] = broadcast.smartPauseStart .split(':') .map(Number) const [endH, endM] = broadcast.smartPauseEnd.split(':').map(Number) const startTime = startH * 60 + startM const endTime = endH * 60 + endM if (currentTime >= startTime && currentTime <= endTime) { await BroadcastModel.pending(broadcast.id) } } if ( broadcast.batchEnabled && broadcast.resumeAt && dayjs(broadcast.resumeAt).isBefore(now) ) { await db.broadcasts.update(broadcast.id, { status: Status.PENDING, resumeAt: null, }) } } await processBroadcastQueue() } const validationRef = useRef(true) const cancel = async (broadcastId: number) => { validationRef.current = false while (processingState.current === 'PROCESSING') { await delay(200) } processingState.current = 'PROCESSING' try { await db.broadcastContacts .where({ broadcastId }) .and((c) => [Status.PENDING, Status.SCHEDULER, Status.RUNNING].includes(c.status), ) .modify({ status: Status.CANCELLED, error: 'Cancelled by user' }) await BroadcastModel.cancel(broadcastId) toast.info('Broadcast has been cancelled.') } catch (e) { console.error(`Error during cancellation of broadcast ${broadcastId}:`, e) toast.error('Failed to cancel broadcast.') } finally { validationRef.current = true processingState.current = 'IDLE' } } const initializeBroadcaster = async () => { await BroadcastContactModel.resetRunningStatuses() await processBroadcastQueue() } return { init: initializeBroadcaster, checkScheduled: checkScheduledAndPaused, cancel, } } export default useBroadcast
```

# src/features/broadcast/hooks/useRecipientManager.ts

```ts
// src/features/broadcast/hooks/useRecipientManager.ts import useFile from '@/hooks/useFile' import db from '@/libs/db' import toast from '@/utils/toast' import { useDebouncedValue, useDisclosure } from '@mantine/hooks' import _ from 'lodash' import type { DataTableSortStatus } from 'mantine-datatable' import { useEffect, useMemo, useState } from 'react' interface Recipient { number: string name: string source?: string } interface useRecipientManagerProps { initialRecipients: Recipient[] } const PAGE_SIZE = 10 /** * @hook useRecipientManager * @description Manages all state and logic for the recipient management modal. */ export const useRecipientManager = ({ initialRecipients, }: useRecipientManagerProps) => { // State for data and UI const [recipients, setRecipients] = useState<Recipient[]>([]) const [selectedRecords, setSelectedRecords] = useState<Recipient[]>([]) const [editingRecipient, setEditingRecipient] = useState<Recipient | null>( null, ) const [page, setPage] = useState(1) const [searchQuery, setSearchQuery] = useState('') const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) const [sortStatus, setSortStatus] = useState<DataTableSortStatus>({ columnAccessor: 'name', direction: 'asc', }) const [editingCell, setEditingCell] = useState<{ recordId: string columnId: string } | null>(null) const [editValue, setEditValue] = useState('') const [isSaving, setIsSaving] = useState(false) const [listToLoad, setListToLoad] = useState<{ name: string recipients: Recipient[] } | null>(null) // Modal handlers const [showManualModal, manualModalHandlers] = useDisclosure(false) const [showExcelModal, excelModalHandlers] = useDisclosure(false) const [showGroupsModal, groupsModalHandlers] = useDisclosure(false) const [showEditModal, editModalHandlers] = useDisclosure(false) const [showMyContactsModal, myContactsModalHandlers] = useDisclosure(false) const [showSaveListModal, saveListModalHandlers] = useDisclosure(false) const [showLoadListModal, loadListModalHandlers] = useDisclosure(false) const [showConfirmLoadModal, confirmLoadModalHandlers] = useDisclosure(false) const fileExporter = useFile() // Effect to initialize or reset state when the modal opens useEffect(() => { setRecipients(_.cloneDeep(initialRecipients)) setSelectedRecords([]) setPage(1) setSearchQuery('') setSortStatus({ columnAccessor: 'name', direction: 'asc' }) }, [initialRecipients]) // Memoized filtering and sorting const filteredAndSortedRecipients = useMemo(() => { let data = [...recipients] if (debouncedSearchQuery) { const lowerCaseQuery = debouncedSearchQuery.toLowerCase() data = data.filter( (r) => r.name?.toLowerCase().includes(lowerCaseQuery) || r.number?.toLowerCase().includes(lowerCaseQuery), ) } const { columnAccessor, direction } = sortStatus if (columnAccessor) { data = _.orderBy(data, [columnAccessor], [direction]) } return data }, [recipients, debouncedSearchQuery, sortStatus]) // Memoized pagination const paginatedRecipients = useMemo(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE return filteredAndSortedRecipients.slice(from, to) }, [filteredAndSortedRecipients, page]) // Effect to reset page number on search or sort change useEffect(() => { setPage(1) }, [debouncedSearchQuery, sortStatus]) // Handlers const handleAddRecipients = (newRecipients: any[]) => { const formatted = newRecipients.map((rec) => { if (typeof rec === 'string') { return { number: rec, name: 'N/A', source: 'Manual' } } return { number: rec.number || rec.phoneNumber, name: rec.name || rec.savedName || rec.publicName || 'N/A', } }) const combined = [...recipients, ...formatted] const unique = _.uniqBy(combined, 'number') setRecipients(unique) const addedCount = unique.length - recipients.length toast.success(`${addedCount} recipient(s) added successfully.`) } const handleDeleteRecipient = (numberToDelete: string) => { setRecipients((current) => current.filter((r) => r.number !== numberToDelete), ) } const handleBulkDelete = () => { const numbersToDelete = new Set(selectedRecords.map((r) => r.number)) setRecipients((current) => current.filter((r) => !numbersToDelete.has(r.number)), ) setSelectedRecords([]) toast.success(`${numbersToDelete.size} recipient(s) deleted.`) } const handleOpenEditModal = (recipient: Recipient) => { setEditingRecipient(recipient) editModalHandlers.open() } const handleUpdateRecipientFromModal = ( originalNumber: string, updatedData: { number: string; name: string }, ) => { const isDuplicate = recipients.some( (r) => r.number === updatedData.number && r.number !== originalNumber, ) if (isDuplicate) { toast.error(`The number ${updatedData.number} already exists.`) return } setRecipients((current) => current.map((r) => r.number === originalNumber ? { ...r, name: updatedData.name, number: updatedData.number } : r, ), ) editModalHandlers.close() } const handleSaveCellEdit = () => { if (!editingCell) return const { recordId, columnId } = editingCell const finalValue = editValue.trim() if (columnId === 'number') { if (finalValue === '') { toast.error('Number cannot be empty.') return } const isDuplicate = recipients.some( (r) => r.number === finalValue && r.number !== recordId, ) if (isDuplicate) { toast.error(`The number ${finalValue} already exists.`) return } } setRecipients((current) => current.map((r) => r.number === recordId ? { ...r, [columnId]: finalValue || r[columnId] } : r, ), ) setEditingCell(null) } const handleSaveList = async (name: string) => { if (recipients.length === 0) return toast.error('Cannot save an empty list.') setIsSaving(true) try { await db.broadcastRecipients.add({ name, //@ts-ignore recipients, createdAt: new Date(), }) toast.success(`List "${name}" saved successfully.`) saveListModalHandlers.close() } catch (error) { toast.error('Failed to save the list.') } finally { setIsSaving(false) } } const handleLoadList = (list: { name: string; recipients: Recipient[] }) => { setListToLoad(list) confirmLoadModalHandlers.open() } const confirmLoadList = (mode: 'merge' | 'replace') => { if (!listToLoad) return if (mode === 'replace') { setRecipients(listToLoad.recipients) toast.success(`Loaded ${listToLoad.recipients.length} recipients.`) } else { const combined = [...recipients, ...listToLoad.recipients] const unique = _.uniqBy(combined, 'number') setRecipients(unique) const addedCount = unique.length - recipients.length toast.success(`${addedCount} new recipient(s) merged successfully.`) } confirmLoadModalHandlers.close() setListToLoad(null) } const handleExport = async (format: string) => { if (recipients.length === 0) return toast.info('No recipients to export.') const data = recipients.map((r) => ({ number: r.number, name: r.name })) await fileExporter.saveAs( format, data, `recipients_${new Date().toISOString().slice(0, 10)}`, ) } const handleClearAll = () => setRecipients([]) return { // State recipients, paginatedRecipients, filteredAndSortedRecipients, selectedRecords, editingRecipient, editingCell, editValue, isSaving, page, searchQuery, sortStatus, listToLoad, // State Setters setSelectedRecords, setPage, setSearchQuery, setSortStatus, setEditingCell, setEditValue, // Handlers handleAddRecipients, handleDeleteRecipient, handleBulkDelete, handleOpenEditModal, handleUpdateRecipientFromModal, handleSaveCellEdit, handleSaveList, handleLoadList, confirmLoadList, handleExport, handleClearAll, // Modal States and Handlers modals: { manual: { opened: showManualModal, ...manualModalHandlers }, excel: { opened: showExcelModal, ...excelModalHandlers }, groups: { opened: showGroupsModal, ...groupsModalHandlers }, edit: { opened: showEditModal, ...editModalHandlers }, myContacts: { opened: showMyContactsModal, ...myContactsModalHandlers }, saveList: { opened: showSaveListModal, ...saveListModalHandlers }, loadList: { opened: showLoadListModal, ...loadListModalHandlers }, confirmLoad: { opened: showConfirmLoadModal, ...confirmLoadModalHandlers, }, }, } }
```

# src/features/broadcast/PageBroadcast.tsx

```tsx
// src/features/broadcast/PageBroadcast.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Media, Status } from '@/constants' import useDataQuery from '@/hooks/useDataQuery' import useFile from '@/hooks/useFile' import type { Broadcast } from '@/libs/db' import db from '@/libs/db' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Box, Button, Group, LoadingOverlay, MultiSelect, Stack, TextInput, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import { DataTable } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' import { getBroadcastColumns } from './components/Datatable/BroadcastColumns' import ModalCreateBroadcast from './components/Modal/ModalCreateBroadcast' import ModalDetailHistory from './components/Modal/ModalDetailHistory' import ModalEditSchedule from './components/Modal/ModalEditSchedule' import useBroadcast from './hooks/useBroadcast' const PageBroadcast: React.FC = () => { const dataQuery = useDataQuery<Broadcast>({ table: db.broadcasts, initialPageSize: 10, searchField: 'name', initialSort: { field: 'id', direction: 'desc' }, }) const broadcastHook = useBroadcast() const fileExporter = useFile() const [selectedTags, setSelectedTags] = useState<string[]>([]) const allTags = useLiveQuery(async () => { const tagArrays = await db.broadcasts.where('tags').notEqual('').toArray() const tagSet = new Set<string>() tagArrays.forEach((b) => b.tags?.forEach((tag) => tagSet.add(tag))) return Array.from(tagSet).sort() }, []) || [] const allBroadcastContacts = useLiveQuery(() => db.broadcastContacts.toArray(), []) || [] const [showModalCreate, modalCreateHandlers] = useDisclosure(false) const [showModalDetail, modalDetailHandlers] = useDisclosure(false) const [showEditScheduleModal, editScheduleModalHandlers] = useDisclosure(false) const [editingBroadcast, setEditingBroadcast] = useState<Broadcast | null>( null, ) const [detailData, setDetailData] = useState<Broadcast | null>(null) const [cloneData, setCloneData] = useState< (Broadcast & { recipients?: any[] }) | null >(null) const [isExporting, setIsExporting] = useState(false) const [selectedRecords, setSelectedRecords] = useState<Broadcast[]>([]) useEffect(() => { const otherFilters = dataQuery.filters.filter((f) => f.field !== 'tags') || [] if (selectedTags.length > 0) { dataQuery.setFilters([ ...otherFilters, { field: 'tags', operator: 'anyOf', value: selectedTags, }, ]) } else { dataQuery.setFilters(otherFilters) } }, [selectedTags]) const broadcastStatsMap = useMemo(() => { const statsMap = new Map< number, { total: number success: number pending: number running: number failed: number scheduled: number cancelled: number firstError?: string scheduledAt?: Date } >() for (const contact of allBroadcastContacts) { if (!statsMap.has(contact.broadcastId)) { statsMap.set(contact.broadcastId, { total: 0, success: 0, pending: 0, running: 0, failed: 0, scheduled: 0, cancelled: 0, }) } const stats = statsMap.get(contact.broadcastId)! stats.total++ switch (contact.status) { case Status.SUCCESS: stats.success++ break case Status.PENDING: stats.pending++ break case Status.RUNNING: stats.running++ break case Status.FAILED: stats.failed++ if (!stats.firstError && contact.error) { stats.firstError = contact.error } break case Status.SCHEDULER: stats.scheduled++ if (!stats.scheduledAt && contact.scheduledAt) { stats.scheduledAt = contact.scheduledAt } break case Status.CANCELLED: stats.cancelled++ break } } return statsMap }, [allBroadcastContacts]) const handleOpenCreateModal = ( dataToClone: (Broadcast & { recipients?: any[] }) | null = null, ) => { setCloneData(dataToClone) modalCreateHandlers.open() } const handleCreateFollowUp = async ( broadcast: Broadcast, type: 'SUCCESS' | 'FAILED' | 'ALL', ) => { modalDetailHandlers.close() const query = db.broadcastContacts.where({ broadcastId: broadcast.id }) let recipientsQuery let nameSuffix = '' if (type === 'SUCCESS') { recipientsQuery = query.filter((c) => c.status === Status.SUCCESS) nameSuffix = ' (Follow-up: Success)' } else if (type === 'FAILED') { recipientsQuery = query.filter((c) => c.status === Status.FAILED) nameSuffix = ' (Follow-up: Failed)' } else { recipientsQuery = query nameSuffix = ' (Follow-up: All)' } const recipients = await recipientsQuery.toArray() if (recipients.length === 0) { toast.info(`No recipients found for status: ${type}`) return } const newRecipients = recipients.map((c) => ({ number: c.number, name: c.name, })) const dataToClone = { ...broadcast, name: `${broadcast.name || 'Broadcast'}${nameSuffix}`, recipients: newRecipients, } handleOpenCreateModal(dataToClone) } const handleViewDetails = (broadcast: Broadcast) => { setDetailData(broadcast) modalDetailHandlers.open() } const handleEditSchedule = (broadcast: Broadcast) => { const stats = broadcastStatsMap.get(broadcast.id) if (stats && stats.scheduledAt) { const broadcastWithSchedule = { ...broadcast, scheduledAt: stats.scheduledAt, } setEditingBroadcast(broadcastWithSchedule as Broadcast) editScheduleModalHandlers.open() } else { toast.error('Could not find schedule information for this broadcast.') } } const handleUpdateSchedule = async ( broadcastId: number, newScheduledAt: Date, ) => { try { await db.broadcastContacts .where({ broadcastId: broadcastId, status: Status.SCHEDULER }) .modify({ scheduledAt: newScheduledAt }) await db.broadcasts.update(broadcastId, { status: Status.SCHEDULER }) toast.success('Broadcast schedule updated successfully.') editScheduleModalHandlers.close() } catch (error) { console.error('Failed to update schedule:', error) toast.error('Failed to update the schedule.') } } const deleteBroadcasts = async (broadcastsToDelete: Broadcast[]) => { if (broadcastsToDelete.length === 0) return const isPlural = broadcastsToDelete.length > 1 const confirmationMessage = `Are you sure you want to delete ${ broadcastsToDelete.length } broadcast${isPlural ? 's' : ''}? This action is irreversible.` if (!confirm(confirmationMessage)) return try { const broadcastIds = broadcastsToDelete.map((b) => b.id) await db.transaction( 'rw', db.broadcasts, db.broadcastContacts, db.media, async () => { await db.broadcastContacts .where('broadcastId') .anyOf(broadcastIds) .delete() await db.media .where('parentId') .anyOf(broadcastIds) .and((item) => item.type === Media.BROADCAST) .delete() await db.broadcasts.bulkDelete(broadcastIds) }, ) toast.success( `${broadcastsToDelete.length} broadcast${ isPlural ? 's' : '' } deleted successfully.`, ) setSelectedRecords([]) } catch (error) { console.error('Failed to delete broadcast(s):', error) toast.error('Failed to delete the broadcast(s).') } } const handleDelete = (broadcast: Broadcast) => { deleteBroadcasts([broadcast]) } const handleBulkDelete = () => { deleteBroadcasts(selectedRecords) } const handleClearAll = async () => { const allBroadcasts = await db.broadcasts.toArray() if (allBroadcasts.length === 0) { toast.info('There are no broadcasts to clear.') return } await deleteBroadcasts(allBroadcasts) } const handleExport = async (broadcast: Broadcast, format: string) => { setIsExporting(true) try { const contacts = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .toArray() if (contacts.length === 0) { toast.info('No data to export.') return } const dataForExport = contacts.map((c) => ({ Name: c.name || '-', 'Number/ID': c.number.split('@')[0], Status: c.status, 'Sent At': c.sendAt ? dayjs(c.sendAt).format('YYYY-MM-DD HH:mm:ss') : '-', Error: c.error || '-', })) const filename = `broadcast_${ broadcast.name || broadcast.id }_${new Date().toISOString().slice(0, 10)}` await fileExporter.saveAs(format, dataForExport, filename) } catch (error) { console.error('Failed to export broadcast data:', error) toast.error('An error occurred during export.') } finally { setIsExporting(false) } } const columns = getBroadcastColumns( { onViewDetails: handleViewDetails, onClone: handleOpenCreateModal, onExport: handleExport, onCancel: broadcastHook.cancel, onDelete: handleDelete, onEditSchedule: handleEditSchedule, }, broadcastStatsMap, ) return ( <LayoutPage width={860}> <Stack style={{ height: '100%' }}> <Group justify="space-between" mb="md"> <Group> <TextInput placeholder="Search by Name..." value={dataQuery.search} size="sm" onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} /> <MultiSelect placeholder="Filter by tags..." data={allTags} value={selectedTags} onChange={setSelectedTags} leftSection={<Icon icon="tabler:tag" fontSize={16} />} size="sm" w={250} clearable /> </Group> <Group> {selectedRecords.length > 0 && ( <Button variant="outline" color="red" size="sm" leftSection={<Icon icon="tabler:trash" fontSize={18} />} onClick={handleBulkDelete} > Delete Selected ({selectedRecords.length}) </Button> )} {dataQuery.data && dataQuery.data.length > 0 && selectedRecords.length === 0 && ( <Button variant="default" color="red" size="sm" leftSection={<Icon icon="tabler:clear-all" fontSize={18} />} onClick={handleClearAll} > Clear All </Button> )} <Button size="sm" leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={() => handleOpenCreateModal()} > Create </Button> </Group> </Group> <Box style={{ position: 'relative' }}> <LoadingOverlay visible={isExporting || dataQuery.data === undefined} zIndex={1000} overlayProps={{ radius: 'sm', blur: 2 }} /> <DataTable selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} records={dataQuery.data} columns={columns} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} sortStatus={ dataQuery.sort ? { columnAccessor: dataQuery.sort.field, direction: dataQuery.sort.direction, } : undefined } onSortStatusChange={(status) => { if (typeof status.columnAccessor === 'string') { dataQuery.toggleSort(status.columnAccessor) } }} minHeight={560} noRecordsText="No broadcasts found" striped highlightOnHover withTableBorder borderRadius="sm" shadow="xs" verticalAlign="top" /> </Box> </Stack> <ModalCreateBroadcast opened={showModalCreate} onClose={() => { modalCreateHandlers.close() setCloneData(null) }} onSuccess={() => { modalCreateHandlers.close() setCloneData(null) }} cloneData={cloneData} /> <ModalDetailHistory opened={showModalDetail} onClose={modalDetailHandlers.close} data={detailData} onCreateFollowUp={handleCreateFollowUp} /> <ModalEditSchedule opened={showEditScheduleModal} onClose={editScheduleModalHandlers.close} onSubmit={handleUpdateSchedule} broadcastData={editingBroadcast} /> </LayoutPage> ) } export default PageBroadcast
```

# src/hooks/useAi.ts

```ts
// src/hooks/useAi.ts import { AI } from '@/constants/action' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' const useAi = () => { const rewriteMessage = async ( prompt: string, message: string, system: | string | null = 'You are an expert copywriter. Your task is to rewrite the user message based on their instruction.', ): Promise<Response<string>> => { // Send the request to the background relay defined in `ai.relay.ts` return await sendToBackgroundViaRelay({ //@ts-ignore name: 'ai', body: { prompt, message, system }, }) } return { rewriteMessage, } } export default useAi
```

# src/hooks/useDataQuery.ts

```ts
import type { EntityTable } from 'dexie' import { useLiveQuery } from 'dexie-react-hooks' import { useMemo, useState } from 'react' type SortDirection = 'asc' | 'desc' interface Sort { field: string direction: SortDirection } type SortState = Sort | null type FilterOperator = | 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'between' // ++ ADDED: A new operator to check for any matching item in an array. | 'anyOf' export interface Filter { field: string operator: FilterOperator value: any secondValue?: any } interface useDataQueryOptions<T> { //@ts-ignore table: EntityTable<T, 'id'> initialPageSize?: number searchField?: string initialSort?: Sort initialFilters?: Filter[] } export const useDataQuery = <T>(options: useDataQueryOptions<T>) => { const { table, initialPageSize = 10, searchField = 'name', initialSort = { field: 'id', direction: 'desc' }, initialFilters = [], } = options const [page, setPage] = useState(1) const [pageSize, setPageSize] = useState(initialPageSize) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<T[]>([]) const [sort, setSort] = useState<SortState>(initialSort) const [filters, setFilters] = useState<Filter[]>(initialFilters) const applyFilter = (query: any, filter: Filter) => { const { field, operator, value, secondValue } = filter switch (operator) { case 'equals': return query.filter((item: any) => item[field] === value) case 'contains': return query.filter((item: any) => String(item[field]) .toLowerCase() .includes(String(value).toLowerCase()), ) case 'startsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .startsWith(String(value).toLowerCase()), ) case 'endsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .endsWith(String(value).toLowerCase()), ) case 'greaterThan': return query.filter((item: any) => item[field] > value) case 'lessThan': return query.filter((item: any) => item[field] < value) case 'between': return query.filter( (item: any) => item[field] >= value && item[field] <= (secondValue ?? value), ) // ++ ADDED: Logic for the new 'anyOf' operator to handle tag filtering. case 'anyOf': if (!Array.isArray(value) || value.length === 0) { return query // If filter value is not a valid array, return original data. } return query.filter( (item: any) => Array.isArray(item[field]) && item[field].some((tag: any) => value.includes(tag)), ) default: return query } } const data = useLiveQuery( async () => { if (pageSize <= 0) return { data: [], totalItems: 0, hasMore: false } const startIndex = (page - 1) * pageSize let query = search ? table.where(searchField).startsWithIgnoreCase(search) : table.toCollection() let results = await query.toArray() filters.forEach((filter) => { results = applyFilter(results, filter) }) if (sort) { results.sort((a: any, b: any) => { const aValue = a[sort.field] const bValue = b[sort.field] if (aValue === bValue) return 0 const comparison = aValue > bValue ? 1 : -1 return sort.direction === 'asc' ? comparison : -comparison }) } const paginatedResults = results.slice(startIndex, startIndex + pageSize) return { data: paginatedResults, totalItems: results.length, hasMore: startIndex + paginatedResults.length < results.length, } }, [page, pageSize, search, sort, filters], // filters is now a dependency ) const _delete = async (id: any) => { if (confirm('Are you sure?')) { await table.delete(id) } } const toggleSort = (field: string) => { setSort((currentSort) => { if (!currentSort || currentSort.field !== field) { return { field, direction: 'asc' } } if (currentSort.direction === 'asc') { return { field, direction: 'desc' } } if (currentSort.direction === 'desc') { return null } return currentSort }) } const derivedData = useMemo( () => ({ data: data?.data ?? [], totalRecords: data?.totalItems ?? 0, hasMore: data?.hasMore ?? false, }), [data], ) return { ...derivedData, selectedRecords, page, pageSize, search, sort, filters, setPage, setPageSize, setSelectedRecords, setSearch, toggleSort, setFilters, // Expose setFilters directly _delete, searchField, } } export default useDataQuery
```

# src/hooks/useFile.ts

```ts
// src/utils/file.ts import { SaveAs, Setting } from '@/constants' import { storage } from '@/libs/storage' import FileSaver from 'file-saver' import _ from 'lodash' import * as XLSX from 'xlsx' import useLicense from './useLicense' const useFile = () => { const license = useLicense() const getSelectedColumns = async () => { return ( (await storage.get<Record<string, boolean>>(Setting.EXPORT_COLUMNS)) || { phoneNumber: true, publicName: true, savedName: true, isBlocked: true, isBusiness: true, isMyContact: true, } ) } const serializeData = async (data: any[]) => { const selectedColumns = await getSelectedColumns() let filteredData = data.map((item: any) => _.pickBy(item, (_, key) => selectedColumns[key] === true), ) if (license.isFree() && filteredData.length > 10) { filteredData = filteredData.map((item, index) => index >= 10 ? _.mapValues(item, () => '********') : item, ) } return filteredData } const defaultFilename = () => { return `export_${new Date().toISOString().slice(0, 10)}` } const saveAsCSV = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } const saveAsExcel = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet 1') XLSX.writeFile(workbook, `${filename}.xlsx`) } const saveAsJson = (data: any[], filename: string) => { const json = JSON.stringify(data, null, 2) const blob = new Blob([json], { type: 'application/json' }) FileSaver.saveAs(blob, `${filename}.json`) } const saveAsVCard = (data: any[]) => { const vcardContent = data .map((contact) => { const name = contact.savedName || contact.publicName || 'Unknown' const phone = contact.phoneNumber ? `+${contact.phoneNumber}` : '' return `BEGIN:VCARD\nVERSION:3.0\nFN:${name}\nTEL;TYPE=CELL:${phone}\nEND:VCARD` }) .join('\n') const blob = new Blob([vcardContent], { type: 'text/vcard' }) FileSaver.saveAs(blob, `${defaultFilename()}.vcf`) } /** * Main function to save data in various formats. * @param fileType The format to save as (e.g., 'csv', 'xlsx'). * @param data The array of data objects to save. * @param filename (Optional) The base name for the file, without extension. */ const saveAs = async (fileType: string, data: any[], filename?: string) => { const processedData = await serializeData(data) const finalFilename = filename || defaultFilename() switch (fileType) { case SaveAs.CSV: saveAsCSV(processedData, finalFilename) break case SaveAs.EXCEL: saveAsExcel(processedData, finalFilename) break case SaveAs.JSON: saveAsJson(processedData, finalFilename) break case SaveAs.VCARD: saveAsVCard(processedData) // VCard has its own filename logic break // Other formats like Markdown and HTML can be added here. default: console.error(`Unsupported file type: ${fileType}`) break } } return { saveAs } } export default useFile
```

# src/hooks/useLicense.ts

```ts
// src/hooks/useLicense.ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import type { License } from '@/types' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { sendToBackground } from '@plasmohq/messaging' import { isPast } from 'date-fns' // English: Define a type for the cache entry, including the data and a timestamp. interface CachedLicense { data: License timestamp: number } const useLicense = () => { const { license, setLicense } = useAppStore() const callLemonSqueezyApi = async (action: string, body: any) => { return await sendToBackground({ name: 'lemonsqueezy', body: { action, body }, }) } const init = async () => { // Check for a cached license entry. const cachedEntry = await storage.get<CachedLicense | null>( Setting.LICENSE_DATA_CACHE, ) // MODIFIED: The time-based staleness check has been removed. // Now, if a cached license exists and its status is 'active', it will be used indefinitely. // This prevents unnecessary API calls and ensures the license is "cached forever". if (cachedEntry && cachedEntry.data.license_key.status === 'active') { setLicense(cachedEntry.data) return } // If no valid cache, proceed with the standard validation flow. const licenseKey = await storage.get<string | null>(Setting.LICENSE_KEY) if (!licenseKey) { setLicense(null) await storage.remove(Setting.LICENSE_DATA_CACHE) return } const response = await callLemonSqueezyApi('validateLicense', { licenseKey, }) if (response.error) { // Validation failed, clear all license-related storage. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is invalid or has been deactivated. You have been switched to the Free plan.', 'License Invalid', ) return } if (response.data.meta.store_id.toString() !== getStoreId()) { await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is for a different product. You have been switched to the Free plan.', 'License Error', ) return } // Validation successful, update app state and cache the license data if active. setLicense(response.data) if (response.data.license_key.status === 'active') { // Store the license data along with the current timestamp. const cacheEntry: CachedLicense = { data: response.data, timestamp: Date.now(), } await storage.set(Setting.LICENSE_DATA_CACHE, cacheEntry) } if ( response.data.license_key.expires_at && isPast(new Date(response.data.license_key.expires_at)) ) { toast.info( 'Your license has expired. You have been switched to the Free plan.', 'License Expired', ) await storage.remove(Setting.LICENSE_DATA_CACHE) } } const isFree = (): boolean => { if (!license) { return true } return license.license_key.status !== 'active' } const isPro = () => { if (!license) { return false } return license.license_key.status === 'active' } const isExpired = () => { if (!license || !license.license_key.expires_at) { return false } return isPast(new Date(license.license_key.expires_at)) } const getLicense = () => { return license } const activate = async (licenseKey: string) => { const response = await callLemonSqueezyApi('activateLicense', { licenseKey, }) if (!response.error) { setLicense(response.data) await storage.set(Setting.LICENSE_KEY, licenseKey) await storage.set(Setting.LICENSE_INSTANCE_ID, response.data.instance.id) // Cache the license data with the timestamp on successful activation. if (response.data.license_key.status === 'active') { const cacheEntry: CachedLicense = { data: response.data, timestamp: Date.now(), } await storage.set(Setting.LICENSE_DATA_CACHE, cacheEntry) } } return response } const deactivate = async () => { const licenseKey = await storage.get(Setting.LICENSE_KEY) const instanceId = await storage.get(Setting.LICENSE_INSTANCE_ID) try { const response = await callLemonSqueezyApi('deactivateLicense', { licenseKey, instanceId, }) if (response.data.deactivated) { // Clear all license-related data from storage on deactivation. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.success('Your license has been deactivated from this device.') } else { toast.error('Failed to deactivate the license. Please contact support.') } } catch (e) { toast.error('An error occurred during deactivation.') } } const goToMyOrders = async () => { if (!license?.meta?.customer_id) { toast.error('Could not find customer information.') return } try { const response = await callLemonSqueezyApi('getCustomer', { customerId: license.meta.customer_id, }) if (response.error) { toast.error('Could not retrieve customer portal link.') return } window.open( response.data.data.attributes.urls.customer_portal, '_blank', 'noopener,noreferrer', ) } catch (e) { toast.error('An error occurred while fetching your subscription details.') } } return { init, isFree, isPro, isExpired, activate, getLicense, goToMyOrders, deactivate, } } export default useLicense
```

# src/hooks/useRuntimeMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = ( message: T, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void, ) => void | boolean /** * A React hook for handling Chrome runtime messages * @param listener The callback function to handle incoming messages * @returns void * * @example * useRuntimeMessage((message, sender, sendResponse) => { * if (message.type === 'getData') { * sendResponse({ data: 'example' }) * } * // Return true to keep the message channel open for async responses * return true * }) */ const useRuntimeMessage = <T = any>(listener: MessageListener<T>): void => { const memoizedHandler = useCallback<MessageListener<T>>( (message, sender, sendResponse) => { return listener(message, sender, sendResponse) }, [listener], ) useEffect(() => { chrome.runtime.onMessage.addListener(memoizedHandler) return () => { chrome.runtime.onMessage.removeListener(memoizedHandler) } }, [memoizedHandler]) } export default useRuntimeMessage
```

# src/hooks/useWa.ts

```ts
import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' const useWa = () => { const { isReady, activeChat } = useAppStore() return { isReady, activeChat, ...wa, } } export default useWa
```

# src/hooks/useWindowMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = (event: MessageEvent<T>) => void const useWindowMessage = <T = any>(listener: MessageListener<T>): void => { const handleMessage = useCallback<MessageListener<T>>( (event) => { listener(event) }, [listener], ) useEffect(() => { window.addEventListener('message', handleMessage) return () => window.removeEventListener('message', handleMessage) }, [handleMessage]) } export default useWindowMessage
```

# src/libs/db.ts

```ts
// src/libs/db.ts import Dexie, { type EntityTable } from 'dexie' import packageJson from '../../package.json' export interface Media { id: number parentId: number type: string name: string file: File ext: string } export interface Broadcast { id: number name?: string | null type: string message: any isTyping: number isScheduler: number status: string delayMin?: number delayMax?: number validateNumbers: number smartPauseEnabled: number smartPauseStart: string smartPauseEnd: string batchEnabled: number batchSize: number batchDelay: number resumeAt?: Date | null tags?: string[] contentHash?: string warmupModeEnabled: number // ADDED: Warm-up mode toggle } export interface BroadcastContact { id: number broadcastId: number number: string name?: string | null status: string error?: string | null scheduledAt?: Date | null sendAt?: Date | null } export interface BroadcastTemplate { id: number name: string type: string message: any } export interface BroadcastRecipient { id: number name: string recipients: { name: string; number: string; source: string }[] createdAt: Date } const db = new Dexie(packageJson.name) as Dexie & { media: EntityTable<Media, 'id'> broadcasts: EntityTable<Broadcast, 'id'> broadcastContacts: EntityTable<BroadcastContact, 'id'> broadcastTemplates: EntityTable<BroadcastTemplate, 'id'> broadcastRecipients: EntityTable<BroadcastRecipient, 'id'> } // MODIFIED: Database version incremented to apply schema changes. db.version(1).stores({ media: '++id, parentId, type, name, file, ext', // MODIFIED: Added `warmupModeEnabled` to the schema. broadcasts: '++id, name, type, isTyping, isScheduler, status, delayMin, delayMax, validateNumbers, smartPauseEnabled, smartPauseStart, smartPauseEnd, batchEnabled, batchSize, batchDelay, resumeAt, *tags, contentHash, warmupModeEnabled', broadcastContacts: '++id, broadcastId, number, name, status, error, scheduledAt, sendAt, [broadcastId+status]', broadcastTemplates: '++id, name, type, message', broadcastRecipients: '++id, name, createdAt', }) export default db
```

# src/libs/http.ts

```ts
import fetchAdapter from '@haverstack/axios-fetch-adapter' import axios from 'axios' const http = axios.create({ adapter: fetchAdapter, }) export default http
```

# src/libs/ls.ts

```ts
import * as lemon from '@lemonsqueezy/lemonsqueezy.js' lemon.lemonSqueezySetup({}) const lemonSqueezy = lemon export default lemonSqueezy
```

# src/libs/storage.ts

```ts
import { Storage } from '@plasmohq/storage' export const storage = new Storage({})
```

# src/libs/theme.ts

```ts
import { Button, createTheme, FileInput, Menu, Modal, MultiSelect, NumberInput, Popover, Radio, Select, Switch, TagsInput, Text, Textarea, TextInput, Tooltip, } from '@mantine/core' const theme = createTheme({ colors: { emerald: [ '#effbf3', '#ddf4e5', '#b6eac7', '#8cdfa7', '#6bd68c', '#56d07b', '#4acd72', '#3bb560', '#31a154', '#145229', ], }, primaryColor: 'teal', cursorType: 'pointer', components: { Button: Button.extend({ defaultProps: { size: 'sm', }, }), FileInput: FileInput.extend({ defaultProps: { size: 'md', }, }), Menu: Menu.extend({ defaultProps: { withinPortal: false } }), Modal: Modal.extend({ defaultProps: { size: 'xl', withCloseButton: false, withOverlay: false, withinPortal: false, }, }), NumberInput: NumberInput.extend({ defaultProps: { size: 'md' } }), MultiSelect: MultiSelect.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Popover: Popover.extend({ defaultProps: { withinPortal: false, }, }), Radio: Radio.extend({ defaultProps: { size: 'md', }, }), Select: Select.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Switch: Switch.extend({ defaultProps: { size: 'md', }, }), TagsInput: TagsInput.extend({ defaultProps: { size: 'md', }, }), Text: Text.extend({ defaultProps: { size: 'md', }, }), Textarea: Textarea.extend({ defaultProps: { size: 'md', }, }), TextInput: TextInput.extend({ defaultProps: { size: 'md', }, }), Tooltip: Tooltip.extend({ defaultProps: { position: 'left', withinPortal: false, withArrow: true, }, }), }, }) export default theme
```

# src/libs/wa/blocklist.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' export const all = async (): Promise<Wid[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.ALL, body: {}, }) } export const blockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.BLOCK_CONTACT, body: chatId, }) } export const isBlocked = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.IS_BLOCKED, body: chatId, }) } export const unblockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.UNBLOCK_CONTACT, body: chatId, }) }
```

# src/libs/wa/cart.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { SendMessageOptions } from '@wppconnect/wa-js/dist/chat' /** * Add product in cart * * @example * \`\`\`javascript * const cart = wa.cart.add('[number]@c.us', [ * { id: 'productId', qnt: 2 }, * ]); * \`\`\` */ export const add = async ( chatId: string, products: { id: string qnt: number }[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.ADD, body: { chatId, products }, }) } /** * Clear all items of cart * */ export const clear = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.CLEAR, body: wid, }) } /** * Get products in cart chat * * @example * \`\`\`javascript * const cart = wa.cart.get('[number]@c.us'); * \`\`\` */ export const get = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET, body: wid, }) } /** * Get thumb of a cart * * @example * \`\`\`javascript * const cart = wa.cart.getThumbFromCart('[number]@c.us'); * \`\`\` */ export const getThumbFromCart = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET_THUMB_FROM_CART, body: wid, }) } /** * Remove a product in cart * * @example * \`\`\`javascript * const cart = wa.cart.remove('[number]@c.us', '6987301181294productId'); * \`\`\` */ export const remove = async ( chatId: string, productId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.REMOVE, body: { chatId, productId }, }) } /** * Send a request order to business chat * * @example * \`\`\`javascript * const cart = wa.cart.submit('[number]@c.us'); * \`\`\` * * @example * \`\`\`javascript * // Send cart with a custom message * const cart = wa.cart.submit('[number]@c.us', 'Custom message here'); * \`\`\` */ export const submit = async ( wid: string, msg?: string, options?: SendMessageOptions, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.SUBMIT, body: { wid, msg, options }, }) } /** * Update product in cart * * @example * \`\`\`javascript * const cart = wa.cart.update('[number]@c.us', '6987301181294productId', { quantity: 12 }); * \`\`\` */ export const update = async ( chatId: string, productId: string, options: { quantity: number }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.UPDATE, body: { chatId, productId, options }, }) }
```

# src/libs/wa/catalog.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { createProductParams } from '@wppconnect/wa-js/dist/catalog/functions/createProduct' import type { editProductParams } from '@wppconnect/wa-js/dist/catalog/functions/editProduct' /** * Add image on product * This function include additional images on product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.addProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const addProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.ADD_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Add image on product * This function change main image of product * for change additional images use @addProductImage * * @example * \`\`\`javascript * await wa.catalog.changeProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const changeProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CHANGE_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Create new collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.createCollection('Collection Name', ['565656589898']); * \`\`\` */ export const createCollection = async ( collectionName: string, productsId: string[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_COLLECTION, body: { collectionName, productsId }, }) } /** * Create new product * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.addProduct( { name: 'Product name', image: 'base64 image string', description: 'product description', price: '89.90', isHidden: false, url: 'https://wppconnect.io', retailerId: 'AKA001', } ); * \`\`\` */ export const createProduct = async ( params: createProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_PRODUCT, body: params, }) } /** * Delete a collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.deleteCollection("377095767832354"); * \`\`\` * * @return Return sucess or error */ export const deleteCollection = async (collectionId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_COLLECTION, body: collectionId, }) } /** * @example * \`\`\`javascript * * // Delete various products * const myCatalog = await wa.catalog.delProducts(['6104203702939361', '6104289702939361']); * \`\`\` */ export const deleteProduct = async (productsIds: string[]): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_PRODUCT, body: productsIds, }) } /** * @example * \`\`\`javascript * const myCatalog = await wa.catalog.EditCollection('565656589898', { collectionName: 'New Name for collection', productsToAdd: ['5656523223'], productsToRemove: ['5656523232']}); * \`\`\` */ interface paramsEditCollection { name?: string productsToAdd?: string[] productsToRemove?: string[] } export const editCollection = async ( collectionId: string, params: paramsEditCollection, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_COLLECTION, body: { collectionId, params }, }) } /** * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = wa.catalog.editProduct('5498255476885590', {name: 'Plano 01', price: '89990', description: 'Insert description for your product', isHidden: true, url: 'http://www.wppconnect.io', retailerId: 'AKA001'}); * \`\`\` */ export const editProduct = async ( productId: string, params: editProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_PRODUCT, body: { productId, params }, }) } /** * Get collections of catalog * * @example * \`\`\`javascript * // Retrieve 20 collections of chat * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20'); * * // Retrieve 20 collections of chat and products arrays limit with 10 products * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20', '10'); * \`\`\` */ export const getCollections = async ( chatId: string, qnt?: number, productsCount?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_COLLECTIONS, body: { chatId, qnt, productsCount }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ export const getMyCatalog = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_MY_CATALOG, body: {}, }) } /** * Retrieves product by id * * @example * \`\`\`javascript * // Retrieve data of product * await wa.catalog.getProductById('5521985565656@c.us', '68685985868923'); * \`\`\` */ export const getProductById = async ( chatId: string, productId: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCT_BY_ID, body: { chatId, productId }, }) } /** * Retrieves product by contact id * * @example * Get products of catalogs * \`\`\`javascript * await wa.catalog.getProducts('5521985625689@c.us', 10); * \`\`\` */ export const getProducts = async (chatId: string, qnt: number): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCTS, body: { chatId, qnt }, }) } /** * Remove image on product * This function remove additional images of product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.removeProductImage('68685985868923', '0'); * \`\`\` */ export const removeProductImage = async ( productId: string, index: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.REMOVE_PRODUCT_IMAGE, body: { productId, index }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` */ export const setProductVisibility = async ( productId: any, isHidden: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.SET_PRODUCT_VISIBILITY, body: { productId, isHidden }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` * * @return Return sucess of product visibility set */ export const updateCartEnabled = async (enabled: boolean): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.UPDAGE_CART_ENABLED, body: enabled, }) }
```

# src/libs/wa/chat.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions, DeleteMessageReturn, ForwardMessagesOptions, GetMessagesOptions, RawMessage, } from '@wppconnect/wa-js/dist/chat' import type { ParticipantStatusACK } from '@wppconnect/wa-js/dist/chat/functions/getMessageACK' import type { Stringable } from '@wppconnect/wa-js/dist/types' import type { MsgKey, MsgModel, Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { ACK } from '@wppconnect/wa-js/dist/whatsapp/enums' /** * Archive a chat * * @example * // Archive a chat * wa.chat.archive('[number]@c.us'); * * // Unarchive a chat * wa.chat.archive('[number]@c.us', false); * \`\`\` */ export const archive = async ( chatId: string | Wid, archive = true, ): Promise<{ wid: Wid archive: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.ARCHIVE, body: { chatId, archive }, }) } /** * Get if message can played * * @example * \`\`\`javascript * wa.chat.canMarkPlayed('[message_id]'); * \`\`\` */ export const canMarkPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MARK_PLAYED, body: messageId, }) } /** * Check if is possible to mute this chat * * @example * \`\`\`javascript * const canMute = wa.chat.canMute('[number]@c.us'); * \`\`\` */ export const canMute = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MUTE, body: chatId, }) } /** * Get if message can reply * * @example * \`\`\`javascript * wa.chat.canReply('[message_id]'); * \`\`\` */ export const canReply = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_REPLY, body: messageId, }) } /** * Clear a chat message * */ export const clear = async ( chatId: string | Wid, keepStarred = true, ): Promise<{ wid: Wid status: number keepStarred: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLEAR, body: { chatId, keepStarred }, }) } /** * Close the chat tab * * @example * \`\`\`javascript * await wa.chat.closeChat(); * \`\`\` * */ export const closeChat = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLOSE_CHAT, body: {}, }) } /** * Delete a chat * */ export const _delete = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE, body: chatId, }) } /** * Delete a message * * @example * \`\`\`javascript * // Delete a message * wa.chat.deleteMessage('[number]@c.us', 'msgid'); * // Delete a list of messages * wa.chat.deleteMessage('[number]@c.us', ['msgid1', 'msgid2]); * // Delete a message and delete media * wa.chat.deleteMessage('[number]@c.us', 'msgid', true); * // Revoke a message * wa.chat.deleteMessage('[number]@c.us', 'msgid', true, true); * \`\`\` * */ export const deleteMessage = async ( chatId: string | Wid, ids: string | string[], deleteMediaInDevice = false, revoke = false, ): Promise<DeleteMessageReturn | DeleteMessageReturn[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE_MESSAGE, body: { chatId, ids, deleteMediaInDevice, revoke }, }) } /** * Downloads media from a message * * @example * \`\`\`javascript * await wa.chat.downloadMedia('messageId'); * \`\`\` */ export const downloadMedia = async ( messageId: string | MsgKey, ): Promise<Blob | null> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DOWNLOAD_MEDIA, body: messageId, }) } export const find = async (chatId: string | Wid): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FIND, body: chatId, }) } /** * Forward messages to a chat * * @example * \`\`\`javascript * // Forward messages * wa.chat.forwardMessage('[number]@c.us', 'true_[number]@c.us_ABCDEF'); * \`\`\` */ export const forwardMessage = async ( toChatId: string | Wid, msgId: string | MsgKey, options: ForwardMessagesOptions = {}, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FORWARD_MESSAGE, body: { toChatId, msgId, options }, }) } /** * Find a chat by id * */ export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET, body: chatId, }) } export const getActiveChat = async () => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_ACTIVE_CHAT, body: {}, }) } /** * Get timestamp of last seen * @example * \`\`\`javascript * wa.chat.getLastSeen('[number]@c.us'); * \`\`\` */ export const getLastSeen = async ( chatId: string | Wid, ): Promise<number | boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_LAST_SEEN, body: chatId, }) } /** * Get message ACK from a message * * @example * \`\`\`javascript * // Get message ACK * const ackInfo = await WPP.chat.getMessageACK('true_[number]@c.us_ABCDEF'); * * console.log(ackInfo.deliveryRemaining); // Delivery Remaining * console.log(ackInfo.readRemaining); // Read Remaining * console.log(ackInfo.playedRemaining); // PlayedRemaining, for audio(ptt) only * * console.log(ackInfo.participants[0].deliveredAt); // Delivered At, in timestamp format * console.log(ackInfo.participants[0].readAt); // Read At, in timestamp format * console.log(ackInfo.participants[0].playedAt); // Played At, in timestamp format, for audio(ptt) only * * //To get only how was received * const received = ackInfo.participants.filter(p => p.deliveredAt || p.readAt || p.playedAt); * * //To get only how was read * const read = ackInfo.participants.filter(p => p.readAt || p.playedAt); * * //To get only how was played * const played = ackInfo.participants.filter(p => p.playedAt); * \`\`\` */ export const getMessageACK = async ( msgId: string | MsgKey, ): Promise<{ ack: ACK fromMe: boolean deliveryRemaining: number readRemaining: number playedRemaining: number participants: ParticipantStatusACK[] }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGE_ACK, body: msgId, }) } /** * Fetch messages from a chat * * @example * \`\`\`javascript * // Some messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * }); * * // All messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * }); * * // Last 20 unread messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * onlyUnread: true, * }); * * // All unread messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * onlyUnread: true, * }); * * // 20 messages before specific message * wa.chat.getMessages('[number]@c.us', { * count: 20, * direction: 'before', * id: '<full message id>' * }); * * // Only media messages (url, document and links) * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'all', * }); * * // Only image messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'image', * }); * * // Only document messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'document', * }); * * // Only link (url) messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'url', * }); * \`\`\` */ export const getMessages = async ( chatId: string | Wid, options: GetMessagesOptions = {}, ): Promise<any[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGES, body: { chatId, options }, }) } /** * Get notes from a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.getNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const getNotes = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_NOTES, body: chatId, }) } /** * Get the platform message from message ID * * The platform can be: * * android * * iphone * * web * * unknown * * @example * \`\`\`javascript * // to get platform from a message * const platform = wa.chat.getPlatformFromMessage('[message_id]'); * \`\`\` */ export const getPlatformFromMessage = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<'android' | 'iphone' | 'web' | 'unknown'> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_PLATFORM_MESSAGE, body: messageId, }) } /** * Return a list of chats * * @example * \`\`\`javascript * // All chats * const chats = await wa.chat.list(); * * // Some chats * const chats = wa.chat.list({count: 20}); * * // 20 chats before specific chat * const chats = wa.chat.list({count: 20, direction: 'before', id: '[number]@c.us'}); * * // Only users chats * const chats = await wa.chat.list({onlyUsers: true}); * * // Only groups chats * const chats = await wa.chat.list({onlyGroups: true}); * * // Only communities chats * const chats = await wa.chat.list({onlyCommunities: true}); * * // Only Newsletter * const chats = await wa.chat.list({onlyNewsletter: true}); * * // Only with label Text * const chats = await wa.chat.list({withLabels: ['Test']}); * * // Only with label id * const chats = await wa.chat.list({withLabels: ['1']}); * * // Only with label with one of text or id * const chats = await wa.chat.list({withLabels: ['Alfa','5']}); * \`\`\` * */ export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.LIST, body: options, }) } /** * Mark a chat to composing state * and keep sending "is writting a message" * * @example * \`\`\`javascript * // Mark is composing * wa.chat.markIsComposing('[number]@c.us'); * * // Mark is composing for 5 seconds * wa.chat.markIsComposing('[number]@c.us', 5000); * \`\`\` */ export const markIsComposing = async ( chatId: string | Wid, duration?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_COMPOSING, body: { chatId, duration }, }) } /** * Mark a chat is paused state * * @example * \`\`\`javascript * // Mark as recording * wa.chat.markIsPaused('[number]@c.us'); * \`\`\` */ export const markIsPaused = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_PAUSED, body: chatId, }) } /** * Mark a chat as read and send SEEN event * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsRead('[number]@c.us'); * \`\`\` */ export const markIsRead = async ( chatId: string, ): Promise<{ wid: Wid unreadCount: number }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_READ, body: chatId, }) } /** * Mark a chat to recording state * and keep sending "is recording" * * @example * \`\`\`javascript * // Mark is recording * wa.chat.markIsRecording('[number]@c.us'); * * // Mark is recording for 5 seconds * wa.chat.markIsRecording('[number]@c.us', 5000); * \`\`\` */ export const markIsRecording = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_RECORDING, body: chatId, }) } /** * Mark a chat as unread * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsUnread('[number]@c.us'); * \`\`\` */ export const markIsUnread = async ( chatId: string | Wid, ): Promise<{ wid: Wid }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_UNREAD, body: chatId, }) } /** * Mark message as played * * @example * \`\`\`javascript * wa.chat.markPlayed('[message_id]'); * \`\`\` */ export const markPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_PLAYED, body: messageId, }) } /** * Mute a chat, you can use duration or expiration * For expiration, use unix timestamp (seconds only) * For duration, use seconds * * @example * \`\`\`javascript * // Mute for 60 seconds * wa.chat.mute('[number]@c.us', {duration: 60}); * * // Mute util 2021-01-01 * wa.chat.mute('[number]@c.us', {expiration: 1641006000}); * * // or using date * const expiration = new Date('2022-01-01 00:00:00'); * wa.chat.mute('[number]@c.us', {expiration: expiration}); * \`\`\` * */ export const mute = async ( chatId: string | Wid, time: { expiration: number | Date } | { duration: number }, ): Promise<{ wid: Wid expiration: number isMuted: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MUTE, body: { chatId, time }, }) } /** * Open the chat in the WhatsApp interface in a specific message * * @example * \`\`\`javascript * await wa.chat.openChatAt('[number]@c.us', <message_id>); * \`\`\` * */ export const openChatAt = async ( chatId: string | Wid, messageId: string, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_AT, body: { chatId, messageId }, }) } /** * Open the chat in the WhatsApp interface in bottom position * * @example * \`\`\`javascript * await wa.chat.openChatBottom('[number]@c.us'); * \`\`\` * */ export const openChatBottom = async ( chatId: string, ): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_BOTTOM, body: chatId, }) } /** * Open the chat in the WhatsApp interface from first unread message * * @example * \`\`\`javascript * await wa.chat.openChatFromUnread('[number]@c.us'); * \`\`\` * */ export const openChatFromUnread = async ( chatId: string | Wid, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_FROM_UNREAD, body: chatId, }) } /** * Pin a message in chat * * @example * \`\`\`javascript * // Pin a message in chat * wa.chat.pinMsg('true_[number]@c.us_ABCDEF'); * * // Pin a message in chat for 30 days * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', 2592000); * * // Unpin a message * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', false); * \`\`\` */ export const pinMsg = async ( msgId: string | MsgKey, pin = true, seconds = 604800, // default 7 days ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN_MSG, body: { msgId, pin, seconds }, }) } /** * Set custom Chat list in panel of whatsapp * * @example * \`\`\`javascript * // Your custom list * wa.chat.setChatList('custom', ['number@c.us', 'number2@c.us']); * * // List only with unread chats * wa.chat.setChatList('unread'); * * // List only with favorites chats * wa.chat.setChatList('favorites'); * * // List only with groups chats * wa.chat.setChatList('group'); * * // List only labels chat * wa.chat.setChatList('labels', '454545_labelId'); * \`\`\` */ export const setChatList = async (type: string, ids?: string | string[]) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_CHAT_LIST, body: { type, ids }, }) } export const setInputText = async (text: string, chatId?: string | Wid) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_INPUT_TEXT, body: { text, chatId }, }) } /** * Set notes for a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.setNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const setNotes = async ( chatId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_NOTES, body: { chatId, content }, }) }
```

# src/libs/wa/conn.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Alternative login method using code * Get the Link Device Code for Authentication using the phone number * * @example * \`\`\`javascript * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]'); * * // Disable push notification * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]', false); * \`\`\` */ export const genLinkDeviceCodeForPhoneNumber = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }) } /** * Return the current auth code * * @example * \`\`\`javascript * const authCode = await wa.conn.getAuthCode(); * console.log(authCode.fullCode); // Output: a long string to generate a QRCode * \`\`\` */ export const getAuthCode = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_AUTH_CODE, }) } export const getMyUserId = async (): Promise<Wid | undefined> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_MY_USER_ID, }) }
```

# src/libs/wa/contact.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ContactListOptions } from '@wppconnect/wa-js/dist/contact' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Get a contact by id * * @example * \`\`\`javascript * await wa.contact.get('[number]@c.us'); * \`\`\` * */ export const get = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET, body: contactId, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getBusinessProfile('[number]@c.us'); * \`\`\` * */ export const getBusinessProfile = async ( contactId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_BUSINESS_PROFILE, body: contactId, }) } /** * Get all commons groups for the contact * * @example * \`\`\`javascript * const groups_ids = await wa.contact.getCommonGroups('[number]@c.us'); * \`\`\` * */ export const getCommonGroups = async (wid: Wid | string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_COMMON_GROUPS, body: wid, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getProfilePictureUrl('[number]@c.us'); * \`\`\` * */ export const getProfilePictureUrl = async ( contactId: string | Wid, full = true, ): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_PROFILE_PICTURE_URL, body: { contactId, full }, }) } /** * Get the current text status * * @example * \`\`\`javascript * await wa.contact.getStatus('[number]@c.us'); * \`\`\` */ export const getStatus = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_STATUS, body: contactId, }) } export const list = async (options: ContactListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.LIST, body: options, }) } export const isExist = async (contactId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.IS_EXIST, body: contactId, }) }
```

# src/libs/wa/group.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions } from '@wppconnect/wa-js/dist/chat' import type { GroupProperty } from '@wppconnect/wa-js/dist/group' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Add one or more participants to a group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.addParticipants('[group@g.us]', [number@c.us]); * * // Get participant result: * console.log(result['123@c.us'].code); * console.log(result['123@c.us'].invite_code); * console.log(result['123@c.us'].invite_code_exp); * console.log(result['123@c.us'].message); * console.log(result['123@c.us'].wid); * * const memberResult = result['123@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['123@c.us'].invite_code; * console.log(link); * \`\`\` */ export const addParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.ADD_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Approve a membership request to group * * @example * \`\`\`javascript * await wa.group.approve(12345645@g.us, 5554999999999@c.us); * \`\`\` * */ export const approve = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.APPROVE, body: { groupId, membershipIds }, }) } /** * Check if your account is allowed to add new participants * * @example * \`\`\`javascript * const result = await wa.group.canAdd('group@g.us'); * console.log(result); * \`\`\` */ export const canAdd = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_ADD, body: groupId, }) } /** * Check if your account is allowed to demote participants * * @example * \`\`\`javascript * await wa.group.canDemote('group@g.us'); * console.log(result); * \`\`\` */ export const canDemote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_DEMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to promote participants * * @example * \`\`\`javascript * await WPP.group.canPromote('group@g.us'); * console.log(result); * \`\`\` * */ export const canPromote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_PROMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to remove participants * * @example * \`\`\`javascript * const result = await wa.group.canRemove('group@g.us'); * console.log(result); * \`\`\` */ export const canRemove = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_REMOVE, body: { groupId, participantsIds }, }) } /** * Create a new group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.create('Test Group', ['number@c.us']); * * console.log(result.gid.toString()); // Get the group ID * * // Get participant result: * console.log(result['number@c.us'].code); * console.log(result['number@c.us'].invite_code); * console.log(result['number@c.us'].invite_code_exp); * console.log(result['number@c.us'].message); * console.log(result['number@c.us'].wid); * * const memberResult = result['number@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['number@c.us'].invite_code; * console.log(link); * * // Create a Subgroup for a community * const result = await wa.group.create('Test Group', ['number@c.us'], 'communit@g.us'); * \`\`\` */ export const create = async ( groupName: string, participantsIds: (string | Wid) | (string | Wid)[], parentGroup: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CREATE, body: { groupName, participantsIds, parentGroup }, }) } /** * @example * \`\`\`javascript * // One member * await wa.group.demoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.demoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const demoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.DEMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Get group info from an inviteCode * * @example * \`\`\`javascript * await wa.group.getGroupInfoFromInviteCode('<inviteCode>'); * \`\`\` */ export const getGroupInfoFromInviteCode = async ( inviteCode: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, body: inviteCode, }) } /** * Get the max number of participants for a group * * @example * \`\`\`javascript * const limit = await wa.group.getGroupSizeLimit(); * console.log(limit); * \`\`\` */ export const getGroupSizeLimit = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_SIZE_LIMIT, body: {}, }) } export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LIST, }) } /** * @description Sends a request to the background script to get a group's invite link. * @param groupId The ID of the group (e.g., '1234567890@g.us'). * @returns A promise that resolves with the invite link string. */ export const getInviteLink = async (groupId: string): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_INVITE_LINK, body: { groupId }, }) } /** * Retrieve a lista of a membership approval requests * * @example * \`\`\`javascript * await wa.group.getMembershipRequests(12345645@g.us); * \`\`\` */ export const getMembershipRequests = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_MEMBERSHIP_REQUESTS, body: groupId, }) } /** * Get an array of participants of a group * * @example * \`\`\`javascript * wa.group.getParticipants('[group-id]@g.us'); * \`\`\` */ export const getParticipants = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_PARTICIPANTS, body: groupId, }) } export const iAmAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_ADMIN, body: groupId, }) } export const iAmMember = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_MEMBER, body: groupId, }) } export const iAmRestrictedMember = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_RESTRICTED_MEMBER, body: groupId, }) } export const iAmSuperAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_SUPER_ADMIN, body: groupId, }) } /** * Join in a group from an invite code. * * @example * \`\`\`javascript * await wa.group.join('abcde....'); * \`\`\` */ export const join = async (inviteCode: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.JOIN, body: inviteCode, }) } /** * Leave from a group. * * @example * \`\`\`javascript * await wa.group.leave('[number]@g.us'); * \`\`\` */ export const leave = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LEAVE, body: groupId, }) } /** * Promote group member to admin * * @example * \`\`\`javascript * // One member * await wa.group.promoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.promoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` * * @category Group */ export const promoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.PROMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Reject a membership request to group * * @example * \`\`\`javascript * await wa.group.reject(12345645@g.us, 5554999999999@c.us); * \`\`\` */ export const reject = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REJECT, body: { groupId, membershipIds }, }) } /** * Remove the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.removeIcon('[group@g.us]'); * \`\`\` */ export const removeIcon = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_ICON, body: groupId, }) } /** * Remove participants of a group * * @example * \`\`\`javascript * // One member * await wa.group.removeParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.removeParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const removeParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Revoke the current invite code and generate new one. * * @example * \`\`\`javascript * const code = WPP.group.revokeInviteCode('[group-id]@g.us'); * const link = 'https://chat.whatsapp.com/' + code; * \`\`\` */ export const revokeInviteCode = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REVOKE_INVITE_CODE, body: groupId, }) } /** * Define the group description * * @example * \`\`\`javascript * await wa.group.setDescription('[group-id]@g.us', 'new group description'); * \`\`\` */ export const setDescription = async ( groupId: string | Wid, description: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_DESCRIPTION, body: { groupId, description }, }) } /** * Set the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.setIcon('[group@g.us]', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const setIcon = async ( groupId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_ICON, body: { groupId, content }, }) } /** * Set the group property * * @example * \`\`\`javascript * // Only admins can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', true); * * // All can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', false); * * // Disatble temporary messages * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 0); * * // Enable temporary messages for 24 hours * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 86400); * * // Enable temporary messages for 7 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 604800); * * // Enable temporary messages for 90 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 7776000); * * // Only admins can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', true); * * // All can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', false); * \`\`\` */ export const setProperty = async ( groupId: string | Wid, property: GroupProperty, value: 0 | 1 | 86400 | 604800 | 7776000 | boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_PROPERTY, body: { groupId, property, value }, }) } /** * Define the group subject * * @example * \`\`\`javascript * await wa.group.setSubject('[group-id]@g.us', 'new group subject'); * \`\`\` */ export const setSubject = async ( groupId: string | Wid, subject: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_SUBJECT, body: { groupId, subject }, }) }
```

# src/libs/wa/index.ts

```ts
import * as chat from './chat' import * as conn from './conn' import * as contact from './contact' import * as group from './group' import * as on from './on' import * as send from './send' export default { on, conn, send, contact, chat, group, }
```

# src/libs/wa/newsletter.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' /** * Create a newsletter * * @example * \`\`\`javascript * // To edit name * wa.newsletter.create('Name for your newsletter', { * description: 'Description for that', * picture: '<base64_string', * }); * \`\`\` */ export const create = async ( name: string, opts: { description?: string; picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.CREATE, body: { name, opts }, }) } /** * Delete a newsletter * * @example * \`\`\`javascript * const code = wa.newsletter.destroy('[newsletter-id]@newsletter'); * \`\`\` */ export const destroy = async (id: string): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.DESTROY, body: id, }) } /** * Edit the newsletter data * * @example * \`\`\`javascript * // To edit name * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * name: 'New Name' * }); * * // To edit description * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * description: 'New description' * }); * * // To change picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: '<base64_image>' * }); * * // To remove picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: null * }); * \`\`\` */ export const edit = async ( newsletterId: string, opts: { name?: string description?: string picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.EDIT, body: { newsletterId, opts }, }) } /** * Get subscribers of a newsletters * * @example * \`\`\`javascript * const code = wa.newsletter.getSubscribers('[newsletter-id]@newsletter'); * \`\`\` */ export const getSubscribers = async (id: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.GET_SUBSCRIBERS, body: id, }) } /** * Mute and unmute a newsletter * * @example * // Mute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', true); * \`\`\` * * // Unmute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', false); * \`\`\` */ export const mute = async ( newsletterId: string, value?: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.MUTE, body: { newsletterId, value }, }) }
```

# src/libs/wa/on.ts

```ts
export const ready = (callback = () => {}) => { const targetSelector = '#side' // WhatsApp left-panel root const node = document.querySelector(targetSelector) if (node) { require('@wppconnect/wa-js/dist/wppconnect-wa') callback() return } // Wait for the node to appear only once const observer = new MutationObserver(() => { const el = document.querySelector(targetSelector) if (el) { console.log('✅✅✅✅✅') observer.disconnect() // stop watching require('@wppconnect/wa-js/dist/wppconnect-wa') callback() } }) observer.observe(document.body, { childList: true, subtree: true, }) }
```

# src/libs/wa/profile.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { BusinessProfileModel } from '@wppconnect/wa-js/dist/whatsapp' /** * Update your business profile * * @example * \`\`\`javascript * await wa.profile.editBusinessProfile({description: 'New description for profile'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({categories: { id: "133436743388217", localized_display_name: "Artes e entretenimento", not_a_biz: false, }}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({email: 'test@test.com.br'}); * \`\`\` * * Change website of profile (max 2 sites) * \`\`\`javascript * await wa.profile.editBusinessProfile({website: [ "https://www.wppconnect.io", "https://www.teste2.com.br", ]}); * \`\`\` * * Change businessHours for Specific Hours * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { * { tue: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, wed: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, thu: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, fri: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sat: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sun: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, } }, timezone: "America/Sao_Paulo" }); * * Change businessHours for Always Opened * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "open_24h", }, tue: { mode: "open_24h", }, wed: { mode: "open_24h", }, thu: { mode: "open_24h", }, fri: { mode: "open_24h", }, sat: { mode: "open_24h", }, sun: { mode: "open_24h", }, } timezone: "America/Sao_Paulo" }); * * Change businessHours for Appointment Only * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "appointment_only", }, tue: { mode: "appointment_only", }, wed: { mode: "appointment_only", }, thu: { mode: "appointment_only", }, fri: { mode: "appointment_only", }, sat: { mode: "appointment_only", }, sun: { mode: "appointment_only", }, } timezone: "America/Sao_Paulo" }); * * */ export const editBusinessProfile = async ( params: BusinessProfileModel, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.EDIT_BUSINESS_PROFILE, body: params, }) } /** * Get your current profile name * * @example * \`\`\`javascript * const myProfileName = wa.profile.getMyProfileName(); * \`\`\` */ export const getMyProfileName = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_NAME, body: {}, }) } /** * Get your current profile picture * * @example * \`\`\`javascript * await wa.profile.getMyProfilePicture(); * \`\`\` */ export const getMyProfilePicture = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_PICTURE, body: {}, }) } /** * Get your current text status * * @example * \`\`\`javascript * await wa.profile.getMyStatus(); * \`\`\` */ export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_STATUS, body: {}, }) } /** * Return the current logged user is Bussiness or not * * @example * \`\`\`javascript * wa.profile.isBusiness(); * \`\`\` */ export const isBusiness = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.IS_BUSINESS, body: {}, }) } /** * Remove your profile picture * * @example * \`\`\`javascript * await wa.profile.removeMyProfilePicture(); * \`\`\` */ export const removeMyProfilePicture = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.REMOVE_MY_PROFILE_PICTURE, body: {}, }) } /** * Update your current profile name * * @example * \`\`\`javascript * await wa.profile.setMyProfileName('My new name'); * \`\`\` */ export const setMyProfileName = async (name: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_NAME, body: {}, }) } /** * Update your profile picture * * @example * \`\`\`javascript * await wa.profile.setMyProfilePicture('data:image/jpeg;base64,.....'); * \`\`\` */ export const setMyProfilePicture = async (content: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_PICTURE, body: content, }) } /** * Update your current text status * * @example * \`\`\`javascript * await wa.profile.setMyStatus('Example text'); * \`\`\` */ export const setMyStatus = async (statusText: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_STATUS, body: statusText, }) }
```

# src/libs/wa/send.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { AudioMessageOptions, AutoDetectMessageOptions, DocumentMessageOptions, ImageMessageOptions, LocationMessageOptions, PoolMessageOptions, SendMessageOptions, StickerMessageOptions, TextMessageOptions, VCardContact, VideoMessageOptions, } from '@wppconnect/wa-js/dist/chat' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { SendMsgResult } from '@wppconnect/wa-js/dist/whatsapp/enums' export const text = async ( chatId: any, content: any, options: TextMessageOptions = {}, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.TEXT, body: { chatId, content, options, }, }) } export const file = async ( chatId: string | Wid, content: string | Blob | File, options: | AutoDetectMessageOptions | AudioMessageOptions | DocumentMessageOptions | ImageMessageOptions | VideoMessageOptions | StickerMessageOptions | TextMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.FILE, body: { chatId, content, options, }, }) } export const location = async ( chatId: string | Wid, options: LocationMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.LOCATION, body: { chatId, options, }, }) } export const poll = async ( chatId: any, name: string, choices: string[], options?: PoolMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.POLL, body: { chatId, name, choices, options, }, }) } export const vcard = async ( chatId: string | Wid, contacts: string | Wid | VCardContact | (string | Wid | VCardContact)[], options?: SendMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.VCARD, body: { chatId, contacts, options, }, }) }
```

# src/libs/wa/status.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ImageStatusOptions, TextStatusOptions, VideoStatusOptions, } from '@wppconnect/wa-js/dist/status' import type { MsgKey, Wid } from '@wppconnect/wa-js/dist/whatsapp' export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET, body: chatId, }) } export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET_MY_STATUS, body: {}, }) } export const remove = async (msgId: string | MsgKey): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.REMOVE, body: msgId, }) } /** * Send a image message to status stories * * @example * \`\`\`javascript * wa.status.sendImageStatus('data:image/jpeg;base64,<a long base64 file...>'); * \`\`\` */ export const sendImageStatus = async ( content: any, options: ImageStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_IMAGE_STATUS, body: { content, options }, }) } /** * Mark status as read/seen * * @example * \`\`\`javascript * wa.status.sendReadStatus('[phone_number]@c.us', 'false_status@broadcast_3A169E0FD4BC6E92212F_5521526232927@c.us'); * \`\`\` */ export const sendReadStatus = async ( chatId: string | Wid, statusId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_READ_STATUS, body: { chatId, statusId }, }) } /** * Send a text message to status stories * * @example * \`\`\`javascript * wa.status.sendTextStatus(`Bootstrap primary color: #0275d8`, { backgroundColor: '#0275d8', font: 2}); * \`\`\` */ export const sendTextStatus = async ( content: any, options: TextStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_TEXT_STATUS, body: { content, options }, }) } /** * Send a video message to status stories * * @example * \`\`\`javascript * wa.status.sendVideoStatus('data:video/mp4;base64,<a long base64 file...>'); * \`\`\` */ export const sendVideoStatus = async ( content: any, options: VideoStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_VIDEO_STATUS, body: { content, options }, }) } /** * Define a custom list of participants to send the status message * * @example * \`\`\`javascript * // Use a custom list * await wa.status.updateParticipants(['123@c.us', '456@c.us']); * // Use the contacts by default * await wa.status.updateParticipants(null); * \`\`\` */ export const updateParticipants = async ( ids?: (string | Wid)[] | null, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.UPDATE_PARTICIPANTS, body: ids, }) }
```

# src/models/BroadcastContactModel.ts

```ts
// src/models/BroadcastContactModel.ts import { Status } from '@/constants' import db from '@/libs/db' const success = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.SUCCESS, sendAt: new Date(), }) } const running = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.RUNNING }) } const pending = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.PENDING }) } const failed = async (id: number, message: string | null = null) => { return await db.broadcastContacts.update(id, { status: Status.FAILED, error: message, }) } // ++ MODIFIED: This function now fetches a batch of pending contacts instead of just one. // This reduces the number of database queries in the main processing loop. const getStatusPendingBatch = async (limit: number = 20) => { return await db.broadcastContacts .where('status') .equals(Status.PENDING) .limit(limit) .toArray() } const resetRunningStatuses = async () => { const updatedContacts = await db.broadcastContacts .where('status') .equals(Status.RUNNING) .modify({ status: Status.PENDING }) if (updatedContacts > 0) { await db.broadcasts .where('status') .equals(Status.RUNNING) .modify({ status: Status.PENDING }) console.log( `Reset ${updatedContacts} contacts and potentially their broadcasts.`, ) } else { console.log('No stuck RUNNING statuses found.') } } export default { getStatusPendingBatch, success, failed, running, pending, resetRunningStatuses, }
```

# src/models/BroadcastModel.ts

```ts
import { Status } from '@/constants' import db, { type Broadcast } from '@/libs/db' const running = async (id: number) => { await db.broadcasts.update(id, { status: Status.RUNNING }) } const success = async (id: number) => { await db.broadcasts.update(id, { status: Status.SUCCESS }) } const cancel = async (id: number) => { await db.broadcasts.update(id, { status: Status.CANCELLED }) } // ++ MODIFIED: Changed status from CANCELLED to PAUSED to support the new feature. const pause = async (id: number) => { await db.broadcasts.update(id, { status: Status.PAUSED }) } const pending = async (id: number) => { await db.broadcasts.update(id, { status: Status.PENDING }) } const get = async (id: number): Promise<Broadcast> => { return await db.broadcasts.get(id) } export default { get, running, success, pause, cancel, pending, }
```

# src/models/MediaModel.ts

```ts
import { Media } from '@/constants' import db from '@/libs/db' const firstByBroadcastId = async (broadcastId: number) => { return await db.media .where({ parentId: broadcastId, type: Media.BROADCAST, }) .first() } export default { firstByBroadcastId, }
```

# src/models/useBroadcastForm.ts

```ts
// src/models/useBroadcastForm.ts import { Media, Message, Setting, Status } from '@/constants' import useInputMessage from '@/features/broadcast/components/Input/Message/useInputMessage' import useLicense from '@/hooks/useLicense' import db, { type Broadcast, type BroadcastContact } from '@/libs/db' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import toast from '@/utils/toast' import { formHasErrors, isTypeMessageMedia, showModalUpgrade, } from '@/utils/util' import { useForm } from '@mantine/form' import { addMinutes, differenceInHours, isFuture } from 'date-fns' import _ from 'lodash' import { useEffect } from 'react' const defaultValues = { name: '', numbers: [] as any[], tags: [] as string[], isTyping: true, validateNumbers: true, scheduler: { enabled: false, scheduledAt: addMinutes(new Date(), 5), }, smartPause: { enabled: false, start: '09:00', end: '17:00', }, batch: { enabled: false, size: 20, delay: 15, }, // ADDED: Default state for the new warm-up mode feature. warmupMode: { enabled: false, }, delayMin: 3, delayMax: 6, } interface useBroadcastFormProps { cloneData?: (Broadcast & { recipients?: any[] }) | null onSuccess: () => void onClose: () => void } /** * @description A simple hashing function for an object. * @param obj The object to hash. * @returns A numeric string representing the hash. */ const hashMessage = (obj: any): string => { const str = JSON.stringify(obj) if (str.length === 0) return '0' const hash = str .split('') .reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0) return hash.toString() } /** * @hook useBroadcastForm * @description Encapsulates all the logic for creating and editing a broadcast campaign. * This includes form management, validation, data cloning, and submission handlers. */ export const useBroadcastForm = ({ cloneData = null, onSuccess, onClose, }: useBroadcastFormProps) => { const license = useLicense() const { profile } = useAppStore() const form = useForm({ initialValues: defaultValues, validate: { numbers: (value) => { if (_.isEmpty(value)) return 'At least one recipient is required' if (license.isFree() && value.length > 5) { form.setFieldValue('numbers', _.initial(value)) return 'Free plan allows up to 5 contacts.' } return null }, scheduler: (value) => { if (license.isFree()) { form.setFieldValue('scheduler.enabled', false) return } if (value.enabled && !value.scheduledAt) { return 'Scheduled date and time is required.' } if ( value.enabled && value.scheduledAt && !isFuture(new Date(value.scheduledAt)) ) { return 'Scheduled time must be in the future.' } if ( license.isFree() && value.enabled && value.scheduledAt && differenceInHours(new Date(value.scheduledAt), new Date()) >= 1 ) { showModalUpgrade( 'Schedule for Any Day', 'Want to plan your broadcasts for tomorrow, next week, or even next month? Upgrade to Pro and unlock the freedom to schedule messages anytime in the future!', ) form.setFieldValue('scheduler.scheduledAt', new Date()) return } return null }, smartPause: (value) => { if (license.isFree()) { form.setFieldValue('smartPause.enabled', false) return } if (!value.enabled) return null if (!value.start || !value.end) { return 'Start and end times are required for Smart Pause.' } if (value.start >= value.end) { return 'Start time must be before end time.' } return null }, batch: (value) => { if (license.isFree()) { form.setFieldValue('batch.enabled', false) return } if (!value.enabled) return null if (!value.size || value.size < 1) { return 'Batch size must be at least 1.' } if (!value.delay || value.delay < 1) { return 'Batch delay must be at least 1 minute.' } return null }, delayMin: (value) => !value || value < 1 ? 'Minimum delay must be at least 1 second.' : null, delayMax: (value, values) => { if (!value || value < 1) return 'Maximum delay must be at least 1 second.' if (values.delayMin && value < values.delayMin) { return 'Max delay cannot be less than min delay.' } return null }, }, validateInputOnChange: [ 'numbers', 'scheduler.scheduledAt', 'warmupMode.enabled', 'batch.enabled', 'smartPause.enabled', 'scheduler.enabled', ], }) const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() useEffect(() => { const populateForm = async () => { if (cloneData) { let recipientsToSet: any[] = [] let nameSuffix = ' (Copy)' const broadcastName = `${cloneData.name || 'Broadcast'}` if (cloneData.recipients && cloneData.recipients.length > 0) { recipientsToSet = cloneData.recipients nameSuffix = ' (Resend)' } else { const originalRecipients = await db.broadcastContacts .where({ broadcastId: cloneData.id }) .toArray() recipientsToSet = originalRecipients.map((contact) => ({ number: contact.number, name: contact.name, })) } form.setValues({ name: `${broadcastName}${nameSuffix}`, numbers: recipientsToSet, tags: cloneData.tags || [], isTyping: !!cloneData.isTyping, validateNumbers: !!cloneData.validateNumbers, scheduler: { enabled: false, scheduledAt: addMinutes(new Date(), 5), }, smartPause: { enabled: !!cloneData.smartPauseEnabled, start: cloneData.smartPauseStart || '09:00', end: cloneData.smartPauseEnd || '17:00', }, batch: { enabled: !!cloneData.batchEnabled, size: cloneData.batchSize || 20, delay: cloneData.batchDelay || 15, }, // ADDED: Ensure warm-up mode setting is cloned. warmupMode: { enabled: !!cloneData.warmupModeEnabled, }, delayMin: cloneData.delayMin ? cloneData.delayMin / 1000 : 3, delayMax: cloneData.delayMax ? cloneData.delayMax / 1000 : 6, }) const { type, message } = cloneData inputMessageForm.setFieldValue('type', type) switch (type) { case Message.TEXT: inputMessageForm.setFieldValue('inputText', message as string) break case Message.IMAGE: case Message.VIDEO: case Message.FILE: const mediaFile = await db.media .where({ parentId: cloneData.id, type: Media.BROADCAST }) .first() const caption = (message as any)?.caption || (typeof message === 'string' ? message : '') if (type === Message.IMAGE) { inputMessageForm.setFieldValue('inputImage', { file: mediaFile?.file || null, caption, }) } else if (type === Message.VIDEO) { inputMessageForm.setFieldValue('inputVideo', { file: mediaFile?.file || null, caption, }) } else { inputMessageForm.setFieldValue('inputFile', { file: mediaFile?.file || null, caption, }) } break case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', message) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', message) break } } } if (cloneData) { populateForm().catch(console.error) } }, [cloneData]) const handleClose = () => { form.reset() inputMessageForm.reset() onClose() } const saveAndDispatchBroadcast = async () => { const messagePayload = getMessage() const messageType = inputMessageForm.values.type const broadcastData = { name: form.values.name, tags: form.values.tags, type: messageType, message: messagePayload, contentHash: hashMessage(messagePayload), isTyping: form.values.isTyping ? 1 : 0, isScheduler: form.values.scheduler.enabled ? 1 : 0, validateNumbers: form.values.validateNumbers ? 1 : 0, status: form.values.scheduler.enabled ? Status.SCHEDULER : Status.PENDING, delayMin: form.values.delayMin * 1000, delayMax: form.values.delayMax * 1000, smartPauseEnabled: form.values.smartPause.enabled ? 1 : 0, smartPauseStart: form.values.smartPause.start, smartPauseEnd: form.values.smartPause.end, batchEnabled: form.values.batch.enabled ? 1 : 0, batchSize: form.values.batch.size, batchDelay: form.values.batch.delay, // ADDED: Save the warm-up mode state to the database. warmupModeEnabled: form.values.warmupMode.enabled ? 1 : 0, resumeAt: null, } try { const broadcastId = await db.broadcasts.add(broadcastData as Broadcast) if (isTypeMessageMedia(inputMessageForm.values.type)) { await insertBroadcastFile(broadcastId, Media.BROADCAST) } //@ts-ignore const contacts: BroadcastContact[] = form.values.numbers.map( (recipient: any) => ({ broadcastId, number: recipient.number, name: recipient.name, status: form.values.scheduler.enabled ? Status.SCHEDULER : Status.PENDING, scheduledAt: form.values.scheduler.enabled ? form.values.scheduler.scheduledAt : null, }), ) await db.broadcastContacts.bulkAdd(contacts) onSuccess() } catch (error) { console.error('Failed to save broadcast:', error) toast.error('An error occurred while saving the broadcast.') } } const handleSendBroadcast = async () => { if (formHasErrors(form, inputMessageForm)) return 'VALIDATION_ERROR' const messagePayload = getMessage() const contentHash = hashMessage(messagePayload) const lastBroadcast = await db.broadcasts.orderBy('id').last() if (lastBroadcast && lastBroadcast.contentHash === contentHash) { return 'DUPLICATE' } const hasAcknowledged = await storage.get( Setting.HAS_ACKNOWLEDGED_BROADCAST_WARNING, ) if (!hasAcknowledged) { return 'NEEDS_WARNING' } await saveAndDispatchBroadcast() return 'SUCCESS' } const handleWarningAccepted = async () => { await storage.set(Setting.HAS_ACKNOWLEDGED_BROADCAST_WARNING, true) await saveAndDispatchBroadcast() } return { form, inputMessageForm, handleClose, handleSendBroadcast, handleWarningAccepted, forceSendBroadcast: saveAndDispatchBroadcast, } }
```

# src/relays/blocklist.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const blockContact = () => { relay( { name: Action.Blocklist.BLOCK_CONTACT, }, async ({ body }) => { return await WPP.blocklist.blockContact(body) }, ) } const isBlocked = () => { relay( { name: Action.Blocklist.IS_BLOCKED, }, async ({ body }) => { return WPP.blocklist.isBlocked(body) }, ) } const unblockContact = () => { relay( { name: Action.Blocklist.UNBLOCK_CONTACT, }, async ({ body }) => { return WPP.blocklist.unblockContact(body) }, ) } const initBlocklistRelays = () => { all() blockContact() isBlocked() unblockContact() } export default initBlocklistRelays
```

# src/relays/cart.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const add = () => { relay( { name: Action.Cart.ADD, }, async ({ body }) => { const { chatId, products } = body return await WPP.cart.add(chatId, products) }, ) } const clear = () => { relay( { name: Action.Cart.CLEAR, }, async ({ body }) => { return await WPP.cart.clear(body) }, ) } const get = () => { relay( { name: Action.Cart.GET, }, async ({ body }) => { return WPP.cart.get(body) }, ) } const getThumbFromCart = () => { relay( { name: Action.Cart.GET_THUMB_FROM_CART, }, async ({ body }) => { return await WPP.cart.getThumbFromCart(body) }, ) } const remove = () => { relay( { name: Action.Cart.REMOVE, }, async ({ body }) => { const { chatId, productId } = body return WPP.cart.remove(chatId, productId) }, ) } const submit = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { wid, msg, options } = body return WPP.cart.submit(wid, msg, options) }, ) } const update = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { chatId, productId, options } = body return WPP.cart.update(chatId, productId, options) }, ) } const initCartRelays = () => { add() clear() get() getThumbFromCart() remove() submit() update() } export default initCartRelays
```

# src/relays/catalog.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const addProductImage = () => { relay( { name: Action.Catalog.ADD_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.addProductImage(productId, content) }, ) } const changeProductImage = () => { relay( { name: Action.Catalog.CHANGE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.changeProductImage(productId, content) }, ) } const createCollection = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { const { collectionName, productsId } = body return await WPP.catalog.createCollection(collectionName, productsId) }, ) } const createProduct = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.createProduct(body) }, ) } const deleteCollection = () => { relay( { name: Action.Catalog.DELETE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.deleteCollection(body) }, ) } const deleteProduct = () => { relay( { name: Action.Catalog.DELETE_PRODUCT, }, async ({ body }) => { return await WPP.catalog.delProducts(body) }, ) } const editCollection = () => { relay( { name: Action.Catalog.EDIT_COLLECTION, }, async ({ body }) => { const { collectionId, params } = body return await WPP.catalog.editCollection(collectionId, params) }, ) } const editProduct = () => { relay( { name: Action.Catalog.EDIT_PRODUCT, }, async ({ body }) => { const { productId, params } = body return await WPP.catalog.editProduct(productId, params) }, ) } const getCollections = () => { relay( { name: Action.Catalog.GET_COLLECTIONS, }, async ({ body }) => { const { chatId, qnt, productsCount } = body return await WPP.catalog.getCollections(chatId, qnt, productsCount) }, ) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ const getMyCatalog = () => { relay( { name: Action.Catalog.GET_MY_CATALOG, }, async ({ body }) => { return await WPP.catalog.getMyCatalog() }, ) } const getProductById = () => { relay( { name: Action.Catalog.GET_PRODUCT_BY_ID, }, async ({ body }) => { const { chatId, productId } = body return await WPP.catalog.getProductById(chatId, productId) }, ) } const getProducts = () => { relay( { name: Action.Catalog.GET_PRODUCTS, }, async ({ body }) => { const { chatId, qnt } = body return await WPP.catalog.getProducts(chatId, qnt) }, ) } const removeProductImage = () => { relay( { name: Action.Catalog.REMOVE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, index } = body return await WPP.catalog.removeProductImage(productId, index) }, ) } const setProductVisibility = () => { relay( { name: Action.Catalog.SET_PRODUCT_VISIBILITY, }, async ({ body }) => { const { productId, isHidden } = body return await WPP.catalog.setProductVisibility(productId, isHidden) }, ) } const updateCartEnabled = () => { relay( { name: Action.Catalog.UPDAGE_CART_ENABLED, }, async ({ body }) => { return await WPP.catalog.updateCartEnabled(body) }, ) } const initCatalogRelays = () => { addProductImage() changeProductImage() createCollection() createProduct() deleteCollection() deleteProduct() editCollection() editProduct() getCollections() getMyCatalog() getProductById() getProducts() removeProductImage() setProductVisibility() updateCartEnabled() } export default initCatalogRelays
```

# src/relays/chat.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const archive = () => { relay( { name: Action.Chat.ARCHIVE, }, async ({ body }) => { return await WPP.chat.archive(body) }, ) } const canMarkPlayed = () => { relay( { name: Action.Chat.CAN_MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.canMarkPlayed(body) }, ) } const canMute = () => { relay( { name: Action.Chat.CAN_MUTE, }, async ({ body }) => { return WPP.chat.canMute(body) }, ) } const canReply = () => { relay( { name: Action.Chat.CAN_REPLY, }, async ({ body }) => { return await WPP.chat.canReply(body) }, ) } const clear = () => { relay( { name: Action.Chat.CLEAR, }, async ({ body }) => { return await WPP.chat.clear(body) }, ) } const closeChat = () => { relay( { name: Action.Chat.CLOSE_CHAT, }, async ({ body }) => { return await WPP.chat.closeChat() }, ) } const _delete = () => { relay( { name: Action.Chat.DELETE, }, async ({ body }) => { return await WPP.chat.delete(body) }, ) } const deleteMessage = () => { relay( { name: Action.Chat.DELETE_MESSAGE, }, async ({ body }) => { const { chatId, ids, deleteMediaInDevice, revoke } = body return await WPP.chat.deleteMessage( chatId, ids, deleteMediaInDevice, revoke, ) }, ) } const list = () => { relay( { name: Action.Chat.LIST, }, async ({ body }) => { console.log('body', body) return (await WPP.chat.list(body)).map(serialize.chat) }, ) } const find = () => { relay( { name: Action.Chat.FIND, }, async (req) => { try { const chatId = req.body const chat = await WPP.chat.find(chatId) return response.success(serialize.chat(chat)) } catch (error) { return response.error(error.message) } }, ) } const forwardMessage = () => { relay( { name: Action.Chat.FORWARD_MESSAGE, }, async ({ body }) => { const { toChatId, msgId, options } = body return await WPP.chat.forwardMessage(toChatId, msgId, options) }, ) } const get = () => { relay( { name: Action.Chat.GET, }, async ({ body }) => { try { const chat = WPP.chat.get(body) return serialize.chat(chat) } catch (error) {} }, ) } const getActiveChat = () => { relay( { name: Action.Chat.GET_ACTIVE_CHAT, }, async (req) => { try { const chat = WPP.chat.getActiveChat() if (!chat) { return null } return serialize.chat(chat) } catch (error) { return null } }, ) } const getLastSeen = () => { relay( { name: Action.Chat.GET_LAST_SEEN, }, async ({ body }) => { return await WPP.chat.getLastSeen(body) }, ) } const getMessageACK = () => { relay( { name: Action.Chat.GET_MESSAGE_ACK, }, async ({ body }) => { return await WPP.chat.getMessageACK(body) }, ) } const getMessages = () => { relay( { name: Action.Chat.GET_MESSAGES, }, async ({ body }) => { const { chatId, options } = body const messages = await WPP.chat.getMessages(chatId, options) return messages.map(serialize.message) }, ) } const getNotes = () => { relay( { name: Action.Chat.GET_NOTES, }, async ({ body }) => { return await WPP.chat.getNotes(body) }, ) } const getPlatformFromMessage = () => { relay( { name: Action.Chat.GET_PLATFORM_MESSAGE, }, async ({ body }) => { return WPP.chat.getPlatformFromMessage(body) }, ) } const markIsComposing = () => { relay( { name: Action.Chat.MARK_IS_COMPOSING, }, async ({ body }) => { const { chatId, duration } = body return WPP.chat.markIsComposing(chatId, duration) }, ) } const markIsPaused = () => { relay( { name: Action.Chat.MARK_IS_PAUSED, }, async ({ body }) => { return await WPP.chat.markIsPaused(body) }, ) } const markIsRead = () => { relay( { name: Action.Chat.MARK_IS_READ, }, async ({ body }) => { return await WPP.chat.markIsRead(body) }, ) } const markIsRecording = () => { relay( { name: Action.Chat.MARK_IS_RECORDING, }, async ({ body }) => { return await WPP.chat.markIsRecording(body) }, ) } const markIsUnread = () => { relay( { name: Action.Chat.MARK_IS_UNREAD, }, async ({ body }) => { return await WPP.chat.markIsUnread(body) }, ) } const markPlayed = () => { relay( { name: Action.Chat.MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.markPlayed(body) }, ) } const mute = () => { relay( { name: Action.Chat.MUTE, }, async ({ body }) => { const { chatId, time } = body return await WPP.chat.mute(chatId, time) }, ) } const openChatAt = () => { relay( { name: Action.Chat.OPEN_CHAT_AT, }, async ({ body }) => { const { chatId, messageId } = body return await WPP.chat.openChatAt(chatId, messageId) }, ) } const openChatFromUnread = () => { relay( { name: Action.Chat.OPEN_CHAT_FROM_UNREAD, }, async ({ body }) => { return await WPP.chat.openChatFromUnread(body) }, ) } const pinMsg = () => { relay( { name: Action.Chat.PIN_MSG, }, async ({ body }) => { const { msgId, pin, seconds } = body return await WPP.chat.pinMsg(msgId, pin, seconds) }, ) } const openChatBottom = () => { relay( { name: Action.Chat.OPEN_CHAT_BOTTOM, }, async (req) => { try { const chatId = req.body return await WPP.chat.openChatBottom(chatId) } catch (error) { return false } }, ) } const setChatList = () => { relay( { name: Action.Chat.SET_CHAT_LIST, }, async (req) => { try { const { type, ids } = req.body await WPP.chat.setChatList(type, ids) } catch (error) { console.error(`setChatList: ${error}`) } }, ) } const setInputText = () => { relay( { name: Action.Chat.SET_INPUT_TEXT, }, async ({ body }) => { const { text, chatId } = body return await WPP.chat.setInputText(text, chatId) }, ) } const setNotes = () => { relay( { name: Action.Chat.SET_NOTES, }, async ({ body }) => { const { chatId, content } = body return await WPP.chat.setNotes(chatId, content) }, ) } const downloadMedia = () => { relay( { name: Action.Chat.DOWNLOAD_MEDIA, }, async ({ body: messageId }) => { try { const media = await Promise.race([ WPP.chat.downloadMedia(messageId), new Promise((_, reject) => setTimeout(() => reject(new Error('Error download media')), 3000), ), ]) return media } catch (error) { return null } }, ) } const initChatRelay = () => { archive() canMarkPlayed() canMute() canReply() clear() closeChat() _delete() deleteMessage() downloadMedia() find() forwardMessage() get() getActiveChat() getLastSeen() getMessageACK() getMessages() getNotes() getPlatformFromMessage() markIsComposing() markIsPaused() markIsRead() markIsRecording() markIsUnread() markPlayed() mute() list() openChatBottom() openChatAt() openChatFromUnread() pinMsg() setChatList() setInputText() setNotes() } export default initChatRelay
```

# src/relays/community.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const initCommunityRelays = () => { all() } export default initCommunityRelays
```

# src/relays/conn.relay.ts

```ts
import { Account, Action } from '@/constants' import country from '@/utils/country' import { delay } from '@/utils/util' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const genLinkDeviceCodeForPhoneNumber = () => { relay( { name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }, async ({ body }) => { const { phone, sendPushNotification } = body return await WPP.conn.genLinkDeviceCodeForPhoneNumber( phone, sendPushNotification, ) }, ) } const getAuthCode = () => { relay( { name: Action.Conn.GET_AUTH_CODE, }, async ({ body }) => { return await WPP.conn.getAuthCode() }, ) } const getMyUserId = () => { relay( { name: Action.Conn.GET_MY_USER_ID, }, async (req) => { return WPP.conn.getMyUserId() }, ) } const getProfile = () => { relay( { name: Action.Conn.GET_PROFILE, }, async (req) => { await delay(1000) const { user: number } = WPP.conn.getMyUserId() const contact = await WPP.contact.get(`${number}@c.us`) const countryCode = await WPP.whatsapp.functions.getCountryShortcodeByPhone(contact.id.user) const selectedCountry = country.getCountryByCode(countryCode) return { name: contact.pushname || contact.formattedName || contact.name || contact.verifiedName, number, type: contact.isBusiness ? Account.BUSINESS : Account.PERSONAL, country: selectedCountry.label, } }, ) } const initConnRelays = () => { genLinkDeviceCodeForPhoneNumber() getAuthCode() getMyUserId() getProfile() } export default initConnRelays
```

# src/relays/contact.relay.ts

```ts
import { Action } from '@/constants' import filterBy from '@/utils/filterBy' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Contact.GET, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getBusinessProfile = () => { relay( { name: Action.Contact.GET_BUSINESS_PROFILE, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getCommonGroups = () => { relay( { name: Action.Contact.GET_COMMON_GROUPS, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getProfilePictureUrl = () => { relay( { name: Action.Contact.GET_PROFILE_PICTURE_URL, }, async ({ body }) => { const { contactId, full } = body return await WPP.contact.getProfilePictureUrl(contactId, full) }, ) } const getStatus = () => { relay( { name: Action.Contact.GET_STATUS, }, async ({ body }) => { return await WPP.contact.getStatus(body) }, ) } const list = () => { relay( { name: Action.Contact.LIST, }, async (req) => { const options = req.body const contacts = ((await WPP.contact.list(options)) ?? []) .filter(filterBy.dontIncludeLid) .map(serialize.contact) return contacts }, ) } const isExist = () => { relay( { name: Action.Contact.IS_EXIST, }, async (req) => { try { const contactId = req.body const result = await WPP.contact.queryExists(contactId) return !!result } catch (error) { return false } }, ) } const initContactRelay = () => { get() getBusinessProfile() getCommonGroups() getProfilePictureUrl() getStatus() isExist() list() } export default initContactRelay
```

# src/relays/group.relay.ts

```ts
import { Action } from '@/constants' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' import { contact } from '@wppconnect/wa-js' import _ from 'lodash' const addParticipants = () => { relay( { name: Action.Group.ADD_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.addParticipants(groupId, participantsIds) }, ) } const approve = () => { relay( { name: Action.Group.APPROVE, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.approve(groupId, membershipIds) }, ) } const canAdd = () => { relay( { name: Action.Group.CAN_ADD, }, async ({ body }) => { return await WPP.group.canAdd(body) }, ) } const canDemote = () => { relay( { name: Action.Group.CAN_DEMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canDemote(groupId, participantsIds) }, ) } const canPromote = () => { relay( { name: Action.Group.CAN_PROMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canPromote(groupId, participantsIds) }, ) } const canRemove = () => { relay( { name: Action.Group.CAN_REMOVE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canRemove(groupId, participantsIds) }, ) } const create = () => { relay( { name: Action.Group.CREATE, }, async ({ body }) => { const { groupName, participantsIds, parentGroup } = body return await WPP.group.create(groupName, participantsIds, parentGroup) }, ) } const demoteParticipants = () => { relay( { name: Action.Group.DEMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.demoteParticipants(groupId, participantsIds) }, ) } const getGroupInfoFromInviteCode = () => { relay( { name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, }, async ({ body }) => { return await WPP.group.getGroupInfoFromInviteCode(body) }, ) } const getGroupSizeLimit = () => { relay( { name: Action.Group.GET_GROUP_SIZE_LIMIT, }, async ({ body }) => { return await WPP.group.getGroupSizeLimit() }, ) } const list = () => { relay( { name: Action.Group.LIST, }, async ({ body }) => { try { const me = WPP.conn.getMyUserId() const groups = (await WPP.chat.list({ onlyGroups: true })).map( (group) => { const participants = group.groupMetadata.participants .getModelsArray() .map(serialize.participant) .filter( (participant) => //@ts-ignore participant.contact.phoneNumber?.user !== me.user, ) const id = `${group.id.user}@${group.id.server}` return { id, name: group.name || group.formattedTitle, desc: group.groupMetadata?.desc, avatar: group.contact?.getProfilePicThumb().__x_eurl, size: group.groupMetadata?.size, participants, isAdmin: group.groupMetadata?.participants?.iAmAdmin(), isSuperAdmin: group.groupMetadata?.participants?.iAmSuperAdmin(), superAdmin: serialize.contact( group.groupMetadata?.participants?.getSuperAdmin()?.contact, ), admins: group.groupMetadata?.participants ?.getAdmins() .map((participant) => serialize.contact(participant.contact)), } }, ) return _.sortBy(groups, 'name') } catch (error) { return [] } }, ) } const getInviteLink = () => { relay( { name: Action.Group.GET_INVITE_LINK, }, async (req) => { try { const { groupId } = req.body const link = await WPP.group.getInviteCode(groupId) return `https://chat.whatsapp.com/${link}` } catch (error) { console.error(`getInviteLink relay error: ${error}`) return null } }, ) } const getMembershipRequests = () => { relay( { name: Action.Group.GET_MEMBERSHIP_REQUESTS, }, async ({ body }) => { return await WPP.group.getMembershipRequests(body) }, ) } const getParticipants = () => { relay( { name: Action.Group.GET_PARTICIPANTS, }, async ({ body }) => { try { const participants = await WPP.group.getParticipants(body) return participants.map(serialize.participant) } catch (error) { return [] } }, ) } const iAmAdmin = () => { relay( { name: Action.Group.IAM_ADMIN, }, async ({ body }) => { return await WPP.group.iAmAdmin(body) }, ) } const iAmMember = () => { relay( { name: Action.Group.IAM_MEMBER, }, async ({ body }) => { return await WPP.group.iAmMember(body) }, ) } const iAmRestrictedMember = () => { relay( { name: Action.Group.IAM_RESTRICTED_MEMBER, }, async ({ body }) => { return await WPP.group.iAmRestrictedMember(body) }, ) } const iAmSuperAdmin = () => { relay( { name: Action.Group.IAM_SUPER_ADMIN, }, async ({ body }) => { return await WPP.group.iAmSuperAdmin(body) }, ) } const join = () => { relay( { name: Action.Group.JOIN, }, async ({ body }) => { return await WPP.group.join(body) }, ) } const leave = () => { relay( { name: Action.Group.LEAVE, }, async ({ body }) => { return await WPP.group.leave(body) }, ) } const promoteParticipants = () => { relay( { name: Action.Group.PROMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.promoteParticipants(groupId, participantsIds) }, ) } const reject = () => { relay( { name: Action.Group.REJECT, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.reject(groupId, membershipIds) }, ) } const removeIcon = () => { relay( { name: Action.Group.REMOVE_ICON, }, async ({ body }) => { return await WPP.group.removeIcon(body) }, ) } const removeParticipants = () => { relay( { name: Action.Group.REMOVE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.removeParticipants(groupId, participantsIds) }, ) } const revokeInviteCode = () => { relay( { name: Action.Group.REVOKE_INVITE_CODE, }, async ({ body }) => { return await WPP.group.revokeInviteCode(body) }, ) } const setDescription = () => { relay( { name: Action.Group.SET_DESCRIPTION, }, async ({ body }) => { const { groupId, description } = body return await WPP.group.setDescription(groupId, description) }, ) } const setIcon = () => { relay( { name: Action.Group.SET_ICON, }, async ({ body }) => { const { groupId, content } = body return await WPP.group.setIcon(groupId, content) }, ) } const setProperty = () => { relay( { name: Action.Group.SET_PROPERTY, }, async ({ body }) => { const { groupId, property, value } = body return await WPP.group.setProperty(groupId, property, value) }, ) } const setSubject = () => { relay( { name: Action.Group.SET_SUBJECT, }, async ({ body }) => { const { groupId, subject } = body return await WPP.group.setSubject(groupId, subject) }, ) } const initGroupRelay = () => { addParticipants() approve() canAdd() canDemote() canPromote() canRemove() create() demoteParticipants() getInviteLink() getGroupInfoFromInviteCode() getGroupSizeLimit() getMembershipRequests() getParticipants() list() iAmAdmin() iAmMember() iAmRestrictedMember() iAmSuperAdmin() join() leave() promoteParticipants() reject() removeIcon() removeParticipants() revokeInviteCode() setDescription() setIcon() setProperty() setSubject() } export default initGroupRelay
```

# src/relays/index.ts

```ts
import initBlocklistRelays from './blocklist.relay' import initCartRelays from './cart.relay' import initChatRelay from './chat.relay' import initConnRelays from './conn.relay' import initContactRelay from './contact.relay' import initGroupRelay from './group.relay' import initSendRelay from './send.relay' import initStatusRelay from './status.relay' export const initInjectScriptRelays = () => { initBlocklistRelays() initCartRelays() initChatRelay() initConnRelays() initContactRelay() initGroupRelay() initSendRelay() initStatusRelay() }
```

# src/relays/newsletter.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const create = () => { relay( { name: Action.Newsletter.CREATE, }, async ({ body }) => { const { name, opts } = body return await WPP.newsletter.create(name, opts) }, ) } const destroy = () => { relay( { name: Action.Newsletter.DESTROY, }, async ({ body }) => { return await WPP.newsletter.destroy(body) }, ) } const edit = () => { relay( { name: Action.Newsletter.EDIT, }, async ({ body }) => { const { newsletterId, opts } = body return await WPP.newsletter.edit(newsletterId, opts) }, ) } const getSubscribers = () => { relay( { name: Action.Newsletter.GET_SUBSCRIBERS, }, async ({ body }) => { return await WPP.newsletter.getSubscribers(body) }, ) } const mute = () => { relay( { name: Action.Newsletter.MUTE, }, async ({ body }) => { const { newsletterId, value } = body return await WPP.newsletter.mute(newsletterId, value) }, ) } const initNewsletterRelay = () => { create() destroy() edit() getSubscribers() mute() } export default initNewsletterRelay
```

# src/relays/profile.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Profile.EDIT_BUSINESS_PROFILE, }, async ({ body }) => { return WPP.status.get(body) }, ) } const initProfileRelays = () => { get() } export default initProfileRelays
```

# src/relays/send.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const sendText = () => { relay( { name: Action.Send.TEXT, }, async (req) => { try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendTextMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendFile = () => { relay( { name: Action.Send.FILE, }, async (req) => { console.log('req', req) try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendFileMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendLocation = () => { relay( { name: Action.Send.LOCATION, }, async (req) => { try { const { chatId, options } = req.body const { sendMsgResult } = await WPP.chat.sendLocationMessage( chatId, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendPoll = () => { relay( { name: Action.Send.POLL, }, async (req) => { try { const { chatId, name, choices, options } = req.body const { sendMsgResult } = await WPP.chat.sendCreatePollMessage( chatId, name, choices, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendVCard = () => { relay( { name: Action.Send.VCARD, }, async (req) => { try { const { chatId, contacts, options } = req.body const { sendMsgResult } = await WPP.chat.sendVCardContactMessage( chatId, contacts, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const initSendRelay = () => { sendText() sendFile() sendLocation() sendPoll() sendVCard() } export default initSendRelay
```

# src/relays/status.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Status.GET, }, async ({ body }) => { return WPP.status.get(body) }, ) } const getMyStatus = () => { relay( { name: Action.Status.GET_MY_STATUS, }, async ({ body }) => { return await WPP.status.getMyStatus() }, ) } const remove = () => { relay( { name: Action.Status.REMOVE, }, async ({ body }) => { return await WPP.status.remove(body) }, ) } const sendImageStatus = () => { relay( { name: Action.Status.SEND_IMAGE_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendImageStatus(content, options) }, ) } const sendReadStatus = () => { relay( { name: Action.Status.SEND_READ_STATUS, }, async ({ body }) => { const { chatId, statusId } = body return await WPP.status.sendReadStatus(chatId, statusId) }, ) } const sendTextStatus = () => { relay( { name: Action.Status.SEND_TEXT_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendTextStatus(content, options) }, ) } const sendVideoStatus = () => { relay( { name: Action.Status.SEND_VIDEO_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendVideoStatus(content, options) }, ) } const updateParticipants = () => { relay( { name: Action.Status.UPDATE_PARTICIPANTS, }, async ({ body }) => { return await WPP.status.updateParticipants(body) }, ) } const initStatusRelay = () => { get() getMyStatus() remove() sendImageStatus() sendReadStatus() sendTextStatus() sendVideoStatus() updateParticipants() } export default initStatusRelay
```

# src/stores/app.ts

```ts
import type { License } from '@/types' import { create } from 'zustand' interface AppState { isReady: boolean setIsReady: (isReady: boolean) => void profile: any setProfile: (profile: any) => void license?: License | null setLicense: (license: any) => void groups: any[] setGroups: (groups: []) => void isLoading: boolean setIsLoading: (state: boolean) => void activeChat: any setActiveChat: (chat: any) => void } export const useAppStore = create<AppState>((set) => ({ isReady: false, setIsReady: (isReady: boolean) => set({ isReady }), license: null, setLicense: (license: any) => set({ license: license }), groups: [], setGroups: (groups: []) => set({ groups }), profile: {}, setProfile: (profile: any) => set({ profile }), isLoading: false, setIsLoading: (state: any) => set({ isLoading: state }), activeChat: {}, setActiveChat: (chat: any) => set({ activeChat: chat }), }))
```

# src/stores/toast.ts

```ts
import { create } from 'zustand' export interface Toast { id: number type: 'success' | 'error' | 'info' | 'warning' title: string message: string duration?: number } interface ToastState { toasts: Toast[] addToast: (toast: Omit<Toast, 'id'>) => void removeToast: (id: number) => void } export const useToastStore = create<ToastState>((set) => ({ toasts: [], addToast: (toast) => set((state) => ({ toasts: [...state.toasts, { ...toast, id: Date.now() }], })), removeToast: (id) => set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id), })), }))
```

# src/styles/globals.css

```css
div.plasmo-csui-container { margin: 0; color-scheme: var(--mantine-color-scheme); font-family: var(--mantine-font-family); font-size: var(--mantine-font-size-md); line-height: var(--mantine-line-height); background-color: var(--mantine-color-body); color: var(--mantine-color-text); -webkit-font-smoothing: var(--mantine-webkit-font-smoothing); -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing); right: 0px; left: auto !important; } .root { position: fixed; top: '30%'; left: '50%'; transform: 'translate(-50%, -50%)'; z-index: 1001; background-color: red; } #plasmo-inline { background: transparent; }
```

# src/tabs/landing-page.tsx

```tsx
import { PRIMARY_ICON } from '@/constants' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { Accordion, Anchor, Avatar, Badge, Box, Button, Card, Center, Container, Divider, Grid, Group, List, MantineProvider, Paper, Stack, Table, Text, ThemeIcon, Title, Tooltip, Transition, } from '@mantine/core' import '@mantine/core/styles.css' import { useWindowScroll } from '@mantine/hooks' import React, { useEffect, useState } from 'react' // --- Start: Updated Config for Direct Chat Focus --- // Define a structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // Centralized list of features for easy management and comparison const comparisonFeatures: PlanFeature[] = [ { feature: 'Start Chats Without Saving Numbers', free: true, pro: true, }, { feature: 'Send Text Messages', free: true, pro: true, }, { feature: 'Send Media (Images, Videos, Docs)', free: false, pro: true, }, { feature: 'Share Location Pins', free: false, pro: true, }, { feature: 'Save Unlimited Message Templates', free: '1 Template', pro: 'Unlimited', }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, ] // Define plan objects for the pricing cards. const plans = [ { name: 'Free', isFree: true, description: 'For basic direct messaging needs.', price: '$0', placeholderPrice: null, link: '#', features: [ 'Start unlimited chats', 'No need to save contacts', 'Send text messages only', 'Standard support', ], }, { name: 'Pro Lifetime', isFree: false, description: 'Pay once, unlock powerful messaging features forever.', placeholderPrice: '$89', price: '$39', link: 'https://extdotninja.lemonsqueezy.com/buy/53f1c17b-8636-49cf-b454-ab0ad2700418?media=0&logo=0&desc=0&discount=0', features: [ 'Send All Media Types (Images, Videos, Files)', 'Share Locations', 'Save Unlimited Message Templates', 'Priority Customer Support', 'All Future Updates Included', ], }, ] // --- End: Updated Config --- const CheckIcon = () => ( <Icon icon="tabler:check" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-teal-6)" /> ) const CrossIcon = () => ( <Icon icon="tabler:x" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-red-6)" /> ) // --- Countdown Timer Logic --- interface TimeLeft { days: number hours: number minutes: number seconds: number } const calculateTimeLeft = (offerEndDate: Date): TimeLeft | null => { const difference = +offerEndDate - +new Date() if (difference <= 0) { return null } return { days: Math.floor(difference / (1000 * 60 * 60 * 24)), hours: Math.floor((difference / (1000 * 60 * 60)) % 24), minutes: Math.floor((difference / 1000 / 60) % 60), seconds: Math.floor((difference / 1000) % 60), } } const TimeSegment: React.FC<{ value: number; label: string }> = ({ value, label, }) => ( <Stack align="center" gap={0}> <Text fz={32} fw={700} c="yellow.6"> {' '} {String(value).padStart(2, '0')}{' '} </Text> <Text size="xs" c="dimmed"> {' '} {label}{' '} </Text> </Stack> ) const CountdownTimer: React.FC<{ offerEndDate: Date; isMini?: boolean }> = ({ offerEndDate, isMini = false, }) => { const [timeLeft, setTimeLeft] = useState<TimeLeft | null>( calculateTimeLeft(offerEndDate), ) useEffect(() => { const timer = setInterval(() => { setTimeLeft(calculateTimeLeft(offerEndDate)) }, 1000) return () => clearInterval(timer) }, [offerEndDate]) if (!timeLeft) { return ( <Text c="red.7" fw={700} size="lg"> {' '} Offer has ended!{' '} </Text> ) } if (isMini) { return ( <Text c="white" size="sm" fw={500}> {' '} Offer Ends In: {String(timeLeft.days).padStart(2, '0')}: {String(timeLeft.hours).padStart(2, '0')}: {String(timeLeft.minutes).padStart(2, '0')}: {String(timeLeft.seconds).padStart(2, '0')} </Text> ) } return ( <Group justify="center" gap="lg"> <TimeSegment value={timeLeft.days} label="DAYS" /> <TimeSegment value={timeLeft.hours} label="HOURS" /> <TimeSegment value={timeLeft.minutes} label="MINUTES" /> <TimeSegment value={timeLeft.seconds} label="SECONDS" /> </Group> ) } // --- End Countdown Timer Logic --- // --- Section Components --- const HeroSection = () => ( <Center p="xl" pt={80}> <Stack align="center" gap="xl" ta="center" maw={700}> <ThemeIcon size={80} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon="tabler:message-circle-plus" fontSize={48} /> </ThemeIcon> <Title order={1} fz={{ base: 36, sm: 48 }}> {' '} Instantly Start WhatsApp Chats Without Saving Numbers.{' '} </Title> <Text c="dimmed" fz="lg"> {' '} The fastest way to send messages, images, videos, and files to any WhatsApp number. No more cluttering your contact list for one-time conversations.{' '} </Text> <Stack align="center"> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > {' '} Get Lifetime Access Now{' '} </Button> <Text size="xs" c="dimmed"> {' '} Includes 30-day money-back guarantee{' '} </Text> </Stack> </Stack> </Center> ) const FeaturesSection = () => { const featuresData = [ { icon: 'tabler:address-book-off', title: 'No More "Ghost" Contacts', description: 'Message any number without saving it. Perfect for business inquiries, customer support, or one-time contacts.', }, { icon: 'tabler:paperclip', title: 'Send Anything, Instantly', description: 'Go beyond text. The Pro version lets you send images, videos, documents.', }, { icon: 'tabler:shield-lock', title: 'Private & Secure', description: 'Your messages are sent directly via WhatsApp Web. We never see, store, or have access to your conversations.', }, { icon: 'tabler:template', title: 'Save Time with Templates', description: 'Create and reuse message templates for common replies, greetings, or information. (Pro Feature)', }, { icon: 'tabler:rocket', title: 'Simple & Fast', description: 'A clean, intuitive interface designed to get your message sent in seconds, right from WhatsApp Web.', }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>A Smarter Way to Chat</Title> <Text c="dimmed"> {' '} Unlock powerful features that make direct messaging faster and more efficient.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {featuresData.map((feature) => ( <Grid.Col span={{ base: 12, md: 4 }} key={feature.title}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon={feature.icon} fontSize={22} /> </ThemeIcon> <Text fw={700} fz="lg"> {' '} {feature.title}{' '} </Text> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} {feature.description}{' '} </Text> </Card> </Grid.Col> ))} </Grid> </Box> ) } const UserPersonaSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Built For Everyone</Title> <Text c="dimmed"> {' '} Whether for work or personal convenience, we've got you covered.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:briefcase" fontSize={22} /> </ThemeIcon> <Title order={3}>For Professionals & Business</Title> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} Quickly follow up with leads, send quotes, or provide support without adding every number to your business phone.{' '} </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> {' '} Send promotional images or PDF invoices directly.{' '} </List.Item> <List.Item> {' '} Keep your professional contacts list clean and organized.{' '} </List.Item> </List> <Button component="a" href="#pricing" mt="auto" variant="light" color="teal" > {' '} Upgrade for Business Needs{' '} </Button> </Stack> </Card> </Grid.Col> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:heart" fontSize={22} /> </ThemeIcon> <Title order={3}>For Personal Use</Title> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} Contact a seller on a marketplace, RSVP to an event, or message a new acquaintance without filling your address book.{' '} </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> {' '} Quickly message someone from a classifieds ad.{' '} </List.Item> <List.Item> {' '} Send your location to a friend you're meeting.{' '} </List.Item> <List.Item> {' '} Keep your personal contacts for people you actually know.{' '} </List.Item> </List> <Button component="a" href="#pricing" mt="auto" variant="light" color="teal" > {' '} Get More Convenience{' '} </Button> </Stack> </Card> </Grid.Col> </Grid> </Box> ) const CaseStudySection = () => { const caseStudies = [ { icon: 'tabler:building-store', title: 'Contacting a Marketplace Seller', description: "A user wants to ask about an item on an online marketplace. Instead of saving the seller's number, they use the extension to instantly send a message and a picture of the item.", features: ['No Contact Saving', 'Send Images'], persona: 'For Online Shoppers', }, { icon: 'tabler:users', title: 'Following Up with a Lead', description: 'A sales professional meets a new lead and needs to send them a company brochure. She quickly sends the PDF without cluttering her personal contacts.', features: ['Send Documents'], persona: 'For Sales & Business', }, { icon: 'tabler:tools-kitchen-2', title: 'Coordinating with a Technician', description: 'A homeowner needs to send their address to a repairman. They use the extension to share a location pin directly, ensuring the technician finds their house without any hassle.', features: ['Send Location', 'Quick Messaging'], persona: 'For Everyday Tasks', }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Solves Real-World Problems</Title> <Text c="dimmed"> {' '} See how people use our tool to make communication faster and easier.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {caseStudies.map((study) => ( <Grid.Col span={{ base: 12, md: 4 }} key={study.title}> <Card withBorder radius="lg" p="xl" style={{ height: '100%', display: 'flex', flexDirection: 'column', }} > <Stack style={{ flexGrow: 1 }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon={study.icon} fontSize={22} /> </ThemeIcon> <Title order={4}>{study.title}</Title> </Group> <Text c="dimmed" size="sm" mt="sm"> {' '} {study.description}{' '} </Text> </Stack> <Group gap="xs" mt="lg"> {study.features.map((feature) => ( <Badge key={feature} variant="light" color="teal"> {feature} </Badge> ))} </Group> </Card> </Grid.Col> ))} </Grid> </Box> ) } const PricingSection: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => ( <Box mt={80} id="pricing"> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Get a Lifetime License</Title> <Text c="dimmed">One single payment. All Pro features forever.</Text> </Stack> </Center> <Group justify="center" align="stretch" mt="xl" gap="lg"> {plans.map((plan, index) => ( <Paper key={index} withBorder w={{ base: '100%', sm: 380 }} radius={'lg'} p="xl" style={{ border: !plan.isFree ? '2px solid var(--mantine-color-teal-6)' : undefined, boxShadow: !plan.isFree ? 'var(--mantine-shadow-lg)' : 'var(--mantine-shadow-sm)', position: 'relative', }} > <Stack justify="space-between" style={{ height: '100%' }}> <Box ta="center"> <Title order={2}>{plan.name}</Title> <Text c="dimmed" mt={4} size="sm"> {' '} {plan.description}{' '} </Text> </Box> <Box my="lg" ta="center"> {!plan.isFree && ( <Stack mb="lg"> <Title order={4} c="orange.7"> {' '} LAUNCH OFFER: 56% OFF ENDS SOON!{' '} </Title> <CountdownTimer offerEndDate={offerEndDate} /> <Text size="xs" c="dimmed" mt="xs"> {' '} Don't miss out on saving $50. Price returns to normal after the timer ends.{' '} </Text> </Stack> )} <Box pos="relative"> <Group gap={8} align={'baseline'} justify="center"> {plan.placeholderPrice && ( <Title order={3} c={'dimmed'} style={{ textDecorationLine: 'line-through' }} > {' '} {plan.placeholderPrice}{' '} </Title> )} <Title order={1} fz={52}> {' '} {plan.price}{' '} </Title> </Group> </Box> </Box> <Divider label="Key Features" labelPosition="center" my="sm" /> <Stack gap="sm" mb="lg"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="sm" wrap="nowrap" align="flex-start"> <ThemeIcon variant="light" color={plan.isFree ? 'gray' : 'teal'} size="sm" radius="xl" > {plan.isFree ? ( <Icon icon="tabler:circle-check" fontSize={16} /> ) : ( <Icon icon="tabler:star" fontSize={16} /> )} </ThemeIcon> <Text size="sm">{feature}</Text> </Group> ))} </Stack> <Box mt="auto"> {plan.isFree ? ( <Button size="md" variant="default" fullWidth disabled> {' '} Your Current Plan{' '} </Button> ) : ( <Stack gap="xs"> <Button size="lg" component="a" href={plan.link} target="_blank" fullWidth leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Upgrade to Pro{' '} </Button> <Stack gap={4} align="center" mt="xs"> <Group justify="center" gap={6}> <Icon icon="tabler:lock" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> {' '} 100% Secure Payment via Lemon Squeezy{' '} </Text> </Group> <Group justify="center" gap={6}> <Icon icon="tabler:shield-check" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> {' '} 30-Day Money-Back Guarantee{' '} </Text> </Group> </Stack> </Stack> )} </Box> </Stack> </Paper> ))} </Group> </Box> ) const NoSubscriptionSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>No Monthly Fees. Own It Forever.</Title> <Text c="dimmed"> {' '} Forget recurring subscription costs. With the Pro version, you pay once for lifetime access to all current features and future updates.{' '} </Text> <Card withBorder p="xl" radius="lg" mt="md" w="100%"> <Grid align="center"> <Grid.Col span={5} ta="center"> <Stack align="center"> <Icon icon="tabler:calendar-dollar" fontSize={48} color="var(--mantine-color-red-6)" /> <Text fw={500}>Endless Subscriptions</Text> <Icon icon="tabler:x" fontSize={32} color="var(--mantine-color-red-6)" /> </Stack> </Grid.Col> <Grid.Col span={2}> <Center> <Divider orientation="vertical" /> </Center> </Grid.Col> <Grid.Col span={5} ta="center"> <Stack align="center"> <Icon icon="tabler:pig-money" fontSize={48} color="var(--mantine-color-teal-6)" /> <Text fw={500}>One-Time Payment</Text> <Icon icon="tabler:check" fontSize={32} color="var(--mantine-color-teal-6)" /> </Stack> </Grid.Col> </Grid> </Card> </Stack> </Center> </Box> ) const FeatureComparisonTable = () => ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> {' '} Features Comparison{' '} </Title> </Center> <Card withBorder radius="lg" p={0}> <Table striped highlightOnHover verticalSpacing="md" fz="sm"> <Table.Thead> <Table.Tr> <Table.Th w="40%">Feature</Table.Th> <Table.Th ta="center">Free</Table.Th> <Table.Th ta="center">Pro</Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {comparisonFeatures.map((item) => ( <Table.Tr key={item.feature} style={{ backgroundColor: item.free === false ? 'var(--mantine-color-teal-0)' : undefined, }} > <Table.Td> <Group gap="xs" justify="space-between"> <Text fw={500}>{item.feature}</Text> </Group> </Table.Td> <Table.Td ta="center"> {typeof item.free === 'boolean' ? ( item.free ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Text size="sm">{item.free}</Text> )} </Table.Td> <Table.Td ta="center"> {typeof item.pro === 'boolean' ? ( item.pro ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Badge color="teal" variant="light"> {' '} {item.pro}{' '} </Badge> )} </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </Card> </Box> ) const SecuritySection = () => ( <Box mt={80}> <Card withBorder p="xl" radius="lg" bg="gray.0"> <Grid align="center"> <Grid.Col span={{ base: 12, md: 2 }} ta="center"> <ThemeIcon size={80} radius="xl" variant="light" color="teal"> <Icon icon="tabler:shield-lock" fontSize={48} /> </ThemeIcon> </Grid.Col> <Grid.Col span={{ base: 12, md: 10 }}> <Title order={2}>Your Privacy is Our Top Priority</Title> <Text c="dimmed" mt="md"> {' '} We designed this extension with a "privacy-first" approach. You have complete and total control over your data, always.{' '} </Text> <List mt="md" spacing="xs" size="sm" icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> {' '} <b>Direct Sending:</b> Your messages are sent directly through the official WhatsApp Web interface.{' '} </List.Item> <List.Item> {' '} <b>No Data Storage:</b> We never see, save, or have access to your conversations, contacts, or files.{' '} </List.Item> <List.Item> {' '} <b>You Are in Control:</b> All actions happen on your own computer, under your control.{' '} </List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const TestimonialsSection = () => { const testimonialsData = [ { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-8.png', name: 'Sarah L.', role: 'Small Business Owner', quote: 'This has been a lifesaver for my business. I contact dozens of new people a day, and <b>not having to save every single number is a huge time-saver</b>. The ability to send a PDF quote directly with the Pro version is a game-changer.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-2.png', name: 'Mike P.', role: 'Online Seller', quote: "I use this all the time for marketplace listings and one-off inquiries. <b>So simple and fast</b>. It's how WhatsApp should have worked from the beginning! The Pro upgrade was a no-brainer to send product videos.", }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-4.png', name: 'Alisha C.', role: 'Event Coordinator', quote: "Coordinating with vendors and clients means contacting lots of new numbers. This tool keeps my phone's address book from becoming a mess. <b>Scheduling reminders with the Pro version</b> is also an incredible feature.", }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-5.png', name: 'David G.', role: 'Community Manager', quote: 'I need to message new members without saving all their numbers. This extension makes it effortless. The <b>ability to use message templates</b> saves me so much time every day. Worth every penny for the lifetime license.', }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Trusted by Users Like You</Title> <Text c="dimmed"> {' '} See what our happy customers are saying about the Pro version.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {testimonialsData.map((testimonial) => ( <Grid.Col span={{ base: 12, md: 6 }} key={testimonial.name}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack> <Text c="dimmed" dangerouslySetInnerHTML={{ __html: testimonial.quote }} /> <Group mt="md"> <Avatar src={testimonial.avatar} alt={testimonial.name} radius="xl" /> <div> <Text fw={500}>{testimonial.name}</Text> <Text size="xs" c="dimmed"> {' '} {testimonial.role}{' '} </Text> </div> </Group> </Stack> </Card> </Grid.Col> ))} </Grid> </Box> ) } const GuaranteeSection = () => ( <Paper bg="teal.0" radius="lg" p="xl" mt={80} style={{ border: '2px dashed var(--mantine-color-teal-4)' }} > <Group justify="center" align="center"> <ThemeIcon variant="light" color="teal" size={60} radius="xl"> <Icon icon="tabler:shield-check" fontSize={32} /> </ThemeIcon> <Stack gap={0} ta={{ base: 'center', sm: 'left' }}> <Title order={3}>Our 100% 'Peace of Mind' Full Guarantee</Title> <Text c="dimmed" maw={500}> {' '} We're confident you'll love the Pro features. If you're not 100% satisfied, contact us within 30 days of your purchase for a full, no-questions-asked refund.{' '} </Text> </Stack> </Group> </Paper> ) const FaqSection = () => { const faqData = [ { icon: 'tabler:rocket', question: 'What are the main benefits of upgrading to Pro?', answer: 'Pro unlocks powerful messaging features. You can <b>send files like images, videos, and documents</b> and locations, and <b>schedule messages</b> to be sent later. It turns a simple convenience into a powerful communication tool.', }, { icon: 'tabler:key', question: 'Is this a one-time payment or a subscription?', answer: 'It is a <b>one-time payment</b>. You pay once and get lifetime access to all current and future Pro features. No monthly fees, no subscriptions, ever.', }, { icon: 'tabler:alert-circle', question: 'Do I need to save the number in my contacts first?', answer: "No! That's the main feature of the extension. You can type in any valid WhatsApp number and start a chat immediately without adding it to your address book.", }, { icon: 'tabler:shield-check', question: 'Is it safe to use?', answer: 'Absolutely. The extension uses the official WhatsApp Web interface to send messages. It operates <b>locally on your computer</b>, and we do not store your messages or have access to your account.', }, ] return ( <Box mt={80} id="faq"> <Center> <Title order={2} ta="center" mb="xl"> {' '} Frequently Asked Questions{' '} </Title> </Center> <Accordion variant="separated" radius="lg"> {faqData.map((item, index) => ( <Accordion.Item key={index} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > <Text fw={500}>{item.question}</Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} /> </Accordion.Panel> </Accordion.Item> ))} </Accordion> </Box> ) } const ValueStackSection = () => ( <Box mt={80}> <Card withBorder radius="lg" p="xl"> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Here's Everything You Get</Title> <Text c="dimmed"> {' '} Your Pro Lifetime License is a complete package for powerful, direct communication.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Start Chats Without Saving Numbers</List.Item> <List.Item>Send All Media Types (Images, Videos, etc.)</List.Item> </List> </Grid.Col> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Schedule Messages for Later</List.Item> <List.Item>Priority Customer Support</List.Item> <List.Item>30-Day Money-Back Guarantee</List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const ContactUsSection = () => ( <Box mt={80}> <Card withBorder p="xl" shadow="sm" radius="lg"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still Have Questions?</Title> <Text c="dimmed" size="sm"> {' '} Our team is ready to help. Contact us for any inquiries.{' '} </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > {' '} extdotninja@gmail.com{' '} </Anchor> </Stack> </Group> </Card> </Box> ) const Footer = () => ( <Box mt={80} py="xl"> <Divider /> <Stack align="center" ta="center" mt="xl" gap={4}> <Text size="sm"> {' '} Copyright © {new Date().getFullYear()}. All Rights Reserved.{' '} </Text> <Text size="xs" c="dimmed" maw={500}> {' '} This is an independent software and is not affiliated with, sponsored, or endorsed by WhatsApp LLC.{' '} </Text> </Stack> </Box> ) const StickyHeader: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => { const [scroll] = useWindowScroll() return ( <Transition mounted={scroll.y > 200} transition="slide-down" duration={300} timingFunction="ease" > {(styles) => ( <Paper shadow="md" radius={0} p="xs" style={{ ...styles, position: 'fixed', top: 0, left: 0, right: 0, zIndex: 1000, backgroundColor: 'var(--mantine-color-dark-8)', }} > <Container size="md"> <Group justify="space-between"> <CountdownTimer offerEndDate={offerEndDate} isMini /> <Button size="sm" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={18} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Get Lifetime Access for Just $39!{' '} </Button> </Group> </Container> </Paper> )} </Transition> ) } const getOfferEndDate = (): Date => { const storedEndDate = localStorage.getItem('offerEndDate') if (storedEndDate && new Date(storedEndDate) > new Date()) { return new Date(storedEndDate) } const newEndDate = new Date() newEndDate.setDate(newEndDate.getDate() + 3) localStorage.setItem('offerEndDate', newEndDate.toISOString()) return newEndDate } const LandingPage = () => { const [notification, setNotification] = useState<{ city: string country: string } | null>(null) const [offerEndDate] = useState(getOfferEndDate) useEffect(() => { const locations = [ { city: 'Torino', country: 'Italy' }, { city: 'Shaqra', country: 'Saudi Arabia' }, { city: 'Miami', country: 'United States' }, ] let timeoutId: NodeJS.Timeout const scheduleNextNotification = () => { clearTimeout(timeoutId) const randomDelay = Math.floor(Math.random() * (15000 - 8000 + 1)) + 8000 // 8-15 seconds timeoutId = setTimeout(() => { const randomLocation = locations[Math.floor(Math.random() * locations.length)] setNotification(randomLocation) timeoutId = setTimeout(() => { setNotification(null) scheduleNextNotification() }, 4000) // Show for 4 seconds }, randomDelay) } timeoutId = setTimeout(scheduleNextNotification, 5000) // First one after 5 seconds return () => clearTimeout(timeoutId) }, []) return ( <MantineProvider theme={theme}> <StickyHeader offerEndDate={offerEndDate} /> <Container size="md" py="xl"> <Stack gap={80}> <HeroSection /> <FeaturesSection /> <UserPersonaSection /> <CaseStudySection /> <PricingSection offerEndDate={offerEndDate} /> <NoSubscriptionSection /> <FeatureComparisonTable /> <SecuritySection /> <TestimonialsSection /> <GuaranteeSection /> <FaqSection /> <ValueStackSection /> <ContactUsSection /> <Center mt={40}> <Stack align="center" gap="lg"> <Title order={2}>Ready to Supercharge Your Messaging?</Title> <Text c="dimmed" size="lg"> {' '} Get all Pro features for a one-time payment.{' '} </Text> <Stack align="center"> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > {' '} Get Lifetime Access Now for Just $39{' '} </Button> <Text size="xs" c="dimmed"> {' '} 30-day no-questions-asked money-back guarantee.{' '} </Text> </Stack> </Stack> </Center> <Footer /> </Stack> </Container> <Transition mounted={!!notification} transition="slide-right" duration={500} timingFunction="ease" > {(styles) => ( <Paper shadow="lg" p="sm" radius="md" withBorder style={{ ...styles, position: 'fixed', bottom: 20, left: 20, zIndex: 2000, }} > <Group> <ThemeIcon color="teal" size={36} radius="xl"> <Icon icon="tabler:shield-check" fontSize={22} /> </ThemeIcon> <Stack gap={0}> <Text fw={500} size="sm"> {' '} Just upgraded to Pro!{' '} </Text> <Text size="xs" c="dimmed"> {' '} {`Someone from ${notification?.city}, ${notification?.country}`}{' '} </Text> </Stack> </Group> </Paper> )} </Transition> </MantineProvider> ) } export default LandingPage
```

# src/tabs/resource-page.tsx

```tsx
// src/tabs/resource-page.tsx // English: This file provides promotional materials for the Chrome Web Store listing. import PromoIcon from '@/components/Promo/PromoIcon' import ScreenshotWrapper from '@/components/Promo/ScreenshotWrapper' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { ActionIcon, Avatar, Badge, Button, Card, Center, Checkbox, Code, Container, CopyButton, Grid, Group, List, MantineProvider, Paper, Stack, Tabs, Text, Textarea, TextInput, ThemeIcon, Title, } from '@mantine/core' import '@mantine/core/styles.css' import 'mantine-datatable/styles.layer.css' import React from 'react' // English: Using a darker gradient that matches the landing page's teal-to-lime theme for a prominent look. const PROMO_GRADIENT_BACKGROUND = 'linear-gradient(135deg, var(--mantine-color-teal-8), var(--mantine-color-lime-8))' // --- Marquee Promo Tile (1280x800px) --- const MarqueeTileFeatureShowcase = () => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center"> <Grid.Col span={5}> <Stack> <ThemeIcon size={90} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon="tabler:message-circle-plus" fontSize={70} /> </ThemeIcon> <Title fz={48} lh={1.2} c="white"> {' '} Direct Chat for WhatsApp{' '} </Title> <Title order={2} c="white" fw={500} mt="md"> {' '} Instantly chat with anyone on WhatsApp without saving their number. Send text, images, videos, files, and more.{' '} </Title> </Stack> </Grid.Col> <Grid.Col span={5}> <Stack gap="lg"> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={60} > <Icon icon="tabler:keyboard" fontSize={45} /> </ThemeIcon> <Title order={1} fw={700}> {' '} Enter Any Number{' '} </Title> </Group> <Title size={26} c="gray.7" fw={500} mt="md"> {' '} Start chats with unsaved contacts.{' '} </Title> </Card> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={60} > <Icon icon="tabler:paperclip" fontSize={45} /> </ThemeIcon> <Title order={1} fw={700}> {' '} Send All Media Types{' '} </Title> </Group> <Title size={26} c="gray.7" fw={500} mt="md"> {' '} Send images, videos, docs & more. </Title> </Card> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={60} > <Icon icon="tabler:address-book-off" fontSize={45} /> </ThemeIcon> <Title order={1} fw={700}> {' '} Keep Contacts Clean{' '} </Title> </Group> <Title size={26} c="gray.7" fw={500} mt="md"> {' '} No more clutter for one-time chats.{' '} </Title> </Card> </Stack> </Grid.Col> </Grid> </Stack> </Paper> ) // --- Feature Mockups for Screenshots --- const FeatureMockupDirectChatUI = () => ( <Card withBorder radius="md" p="xl" w={500}> <Stack> <Title order={4}>Direct Chat Interface</Title> <Text c="dimmed" size="sm"> {' '} A clean and simple form to start your conversation quickly.{' '} </Text> <TextInput label="WhatsApp Number" placeholder="e.g., 6281234567890" description="Enter the full number with country code." defaultValue="12025550181" /> <Textarea label="Message" placeholder="Write a message..." defaultValue="Hello! I'm interested in the item you listed for sale." minRows={4} /> <Button mt="sm">Send Message</Button> </Stack> </Card> ) const FeatureMockupMessageTypeSelection = () => ( <Card withBorder radius="md" p="xl" w={500}> <Stack> <Title order={4}>Go Beyond Text</Title> <Text c="dimmed" size="sm"> {' '} Upgrade to unlock all message types for richer conversations.{' '} </Text> <Text fw={500} size="sm" mt="md"> Message Type </Text> <Grid> <Grid.Col span={4}> <Button variant="filled" fullWidth> <Icon icon="tabler:text-size" fontSize={24} /> </Button> </Grid.Col> <Grid.Col span={4}> <Button variant="default" fullWidth> <Icon icon="tabler:photo" fontSize={24} /> </Button> </Grid.Col> <Grid.Col span={4}> <Button variant="default" fullWidth> <Icon icon="tabler:video" fontSize={24} /> </Button> </Grid.Col> <Grid.Col span={4}> <Button variant="default" fullWidth> <Icon icon="tabler:file" fontSize={24} /> </Button> </Grid.Col> <Grid.Col span={4}> <Button variant="default" fullWidth> <Icon icon="tabler:map-pin" fontSize={24} /> </Button> </Grid.Col> <Grid.Col span={4}> <Button variant="default" fullWidth> <Icon icon="tabler:user-square" fontSize={24} /> </Button> </Grid.Col> </Grid> </Stack> </Card> ) const FeatureMockupImageUpload = () => ( <Card withBorder radius="md" p="xl" w={500}> <Stack> <Title order={4}>Attach Images, Videos & Files</Title> <Text c="dimmed" size="sm"> {' '} Easily upload media with a caption, just like in a normal chat.{' '} </Text> <Paper mt="md" withBorder p="xl" radius="md" style={{ borderStyle: 'dashed' }} > <Center> <Stack align="center"> <Icon icon="tabler:photo" fontSize={50} /> <Text>Drag & drop here or click to select a file</Text> <Text size="xs" c="dimmed"> Max size: 3MB | Formats: JPG, PNG, WEBP </Text> </Stack> </Center> </Paper> <Textarea placeholder="Enter your caption here" /> </Stack> </Card> ) const FeatureMockupContactVCard = () => ( <Card withBorder radius="md" p="xl" w={500}> <Stack> <Title order={4}>Send Contacts (vCard)</Title> <Text c="dimmed" size="sm"> {' '} Share contact details from your own contact list without leaving the chat.{' '} </Text> <Group justify="space-between" mt="md"> <Text fw={500}>Selected Contacts (1)</Text> <Button size="xs" variant="outline" leftSection={<Icon icon="tabler:address-book" fontSize={16} />} > Select Contact(s) </Button> </Group> <Paper withBorder p="xs" radius="sm" mt="xs"> <Group justify="space-between"> <Text size="sm">Alice Johnson</Text> <ActionIcon color="red" variant="transparent"> <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Group> </Paper> </Stack> </Card> ) // --- Reusable Marquee Tile for Feature Details --- interface MarqueeTileFeatureDetailProps { icon: string title: string description: string featureComponent: React.ReactNode } const MarqueeTileFeatureDetail: React.FC<MarqueeTileFeatureDetailProps> = ({ icon, title, description, featureComponent, }) => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center"> <Grid.Col span={4}> <Stack> <ThemeIcon size={90} radius="lg"> <Icon icon={icon} fontSize={60} /> </ThemeIcon> <Title order={1} fz={50} lh={1.2} c="white"> {' '} {title}{' '} </Title> <Title order={2} fw={500} c="gray.1" mt="md"> {' '} {description}{' '} </Title> </Stack> </Grid.Col> <Grid.Col span={6}> <Center h="100%">{featureComponent}</Center> </Grid.Col> </Grid> </Stack> </Paper> ) const ScreenshotGallery: React.FC = () => { const screenshotData = [ { title: 'Marquee Promo Tile: Feature Showcase (1280x800)', filename: 'marquee_promo_tile_direct_chat.png', component: <MarqueeTileFeatureShowcase />, }, { title: 'Feature Screenshot: Main Interface (1280x800)', filename: 'feature_direct_chat_main_ui.png', component: ( <MarqueeTileFeatureDetail icon="tabler:keyboard" title="Enter Any Number" description="Simply type or paste any WhatsApp number with its country code to start a direct conversation instantly." featureComponent={<FeatureMockupDirectChatUI />} /> ), }, { title: 'Feature Screenshot: Message Types (1280x800)', filename: 'feature_direct_chat_message_types.png', component: ( <MarqueeTileFeatureDetail icon="tabler:apps" title="Choose Your Message Type" description="Send simple text, images, videos, files, locations, and more." featureComponent={<FeatureMockupMessageTypeSelection />} /> ), }, { title: 'Feature Screenshot: Attach Media (1280x800)', filename: 'feature_direct_chat_attach_media.png', component: ( <MarqueeTileFeatureDetail icon="tabler:paperclip" title="Attach Media & Files" description="Easily upload photos, videos, or documents and add a caption before sending to an unsaved number." featureComponent={<FeatureMockupImageUpload />} /> ), }, { title: 'Feature Screenshot: Send Contacts (1280x800)', filename: 'feature_direct_chat_send_vcard.png', component: ( <MarqueeTileFeatureDetail icon="tabler:user-square" title="Share Contacts Instantly (Pro)" description="Need to share someone's contact details? Select a contact from your address book and send it as a vCard." featureComponent={<FeatureMockupContactVCard />} /> ), }, ] return ( <Stack> <Text c="dimmed" mb="md"> {' '} Generate and download high-resolution promotional assets for the Chrome Web Store.{' '} </Text> <Stack gap="xl"> {screenshotData.map((item) => ( <ScreenshotWrapper key={item.title} title={item.title} filename={item.filename} > {item.component} </ScreenshotWrapper> ))} </Stack> </Stack> ) } const ResourcePage = () => { const storeListingText = { titles: [ 'Direct Chat for WhatsApp', 'Chat Without Saving Numbers', 'Send Media to Unsaved Contacts', ], shortDescriptions: [ 'Start a WhatsApp chat with anyone without saving their number. Send text, images, videos, files, vCards, and more.', 'The quickest way to message unsaved numbers on WhatsApp. Supports all media types, including documents and locations.', 'Stop cluttering your contacts. Type in a number, write your message, and send instantly. Perfect for business and personal use.', ], longDescription: `⚙️ The Fastest Way to Chat on WhatsApp Tired of your phone's contact list being filled with numbers you only need for a one-time conversation? With Direct Chat for WhatsApp, you can start a conversation with any WhatsApp number instantly, without the hassle of saving it to your address book first. This extension integrates seamlessly into WhatsApp Web, providing a simple interface to supercharge your messaging. ✨ Key Features - **Chat Without Saving**: The core feature. Enter any phone number and start chatting right away. Keep your address book clean and organized. - **Send Anything (Pro)**: Go beyond simple text. The Pro version unlocks the ability to send: - 🖼️ Images & Videos - 📄 Documents & Files - 📍 Locations - 👤 Contact Cards (vCards) - **Use Message Templates**: Save time by creating and reusing templates for frequently sent messages. The free version includes 1 template, while Pro offers unlimited templates. - **Simple & Intuitive**: A clean, straightforward interface designed to get your message sent in seconds. - **Privacy-Focused**: The extension operates locally in your browser. We never collect, store, or transmit your personal data, contacts, or chat information. Your privacy is guaranteed. 🤔 Who Is This For? - **Sales & Business Professionals**: Quickly send quotes, brochures, or follow-up messages to new leads. - **Online Shoppers & Sellers**: Easily contact sellers or buyers on marketplaces without adding them as a contact. - **Event Organizers**: Send location pins or event details to attendees and vendors. - **Anyone Needing Convenience**: Message a new acquaintance, a service provider, or a delivery person without the unnecessary step of saving their number. 🚀 How It Works 1. Click the extension icon on the WhatsApp Web page. 2. Enter the full WhatsApp number, including the country code. 3. Type your message or select a media type to send. 4. Click "Send Message"! Upgrade your WhatsApp experience today. Stop the contact clutter and start chatting smarter! --- WhatsApp is a trademark of WhatsApp Inc., registered in the U.S. and other countries. This extension is an independent project and has no relationship to WhatsApp or WhatsApp Inc.`, } const justificationTexts = { singlePurpose: `The extension's single purpose is to allow users to initiate conversations on WhatsApp with phone numbers that are not saved in their contacts. All features—including entering a number, composing a text message, and attaching various media types (images, files, locations, vCards)—are directly tied to this core function of facilitating direct chats within the WhatsApp Web interface.`, storage: `The 'storage' permission is used to locally store user settings and license information. This includes: the user's license key for Pro features and an instance ID for license management. This data is kept on the user's device to ensure a consistent experience without needing a remote server.`, scripting: `Content scripts are essential to inject the extension's user interface onto the web.whatsapp.com page. They also communicate with the WhatsApp Web application's context to securely perform actions on behalf of the user, which is necessary to fulfill the extension's core purpose.`, hostWhatsapp: `Permission for "https://web.whatsapp.com/*" is required for the extension to function. It allows the content scripts to run on WhatsApp Web, enabling the injection of its UI and interaction with the page to send messages to unsaved numbers.`, hostLemonSqueezy: `Permission for "https://api.lemonsqueezy.com/*" is used for secure license management. When a user activates a Pro license, the extension communicates with this API to verify, activate, or deactivate the license key. This is a standard and secure method for handling software licensing and does not involve any personal chat data.`, } const keywords = [ 'whatsapp direct chat', 'wa direct message', 'chat without saving number', 'whatsapp unsaved number', 'send whatsapp without contact', 'whatsapp web extension', 'whatsapp pro', 'send media whatsapp', 'whatsapp marketing', 'whatsapp crm', 'whatsapp business', ] const keywordsString = keywords.join(', ') return ( <MantineProvider theme={theme}> <Container size="lg" py="xl"> <Stack gap="xl"> <Title order={1} ta="center"> {' '} Chrome Web Store - Promotional Resources{' '} </Title> <Text c="dimmed" ta="center"> {' '} Use these assets and text to create your store listing page.{' '} </Text> <Tabs defaultValue="screenshots"> <Tabs.List grow> <Tabs.Tab value="text" leftSection={<Icon icon="tabler:file-text" />} > {' '} Store Listing Text{' '} </Tabs.Tab> <Tabs.Tab value="icons" leftSection={<Icon icon="tabler:photo" />} > {' '} Promotional Icons{' '} </Tabs.Tab> <Tabs.Tab value="screenshots" leftSection={<Icon icon="tabler:camera" />} > {' '} Screenshots & Tiles{' '} </Tabs.Tab> <Tabs.Tab value="keywords" leftSection={<Icon icon="tabler:tags" />} > {' '} Keywords (SEO){' '} </Tabs.Tab> <Tabs.Tab value="privacy" leftSection={<Icon icon="tabler:shield-lock" />} > {' '} Privacy Justifications{' '} </Tabs.Tab> </Tabs.List> <Tabs.Panel value="text" pt="lg"> <Stack gap="xl"> <Stack> <Title order={3}>Titles</Title> {storeListingText.titles.map((title, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={title.length > 30 ? 'red' : 'dimmed'} > {' '} {title.length} / 30 chars{' '} </Text> </Group> <Group mt="sm" justify="space-between"> <Code>{title}</Code> <CopyButton value={title}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Stack> <Title order={3}>Short Descriptions</Title> {storeListingText.shortDescriptions.map((desc, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={desc.length > 132 ? 'red' : 'dimmed'} > {' '} {desc.length} / 132 chars{' '} </Text> </Group> <Textarea mt="sm" readOnly value={desc} autosize maxRows={4} /> <Group justify="flex-end" mt="sm"> <CopyButton value={desc}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Card withBorder radius="md"> <Title order={3}>Detailed Description</Title> <Textarea mt="sm" readOnly value={storeListingText.longDescription} autosize minRows={15} /> <Group justify="flex-end" mt="sm"> <CopyButton value={storeListingText.longDescription}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> </Stack> </Tabs.Panel> <Tabs.Panel value="icons" pt="lg"> <Center> <ScreenshotWrapper title="Promotional Icon (128x128)" filename="icon_128.png" > <PromoIcon size={128} icon={'tabler:message-circle-plus'} /> </ScreenshotWrapper> </Center> </Tabs.Panel> <Tabs.Panel value="screenshots" pt="lg"> <ScreenshotGallery /> </Tabs.Panel> <Tabs.Panel value="keywords" pt="lg"> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={3}>Keywords for Store Listing</Title> <CopyButton value={keywordsString}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} leftSection={<Icon icon="tabler:copy" />} > {' '} {copied ? 'Copied All' : 'Copy All'}{' '} </Button> )} </CopyButton> </Group> <Text c="dimmed" size="sm" mt="xs"> {' '} Use these keywords in your store listing's metadata to improve search visibility.{' '} </Text> <Paper withBorder p="md" mt="md" radius="sm"> <Group gap="xs"> {keywords.map((keyword) => ( <Badge key={keyword} variant="light" color="gray" size="lg" > {' '} {keyword}{' '} </Badge> ))} </Group> </Paper> </Card> </Tabs.Panel> <Tabs.Panel value="privacy" pt="lg"> <Stack gap="xl"> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Single Purpose Justification</Title> <CopyButton value={justificationTexts.singlePurpose}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.singlePurpose} autosize minRows={4} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Storage Permission Justification</Title> <CopyButton value={justificationTexts.storage}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.storage} autosize minRows={5} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Content Scripting Justification</Title> <CopyButton value={justificationTexts.scripting}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.scripting} autosize minRows={5} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}> {' '} Host Permission: https://web.whatsapp.com/*{' '} </Title> <CopyButton value={justificationTexts.hostWhatsapp}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.hostWhatsapp} autosize minRows={4} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}> {' '} Host Permission: https://api.lemonsqueezy.com/*{' '} </Title> <CopyButton value={justificationTexts.hostLemonSqueezy}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.hostLemonSqueezy} autosize minRows={4} /> </Card> </Stack> </Tabs.Panel> </Tabs> </Stack> </Container> </MantineProvider> ) } export default ResourcePage
```

# src/types/globals.d.ts

```ts
import type * as wajs from '@wppconnect/wa-js' declare global { interface Window { WPP: typeof wajs } const WPP: typeof wajs }
```

# src/types/index.d.ts

```ts
import type { Status } from '@/constants' export interface Response<T> { status: keyof typeof Status | string data?: T | null error?: string | null } interface LicenseInstance { createt_at: Date id: string name: string } interface LicenseKey { activation_limit: number activation_usage: number create_at: Date expires_at: Date id: number status: string test_mode: boolean } interface LicenseMeta { customer_email: string customer_id: number customer_name: string order_id: number order_item_id: number product_id: number store_id: number variant_id: number variant_name: string } export interface License { activated?: boolean | null valid?: boolean | null instance?: LicenseInstance | null license_key: LicenseKey meta: LicenseMeta }
```

# src/utils/country.ts

```ts
const countries = { AD: { label: '🇦🇩 Andorra', phone: '376' }, AE: { label: '🇦🇪 United Arab Emirates', phone: '971' }, AF: { label: '🇦🇫 Afghanistan', phone: '93' }, AG: { label: '🇦🇬 Antigua and Barbuda', phone: '1-268' }, AI: { label: '🇦🇮 Anguilla', phone: '1-264' }, AL: { label: '🇦🇱 Albania', phone: '355' }, AM: { label: '🇦🇲 Armenia', phone: '374' }, AO: { label: '🇦🇴 Angola', phone: '244' }, AQ: { label: '🇦🇶 Antarctica', phone: '672' }, AR: { label: '🇦🇷 Argentina', phone: '54' }, AS: { label: '🇦🇸 American Samoa', phone: '1-684' }, AT: { label: '🇦🇹 Austria', phone: '43' }, AU: { label: '🇦🇺 Australia', phone: '61' }, AW: { label: '🇦🇼 Aruba', phone: '297' }, AX: { label: '🇦🇽 Alland Islands', phone: '358' }, AZ: { label: '🇦🇿 Azerbaijan', phone: '994' }, BA: { label: '🇧🇦 Bosnia and Herzegovina', phone: '387' }, BB: { label: '🇧🇧 Barbados', phone: '1-246' }, BD: { label: '🇧🇩 Bangladesh', phone: '880' }, BE: { label: '🇧🇪 Belgium', phone: '32' }, BF: { label: '🇧🇫 Burkina Faso', phone: '226' }, BG: { label: '🇧🇬 Bulgaria', phone: '359' }, BH: { label: '🇧🇭 Bahrain', phone: '973' }, BI: { label: '🇧🇮 Burundi', phone: '257' }, BJ: { label: '🇧🇯 Benin', phone: '229' }, BL: { label: '🇧🇱 Saint Barthelemy', phone: '590' }, BM: { label: '🇧🇲 Bermuda', phone: '1-441' }, BN: { label: '🇧🇳 Brunei Darussalam', phone: '673' }, BO: { label: '🇧🇴 Bolivia', phone: '591' }, BR: { label: '🇧🇷 Brazil', phone: '55' }, BS: { label: '🇧🇸 Bahamas', phone: '1-242' }, BT: { label: '🇧🇹 Bhutan', phone: '975' }, BV: { label: '🇧🇻 Bouvet Island', phone: '47' }, BW: { label: '🇧🇼 Botswana', phone: '267' }, BY: { label: '🇧🇾 Belarus', phone: '375' }, BZ: { label: '🇧🇿 Belize', phone: '501' }, CA: { label: '🇨🇦 Canada', phone: '1' }, CC: { label: '🇨🇨 Cocos (Keeling) Islands', phone: '61' }, CD: { label: '🇨🇩 Congo, Democratic Republic of the', phone: '243' }, CF: { label: '🇨🇫 Central African Republic', phone: '236' }, CG: { label: '🇨🇬 Congo, Republic of the', phone: '242' }, CH: { label: '🇨🇭 Switzerland', phone: '41' }, CI: { label: "🇨🇮 Cote d'Ivoire", phone: '225' }, CK: { label: '🇨🇰 Cook Islands', phone: '682' }, CL: { label: '🇨🇱 Chile', phone: '56' }, CM: { label: '🇨🇲 Cameroon', phone: '237' }, CN: { label: '🇨🇳 China', phone: '86' }, CO: { label: '🇨🇴 Colombia', phone: '57' }, CR: { label: '🇨🇷 Costa Rica', phone: '506' }, CU: { label: '🇨🇺 Cuba', phone: '53' }, CV: { label: '🇨🇻 Cape Verde', phone: '238' }, CW: { label: '🇨🇼 Curacao', phone: '599' }, CX: { label: '🇨🇽 Christmas Island', phone: '61' }, CY: { label: '🇨🇾 Cyprus', phone: '357' }, CZ: { label: '🇨🇿 Czech Republic', phone: '420' }, DE: { label: '🇩🇪 Germany', phone: '49' }, DJ: { label: '🇩🇯 Djibouti', phone: '253' }, DK: { label: '🇩🇰 Denmark', phone: '45' }, DM: { label: '🇩🇲 Dominica', phone: '1-767' }, DO: { label: '🇩🇴 Dominican Republic', phone: '1-809' }, DZ: { label: '🇩🇿 Algeria', phone: '213' }, EC: { label: '🇪🇨 Ecuador', phone: '593' }, EE: { label: '🇪🇪 Estonia', phone: '372' }, EG: { label: '🇪🇬 Egypt', phone: '20' }, EH: { label: '🇪🇭 Western Sahara', phone: '212' }, ER: { label: '🇪🇷 Eritrea', phone: '291' }, ES: { label: '🇪🇸 Spain', phone: '34' }, ET: { label: '🇪🇹 Ethiopia', phone: '251' }, FI: { label: '🇫🇮 Finland', phone: '358' }, FJ: { label: '🇫🇯 Fiji', phone: '679' }, FK: { label: '🇫🇰 Falkland Islands (Malvinas)', phone: '500' }, FM: { label: '🇫🇲 Micronesia, Federated States of', phone: '691' }, FO: { label: '🇫🇴 Faroe Islands', phone: '298' }, FR: { label: '🇫🇷 France', phone: '33' }, GA: { label: '🇬🇦 Gabon', phone: '241' }, GB: { label: '🇬🇧 United Kingdom', phone: '44' }, GD: { label: '🇬🇩 Grenada', phone: '1-473' }, GE: { label: '🇬🇪 Georgia', phone: '995' }, GF: { label: '🇬🇫 French Guiana', phone: '594' }, GG: { label: '🇬🇬 Guernsey', phone: '44' }, GH: { label: '🇬🇭 Ghana', phone: '233' }, GI: { label: '🇬🇮 Gibraltar', phone: '350' }, GL: { label: '🇬🇱 Greenland', phone: '299' }, GM: { label: '🇬🇲 Gambia', phone: '220' }, GN: { label: '🇬🇳 Guinea', phone: '224' }, GP: { label: '🇬🇵 Guadeloupe', phone: '590' }, GQ: { label: '🇬🇶 Equatorial Guinea', phone: '240' }, GR: { label: '🇬🇷 Greece', phone: '30' }, GS: { label: '🇬🇸 South Georgia and the South Sandwich Islands', phone: '500', }, GT: { label: '🇬🇹 Guatemala', phone: '502' }, GU: { label: '🇬🇺 Guam', phone: '1-671' }, GW: { label: '🇬🇼 Guinea-Bissau', phone: '245' }, GY: { label: '🇬🇾 Guyana', phone: '592' }, HK: { label: '🇭🇰 Hong Kong', phone: '852' }, HM: { label: '🇭🇲 Heard Island and McDonald Islands', phone: '672' }, HN: { label: '🇭🇳 Honduras', phone: '504' }, HR: { label: '🇭🇷 Croatia', phone: '385' }, HT: { label: '🇭🇹 Haiti', phone: '509' }, HU: { label: '🇭🇺 Hungary', phone: '36' }, ID: { label: '🇮🇩 Indonesia', phone: '62' }, IE: { label: '🇮🇪 Ireland', phone: '353' }, IL: { label: '🇮🇱 Israel', phone: '972' }, IM: { label: '🇮🇲 Isle of Man', phone: '44' }, IN: { label: '🇮🇳 India', phone: '91' }, IO: { label: '🇮🇴 British Indian Ocean Territory', phone: '246' }, IQ: { label: '🇮🇶 Iraq', phone: '964' }, IR: { label: '🇮🇷 Iran, Islamic Republic of', phone: '98' }, IS: { label: '🇮🇸 Iceland', phone: '354' }, IT: { label: '🇮🇹 Italy', phone: '39' }, JE: { label: '🇯🇪 Jersey', phone: '44' }, JM: { label: '🇯🇲 Jamaica', phone: '1-876' }, JO: { label: '🇯🇴 Jordan', phone: '962' }, JP: { label: '🇯🇵 Japan', phone: '81' }, KE: { label: '🇰🇪 Kenya', phone: '254' }, KG: { label: '🇰🇬 Kyrgyzstan', phone: '996' }, KH: { label: '🇰🇭 Cambodia', phone: '855' }, KI: { label: '🇰🇮 Kiribati', phone: '686' }, KM: { label: '🇰🇲 Comoros', phone: '269' }, KN: { label: '🇰🇳 Saint Kitts and Nevis', phone: '1-869' }, KP: { label: "🇰🇵 Korea, Democratic People's Republic of", phone: '850' }, KR: { label: '🇰🇷 Korea, Republic of', phone: '82' }, KW: { label: '🇰🇼 Kuwait', phone: '965' }, KY: { label: '🇰🇾 Cayman Islands', phone: '1-345' }, KZ: { label: '🇰🇿 Kazakhstan', phone: '7' }, LA: { label: "🇱🇦 Lao People's Democratic Republic", phone: '856' }, LB: { label: '🇱🇧 Lebanon', phone: '961' }, LC: { label: '🇱🇨 Saint Lucia', phone: '1-758' }, LI: { label: '🇱🇮 Liechtenstein', phone: '423' }, LK: { label: '🇱🇰 Sri Lanka', phone: '94' }, LR: { label: '🇱🇷 Liberia', phone: '231' }, LS: { label: '🇱🇸 Lesotho', phone: '266' }, LT: { label: '🇱🇹 Lithuania', phone: '370' }, LU: { label: '🇱🇺 Luxembourg', phone: '352' }, LV: { label: '🇱🇻 Latvia', phone: '371' }, LY: { label: '🇱🇾 Libya', phone: '218' }, MA: { label: '🇲🇦 Morocco', phone: '212' }, MC: { label: '🇲🇨 Monaco', phone: '377' }, MD: { label: '🇲🇩 Moldova, Republic of', phone: '373' }, ME: { label: '🇲🇪 Montenegro', phone: '382' }, MF: { label: '🇲🇫 Saint Martin (French part)', phone: '590' }, MG: { label: '🇲🇬 Madagascar', phone: '261' }, MH: { label: '🇲🇭 Marshall Islands', phone: '692' }, MK: { label: '🇲🇰 Macedonia, the Former Yugoslav Republic of', phone: '389' }, ML: { label: '🇲🇱 Mali', phone: '223' }, MM: { label: '🇲🇲 Myanmar', phone: '95' }, MN: { label: '🇲🇳 Mongolia', phone: '976' }, MO: { label: '🇲🇴 Macao', phone: '853' }, MP: { label: '🇲🇵 Northern Mariana Islands', phone: '1-670' }, MQ: { label: '🇲🇶 Martinique', phone: '596' }, MR: { label: '🇲🇷 Mauritania', phone: '222' }, MS: { label: '🇲🇸 Montserrat', phone: '1-664' }, MT: { label: '🇲🇹 Malta', phone: '356' }, MU: { label: '🇲🇺 Mauritius', phone: '230' }, MV: { label: '🇲🇻 Maldives', phone: '960' }, MW: { label: '🇲🇼 Malawi', phone: '265' }, MX: { label: '🇲🇽 Mexico', phone: '52' }, MY: { label: '🇲🇾 Malaysia', phone: '60' }, MZ: { label: '🇲🇿 Mozambique', phone: '258' }, NA: { label: '🇳🇦 Namibia', phone: '264' }, NC: { label: '🇳🇨 New Caledonia', phone: '687' }, NE: { label: '🇳🇪 Niger', phone: '227' }, NF: { label: '🇳🇫 Norfolk Island', phone: '672' }, NG: { label: '🇳🇬 Nigeria', phone: '234' }, NI: { label: '🇳🇮 Nicaragua', phone: '505' }, NL: { label: '🇳🇱 Netherlands', phone: '31' }, NO: { label: '🇳🇴 Norway', phone: '47' }, NP: { label: '🇳🇵 Nepal', phone: '977' }, NR: { label: '🇳🇷 Nauru', phone: '674' }, NU: { label: '🇳🇺 Niue', phone: '683' }, NZ: { label: '🇳🇿 New Zealand', phone: '64' }, OM: { label: '🇴🇲 Oman', phone: '968' }, PA: { label: '🇵🇦 Panama', phone: '507' }, PE: { label: '🇵🇪 Peru', phone: '51' }, PF: { label: '🇵🇫 French Polynesia', phone: '689' }, PG: { label: '🇵🇬 Papua New Guinea', phone: '675' }, PH: { label: '🇵🇭 Philippines', phone: '63' }, PK: { label: '🇵🇰 Pakistan', phone: '92' }, PL: { label: '🇵🇱 Poland', phone: '48' }, PM: { label: '🇵🇲 Saint Pierre and Miquelon', phone: '508' }, PN: { label: '🇵🇳 Pitcairn', phone: '870' }, PR: { label: '🇵🇷 Puerto Rico', phone: '1' }, PS: { label: '🇵🇸 Palestine, State of', phone: '970' }, PT: { label: '🇵🇹 Portugal', phone: '351' }, PW: { label: '🇵🇼 Palau', phone: '680' }, PY: { label: '🇵🇾 Paraguay', phone: '595' }, QA: { label: '🇶🇦 Qatar', phone: '974' }, RE: { label: '🇷🇪 Reunion', phone: '262' }, RO: { label: '🇷🇴 Romania', phone: '40' }, RS: { label: '🇷🇸 Serbia', phone: '381' }, RU: { label: '🇷🇺 Russian Federation', phone: '7' }, RW: { label: '🇷🇼 Rwanda', phone: '250' }, SA: { label: '🇸🇦 Saudi Arabia', phone: '966' }, SB: { label: '🇸🇧 Solomon Islands', phone: '677' }, SC: { label: '🇸🇨 Seychelles', phone: '248' }, SD: { label: '🇸🇩 Sudan', phone: '249' }, SE: { label: '🇸🇪 Sweden', phone: '46' }, SG: { label: '🇸🇬 Singapore', phone: '65' }, SH: { label: '🇸🇭 Saint Helena', phone: '290' }, SI: { label: '🇸🇮 Slovenia', phone: '386' }, SJ: { label: '🇸🇯 Svalbard and Jan Mayen', phone: '47' }, SK: { label: '🇸🇰 Slovakia', phone: '421' }, SL: { label: '🇸🇱 Sierra Leone', phone: '232' }, SM: { label: '🇸🇲 San Marino', phone: '378' }, SN: { label: '🇸🇳 Senegal', phone: '221' }, SO: { label: '🇸🇴 Somalia', phone: '252' }, SR: { label: '🇸🇷 Suriname', phone: '597' }, SS: { label: '🇸🇸 South Sudan', phone: '211' }, ST: { label: '🇸🇹 Sao Tome and Principe', phone: '239' }, SV: { label: '🇸🇻 El Salvador', phone: '503' }, SX: { label: '🇸🇽 Sint Maarten (Dutch part)', phone: '1-721' }, SY: { label: '🇸🇾 Syrian Arab Republic', phone: '963' }, SZ: { label: '🇸🇿 Swaziland', phone: '268' }, TC: { label: '🇹🇨 Turks and Caicos Islands', phone: '1-649' }, TD: { label: '🇹🇩 Chad', phone: '235' }, TF: { label: '🇹🇫 French Southern Territories', phone: '262' }, TG: { label: '🇹🇬 Togo', phone: '228' }, TH: { label: '🇹🇭 Thailand', phone: '66' }, TJ: { label: '🇹🇯 Tajikistan', phone: '992' }, TK: { label: '🇹🇰 Tokelau', phone: '690' }, TL: { label: '🇹🇱 Timor-Leste', phone: '670' }, TM: { label: '🇹🇲 Turkmenistan', phone: '993' }, TN: { label: '🇹🇳 Tunisia', phone: '216' }, TO: { label: '🇹🇴 Tonga', phone: '676' }, TR: { label: '🇹🇷 Turkey', phone: '90' }, TT: { label: '🇹🇹 Trinidad and Tobago', phone: '1-868' }, TV: { label: '🇹🇻 Tuvalu', phone: '688' }, TW: { label: '🇹🇼 Taiwan, Province of China', phone: '886' }, TZ: { label: '🇹🇿 United Republic of Tanzania', phone: '255' }, UA: { label: '🇺🇦 Ukraine', phone: '380' }, UG: { label: '🇺🇬 Uganda', phone: '256' }, US: { label: '🇺🇸 United States', phone: '1' }, UY: { label: '🇺🇾 Uruguay', phone: '598' }, UZ: { label: '🇺🇿 Uzbekistan', phone: '998' }, VA: { label: '🇻🇦 Holy See (Vatican City State)', phone: '379' }, VC: { label: '🇻🇨 Saint Vincent and the Grenadines', phone: '1-784' }, VE: { label: '🇻🇪 Venezuela', phone: '58' }, VG: { label: '🇻🇬 British Virgin Islands', phone: '1-284' }, VI: { label: '🇻🇮 US Virgin Islands', phone: '1-340' }, VN: { label: '🇻🇳 Vietnam', phone: '84' }, VU: { label: '🇻🇺 Vanuatu', phone: '678' }, WF: { label: '🇼🇫 Wallis and Futuna', phone: '681' }, WS: { label: '🇼🇸 Samoa', phone: '685' }, XK: { label: '🇽🇰 Kosovo', phone: '383' }, YE: { label: '🇾🇪 Yemen', phone: '967' }, YT: { label: '🇾🇹 Mayotte', phone: '262' }, ZA: { label: '🇿🇦 South Africa', phone: '27' }, ZM: { label: '🇿🇲 Zambia', phone: '260' }, ZW: { label: '🇿🇼 Zimbabwe', phone: '263' }, } const getCountryByCode = (code: string) => { return countries[code] ?? { label: '-', phone: '-' } } export default { getCountryByCode, countries, }
```

# src/utils/env.ts

```ts
const isProduction = () => { return process.env.NODE_ENV === 'production' } const isDevelopment = () => { return process.env.NODE_ENV === 'development' } export const isStaging = () => { return process.env.PLASMO_PUBLIC_STAGING === 'true' } export default { isProduction, isDevelopment, isStaging, }
```

# src/utils/ext.ts

```ts
import type { Tabs } from 'webextension-polyfill' import browser from 'webextension-polyfill' export async function getCurrentTab(): Promise<Tabs.Tab> { const queryOptions = { active: true, currentWindow: true } const [tab] = await browser.tabs.query(queryOptions) return tab } export async function getTabs(): Promise<Tabs.Tab[]> { return new Promise(async (resolve, reject) => { try { const tabs = await browser.tabs.query({ currentWindow: true }) const filteredTabs = tabs.filter( (tab) => !tab.url?.startsWith('chrome://'), ) return resolve(filteredTabs) } catch (error) { reject(error) } }) } export async function getTabByUrl(url: string): Promise<Tabs.Tab | null> { const queryOptions = { url: url } const tabs = await browser.tabs.query(queryOptions) return tabs.length > 0 ? tabs[0] : null } export const openWa = async () => { await browser.tabs.create({ url: 'https://web.whatsapp.com' }) } export const isWaTabActive = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return result?.active } export const isWaTabAvailable = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return !!result }
```

# src/utils/filterBy.ts

```ts
import { AccountType, ContactType, MessageType } from '@/constants' import type { ContactModel } from '@wppconnect/wa-js/dist/whatsapp' const dontIncludeLid = (contact: ContactModel) => contact.id.server !== 'lid' const dontIncludeMe = (contact: any, number: any) => contact.phoneNumber !== number const accountType = (contact: any, type: string) => { switch (type) { case AccountType.ALL: return true case AccountType.PERSONAL: return contact.isBusiness === false case AccountType.BUSINESS: return contact.isBusiness === true default: return true } } const contactType = (contact: any, type: string): boolean => { switch (type) { case ContactType.ALL: return true case ContactType.SAVED_CONTACTS: return contact.isMyContact === true case ContactType.UNSAVED_CONTACTS: return contact.isMyContact === false default: return true } } const includeAdmin = (data: any, isIncludeAdmin: boolean) => { if (isIncludeAdmin) { if (data.isAdmin) { return true } } else { if (data.isAdmin) return false } return true } const onlyMyContact = (data: any, onlyMyContact: boolean) => { if (onlyMyContact) { return data.isMyContact === true } else { return data.isMyContact !== true } } const messageType = (contact: any, type: string): boolean => { switch (type) { case MessageType.ALL: return true case MessageType.HAVE_UNREAD_MESSAGES: return contact.hasUnread === true case MessageType.NO_UNREAD_MESSAGES: return contact.hasUnread === false default: return true } } const country = (contact: any, country: string) => { const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) return countryCode === country } export default { dontIncludeLid, dontIncludeMe, accountType, includeAdmin, onlyMyContact, contactType, messageType, country, }
```

# src/utils/page.ts

```ts
import { Action } from '@/constants' import { postMessage } from './util' const goTo = (page: string) => { postMessage(Action.Window.GO_TO_PAGE, page) } export default { goTo, }
```

# src/utils/parse.ts

```ts
// src/utils/util.ts import type { BroadcastContact } from '@/libs/db' import _ from 'lodash' /** * @description Processes Spintax recursively to handle nested variations. * It finds patterns like {option1|option2}, randomly selects one, * and repeats until no patterns are left. * @param {string} text The text containing Spintax format. * @returns {string} The processed text with one variation chosen. */ const processSpintax = (text: string): string => { const spintaxRegex = /{([^{}]*)}/ let processedText = text let match = spintaxRegex.exec(processedText) while (match) { const options = match[1].split('|') const randomIndex = Math.floor(Math.random() * options.length) const chosenOption = options[randomIndex] processedText = processedText.replace(match[0], chosenOption) match = spintaxRegex.exec(processedText) } return processedText } /** * @description Parses a message string by first processing Spintax for variations, * and then replacing personalization placeholders like {name} and {number}. * @param {string} message The message template. * @param {BroadcastContact} contact The recipient's data, containing name and number. * @returns {string} The fully parsed and personalized message. */ const text = (message: string, contact: BroadcastContact): string => { const contactName = contact.name || 'there' const contactNumber = contact.number.split('@')[0] return _.chain(message) .replace(/{name}/g, contactName) .replace(/{number}/g, contactNumber) .value() } export default { text, }
```

# src/utils/response.ts

```ts
import { Status } from '@/constants' import type { Response } from '@/types' const success = <T = any>(data?: T | null): Response<T | undefined | null> => { return { status: Status.SUCCESS, data: data, } } const error = (error: string | undefined | null): Response<null> => { return { status: Status.FAILED, error: error, } } export const response = { success, error, }
```

# src/utils/serialize.ts

```ts
import type { ChatModel, ContactModel, GroupMetadataModel, MediaDataModel, MsgModel, ParticipantModel, } from '@wppconnect/wa-js/dist/whatsapp' import _ from 'lodash' const button = (buttons: any[]) => { return buttons .map(({ type, label, value }) => { switch (type) { case 'text': return { text: value } case 'url': return { text: label, url: value } case 'phoneNumber': return { text: label, phoneNumber: value } default: break } }) .filter((button) => !!button) } const list = (rows: any[]) => { return rows.filter((row) => row.title !== '') } const contact = (contact: ContactModel) => { if (!contact) return {} const hasUnread = WPP.chat.get(contact.id._serialized)?.hasUnread ?? false return { id: contact.id._serialized, number: contact.id.user, avatar: contact.getProfilePicThumb().__x_eurl, name: contact.name, pushname: contact.pushname, shortname: contact.shortName, notifyName: contact.notifyName, formattedName: contact.formattedName, formattedPhone: contact.formattedPhone, formattedShortName: contact.formattedShortName, formattedShortNameWithNonBreakingSpaces: contact.formattedShortNameWithNonBreakingSpaces, formattedUser: contact.formattedUser, isBusiness: contact.isBusiness, isContactBlocked: contact.isContactBlocked, //@ts-ignore isFavorite: contact.isFavorite, isGroup: contact.isGroup, isMe: contact.isMe, isMyContact: contact.isMyContact, isUser: contact.isUser, isWaContact: contact.isWAContact, labels: contact.labels, hasUnread, } } const mediaData = (data?: MediaDataModel) => { if (!data) return {} return { mimeType: data?.mimetype, size: data?.size, base64: data?.preview?.base64, height: data?.fullHeight, width: data?.fullWidth, } } const message = (msgModel: MsgModel) => { return { id: msgModel.id._serialized, ack: msgModel.ack, body: msgModel.body, from: msgModel.from, isViewOnce: msgModel.isViewOnce, timestamp: msgModel.t * 1000, to: msgModel.to, type: msgModel.type, mimetype: msgModel.mimetype, size: msgModel.size, filename: msgModel.filename, caption: msgModel.caption, duration: msgModel.duration, height: msgModel.height, width: msgModel.width, quotedMessage: msgModel.quotedMsg, contact: contact(msgModel.senderObj), } } const groupMetadata = (data: GroupMetadataModel) => { return { id: data?.id?._serialized, description: data?.desc, size: data?.size, subject: data?.subject, creation: data?.creation * 1000, participants: data?.participants?.getModelsArray().map(participant), } } const chat = (chat: ChatModel) => { return { id: chat.id._serialized, name: chat.name, messages: chat.msgs.getModelsArray().map(message), contact: contact(chat.contact), groupMetadata: groupMetadata(chat.groupMetadata), } } const participant = (participant: ParticipantModel) => { return { isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, contact: contact(participant.contact), } } export default { button, list, contact, chat, participant, message, }
```

# src/utils/style.ts

```ts
import appStyle from 'data-text:@/components/App.module.css' import appMenuStyle from 'data-text:@/components/AppMenu.module.css' import layoutStyle from 'data-text:@/components/Layout/LayoutPage.module.css' import toastStyle from 'data-text:@/components/Toast/Toast.module.css' import globalsStyle from 'data-text:@/styles/globals.css' import coreStyle from 'data-text:@mantine/core/styles.css' import dateStyle from 'data-text:@mantine/dates/styles.css' import dropzoneStyle from 'data-text:@mantine/dropzone/styles.css' import tableStyle from 'data-text:mantine-datatable/styles.layer.css' const styles = [ coreStyle, dateStyle, dropzoneStyle, tableStyle, toastStyle, globalsStyle, layoutStyle, appMenuStyle, appStyle, ] const generate = () => { return styles.join('') } export default { generate }
```

# src/utils/throwError.ts

```ts
const broadcastNotFound = () => { throw new Error('Broadcast not found') } const mediaNotFound = () => { throw new Error('Media not found') } const contactNotExist = () => { throw new Error('Contact not exist') } export default { broadcastNotFound, mediaNotFound, contactNotExist, }
```

# src/utils/toast.ts

```ts
import { useToastStore } from '@/stores/toast' const showSuccess = (message: string, title: string = 'Success') => { useToastStore.getState().addToast({ type: 'success', title, message }) } const showError = (message: string, title: string = 'Error') => { useToastStore.getState().addToast({ type: 'error', title, message }) } const showInfo = (message: string, title: string = 'Information') => { useToastStore.getState().addToast({ type: 'info', title, message }) } const showWarning = (message: string, title: string = 'Warning') => { useToastStore.getState().addToast({ type: 'warning', title, message }) } export default { success: showSuccess, error: showError, info: showInfo, // ADDED: Export the new 'warning' function. warning: showWarning, }
```

# src/utils/util.ts

```ts
// src/utils/util.ts import { Action, Message } from '@/constants' import type { UseFormReturnType } from '@mantine/form' import { sendToBackground } from '@plasmohq/messaging' import _ from 'lodash' export async function delay(timeoutMs = 1000) { await new Promise((resolve) => setTimeout(resolve, timeoutMs)) } export const generateRandomDelay = (min: number, max: number) => { // Calculate the range of multiples of 1000 const minThousand = Math.ceil(min / 1000) const maxThousand = Math.floor(max / 1000) // Generate a random integer in that range and multiply by 1000 const randomThousand = Math.floor(Math.random() * (maxThousand - minThousand + 1)) + minThousand return randomThousand * 1000 } export const truncate = (data: string, length: number = 30) => { return _.chain(data) .thru((str) => (str.length > length ? `${str.slice(0, length)}...` : str)) .value() } export const postMessage = (action: string, body: any = null) => { window.postMessage({ action, body }) } export const closePage = () => { postMessage(Action.Window.CLOSE_PAGE) } export const showModalPricing = () => { postMessage(Action.Window.SHOW_MODAL_PRICING) } export const showModalUpgrade = ( featureName = 'Pro Feature', featureBenefit = 'Upgrade to Pro to unlock this feature and many more!', ) => { postMessage(Action.Window.SHOW_MODAL_UPGRADE, { featureName, featureBenefit }) } export const showModalMain = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } export const showModalActivation = () => { postMessage(Action.Window.SHOW_MODAL_ACTIVATION) } export const showModalProfile = () => { postMessage(Action.Window.SHOW_MODAL_PROFILE) } export const showModalFaq = () => { postMessage(Action.Window.SHOW_MODAL_FAQ) } export const goToResourcePage = async () => { await sendToBackground({ name: 'resource-page', body: {}, }) } export const getStoreId = () => { return process.env.PLASMO_PUBLIC_STORE_ID } export const isTypeMessageMedia = (type: string) => { return [Message.MEDIA, Message.IMAGE, Message.VIDEO, Message.FILE].includes( type, ) } export const formHasErrors = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ): boolean => { let hasError = false if (form1.validate().hasErrors) { hasError = true } if (form2.validate().hasErrors) { hasError = true } return hasError } export const resetForms = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ) => { form1.reset() form2.reset() } /** * @description Generates a thumbnail from a video file. * @param {File} file The video file. * @returns {Promise<string>} A promise that resolves with a base64 data URL of the thumbnail. */ export const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve, reject) => { try { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.muted = true video.playsInline = true video.onloadeddata = () => { canvas.width = video.videoWidth canvas.height = video.videoHeight video.currentTime = 1 // Seek to 1 second to get a good frame video.onseeked = () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up memory resolve(thumbnailUrl) } else { reject(new Error('Could not get canvas context.')) } } } video.onerror = () => { URL.revokeObjectURL(video.src) reject(new Error('Failed to load video file for thumbnail.')) } video.src = URL.createObjectURL(file) } catch (error) { reject(error) } }) } export const getContactName = (contact: any) => { return ( contact.name || contact.pushname || contact.notifyName || contact.formattedName || '-' ) }
```

# tsconfig.json

```json
{ "extends": "plasmo/templates/tsconfig.base", "exclude": ["node_modules"], "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"], "compilerOptions": { "paths": { "@/*": ["src/*"] }, "baseUrl": "." } }
```

