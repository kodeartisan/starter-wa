# assets/icon.png

This is a binary file of the type: Image

# package.json

```json
{ "name": "whats-group-link-generator", "shortName": "WAGroupLinks", "displayName": "WA Group Bulk Link Generator for WhatsApp", "version": "1.0.0", "description": "Generate invite links in bulk, create QR codes, and export your list right from WhatsApp Web.", "author": "Extninja", "scripts": { "dev": "plasmo dev --no-cs-reload", "build": "plasmo build", "package": "plasmo package" }, "dependencies": { "@haverstack/axios-fetch-adapter": "^0.12.0", "@lemonsqueezy/lemonsqueezy.js": "^4.0.0", "@mantine/core": "^8.2.2", "@mantine/dates": "^8.2.2", "@mantine/dropzone": "^8.2.2", "@mantine/form": "^8.2.2", "@mantine/hooks": "^8.2.2", "@plasmohq/messaging": "0.7.1", "@plasmohq/storage": "^1.15.0", "@react-pdf/renderer": "^4.3.0", "@wppconnect/wa-js": "^3.18.4", "axios": "^1.11.0", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dayjs": "^1.11.13", "dexie": "^4.0.11", "dexie-react-hooks": "^1.1.7", "emoji-picker-react": "^4.13.2", "file-saver": "^2.0.5", "html2canvas": "^1.4.1", "jquery": "^3.7.1", "jspdf": "^3.0.1", "jszip": "^3.10.1", "lodash": "^4.17.21", "mantine-datatable": "^8.2.0", "plasmo": "0.90.5", "qrcode.react": "^4.2.0", "react": "18.2.0", "react-dom": "18.2.0", "react-if": "^4.1.6", "webextension-polyfill": "^0.12.0", "xlsx": "^0.18.5", "zustand": "^5.0.7" }, "devDependencies": { "@ianvs/prettier-plugin-sort-imports": "4.1.1", "@iconify/react": "^6.0.0", "@types/chrome": "0.0.258", "@types/file-saver": "^2.0.7", "@types/jquery": "^3.5.32", "@types/lodash": "^4.17.20", "@types/node": "20.11.5", "@types/react": "18.2.48", "@types/react-dom": "18.2.18", "@types/webextension-polyfill": "^0.12.3", "postcss": "^8.5.6", "postcss-preset-mantine": "1.17.0", "postcss-simple-vars": "^7.0.1", "prettier": "3.2.4", "typescript": "5.3.3" }, "manifest": { "host_permissions": [ "https://web.whatsapp.com/*", "https://api.lemonsqueezy.com/*" ], "permissions": [], "default_locale": "en" } }
```

# postcss.config.cjs

```cjs
module.exports = { plugins: { 'postcss-preset-mantine': {}, 'postcss-simple-vars': { variables: { 'mantine-breakpoint-xs': '36em', 'mantine-breakpoint-sm': '48em', 'mantine-breakpoint-md': '62em', 'mantine-breakpoint-lg': '75em', 'mantine-breakpoint-xl': '88em', }, }, }, }
```

# README.md

```md
This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo). ## Getting Started First, run the development server: \`\`\`bash pnpm dev # or npm run dev \`\`\` Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`. You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser. For further guidance, [visit our Documentation](https://docs.plasmo.com/) ## Making production build Run the following: \`\`\`bash pnpm build # or npm run build \`\`\` This should create a production bundle for your extension, ready to be zipped and published to the stores. ## Submit to the webstores The easiest way to deploy your Plasmo extension is to use the built-in [bpp](https://bpp.browser.market) GitHub action. Prior to using this action however, make sure to build your extension and upload the first version to the store to establish the basic credentials. Then, simply follow [this setup instruction](https://docs.plasmo.com/framework/workflows/submit) and you should be on your way for automated submission!
```

# src/background/index.ts

```ts
import { Action, Setting } from '@/constants' import { storage } from '@/libs/storage' import { getTabByUrl, openWa } from '@/utils/ext' import { sendToContentScript } from '@plasmohq/messaging' import browser from 'webextension-polyfill' browser.runtime.onInstalled.addListener(async (details) => { if (details.reason === 'install') { await storage.set(Setting.LICENSE_KEY, null) await storage.set(Setting.IS_FIRST_TIME, true) await storage.set(Setting.NEED_TO_OPEN, true) await openWa() } }) browser.action.onClicked.addListener(async () => { const waTab = await getTabByUrl('https://web.whatsapp.com/') if (waTab?.active) { sendToContentScript({ name: Action.Window.SHOW_MODAL_MAIN, }) return } await storage.set(Setting.NEED_TO_OPEN, true) await openWa() })
```

# src/background/messages/http.ts

```ts
import http from '@/libs/http' import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { url, method, data, config } = req.body const httpInstance = { POST: () => { return http.post(url, data, config) }, GET: () => { return http.get(url, config) }, } const result = await httpInstance[method]?.() return res.send(result.data) } export default handler
```

# src/background/messages/lemonsqueezy.ts

```ts
import lemonSqueezy from '@/libs/ls' import type { PlasmoMessaging } from '@plasmohq/messaging' import pkg from '../../../package.json' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body try { let response switch (action) { case 'validateLicense': response = await lemonSqueezy.validateLicense(body.licenseKey) break case 'activateLicense': response = await lemonSqueezy.activateLicense(body.licenseKey, pkg.name) break case 'deactivateLicense': response = await lemonSqueezy.deactivateLicense( body.licenseKey, body.instanceId, ) break case 'getCustomer': response = await lemonSqueezy.getCustomer(body.customerId) break default: return res.send({ error: 'Invalid Lemon Squeezy action' }) } res.send(response) } catch (error) { // Tangani error yang mungkin dilempar oleh SDK Lemon Squeezy res.send({ error: true, message: error.message || 'An unknown error occurred.', }) } } export default handler
```

# src/background/messages/resource-page.ts

```ts
import type { PlasmoMessaging } from '@plasmohq/messaging' import browser from 'webextension-polyfill' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const url = browser.runtime.getURL('tabs/resource-page.html') await browser.tabs.create({ url }) return res.send({}) } export default handler
```

# src/components/AppMenu.module.css

```css
.tab { &:hover, &[data-active] { background-color: var(--mantine-primary-color-filled-hover); } }
```

# src/components/AppMenu.tsx

```tsx
// src/components/AppMenu.tsx import { Action, Page, Setting } from '@/constants' import PageGroupMemberExporter from '@/features/group-member-exporter/PageGroupMemberExporter' import useLicense from '@/hooks/useLicense' import useRuntimeMessage from '@/hooks/useRuntimeMessage' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import env from '@/utils/env' import { Icon } from '@iconify/react' import { Box, Stack, Tabs, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' import classes from './AppMenu.module.css' import Modal from './Modal/Modal' import ModalActivation from './Modal/ModalActivation' import ModalFaq from './Modal/ModalFaq' import ModalPricing from './Modal/ModalPricing' import ModalProfile from './Modal/ModalProfile' import ModalUpgrade from './Modal/ModalUpgrade' const AppMenu: React.FC = () => { const { setIsReady, setGroups } = useAppStore() const wa = useWa() const license = useLicense() const [showModalMain, modalMain] = useDisclosure(env.isDevelopment()) const [showModalActivation, modalActivation] = useDisclosure(false) const [showModalFaq, modalFaq] = useDisclosure(false) const [showModalProfile, modalProfile] = useDisclosure(false) const [showModalPricing, modalPricing] = useDisclosure(false) const [showModalUpgrade, modalUpgradeHandlers] = useDisclosure(false) const [upgradeInfo, setUpgradeInfo] = useState({ featureName: '', featureBenefit: '', }) const [needToOpen, setNeedToOpen] = useStorage(Setting.NEED_TO_OPEN, false) const [activeTab, setActiveTab] = useState<string | null>(Page.HOME) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.GO_TO_PAGE: setActiveTab(body) break case Action.Window.SHOW_MODAL_UPGRADE: setUpgradeInfo({ featureName: body.featureName, featureBenefit: body.featureBenefit, }) modalUpgradeHandlers.open() break case Action.Window.SHOW_MODAL_PRICING: modalPricing.toggle() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break case Action.Window.SHOW_MODAL_FAQ: modalFaq.toggle() break case Action.Window.SHOW_MODAL_PROFILE: modalProfile.toggle() break default: break } }) useRuntimeMessage((message, sender, sendResponse) => { switch (message.name) { case Action.Window.SHOW_MODAL_MAIN: modalMain.toggle() sendResponse() break default: break } // Return true to keep the message channel open for async responses return true }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { if (needToOpen) { modalMain.open() setNeedToOpen(false).then().catch(console.error) } }, [needToOpen]) useEffect(() => { ;(async function () { if (!wa.isReady) return setTimeout(async () => { const groups = await wa.group.list() setGroups(groups) }, 3000) })() }, [wa.isReady]) const handleChangeTab = (value: string | null) => { if (Page.UPGRADE === value) { modalPricing.toggle() return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } if (Page.FAQ === value) { modalFaq.toggle() return } if (Page.PROFILE === value) { modalProfile.toggle() return } setActiveTab(value) } const renderTabList = () => { return ( <Tabs.List style={{ gap: 10, background: 'linear-gradient(180deg, var(--mantine-color-teal-7) 0%, var(--mantine-color-teal-9) 100%)', }} > <Stack justify="space-between" gap={0} style={{ height: '100%' }}> <Box> <Tabs.Tab value={Page.HOME} className={classes.tab}> <Tooltip label="Group Link" position="left"> <Icon icon="tabler:ticket" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> </Box> <Box> <Tabs.Tab value={Page.FAQ} className={classes.tab}> <Tooltip label="Faqs"> <Icon icon="tabler:world-question" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.UPGRADE} className={classes.tab}> <Tooltip label="Upgrade"> <Icon icon="tabler:crown" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab}> <Tooltip label="Activate"> <Icon icon="tabler:key" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PROFILE} className={classes.tab}> <Tooltip label="Profile"> <Icon icon="tabler:user-square-rounded" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> </Stack> </Tabs.List> ) } const renderTabPanel = () => { return ( <> <Tabs.Panel value={Page.HOME}> <PageGroupMemberExporter /> </Tabs.Panel> </> ) } return ( <> <Modal opened={showModalMain} onClose={modalMain.close} p={0}> <Tabs value={activeTab} onChange={handleChangeTab} variant="pills" orientation="vertical" radius={0} keepMounted={false} > {renderTabList()} {renderTabPanel()} </Tabs> </Modal> <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <ModalFaq opened={showModalFaq} onClose={modalFaq.close} /> <ModalProfile opened={showModalProfile} onClose={modalProfile.close} /> <ModalPricing opened={showModalPricing} onClose={modalPricing.close} /> <ModalUpgrade opened={showModalUpgrade} onClose={modalUpgradeHandlers.close} featureName={upgradeInfo.featureName} featureBenefit={upgradeInfo.featureBenefit} /> </> ) } export default AppMenu
```

# src/components/Broadcast/Datatable/MessageType.tsx

```tsx
import { Message } from '@/constants' import { Icon } from '@iconify/react' import { Group, Text } from '@mantine/core' import _ from 'lodash' import React from 'react' interface Props { type: string } const MessageType: React.FC<Props> = ({ type }: Props) => { const icons = { [Message.TEXT]: 'tabler:text-size', [Message.MEDIA]: 'tabler:library-photo', [Message.BUTTON]: 'tabler:hand-finger', [Message.LIST]: 'tabler:list', [Message.LOCATION]: 'tabler:map-pin', [Message.POLL]: 'tabler:list-details', [Message.VCARD]: 'tabler:user-square', } const icon = icons[type] ?? 'tabler:text-size' return ( <Group gap={4}> <Icon icon={icon} fontSize={18} /> <Text>{_.startCase(type?.toLowerCase())}</Text> </Group> ) } export default MessageType
```

# src/components/Broadcast/Input/Excel/ExcelUploader.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Button, FileInput, Group, ScrollArea, Stack, Table, Text, } from '@mantine/core' import FileSaver from 'file-saver' import React, { useState } from 'react' import * as XLSX from 'xlsx' interface Props { onConfirm: (data: any[]) => void onClose: () => void } /** * @component ExcelUploader * @description A generic component for uploading, parsing, previewing, and confirming Excel data. * It encapsulates the core logic previously duplicated in ModalSourceExcel and ExcelUploadPopover. */ const ExcelUploader: React.FC<Props> = ({ onConfirm, onClose }) => { const [parsedData, setParsedData] = useState<any[]>([]) const [excelFile, setExcelFile] = useState<File | null>(null) // Function to download a sample Excel template const handleDownloadSample = () => { const sampleData = [{ number: '6281234567890', name: 'John Doe' }] const worksheet = XLSX.utils.json_to_sheet(sampleData) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Contacts') const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array', }) const data = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8', }) FileSaver.saveAs(data, 'sample_contacts.xlsx') } // Handles file selection and parsing const handleFileChange = (file: File | null) => { if (!file) { setParsedData([]) setExcelFile(null) return } setExcelFile(file) const reader = new FileReader() reader.onload = (event) => { const data = new Uint8Array(event.target?.result as ArrayBuffer) const workbook = XLSX.read(data, { type: 'array' }) const sheetName = workbook.SheetNames[0] const worksheet = workbook.Sheets[sheetName] const json = XLSX.utils.sheet_to_json(worksheet) setParsedData(json) } reader.readAsArrayBuffer(file) } // Removes a specific row from the preview data const handleDeleteRow = (indexToRemove: number) => { setParsedData((currentData) => currentData.filter((_, index) => index !== indexToRemove), ) } // Confirms the upload, passes the data to the parent, and calls the parent's close handler const handleConfirmUpload = () => { onConfirm(parsedData) onClose() } // Resets state and calls the parent's close handler const handleClose = () => { setParsedData([]) setExcelFile(null) onClose() } return ( <> <Text size="xs" c="dimmed" mt={-10}> File must contain a 'number' column. </Text> <Group justify="center"> <Button variant="light" size="xs" onClick={handleDownloadSample} leftSection={<Icon icon="tabler:download" />} > Download Sample </Button> </Group> <FileInput placeholder="Choose file" onChange={handleFileChange} accept=".xlsx, .xls, .csv" clearable value={excelFile} /> {parsedData.length > 0 && ( <> <Text size="sm">Data Preview:</Text> <ScrollArea h={150}> <Table striped highlightOnHover withTableBorder withColumnBorders fz="xs" > <Table.Thead> <Table.Tr> <Table.Th>Number</Table.Th> <Table.Th>Name</Table.Th> <Table.Th></Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {parsedData.map((row, index) => ( <Table.Tr key={index}> <Table.Td>{row.number}</Table.Td> <Table.Td>{row.name}</Table.Td> <Table.Td> <ActionIcon color="red" variant="transparent" onClick={() => handleDeleteRow(index)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </ScrollArea> </> )} <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleConfirmUpload} disabled={parsedData.length === 0} > Add {parsedData.length} Numbers </Button> </Group> </> ) } export default ExcelUploader
```

# src/components/Broadcast/Input/Excel/ExcelUploadPopover.tsx

```tsx
import { Icon } from '@iconify/react' import { Button, Popover, Stack, Text, Tooltip } from '@mantine/core' import React, { useState } from 'react' import ExcelUploader from './ExcelUploader' interface Props { onConfirm: (data: any[]) => void } /** * @component ExcelUploadPopover * @description A popover component for Excel uploads, now refactored to use the generic ExcelUploader. * It acts as a lightweight wrapper, placing the uploader logic inside a Mantine Popover. */ const ExcelUploadPopover: React.FC<Props> = ({ onConfirm }) => { const [popoverOpened, setPopoverOpened] = useState(false) return ( <Popover opened={popoverOpened} onChange={setPopoverOpened} withArrow shadow="md" position="bottom-end" > <Popover.Target> <Tooltip label="Upload excel" position="top"> <Button size={'compact-sm'} variant="outline" onClick={() => setPopoverOpened((o) => !o)} > <Icon icon={'tabler:file-type-xls'} fontSize={24} /> </Button> </Tooltip> </Popover.Target> <Popover.Dropdown w={350}> <Stack> <Text size="sm" fw={500}> Upload Excel File </Text> <ExcelUploader onConfirm={onConfirm} onClose={() => setPopoverOpened(false)} /> </Stack> </Popover.Dropdown> </Popover> ) } export default ExcelUploadPopover
```

# src/components/Broadcast/Input/InputContact.tsx

```tsx
import { Group, TagsInput, Text, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import ExcelUploadPopover from './Excel/ExcelUploadPopover' interface Props { form: UseFormReturnType<any> } const InputContact: React.FC<Props> = ({ form }) => { const handleAddNumbers = (newNumbers: (string | number)[]) => { const currentValues = form.values.numbers const uniqueNumbers = [ ...new Set([...currentValues, ...newNumbers.map(String)]), ] form.setFieldValue('numbers', uniqueNumbers) } // This function is passed to the ExcelUploadPopover to handle the data once confirmed. const handleConfirmExcelUpload = (parsedData: any[]) => { const newNumbers = parsedData .map((item) => item.number?.toString()) .filter(Boolean) if (newNumbers.length > 0) { handleAddNumbers(newNumbers) } } return ( <> <TagsInput label={ <Group justify="space-between" w={687}> <Text fw={500}> Numbers{' '} {form.values.numbers.length ? `(${form.values.numbers.length})` : ''} </Text> <Group mb={6}> <ExcelUploadPopover onConfirm={handleConfirmExcelUpload} /> </Group> </Group> } placeholder="Number with country code, Press Enter to submit" {...form.getInputProps('numbers')} clearable /> </> ) } export default InputContact
```

# src/components/Broadcast/Input/InputSendLater.tsx

```tsx
import useLicense from '@/hooks/useLicense' import { Badge, Group, Switch, Text } from '@mantine/core' import { DateTimePicker } from '@mantine/dates' import type { UseFormReturnType } from '@mantine/form' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputSendLater: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <> <Switch label={ <Group gap="xs"> <Text fw={500}>Send later</Text> <When condition={license.isFree()}> <Badge size="sm" variant="light" color="teal"> PRO </Badge> </When> </Group> } {...form.getInputProps('scheduler.enabled', { type: 'checkbox' })} /> <When condition={form.values.scheduler.enabled}> <DateTimePicker label="Date time" size="md" minDate={dayjs().add(2, 'minutes').toDate()} clearable {...form.getInputProps('scheduler.scheduledAt')} /> </When> </> ) } export default InputSendLater
```

# src/components/Broadcast/Input/InputTextarea.tsx

```tsx
import { Status } from '@/constants' import useAi from '@/hooks/useAi' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Box, Button, Group, LoadingOverlay, Menu, Popover, Stack, Text, Textarea, Tooltip, } from '@mantine/core' import EmojiPicker from 'emoji-picker-react' import React, { useRef, useState } from 'react' interface Props { value: string onChange: (value: string) => void error?: any placeholder?: string | null variables?: { label: string; variable: string }[] } const InputTextarea: React.FC<Props> = ({ value, onChange, error = null, placeholder = 'Enter your message here', variables = [], }) => { const textareaRef = useRef<HTMLTextAreaElement>(null) const [emojiPickerOpened, setEmojiPickerOpened] = useState<boolean>(false) const ai = useAi() const [isRewriting, setIsRewriting] = useState(false) const applyFormat = (startTag: string, endTag: string = '') => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const selectedText = value.substring(start, end) const newText = value.substring(0, start) + startTag + (selectedText || '') + endTag + value.substring(end) onChange(newText) setTimeout(() => { if (textarea) { const newPosition = start + startTag.length + (selectedText.length || 0) textarea.focus() textarea.setSelectionRange(newPosition, newPosition) } }, 0) } const insertSpintaxExample = () => { applyFormat('{option1|option2}') } const handleEmojiSelect = (emojiData: any) => { applyFormat(emojiData.emoji) setEmojiPickerOpened(false) } const insertVariable = (variable: string) => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const newText = value.substring(0, start) + variable + value.substring(end) onChange(newText) setTimeout(() => { if (textarea) { const newPosition = start + variable.length textarea.focus() textarea.setSelectionRange(newPosition, newPosition) } }, 0) } const handleAiRewrite = async (rewriteType: string) => { // ++ MODIFIED: Replaced alert with a toast notification. if (!value) { toast.error('Please enter a message to rewrite.') return } const prompts: Record<string, string> = { professional: 'Rewrite the following message to be more professional', friendly: 'Rewrite the following message to be more friendly and casual', fix_grammar: 'Correct any spelling and grammar mistakes in the following message', } const prompt = prompts[rewriteType] if (!prompt) return setIsRewriting(true) try { const result = await ai.rewriteMessage(prompt, value) if (result.status === Status.SUCCESS && result.data) { onChange(result.data) } else { // ++ MODIFIED: Replaced alert with a toast notification. toast.error(result.error || 'Failed to rewrite message.') } } catch (error: any) { // ++ MODIFIED: Replaced alert with a toast notification. toast.error(error.message || 'An error occurred.') } finally { setIsRewriting(false) } } const renderEmojiToolbar = () => { return ( <Popover opened={emojiPickerOpened} onChange={setEmojiPickerOpened} position="right-end" > <Popover.Target> <Tooltip label="Emoji" position="top"> <ActionIcon onClick={() => setEmojiPickerOpened((o) => !o)} variant="subtle" > <Icon icon="tabler:mood-smile" width={16} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown p={0}> <EmojiPicker width={350} height={370} onEmojiClick={handleEmojiSelect} searchDisabled skinTonesDisabled previewConfig={{ showPreview: false }} /> </Popover.Dropdown> </Popover> ) } return ( <Stack gap={3}> <Group justify="space-between"> <Group gap={6}> <Tooltip label="Italic" position="top"> <ActionIcon onClick={() => applyFormat('_', '_')} variant="subtle"> <Icon icon="tabler:italic" fontSize={18} /> </ActionIcon> </Tooltip> <Tooltip label="Bold" position="top"> <ActionIcon onClick={() => applyFormat('*', '*')} variant="subtle"> <Icon icon="tabler:bold" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Strikethrough" position="top"> <ActionIcon onClick={() => applyFormat('~', '~')} variant="subtle"> <Icon icon="tabler:strikethrough" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Monospace" position="top"> <ActionIcon onClick={() => applyFormat('\`\`\`', '\`\`\`')} variant="subtle" > <Icon icon="tabler:code" width={18} /> </ActionIcon> </Tooltip> <Tooltip label="Use Spintax for message variations. Example: {Hello|Hi}" position="top" multiline w={220} > <ActionIcon onClick={insertSpintaxExample} variant="subtle"> <Icon icon="tabler:arrows-shuffle" fontSize={18} /> </ActionIcon> </Tooltip> {/* ++ START: MODIFIED - Help Popover with corrected JSX syntax. */} {/* This Popover provides users with in-context help on how to use advanced formatting features. */} <Popover width={350} position="top-start" withArrow shadow="md"> <Popover.Target> <Tooltip label="Personalization Help" position="top"> <ActionIcon variant="subtle"> <Icon icon="tabler:help-circle" fontSize={18} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown> <Stack gap="sm"> {/* Section explaining Spintax */} <Box> <Text fw={500} size="sm"> {' '} Message Variations (Spintax){' '} </Text> <Text c="dimmed" size="xs"> {' '} Create random text variations to make your messages unique. Wrap your options in curly braces `{}` and separate them with a pipe `|`.{' '} </Text> <Text size="xs" mt={4}> {' '} <b>Example:</b>{' '} <code> {' '} {'{Hi|Hello}'}, have a {'{great|wonderful}'} day!{' '} </code>{' '} </Text> </Box> {/* Section explaining Personalization variables */} <Box> <Text fw={500} size="sm"> {' '} Personalization{' '} </Text> <Text c="dimmed" size="xs"> {' '} Use variables to automatically insert contact-specific details into your message.{' '} </Text> <Text size="xs" mt={4}> {' '} - <code>{'{name}'}</code>: Inserts the contact's saved name.{' '} </Text> <Text size="xs"> {' '} - <code>{'{number}'}</code>: Inserts the contact's phone number.{' '} </Text> </Box> </Stack> </Popover.Dropdown> </Popover> {/* <Menu shadow="md" width={220} position="top-start" withArrow> <Menu.Target> <Tooltip label="Rewrite with AI" position="top"> <ActionIcon variant="subtle" loading={isRewriting}> <Icon icon="tabler:sparkles" fontSize={18} /> </ActionIcon> </Tooltip> </Menu.Target> <Menu.Dropdown> <Menu.Label>AI Actions</Menu.Label> <Menu.Item leftSection={<Icon icon="tabler:briefcase" />} onClick={() => handleAiRewrite('professional')} > {' '} Make More Professional{' '} </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:mood-smile-beam" />} onClick={() => handleAiRewrite('friendly')} > {' '} Make More Friendly{' '} </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:language" />} onClick={() => handleAiRewrite('fix_grammar')} > {' '} Fix Spelling & Grammar{' '} </Menu.Item> </Menu.Dropdown> </Menu> */} {renderEmojiToolbar()} </Group> </Group> <Box style={{ position: 'relative' }}> <LoadingOverlay visible={isRewriting} zIndex={1000} overlayProps={{ radius: 'sm', blur: 1 }} /> <Stack gap={8}> <Textarea ref={textareaRef} value={value} onChange={(event) => onChange(event.currentTarget.value)} placeholder={ placeholder || 'Write a message... Try variations with Spintax: {Hi|Hello}' } minRows={6} autosize styles={{ input: { ...(error ? { borderColor: 'red', borderWidth: '1px' } : {}), transition: 'border-color 0.3s ease', }, }} /> {variables.length > 0 && ( <Group mb={4}> {variables.map((variable, index) => ( <Button key={index} variant="outline" size="compact-xs" onClick={() => insertVariable(variable.variable)} > {variable.label} </Button> ))} </Group> )} </Stack> </Box> {error && ( <Text c="red" size="sm"> {' '} {error}{' '} </Text> )} </Stack> ) } export default InputTextarea
```

# src/components/Broadcast/Input/InputTyping.tsx

```tsx
import useLicense from '@/hooks/useLicense' import { Badge, Group, Switch, Text, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputTyping: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <Tooltip label='Show "Typing..." status on the recipient to mimic messaging process' refProp="rootRef" position="top-start" > <Switch label={ <Group gap="xs"> <Text fw={500}>Typing effect</Text> <When condition={license.isFree()}> <Badge size="sm" variant="light" color="teal"> PRO </Badge> </When> </Group> } {...form.getInputProps('isTyping', { type: 'checkbox' })} /> </Tooltip> ) } export default InputTyping
```

# src/components/Broadcast/Input/Message/FormFile.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> } const FormFile: React.FC<Props> = ({ form }: Props) => { return ( <> <Upload type="file" value={form.values.inputFile.file} onDrop={(file) => { form.setFieldValue('inputFile.file', file) }} /> <InputTextarea value={form.values.inputFile.caption} onChange={(data) => form.setFieldValue('inputFile.caption', data)} placeholder="Enter your caption here" /> </> ) } export default FormFile
```

# src/components/Broadcast/Input/Message/FormImage.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React, { useEffect, useState } from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> } const FormImage: React.FC<Props> = ({ form }: Props) => { const [preview, setPreview] = useState<string | null>(null) useEffect(() => { return () => { if (preview) { URL.revokeObjectURL(preview) } } }, [preview]) return ( <> <Upload type="image" value={form.values.inputImage.file} onDrop={(file) => { form.setFieldValue('inputImage.file', file) }} /> <InputTextarea value={form.values.inputImage.caption} onChange={(data) => form.setFieldValue('inputImage.caption', data)} placeholder="Enter your caption here" /> </> ) } export default FormImage
```

# src/components/Broadcast/Input/Message/FormLocation.tsx

```tsx
import { Group, TextInput } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' interface Props { form: UseFormReturnType<any> } const FormLocation: React.FC<Props> = ({ form }: Props) => { return ( <> <Group grow> <TextInput required label="Latitude" placeholder="-22.95201" {...form.getInputProps('inputLocation.lat')} /> <TextInput required label="Longitude" placeholder="-43.2102601" {...form.getInputProps('inputLocation.lng')} /> </Group> <TextInput label="Name" {...form.getInputProps('inputLocation.name')} /> <TextInput label="Address" {...form.getInputProps('inputLocation.address')} /> <TextInput label="Url" {...form.getInputProps('inputLocation.url')} /> </> ) } export default FormLocation
```

# src/components/Broadcast/Input/Message/FormPoll.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Button, Fieldset, Group, Stack, Text, TextInput, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const FormPoll: React.FC<Props> = ({ form }: Props) => { const handleInsert = () => { form.insertListItem('inputPoll.choices', '') } const handleRemove = (index: number) => { form.removeListItem('inputPoll.choices', index) } return ( <> <TextInput required label="Name" {...form.getInputProps('inputPoll.name')} /> <Fieldset legend={<Text fw={500}>Choices</Text>}> <Stack> {form.values.inputPoll.choices.map((button: any, index: number) => ( <Group key={index}> <TextInput style={{ flexGrow: 1, }} {...form.getInputProps(`inputPoll.choices.${index}`)} /> <When condition={index !== 0}> <ActionIcon color="red" onClick={() => handleRemove(index)}> <Icon icon={'tabler:trash'} fontSize={24} /> </ActionIcon> </When> </Group> ))} <Box> <Button size="xs" onClick={handleInsert}> Add </Button> </Box> </Stack> </Fieldset> </> ) } export default FormPoll
```

# src/components/Broadcast/Input/Message/FormText.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' interface Props { form: UseFormReturnType<any> } const FormText: React.FC<Props> = ({ form }: Props) => { return ( <InputTextarea value={form.values.inputText} onChange={(data) => form.setFieldValue('inputText', data)} error={form.errors.inputText} /> ) } export default FormText
```

# src/components/Broadcast/Input/Message/FormVCard.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Button, Card, Group, ScrollArea, Stack, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import React from 'react' import ModalSelectContacts from './ModalSelectContacts' interface Props { form: UseFormReturnType<any> } /** * @component FormVCard * @description Renders the UI for selecting one or more contacts to send as a VCard. */ const FormVCard: React.FC<Props> = ({ form }) => { const [showModal, modalHandlers] = useDisclosure(false) const selectedContacts = form.values.inputVCard.contacts // Handler to add contacts from the modal to the form state const handleSelectContacts = (newContacts: any[]) => { // Store the full contact objects; the sender function will extract the ID. form.setFieldValue('inputVCard.contacts', newContacts) modalHandlers.close() } // Handler to remove a contact from the list const handleRemoveContact = (contactId: string) => { // -- MODIFIED: Changed filter logic to use the correct unique identifier `id`. form.setFieldValue( 'inputVCard.contacts', selectedContacts.filter((c: any) => c.id !== contactId), ) } return ( <> <Stack> <Group justify="space-between"> <Text fw={500}>Selected Contacts ({selectedContacts.length})</Text> <Button size="xs" variant="outline" leftSection={<Icon icon="tabler:address-book" fontSize={16} />} onClick={modalHandlers.open} > Select Contact(s) </Button> </Group> {/* Display selected contacts */} <ScrollArea h={150} style={{ border: '1px solid #dee2e6', borderRadius: '4px' }} > <Stack gap="xs" p="xs"> {selectedContacts.length > 0 ? ( selectedContacts.map((contact: any) => ( // -- MODIFIED: Changed key to use `contact.id` for unique identification. <Card withBorder p="xs" radius="sm" key={contact.id}> <Group justify="space-between"> <Text size="sm"> {/* -- MODIFIED: Updated to use the correct properties for displaying the contact's name or number. */} {contact.savedName || contact.publicName || contact.phoneNumber} </Text> <Tooltip label="Remove"> {/* -- MODIFIED: Pass `contact.id` to the remove handler. */} <ActionIcon color="red" variant="transparent" onClick={() => handleRemoveContact(contact.id)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Tooltip> </Group> </Card> )) ) : ( <Text c="dimmed" ta="center" pt="xl"> No contacts selected. </Text> )} </Stack> </ScrollArea> {form.errors['inputVCard.contacts'] && ( <Text c="red" size="xs"> {form.errors['inputVCard.contacts']} </Text> )} </Stack> <ModalSelectContacts opened={showModal} onClose={modalHandlers.close} onSubmit={handleSelectContacts} /> </> ) } export default FormVCard
```

# src/components/Broadcast/Input/Message/FormVideo.tsx

```tsx
import type { UseFormReturnType } from '@mantine/form' import React from 'react' import InputTextarea from '../InputTextarea' import Upload from './Upload' interface Props { form: UseFormReturnType<any> } const FormVideo: React.FC<Props> = ({ form }: Props) => { return ( <> <Upload type="video" value={form.values.inputVideo.file} onDrop={(file) => { form.setFieldValue('inputVideo.file', file) }} /> <InputTextarea value={form.values.inputVideo.caption} onChange={(data) => form.setFieldValue('inputVideo.caption', data)} placeholder="Enter your caption here" /> </> ) } export default FormVideo
```

# src/components/Broadcast/Input/Message/InputMessage.tsx

```tsx
import { Media, Message } from '@/constants' import useLicense from '@/hooks/useLicense' import db, { type BroadcastTemplate } from '@/libs/db' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Popover, Select, SimpleGrid, Stack, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo } from 'react' import { When } from 'react-if' import ModalManageTemplate from '../../Template/ModalManageTemplate' import FormDocument from './FormFile' import FormImage from './FormImage' import FormLocation from './FormLocation' import FormPoll from './FormPoll' import FormText from './FormText' import FormVCard from './FormVCard' // Import new VCard form import FormVideo from './FormVideo' import ProFeatureButton from './ProFeatureButton' interface Props { form: UseFormReturnType<any> disabledTemplateButton?: boolean } const InputMessage: React.FC<Props> = ({ form, disabledTemplateButton = false, }: Props) => { const license = useLicense() const templates = useLiveQuery( async () => await db.broadcastTemplates.toArray(), ) const [showModalManageTemplate, modalManageTemplate] = useDisclosure(false) const labelValueTemplates = useMemo(() => { return templates?.map((template: BroadcastTemplate, index) => ({ label: template.name, value: index.toString(), })) }, [templates]) const handleSelectTemplate = async (index: string) => { const { id, message, type } = templates![parseInt(index, 10)] const dataByMessageTypes: { [key: string]: () => any } = { [Message.TEXT]: () => ({ type, inputText: message }), [Message.IMAGE]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputImage: { file: broadcastFile?.file, ...(message as object) }, } }, [Message.VIDEO]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputVideo: { file: broadcastFile?.file, ...(message as object) }, } }, [Message.FILE]: async () => { const broadcastFile = await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: id }) .first() return { type, inputFile: { file: broadcastFile?.file, caption: message }, } }, [Message.LOCATION]: () => ({ type, inputLocation: { ...(message as object) }, }), [Message.POLL]: () => ({ type, inputPoll: { ...(message as object) } }), } const data = await dataByMessageTypes[type]?.() form.setValues(data) } const renderInputMessage = () => { switch (form.values.type) { case Message.TEXT: return <FormText form={form} /> case Message.IMAGE: return <FormImage form={form} /> case Message.VIDEO: return <FormVideo form={form} /> case Message.FILE: return <FormDocument form={form} /> case Message.LOCATION: return <FormLocation form={form} /> case Message.POLL: return <FormPoll form={form} /> // ++ ADDED: Render the VCard form when its type is selected case Message.VCARD: return <FormVCard form={form} /> default: return null } } const renderMenuMessage = () => { return ( <SimpleGrid cols={5}> <Tooltip label="Text" position="top"> <Button size="sm" variant={form.values.type === Message.TEXT ? 'filled' : 'default'} onClick={() => form.setFieldValue('type', Message.TEXT)} > <Icon icon={'tabler:text-size'} fontSize={24} /> </Button> </Tooltip> <ProFeatureButton form={form} label="Image" icon="tabler:photo" messageType={Message.IMAGE} /> <ProFeatureButton form={form} label="Video" icon="tabler:video" messageType={Message.VIDEO} /> <ProFeatureButton form={form} label="File" icon="tabler:file" messageType={Message.FILE} /> <ProFeatureButton form={form} label="Location" icon="tabler:map-pin" messageType={Message.LOCATION} /> {/* <ProFeatureButton form={form} label="Poll" icon="tabler:list-details" messageType={Message.POLL} /> <ProFeatureButton form={form} label="Contact (VCard)" icon="tabler:user-square" messageType={Message.VCARD} /> */} </SimpleGrid> ) } return ( <> <Stack> <Group justify="space-between"> <Text fw={500}>Message</Text> <When condition={!disabledTemplateButton}> <Popover width={300} position="top-end" withArrow shadow="md"> <Popover.Target> <Tooltip label="Get template" position="top"> <Button size={'compact-sm'} variant="outline"> <Icon icon={'tabler:template'} fontSize={26} /> </Button> </Tooltip> </Popover.Target> <Popover.Dropdown> <Stack> <Select label={ <Group justify="space-between" w={270}> <Text>Use a template</Text> <Tooltip label="Manage Templates"> <ActionIcon variant="transparent" onClick={modalManageTemplate.toggle} > <Icon icon={'tabler:settings'} fontSize={18} /> </ActionIcon> </Tooltip> </Group> } searchable placeholder="Select a template to use" data={labelValueTemplates} onChange={(value) => handleSelectTemplate(value!)} comboboxProps={{ withinPortal: false }} /> </Stack> </Popover.Dropdown> </Popover> </When> </Group> </Stack> {renderMenuMessage()} {renderInputMessage()} <ModalManageTemplate opened={showModalManageTemplate} onClose={modalManageTemplate.close} /> </> ) } export default InputMessage
```

# src/components/Broadcast/Input/Message/ModalSelectContacts.tsx

```tsx
import Modal from '@/components/Modal/Modal' import wa from '@/libs/wa' import { Icon } from '@iconify/react' import { Button, Group, Stack, TextInput, Title } from '@mantine/core' import { DataTable, type DataTableColumn } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (contacts: any[]) => void } /** * @component ModalSelectContacts * @description A modal for fetching, displaying, and selecting from a user's contact list. */ const ModalSelectContacts: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const [contacts, setContacts] = useState<any[]>([]) const [loading, setLoading] = useState(true) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<any[]>([]) useEffect(() => { if (opened) { const fetchContacts = async () => { setLoading(true) try { const contactList = await wa.contact.list({ onlyMyContacts: true }) setContacts(contactList) } catch (error) { console.error('Failed to fetch contacts:', error) } finally { setLoading(false) } } fetchContacts() } else { // Reset state when modal is closed setContacts([]) setSelectedRecords([]) setSearch('') } }, [opened]) const filteredContacts = useMemo(() => { if (!search) return contacts return contacts.filter( (c) => // -- MODIFIED: Corrected typo from `publictName` to `publicName`. c.publicName?.toLowerCase().includes(search.toLowerCase()) || c.savedName?.toLowerCase().includes(search.toLowerCase()) || c.phoneNumber.includes(search), ) }, [contacts, search]) const handleSubmit = () => { onSubmit(selectedRecords) onClose() } const columns: DataTableColumn<any>[] = [ { accessor: 'name', title: 'Name', // -- MODIFIED: Corrected typo from `pubictName` to `publicName`. render: (record) => record.publicName || record.savedName || 'N/A', }, { accessor: 'number', title: 'Number', render: (record) => record.phoneNumber, }, ] return ( <Modal opened={opened} onClose={onClose} w={700} withCloseButton> <Stack h={500} p="sm"> <Title order={4}>Select Contact(s) to Send</Title> <TextInput placeholder="Search contacts by name or number..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={search} onChange={(e) => setSearch(e.currentTarget.value)} disabled={loading} /> <DataTable height="100%" withTableBorder borderRadius="sm" striped highlightOnHover records={filteredContacts} columns={columns} fetching={loading} minHeight={150} noRecordsText="No contacts found" selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} selectionCheckboxProps={{ 'aria-label': 'Select row' }} // ++ ADDED: Provide the 'id' accessor to the table. // This tells the DataTable to use the `id` field of each record object // as its unique identifier, which fixes the selection bug. idAccessor="id" /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedRecords.length === 0} > Add {selectedRecords.length} Contact(s) </Button> </Group> </Stack> </Modal> ) } export default ModalSelectContacts
```

# src/components/Broadcast/Input/Message/ProFeatureButton.tsx

```tsx
import useLicense from '@/hooks/useLicense' import { Icon } from '@iconify/react' import { Badge, Button, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' const ProFeatureButton = ({ form, label, icon, messageType, }: { form: UseFormReturnType<any> label: string icon: string messageType: string }) => { const license = useLicense() return ( <Tooltip label={label} position="top"> <Button size="sm" variant={form.values.type === messageType ? 'filled' : 'default'} onClick={() => { form.setFieldValue('type', messageType) }} rightSection={ <When condition={license.isFree()}> <Badge size="xs" variant="light" color="teal" radius="sm"> PRO </Badge> </When> } > <Icon icon={icon} fontSize={24} /> </Button> </Tooltip> ) } export default ProFeatureButton
```

# src/components/Broadcast/Input/Message/Upload.tsx

```tsx
import { Icon } from '@iconify/react' import { Stack, Text } from '@mantine/core' import { Dropzone, IMAGE_MIME_TYPE, type FileRejection, } from '@mantine/dropzone' import React, { useEffect, useState } from 'react' interface Props { type: 'image' | 'video' | 'file' value: File | null onDrop: (file: File) => void onReject?: (fileRejections: FileRejection[]) => void | null } const Upload: React.FC<Props> = ({ type, value, onDrop, onReject = () => {}, }) => { const [preview, setPreview] = useState<string | null>(null) const [fileInfo, setFileInfo] = useState<{ name: string size: string } | null>(null) const mimes = { image: IMAGE_MIME_TYPE, video: ['video/mp4'], audio: [], file: [], } const maxSizes = { image: 3 * 1024 * 1024, // 3MB video: 8 * 1024 * 1024, // 8MB file: 8 * 1024 * 1024, // 8MB } const idleDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } const rejectDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } useEffect(() => { // Cleanup function to revoke the object URL when the component unmounts // or when the preview changes, to prevent memory leaks. return () => { if (preview) { URL.revokeObjectURL(preview) } } }, [preview]) useEffect(() => { // This effect handles the display of a preview when a file 'value' is provided. if (value) { if (type === 'image') { const previewUrl = URL.createObjectURL(value) setPreview(previewUrl) } else if (type === 'video') { generateVideoThumbnail(value).then((thumbnail) => setPreview(thumbnail)) } else if (type === 'file') { const sizeInMB = (value.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: value.name, size: `${sizeInMB} MB` }) } } else { // If the value is cleared, reset the preview and file info. setPreview(null) setFileInfo(null) } }, [value, type]) const handleDrop = async (files: File[]) => { if (files.length > 0) { const file = files[0] onDrop(file) // Pass the file to the parent component. // Generate a preview based on the file type. if (type === 'video') { const thumbnail = await generateVideoThumbnail(file) setPreview(thumbnail) } else if (type === 'image') { const previewUrl = URL.createObjectURL(file) setPreview(previewUrl) } else if (type === 'file') { const sizeInMB = (file.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: file.name, size: `${sizeInMB} MB` }) } } } const handleReject = (fileRejections: FileRejection[]) => { onReject(fileRejections) console.log(fileRejections) } const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve) => { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.src = URL.createObjectURL(file) video.addEventListener('loadeddata', () => { canvas.width = 200 canvas.height = 150 video.currentTime = 0 // Seek to the beginning video.addEventListener('seeked', () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up the object URL resolve(thumbnailUrl) } }) }) }) } return ( <Dropzone onDrop={handleDrop} onReject={handleReject} maxSize={maxSizes[type]} accept={mimes[type]} multiple={false} > {/* START: MODIFIED - Conditional Rendering for Dropzone states */} {/* This section checks if a file is already selected. If so, it shows the preview. */} {/* If not, it renders the different dropzone states (Idle, Accept, Reject). */} {type === 'file' && fileInfo ? ( <div style={{ textAlign: 'center' }}> <Stack justify="center" align="center"> <Icon icon="tabler:file-text" fontSize={50} /> <Text>File: {fileInfo.name}</Text> <Text size="sm">Size: {fileInfo.size}</Text> </Stack> </div> ) : preview ? ( <div style={{ textAlign: 'center' }}> <img src={preview} alt="Preview" style={{ maxWidth: '100%', height: 100, objectFit: 'contain' }} /> </div> ) : ( // This block provides enhanced visual feedback for the drag-and-drop interaction. <> {/* Default state when no file is being dragged. */} <Dropzone.Idle> <Stack justify="center" align="center"> <Icon icon={ type === 'image' ? 'tabler:photo' : type === 'video' ? 'tabler:video' : type === 'file' ? 'tabler:file-text' : 'tabler:file' } fontSize={50} /> <Text>Drag & drop here or click to select a file</Text> <Text size="xs" c="dimmed"> {idleDescriptions[type]} </Text> </Stack> </Dropzone.Idle> {/* State when a valid file is dragged over the component. */} <Dropzone.Accept> <Stack justify="center" align="center"> <Icon icon={'tabler:upload'} fontSize={50} /> <Text>Drop the file here...</Text> </Stack> </Dropzone.Accept> {/* State when an invalid file is dragged over. */} <Dropzone.Reject> <Stack justify="center" align="center"> <Icon icon={'tabler:x'} fontSize={50} /> <Text>{rejectDescriptions[type]}</Text> </Stack> </Dropzone.Reject> </> )} {/* END: MODIFIED */} </Dropzone> ) } export default Upload
```

# src/components/Broadcast/Input/Message/useInputMessage.ts

```ts
import { Message } from '@/constants' import db from '@/libs/db' import { useForm } from '@mantine/form' import _ from 'lodash' const defaultValues = { type: Message.TEXT, inputText: '', inputImage: { file: null, caption: '', }, inputVideo: { file: null, caption: '', }, inputAudio: { file: null, isPtt: false, caption: '', }, inputFile: { file: null, caption: '', }, inputLocation: { lat: '', lng: '', name: '', address: '', url: '', }, inputPoll: { name: '', choices: ['Choice 1'], }, // ++ MODIFIED: Default value is an empty array for storing selected contacts inputVCard: { contacts: [], }, } const useInputMessage = () => { const form = useForm({ initialValues: defaultValues, validate: { inputText: (value, parent) => { if (parent.type === Message.TEXT && _.isEmpty(value)) { return 'Required' } return null }, inputImage: { file: (value, parent) => { if (parent.type === Message.IMAGE && !value) { return 'Required' } return null }, }, inputVideo: { file: (value, parent) => { if (parent.type === Message.VIDEO && !value) { return 'Required' } return null }, }, inputAudio: { file: (value, parent) => { if (parent.type === Message.AUDIO && !value) { return 'Required' } return null }, }, inputFile: { file: (value, parent) => { if (parent.type === Message.FILE && !value) { return 'Required' } return null }, }, inputLocation: { lat: (value, parent) => { if (parent.type === Message.LOCATION && _.isEmpty(value)) { return 'Required' } return null }, lng: (value, parent) => { if (parent.type === Message.LOCATION && _.isEmpty(value)) { return 'Required' } return null }, }, // ++ ADDED: Validation rule for VCard message type inputVCard: { contacts: (value, parent) => { if (parent.type === Message.VCARD && (!value || value.length === 0)) { return 'At least one contact must be selected.' } return null }, }, }, }) const getMessage = () => { const { type, inputText, inputImage, inputVideo, inputFile, inputLocation, inputPoll, inputVCard, } = form.values const messages = { [Message.TEXT]: inputText, [Message.IMAGE]: { caption: inputImage.caption, }, [Message.VIDEO]: { caption: inputVideo.caption, }, [Message.FILE]: inputFile.caption, [Message.LOCATION]: { lat: inputLocation.lat, lng: inputLocation.lng, name: inputLocation.name, address: inputLocation.address, url: inputLocation.url, }, [Message.VCARD]: inputVCard.contacts, [Message.POLL]: { name: inputPoll.name, choices: inputPoll.choices, }, } return messages[type] ?? inputText } const insertBroadcastFile = async ( parentId: number, broadcastFileType: string, ) => { const { type, inputImage, inputVideo, inputAudio, inputFile } = form.values const inputTypes = { [Message.IMAGE]: inputImage.file, [Message.VIDEO]: inputVideo.file, [Message.AUDIO]: inputAudio.file, [Message.FILE]: inputFile.file, } const file = inputTypes[type] as File await db.media.add({ parentId, type: broadcastFileType, name: file.name, file, ext: file.type, }) } return { form, getMessage, insertBroadcastFile, } } export default useInputMessage
```

# src/components/Broadcast/Template/ModalCreateUpdateTemplate.tsx

```tsx
// src/components/Modal/ModalCreateUpdateTemplate.tsx import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import db, { type BroadcastTemplate } from '@/libs/db' import { formHasErrors, isTypeMessageMedia } from '@/utils/util' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect } from 'react' import InputMessage from '../Input/Message/InputMessage' import useInputMessage from '../Input/Message/useInputMessage' interface Props { opened: boolean onClose: () => void data?: Partial<BroadcastTemplate> | null } const ModalCreateUpdateTemplate: React.FC<Props> = ({ opened, onClose, data = null, }: Props) => { const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => (_.isEmpty(value) ? 'Required' : null), }, }) // The useEffect hook for populating the form based on `data` prop. // This logic is complex and specific to this component, so it remains here. useEffect(() => { if (opened) { if (data) { form.setValues({ name: data.name }) const messageData = data.message as any const type = data.type inputMessageForm.reset() inputMessageForm.setFieldValue('type', type) switch (type) { case Message.TEXT: inputMessageForm.setFieldValue('inputText', messageData as string) break case Message.IMAGE: inputMessageForm.setFieldValue( 'inputImage.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputImage.file', null) break case Message.VIDEO: inputMessageForm.setFieldValue( 'inputVideo.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputVideo.file', null) break case Message.FILE: inputMessageForm.setFieldValue( 'inputFile.caption', messageData as string, ) inputMessageForm.setFieldValue('inputFile.file', null) break case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', messageData) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', messageData) break default: if (typeof messageData === 'string' && !isTypeMessageMedia(type)) { inputMessageForm.setFieldValue('inputText', messageData) } break } } else { form.reset() inputMessageForm.reset() } } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, opened]) // --- START REFACTOR --- // Separated logic for creating a new template. const handleCreate = async () => { const { type } = inputMessageForm.values const { name } = form.values const templateId = await db.broadcastTemplates.add({ name, type, message: getMessage(), }) if (isTypeMessageMedia(type)) { if (typeof templateId === 'number') { await insertBroadcastFile(templateId, Media.BROADCAST_TEMPLATE) } else { console.error('Failed to get templateId as number for media upload') } } } // Separated logic for updating an existing template. const handleUpdate = async () => { if (!data?.id) return const { type } = inputMessageForm.values const { name } = form.values const messagePayload = getMessage() await db.broadcastTemplates.update(data.id, { name, type, message: messagePayload, }) const newFileIsSelected = (type === Message.IMAGE && inputMessageForm.values.inputImage.file) || (type === Message.VIDEO && inputMessageForm.values.inputVideo.file) || (type === Message.FILE && inputMessageForm.values.inputFile.file) if (isTypeMessageMedia(type)) { if (newFileIsSelected) { // If a new file is selected, delete old media and add the new one await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() await insertBroadcastFile(data.id, Media.BROADCAST_TEMPLATE) } // If no new file is selected, and type is still media, existing media is preserved. } else if (isTypeMessageMedia(data.type) && !isTypeMessageMedia(type)) { // If type changed from media to non-media, delete old media. await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() } } // The main submit handler now decides which function to call. const handleSubmit = async () => { if (formHasErrors(form, inputMessageForm)) return if (data && data.id !== undefined) { await handleUpdate() } else { await handleCreate() } onClose() } // --- END REFACTOR --- const handleClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleClose} w={750} withCloseButton> <Stack justify="space-between"> <Stack> <Center> <Title order={3}>{data?.id ? 'Edit' : 'Create'} Template</Title> </Center> <TextInput label="Name" required {...form.getInputProps('name')} /> <InputMessage disabledTemplateButton form={inputMessageForm} /> </Stack> <Group align="end" justify="end"> <Button onClick={handleSubmit}>Submit</Button> </Group> </Stack> </Modal> ) } export default ModalCreateUpdateTemplate
```

# src/components/Broadcast/Template/ModalManageTemplate.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import useDataQuery from '@/hooks/useDataQuery' import useLicense from '@/hooks/useLicense' import type { BroadcastTemplate } from '@/libs/db' import db from '@/libs/db' import { showModalPricing, showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Stack, TextInput, Title, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import MessageType from '../Datatable/MessageType' import ModalCreateUpdateTemplate from './ModalCreateUpdateTemplate' interface Props { opened: boolean onClose: () => void } const ModalManageTemplate: React.FC<Props> = ({ opened, onClose }) => { const license = useLicense() const dataQuery = useDataQuery<BroadcastTemplate>({ table: db.broadcastTemplates, }) // MODIFIED: Allow state to hold a partial template object for cloning const [editingTemplate, setEditingTemplate] = useState<Partial<BroadcastTemplate> | null>(null) const [showModalCreateUpdate, modalCreateUpdate] = useDisclosure(false) const handleDelete = async (template: BroadcastTemplate) => { if (!confirm('Are you sure you want to delete this template?')) return // First, delete any associated media to prevent orphaned data. await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: template.id }) .delete() // After associated media is deleted, delete the template itself. await db.broadcastTemplates.delete(template.id) } const handleEdit = (template: BroadcastTemplate) => { setEditingTemplate(template) modalCreateUpdate.open() } // ADDED: Handler for cloning a template. const handleClone = (template: BroadcastTemplate) => { // Create a new template object for cloning, omitting the id // and appending "(Copy)" to the name. This ensures it's treated as a new entry. const { id, ...restOfTemplate } = template const clonedTemplate = { ...restOfTemplate, name: `${template.name} (Copy)`, } setEditingTemplate(clonedTemplate) modalCreateUpdate.open() } const handleOpenCreateModal = () => { if (license.isFree() && dataQuery.totalRecords >= 1) { showModalUpgrade( 'Unlimited Templates', 'The free version is limited to 1 template. Upgrade to Pro to save unlimited message templates.', ) return } setEditingTemplate(null) modalCreateUpdate.open() } const renderMessage = (broadcastTemplate: BroadcastTemplate) => { const { message } = broadcastTemplate if (!message) return '-' const typeContent = { [Message.TEXT]: typeof message === 'string' ? message : JSON.stringify(message), [Message.MEDIA]: message.caption, [Message.IMAGE]: message.caption, [Message.VIDEO]: message.caption, [Message.FILE]: typeof message === 'string' ? message : message.caption, [Message.BUTTON]: message.title, [Message.LIST]: message.title, [Message.LOCATION]: message.name, [Message.POLL]: message.name, [Message.VCARD]: '-', } return typeContent[broadcastTemplate.type] || JSON.stringify(message) } return ( <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack> <Center> <Title order={3}>Manage Templates</Title> </Center> <Stack gap={0} p={'md'}> <Group justify="space-between"> <TextInput placeholder={`Search by ${dataQuery.searchField}...`} size="sm" value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} /> <Button size="xs" leftSection={<Icon icon="tabler:plus" fontSize={20} />} onClick={handleOpenCreateModal} > {' '} Add{' '} </Button> </Group> <DataTable records={dataQuery?.data} totalRecords={dataQuery?.totalRecords} recordsPerPage={dataQuery?.pageSize} page={dataQuery?.page} onPageChange={dataQuery?.setPage} columns={[ { accessor: 'name' }, { accessor: 'type', render: (record) => <MessageType type={record.type} />, }, { accessor: 'message', title: 'Message', render: renderMessage, }, { accessor: 'actions', title: '', textAlign: 'right', render: (template: BroadcastTemplate) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Edit Template" position="top"> <ActionIcon color="blue" variant="subtle" onClick={() => handleEdit(template)} > <Icon icon="tabler:edit" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Clone Template" position="top"> <ActionIcon color="teal" variant="subtle" onClick={() => handleClone(template)} > <Icon icon="tabler:copy" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Delete Template" position="top"> <ActionIcon color="red" variant="subtle" onClick={async () => await handleDelete(template)} > <Icon icon="tabler:trash" fontSize={22} /> </ActionIcon> </Tooltip> </Group> ), }, ]} /> </Stack> <ModalCreateUpdateTemplate opened={showModalCreateUpdate} onClose={() => { modalCreateUpdate.close() setEditingTemplate(null) }} data={editingTemplate} /> </Stack> </Modal> ) } export default ModalManageTemplate
```

# src/components/Input/InputSelectGroup.tsx

```tsx
// src/components/Input/InputSelectGroup.tsx import { useAppStore } from '@/stores/app' import { Avatar, Group, MultiSelect, Text } from '@mantine/core' import React, { useMemo } from 'react' interface Props { value: string[] onChange: (value: string[]) => void disabled?: boolean filter?: (group: any) => boolean } const InputSelectGroup: React.FC<Props> = ({ value, onChange, disabled, filter, }) => { const { groups } = useAppStore() const groupOptions = useMemo(() => { const filteredGroups = filter ? groups?.filter(filter) : groups return ( filteredGroups?.map((group: any) => ({ label: `${group.name} (${group.participants.length})`, value: group.id, avatar: group.avatar, })) || [] ) }, [groups, filter]) const renderSelectOption = ({ option, }: { option: any & { avatar: string } }) => ( <Group> <Avatar src={option.avatar} radius="xl" /> <Text>{option.label}</Text> </Group> ) return ( <MultiSelect label="Select Group(s)" placeholder="Choose one or more groups from the list" data={groupOptions} value={value} onChange={onChange} disabled={disabled || (groups && groups.length === 0)} searchable nothingFoundMessage="No groups found" renderOption={renderSelectOption} clearable /> ) } export default InputSelectGroup
```

# src/components/Layout/LayoutPage.module.css

```css
.header { border-bottom: 1px solid var(--mantine-color-gray-3); } .footer { border-top: 2px solid var(--mantine-color-gray-3); }
```

# src/components/Layout/LayoutPage.tsx

```tsx
// src/components/Layout/LayoutPage.tsx import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import env from '@/utils/env' import { goToResourcePage, showModalPricing } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Center, Group, Loader, ScrollArea, Stack, Text, Title, type MantineSpacing, type StyleProp, } from '@mantine/core' import icon from 'data-base64:../../../assets/icon.png' import { When } from 'react-if' import packageJson from '../../../package.json' import classes from './LayoutPage.module.css' interface Props { width?: StyleProp<React.CSSProperties['width']> | null height?: StyleProp<React.CSSProperties['height']> | null p?: StyleProp<MantineSpacing> title?: string | null children: React.ReactNode } const LayoutPage: React.FC<Props> = ({ width = 900, height = 620, p = 'xl', children, title = null, }: Props) => { const wa = useWa() const license = useLicense() const renderBody = () => { return ( <Stack p={'xl'} w={width}> {children} </Stack> ) } return ( <> <Stack w={width} gap={0}> <Group justify="space-between" px={'lg'} py={'xs'} className={classes.header} > <Group gap={6}> <img width={32} height={32} src={icon} style={{ borderRadius: 10, }} /> <Title order={4} ml={2}> {title ? title : packageJson.displayName} </Title> <When condition={license.isPro() && env.isProduction()}> <Button radius={'lg'} size="compact-sm" variant="outline" px={'sm'} > <Text fw={500}>Pro</Text> </Button> </When> </Group> <When condition={env.isDevelopment()}> <Button variant="filled" color="blue" size="xs" radius="md" onClick={goToResourcePage} > RS </Button> </When> <When condition={license.isFree() ?? true}> <Button variant="filled" color="yellow" size="xs" radius="md" leftSection={<Icon icon="tabler:crown" fontSize={16} />} onClick={showModalPricing} > Upgrade Now </Button> </When> </Group> {wa.isReady ? ( <ScrollArea h={height}>{renderBody()}</ScrollArea> ) : ( <Center h={height}> <Loader /> </Center> )} </Stack> </> ) } export default LayoutPage
```

# src/components/Modal/Modal.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Card, Paper, type MantineSpacing, type StyleProp, } from '@mantine/core' import React, { type CSSProperties } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void height?: string | number width?: string | number style?: CSSProperties withCloseButton?: boolean | false h?: StyleProp<React.CSSProperties['height']> w?: StyleProp<React.CSSProperties['width']> p?: StyleProp<MantineSpacing> children: React.ReactNode } const Modal: React.FC<Props> = ({ opened, onClose, style = {}, withCloseButton = false, p = 'lg', h, w, children, ...rest }: Props) => { if (!opened) return null return ( <> <div style={{ position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, zIndex: 399, width: '100%', height: '100%', backgroundColor: 'black', opacity: '0.15', }} onClick={onClose} ></div> <Box style={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 1050, ...style, }} {...rest} > <Card shadow={'xs'} p={p} w={w} h={h} radius={'md'}> <When condition={withCloseButton}> <ActionIcon onClick={onClose} color="red" variant="transparent" style={{ position: 'absolute', right: 3, top: 1, }} > <Icon icon="tabler:x" fontSize={16} /> </ActionIcon> <Box mb={'md'} /> </When> {children} </Card> </Box> </> ) } export default Modal
```

# src/components/Modal/ModalActivation.tsx

```tsx
// src/components/Modal/ModalActivation.tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, rem, Stack, Text, TextInput, ThemeIcon, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalActivation: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const form = useForm({ initialValues: defaultValues, validate: { license: (value) => _.isEmpty(value) ? 'A license key is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) const handleOnClose = () => { form.reset() onClose() } const handleSubmit = async () => { const { hasErrors } = form.validate() if (hasErrors) { return } setLoading(true) form.clearErrors() try { const response = await license.activate(form.values.license) if (response.data.error) { form.setFieldError('license', response.data.error.replace(/_/g, ' ')) setLoading(false) return } if (response.data.meta.store_id.toString() !== getStoreId()) { form.setFieldError( 'license', 'This license key is not valid for this product.', ) setLoading(false) return } toast.success('Successfully activated! ') handleOnClose() } catch (err) { console.error('Activation error:', err) form.setFieldError( 'license', 'An unexpected error occurred. Please try again.', ) } finally { setLoading(false) } } return ( <Modal opened={opened} onClose={handleOnClose} w={500} p="xl" withCloseButton > <Stack gap="lg"> <Stack align="center" gap="xs"> <ThemeIcon color="teal" size={rem(60)} radius="xl"> <Icon icon="tabler:key" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> {' '} License Activation{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Enter your license key below to unlock all Pro features.{' '} </Text> </Stack> <Stack> <TextInput label="License Key" placeholder="xxxx-xxxx-xxxx-xxxx" required leftSection={<Icon icon="tabler:key" fontSize={18} />} {...form.getInputProps('license')} /> {/* MODIFIED: Replaced text with more reassuring microcopy. */} <Text size="xs" c="dimmed"> {' '} Your license key validates your purchase, ensuring you receive lifetime access and all future updates.{' '} </Text> </Stack> <Button loading={loading} onClick={handleSubmit} fullWidth size="md" mt="md" leftSection={<Icon icon="tabler:circle-check" fontSize={20} />} > {' '} Activate License{' '} </Button> </Stack> </Modal> ) } export default ModalActivation
```

# src/components/Modal/ModalFaq.tsx

```tsx
// src/components/Modal/ModalFaq.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Accordion, Anchor, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const faqData = [ { icon: 'tabler:key', question: 'Where can I find my license key?', answer: 'You will receive an email from Lemon Squeezy after making a purchase. This email usually contains your purchase details and your license key.', }, { icon: 'tabler:shield-lock', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our priority. This extension does not collect, store, or share any personal data from your WhatsApp account. All processes occur locally on your device.', }, { icon: 'tabler:mail-question', question: 'How can I get more help and support?', answer: 'If you have other questions or need assistance, please feel free to email us at extdotninja@gmail.com. Our team will be happy to help you.', }, ] const ModalFaq: React.FC<Props> = ({ opened, onClose }: Props) => { const handleOnClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleOnClose} withCloseButton w={700}> <Stack> <Stack align="center" gap={4} mb={'xl'}> <Icon icon="tabler:world-question" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> Frequently Asked Questions </Title> </Stack> {/* Accordion */} <Accordion variant="separated" radius="md"> {faqData.map((item) => ( <Accordion.Item key={item.question} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > {/* MODIFIED: Changed the answer to markdown-like bolding for emphasis. */} <Text fw={500} dangerouslySetInnerHTML={{ __html: item.question.replace( /\*\*(.*?)\*\*/g, '<b>$1</b>', ), }} ></Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} ></Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> {/* Contact Support */} <Paper withBorder p="md" shadow="none" radius="md" mt="xl"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still have questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us via email. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Paper> </Stack> </Modal> ) } export default ModalFaq
```

# src/components/Modal/ModalPricing.tsx

```tsx
// src/components/Modal/ModalUpgrade.tsx import Modal from '@/components/Modal/Modal' import plans from '@/config/plans' import { Icon } from '@iconify/react' import { Badge, Box, Button, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const ModalPricing: React.FC<Props> = ({ opened, onClose }) => { return ( <Modal opened={opened} onClose={onClose} w={1300} withCloseButton={false}> <Stack py={'md'}> <Stack align="center" ta="center"> <Title order={1}>Simple, transparent pricing</Title> <Text size={'xl'} c="dimmed"> Choose the perfect plan for your needs. </Text> </Stack> <Group justify="center" align="stretch" mt="sm" gap="lg"> {plans.map((plan, index) => ( <Paper key={index} withBorder radius={'lg'} px={50} py={36} style={{ border: !plan.isFree ? '2px solid var(--mantine-color-teal-6)' : undefined, boxShadow: !plan.isFree ? 'var(--mantine-shadow-lg)' : 'var(--mantine-shadow-sm)', position: 'relative', }} > <Stack justify="space-between" style={{ height: '100%' }}> <Box ta="center"> <Title order={2}>{plan.name}</Title> <Text mt={4} size="sm"> {' '} {plan.description}{' '} </Text> </Box> <Group gap={8} align={'baseline'} justify="center"> {!plan.isFree && plan.placeholderPrice && ( <Text component="span" c="dimmed" fz="xl" fw={500} td="line-through" > {plan.placeholderPrice} </Text> )} <Title order={1} fz={52}> {' '} {plan.price}{' '} </Title> {plan.priceSuffix && ( <Text component="span" c="dimmed" fz="xl" fw={500}> {plan.priceSuffix} </Text> )} </Group> <Stack gap="sm"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="sm" align="flex-start"> <ThemeIcon variant="transparent" color={plan.isFree ? 'gray' : 'teal'} size="sm" radius="xl" > {plan.isFree ? ( <Icon icon="tabler:circle-check" fontSize={16} /> ) : ( <Icon icon="tabler:star-filled" fontSize={16} color="orange" /> )} </ThemeIcon> <Text size="sm" fw={500}> {feature} </Text> </Group> ))} </Stack> <Box mt="md"> {plan.isFree ? ( <Button size="md" variant="default" fullWidth disabled> {' '} Your Current Plan{' '} </Button> ) : ( <Stack gap="xs"> <Button size="lg" component="a" href={plan.link} target="_blank" fullWidth leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Upgrade now </Button> </Stack> )} </Box> </Stack> </Paper> ))} </Group> <Stack gap={4} align="center" mt="md"> <Group justify="center" gap={6}> <Icon icon="tabler:lock" fontSize={16} color="var(--mantine-color-gray-6)" /> <Text size="sm" c="dimmed" fw={500}> 100% Secure Payment via Lemon Squeezy </Text> </Group> </Stack> </Stack> </Modal> ) } export default ModalPricing
```

# src/components/Modal/ModalProfile.tsx

```tsx
// src/features/profile/PageProfile.tsx import { Setting } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import { showModalActivation, showModalPricing } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' import packageJson from '../../../package.json' import Modal from './Modal' interface Props { opened: boolean onClose: () => void } const ModalProfile: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const { profile, license: licenseData } = useAppStore() const [licenseKey] = useStorage(Setting.LICENSE_KEY) const handleDeactivate = async () => { if ( confirm( 'Are you sure you want to deactivate your license on this device?', ) ) { await license.deactivate() } } const handleUpgrade = () => { showModalPricing() } const handleActivate = () => { showModalActivation() } const maskLicenseKey = (key: string | undefined | null) => { if (!key) return 'N/A' const keyParts = key.split('-') if (keyParts.length > 1) { return `****-****-****-${keyParts[keyParts.length - 1]}` } return '****' + key.slice(-4) } const InfoItem = ({ icon, label, value, }: { icon: string label: string value: React.ReactNode }) => ( <Group wrap="nowrap" gap="lg"> <ThemeIcon variant="light" size={36} radius="md"> <Icon icon={icon} fontSize={20} /> </ThemeIcon> <div> <Text size="xs" c="dimmed"> {label} </Text> <Text size="sm" fw={500}> {value || '-'} </Text> </div> </Group> ) return ( <Modal opened={opened} onClose={onClose} withCloseButton w={700}> <Stack> {/* Account Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Title order={5}>Account Details</Title> <Divider /> <InfoItem icon="tabler:info-circle" label="App Version" value={packageJson.version} /> </Stack> </Card> {/* License Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>License Status</Title> <Badge color={license.isPro() ? 'teal' : 'gray'} size="lg" variant="filled" > {license.isPro() ? 'Pro' : 'Free'} </Badge> </Group> <Divider /> <When condition={license.isPro()}> <Stack my="xs" gap="sm"> <InfoItem icon="tabler:user" label="Licensed To" value={licenseData?.meta.customer_name} /> <InfoItem icon="tabler:mail" label="Email" value={licenseData?.meta.customer_email} /> <InfoItem icon="tabler:key" label="License Key" value={maskLicenseKey(licenseKey)} /> <InfoItem icon="tabler:calendar-event" label="Expires On" value={ licenseData?.license_key.expires_at ? dayjs(licenseData.license_key.expires_at).format( 'DD MMMM YYYY', ) : 'Lifetime' } /> </Stack> </When> <Text size="sm" c="dimmed"> {license.isPro() ? 'Thank you for being a Pro user! You have access to all features.' : 'Upgrade to Pro to unlock all features.'} </Text> <Group justify="flex-end" mt="md"> <When condition={license.isFree()}> <Button onClick={handleUpgrade} color="teal" leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Pro </Button> <Button onClick={handleActivate} variant="outline" leftSection={<Icon icon="tabler:key" fontSize={18} />} > Activate License </Button> </When> <When condition={license.isPro()}> <Button onClick={license.goToMyOrders} variant="outline" leftSection={<Icon icon="tabler:credit-card" fontSize={18} />} > Manage Subscription </Button> <Button onClick={handleDeactivate} color="red" variant="light" leftSection={<Icon icon="tabler:key-off" fontSize={18} />} > Deactivate License </Button> </When> </Group> </Stack> </Card> <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>Data Privacy Guarantee</Title> <ThemeIcon variant="light" color="teal"> <Icon icon="tabler:shield-check" fontSize={20} /> </ThemeIcon> </Group> <Divider /> <Text size="sm" c="dimmed"> All your data is stored only on your computer and is never sent to our servers. You have 100% control over your data. </Text> </Stack> </Card> </Stack> </Modal> ) } export default ModalProfile
```

# src/components/Modal/ModalQRCode.tsx

```tsx
// src/components/Modal/ModalQRCode.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Center, Stack, Title } from '@mantine/core' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import { QRCodeCanvas } from 'qrcode.react' import React, { useRef } from 'react' interface Props { opened: boolean onClose: () => void link: string groupName: string } /** * @component ModalQRCode * @description A modal to display and download a QR code for a given link. */ const ModalQRCode: React.FC<Props> = ({ opened, onClose, link, groupName }) => { const qrCodeRef = useRef<HTMLDivElement>(null) /** * @description Generates a canvas from the QR code element and triggers a download. */ const handleDownload = async () => { if (!qrCodeRef.current) return try { const canvas = await html2canvas(qrCodeRef.current, { scale: 4, // Higher scale for better resolution backgroundColor: 'white', }) canvas.toBlob((blob) => { if (blob) { // Sanitize the group name to create a safe filename const safeFilename = groupName .replace(/[^a-z0-9]/gi, '_') .toLowerCase() FileSaver.saveAs(blob, `whatsapp_group_qr_${safeFilename}.png`) } }) } catch (error) { console.error('Failed to generate QR code image:', error) } } if (!link) return null return ( <Modal opened={opened} onClose={onClose} withCloseButton w={400}> <Stack align="center" p="md"> <Title order={4} ta="center"> QR Code for "{groupName}" </Title> <Center p="md" mt="md" style={{ border: '1px solid var(--mantine-color-gray-3)', borderRadius: 'var(--mantine-radius-md)', }} > <div ref={qrCodeRef} style={{ background: 'white', padding: '16px' }}> <QRCodeCanvas value={link} size={200} level="H" /> </div> </Center> <Button mt="lg" onClick={handleDownload} leftSection={<Icon icon="tabler:download" fontSize={18} />} > Download Image </Button> </Stack> </Modal> ) } export default ModalQRCode
```

# src/components/Modal/ModalUpgrade.tsx

```tsx
// src/components/Modal/ModalUpgrade.tsx import Modal from '@/components/Modal/Modal' import { showModalPricing } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Group, rem, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void featureName: string featureBenefit: string } /** * English: A modal to inform free users about a Pro feature they've tried to access. * It provides context about the feature's benefits and offers a clear path to upgrade. */ const ModalUpgrade: React.FC<Props> = ({ opened, onClose, featureName, featureBenefit, }) => { const handleUpgrade = () => { showModalPricing() onClose() } return ( <Modal opened={opened} onClose={onClose} w={500} p="xl" withCloseButton> <Stack gap="lg" align="center"> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} size={rem(60)} radius="xl" > <Icon icon="tabler:rocket" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> Unlock: {featureName} </Title> <Text c="dimmed" size="sm" ta="center"> {featureBenefit} </Text> <Text size="sm" ta="center" fw={500}> Upgrade to Pro to unlock this feature and many more! </Text> <Stack align="center" gap="xs" mt="md" w="100%"> <Group justify="center" style={{ width: '100%' }}> <Button variant="outline" onClick={onClose}> Maybe Later </Button> <Button onClick={handleUpgrade} leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > Upgrade Now </Button> </Group> </Stack> </Stack> </Modal> ) } export default ModalUpgrade
```

# src/components/Promo/PromoIcon.tsx

```tsx
// English: A simple, professional icon wrapper for branding. // This component is reusable for generating different icon sizes and types. import { Icon } from '@iconify/react' import { ThemeIcon } from '@mantine/core' import React from 'react' interface Props { size: number icon: string } const PromoIcon: React.FC<Props> = ({ size, icon }) => { return ( <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius={100} size={size} > {/* Use the Icon component for dynamic icon rendering */} <Icon icon={icon} style={{ width: '70%', height: '70%', color: 'white' }} /> </ThemeIcon> ) } export default PromoIcon
```

# src/components/Promo/ScreenshotWrapper.tsx

```tsx
// src/components/Promo/ScreenshotWrapper.tsx // English: A reusable wrapper to handle screenshot generation and download logic. // It takes a title, a child component to render, and a filename. import { Icon } from '@iconify/react' import { Button, Card, Group, Stack, Text, Title } from '@mantine/core' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import React, { useRef, useState } from 'react' interface Props { title: string filename: string children: React.ReactNode } const ScreenshotWrapper: React.FC<Props> = ({ title, filename, children }) => { const screenshotRef = useRef<HTMLDivElement>(null) const [isLoading, setIsLoading] = useState(false) const handleDownload = async () => { if (!screenshotRef.current) return setIsLoading(true) try { const canvas = await html2canvas(screenshotRef.current, { scale: 2, // Higher scale for better resolution useCORS: true, // Use component's own background and handle transparency correctly. backgroundColor: null, }) canvas.toBlob((blob) => { if (blob) { FileSaver.saveAs(blob, filename) } }) } catch (error) { console.error('Failed to generate screenshot:', error) } finally { setIsLoading(false) } } return ( <Card withBorder radius="md"> <Stack> <Group justify="space-between"> <Title order={4}>{title}</Title> <Button size="xs" variant="light" onClick={handleDownload} loading={isLoading} leftSection={<Icon icon="tabler:download" fontSize={16} />} > Download </Button> </Group> <div ref={screenshotRef} style={{ alignSelf: 'flex-start', }} > {children} </div> </Stack> </Card> ) } export default ScreenshotWrapper
```

# src/components/Toast/Toast.module.css

```css
@keyframes fadeIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .toast { animation: fadeIn 0.3s ease-out forwards; }
```

# src/components/Toast/Toast.tsx

```tsx
import { type Toast } from '@/stores/toast' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Text, ThemeIcon } from '@mantine/core' import { useEffect } from 'react' import classes from './Toast.module.css' interface ToastProps extends Toast { onClose: () => void } const ToastComponent: React.FC<ToastProps> = ({ id, type, title, message, duration = 2000, onClose, }) => { useEffect(() => { const timer = setTimeout(() => { onClose() }, duration) return () => clearTimeout(timer) }, [id, duration, onClose]) const toastConfig = { success: { icon: 'tabler:check', color: 'teal' }, error: { icon: 'tabler:x', color: 'red' }, info: { icon: 'tabler:info-circle', color: 'blue' }, // ADDED: Configuration for the new 'warning' type. warning: { icon: 'tabler:alert-triangle', color: 'orange' }, } const { icon, color } = toastConfig[type] return ( <Paper shadow="lg" p="sm" radius="md" withBorder className={classes.toast} style={{ minWidth: 350, maxWidth: 400 }} > <Group align="flex-start" wrap="nowrap"> <ThemeIcon color={color} size={36} radius="xl" mt={4}> <Icon icon={icon} fontSize={22} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Text fw={600} size="md"> {title} </Text> <Text size="sm" c="dimmed"> {message} </Text> </Stack> <ActionIcon variant="transparent" color="gray" onClick={onClose}> <Icon icon="tabler:x" /> </ActionIcon> </Group> </Paper> ) } export default ToastComponent
```

# src/components/Toast/ToastProvider.tsx

```tsx
import { useToastStore } from '@/stores/toast' import { Box } from '@mantine/core' import React from 'react' import ToastComponent from './Toast' const ToastProvider: React.FC = () => { const { toasts, removeToast } = useToastStore() return ( <Box style={{ position: 'fixed', top: 20, right: 20, zIndex: 2000, display: 'flex', flexDirection: 'column', gap: '10px', }} > {toasts.map((toast) => ( <ToastComponent key={toast.id} id={toast.id} type={toast.type} title={toast.title} message={toast.message} duration={toast.duration} onClose={() => removeToast(toast.id)} /> ))} </Box> ) } export default ToastProvider
```

# src/config/plans.ts

```ts
// src/config/plans.ts // English: Define a structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // English: Centralized list of features for easy management and comparison export const features: PlanFeature[] = [ { feature: 'Message Backups', free: 'Up to 10 messages', pro: 'Unlimited', }, { feature: 'Backup Media (Images, Videos, Docs)', free: false, pro: true, }, { feature: 'Advanced Date Range Filtering', free: 'Last 7 days only', pro: true, }, { feature: 'Multiple Keyword Filtering', free: '1 keyword', // MODIFIED: Changed from `false` to specify the limit. pro: 'Unlimited', // MODIFIED: Changed from `true` to be more descriptive. }, { feature: 'Export to Multiple Formats', free: 'HTML only', pro: 'PDF, CSV, Excel, JSON, TXT', }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, ] // English: Define plan objects for the pricing cards. // This array structure allows for easy side-by-side comparison in the UI. const plans = [ { name: 'Free', isFree: true, description: 'For basic direct messaging needs.', price: '$0', priceSuffix: null, // <-- priceSuffix ditambahkan di sini link: '#', features: [ 'Revoke Links', 'Max 2 Groups', 'Last 5 Links Generation History', 'Standard Support', ], }, { name: 'Per Day', isFree: false, description: 'Ideal for testing.', placeholderPrice: null, price: '$5', priceSuffix: '/Day', link: 'https://extdotninja.lemonsqueezy.com/buy/49bf5c46-9e9b-465b-add0-10bc5903ad69?logo=0', features: [ 'Revoke Links', 'Unlimited Groups', 'Generate & Download QR Codes ', 'Export to CSV/Excel', 'Unlimited Links Generation History', 'Priority Support', ], }, { name: 'Lifetime', isFree: false, description: 'Pay once, access all features forever.', placeholderPrice: '$89', price: '$27', priceSuffix: 'one-time', link: 'https://extdotninja.lemonsqueezy.com/buy/4425cfd5-045c-4b39-ad48-35966feca009?logo=0', features: [ 'Revoke Links', 'Multiple Groups', 'Generate & Download QR Codes ', 'Export to CSV/Excel', 'Unlimited Links Generation History', 'Priority Support', ], }, ] export default plans
```

# src/constants/action.ts

```ts
export const App = { HTTP: 'App.HTPP', AI: 'App.AI', } export const Blocklist = { ALL: 'Blocklist.ALL', BLOCK_CONTACT: 'Blocklist.BLOCK_CONTACT', IS_BLOCKED: 'Blocklist.IS_BLOCKED', UNBLOCK_CONTACT: 'Blocklist.UNBLOCK_CONTACT', } export const Cart = { ADD: 'Cart.ADD', CLEAR: 'Cart.CLEAR', GET: 'Cart.GET', GET_THUMB_FROM_CART: 'Cart.GET_THUMB_FROM_CART', REMOVE: 'Cart.REMOVE', SUBMIT: 'Cart.SUBMIT', UPDATE: 'Cart.UPDATE', } export const Catalog = { ADD_PRODUCT_IMAGE: 'Catalog.ADD_PRODUCT_IMAGE', CHANGE_PRODUCT_IMAGE: 'Catalog.CHANGE_PRODUCT_IMAGE', CREATE_COLLECTION: 'Catalog.CREATE_COLLECTION', CREATE_PRODUCT: 'Catalog.CREATE_PRODUCT', DELETE_COLLECTION: 'Catalog.DELETE_COLLECTION', DELETE_PRODUCT: 'Catalog.DELETE_PRODUCT', EDIT_COLLECTION: 'Catalog.EDIT_COLLECTION', EDIT_PRODUCT: 'Catalog.EDIT_PRODUCT', GET_COLLECTIONS: 'Catalog.GET_COLLECTIONS', GET_MY_CATALOG: 'Catalog.GET_MY_CATALOG', GET_PRODUCT_BY_ID: 'Catalog.GET_PRODUCT_BY_ID', GET_PRODUCTS: 'Catalog.GET_PRODUCTS', REMOVE_PRODUCT_IMAGE: 'Catalog.REMOVE_PRODUCT_IMAGE', SET_PRODUCT_VISIBILITY: 'Catalog.SET_PRODUCT_VISIBILITY', UPDAGE_CART_ENABLED: 'Catalog.UPDAGE_CART_ENABLED', } export const Community = { ADD_SUB_GROUPS: 'Community.ADD_SUB_GROUPS', } export const Chat = { ARCHIVE: 'Chat.ARCHIVE', CAN_MARK_PLAYED: 'Chat.CAN_MARK_PLAYED', CAN_MUTE: 'Chat.CAN_MUTE', CAN_REPLY: 'Chat.CAN_REPLY', CLEAR: 'Chat.CLEAR', CLOSE_CHAT: 'Chat.CLOSE_CHAT', DELETE: 'Chat.DELETE', DELETE_MESSAGE: 'Chat.DELETE_MESSAGE', DOWNLOAD_MEDIA: 'Chat.DOWNLOAD_MEDIA', // ++ ADDED FIND: 'Chat.FIND', FORWARD_MESSAGE: 'Chat.FORWARD_MESSAGE', GET: 'Chat.GET', GET_ACTIVE_CHAT: 'Chat.GET_ACTIVE_CHAT', GET_LAST_SEEN: 'Chat.GET_LAST_SEEN', GET_MESSAGE_ACK: 'Chat.GET_MESSAGE_ACK', GET_MESSAGES: 'Chat.GET_MESSAGES', GET_NOTES: 'Chat.GET_NOTES', GET_PLATFORM_MESSAGE: 'Chat.GET_PLATFORM_MESSAGE', MARK_IS_COMPOSING: 'Chat.MARK_IS_COMPOSING', MARK_IS_PAUSED: 'Chat.MARK_IS_PAUSED', MARK_IS_READ: 'Chat.MARK_IS_READ', MARK_IS_RECORDING: 'Chat.MARK_IS_RECORDING', MARK_IS_UNREAD: 'Chat.MARK_IS_UNREAD', MARK_PLAYED: 'Chat.MARK_PLAYED', MUTE: 'Chat.MUTE', OPEN_CHAT_AT: 'Chat.OPEN_CHAT_AT', OPEN_CHAT_BOTTOM: 'Chat.OPEN_CHAT_BOTTOM', OPEN_CHAT_FROM_UNREAD: 'Chat.OPEN_CHAT_FROM_UNREAD', PIN_MSG: 'Chat.PIN_MSG', LIST: 'Chat.LIST', SET_CHAT_LIST: 'Chat.SET_CHAT_LIST', SET_INPUT_TEXT: 'Chat.SET_INPUT_TEXT', SET_NOTES: 'Chat.SET_NOTES', } export const Contact = { GET: 'Contact.GET', GET_BUSINESS_PROFILE: 'Contact.GET_BUSINESS_PROFILE', GET_COMMON_GROUPS: 'Contact.GET_COMMON_GROUPS', GET_PROFILE_PICTURE_URL: 'Contact.GET_PROFILE_PICTURE_URL', GET_STATUS: 'Contact.GET_STATUS', LIST: 'Contact.LIST', LIST_CONTACT_BY_COUNTRY: 'Contact.LIST_CONTACT_BY_COUNTRY', IS_EXIST: 'Contact.IS_EXIST', REMOVE: 'Contact.REMOVE', } export const Conn = { GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER: 'Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER', GET_AUTH_CODE: 'Conn.GET_AUTH_CODE', GET_PROFILE: 'Conn.GET_PROFILE', GET_MY_USER_ID: 'Conn.GET_MY_USER_ID', } export const Group = { ADD_PARTICIPANTS: 'Group.ADD_PARTICIPANTS', APPROVE: 'Group.APPROVE', LIST: 'Group.LIST', CAN_ADD: 'Group.CAN_ADD', CAN_DEMOTE: 'Group.CAN_DEMOTE', CAN_PROMOTE: 'Group.CAN_PROMOTE', CAN_REMOVE: 'Group.CAN_REMOVE', CREATE: 'Group.CREATE', DEMOTE_PARTICIPANTS: 'Group.DEMOTE_PARTICIPANTS', GET_GROUP_INFO_FROM_INVITE_CODE: 'Group.GET_GROUP_INFO_FROM_INVITE_CODE', GET_GROUP_SIZE_LIMIT: 'Group.GET_GROUP_SIZE_LIMIT', GET_INVITE_LINK: 'Group.GET_INVITE_LINK', GET_MEMBERSHIP_REQUESTS: 'Group.GET_MEMBERSHIP_REQUESTS', GET_PARTICIPANTS: 'Group.GET_PARTICIPANTS', IAM_ADMIN: 'Group.IAM_ADMIN', IAM_MEMBER: 'Group.IAM_MEMBER', IAM_RESTRICTED_MEMBER: 'Group.IAM_RESTRICTED_MEMBER', IAM_SUPER_ADMIN: 'Group.IAM_SUPER_ADMIN', JOIN: 'Group.JOIN', LEAVE: 'Group.LEAVE', PROMOTE_PARTICIPANTS: 'Group.PROMOTE_PARTICIPANTS', REJECT: 'Group.REJECT', REMOVE_ICON: 'Group.REMOVE_ICON', REMOVE_PARTICIPANTS: 'Group.REMOVE_PARTICIPANTS', REVOKE_INVITE_CODE: 'Group.REVOKE_INVITE_CODE', SET_DESCRIPTION: 'Group.SET_DESCRIPTION', SET_ICON: 'Group.SET_ICON', SET_PROPERTY: 'Group.SET_PROPERTY', SET_SUBJECT: 'Group.SET_SUBJECT', } export const Newsletter = { CREATE: 'Newsletter.CREATE', DESTROY: 'Newsletter.DESTROY', EDIT: 'Newsletter.EDIT', GET_SUBSCRIBERS: 'Newsletter.GET_SUBSCRIBERS', MUTE: 'Newsletter.MUTE', } export const Send = { TEXT: 'Send.TEXT', IMAGE: 'Send.IMAGE', LOCATION: 'Send.LOCATION', DOCUMENT: 'Send.DOCUMENT', FILE: 'Send.FILE', POLL: 'Send.POLL', VCARD: 'Send.VCARD', } export const Status = { GET: 'Status.GET', GET_MY_STATUS: 'Status.GET_MY_STATUS', REMOVE: 'Status.REMOVE', SEND_IMAGE_STATUS: 'Status.SEND_IMAGE_STATUS', SEND_READ_STATUS: 'Status.SEND_READ_STATUS', SEND_TEXT_STATUS: 'Status.SEND_TEXT_STATUS', SEND_VIDEO_STATUS: 'Status.SEND_VIDEO_STATUS', UPDATE_PARTICIPANTS: 'Status.UPDATE_PARTICIPANTS', } export const Profile = { EDIT_BUSINESS_PROFILE: 'Profile.EDIT_BUSINESS_PROFILE', GET_MY_PROFILE_NAME: 'Profile.GET_MY_PROFILE_NAME', GET_MY_PROFILE_PICTURE: 'Profile.GET_MY_PROFILE_PICTURE', GET_MY_STATUS: 'Profile.GET_MY_STATUS', IS_BUSINESS: 'Profile.IS_BUSINESS', REMOVE_MY_PROFILE_PICTURE: 'Profile.REMOVE_MY_PROFILE_PICTURE', SET_MY_PROFILE_NAME: 'Profile.SET_MY_PROFILE_NAME', SET_MY_PROFILE_PICTURE: 'Profile.SET_MY_PROFILE_PICTURE', SET_MY_STATUS: 'Profile.SET_MY_STATUS', } export const AI = { REWRITE_MESSAGE: 'AI.REWRITE_MESSAGE', } export const Window = { READY: 'Window.READY', ACTIVE_CHAT: 'Window.ACTIVE_CHAT', GO_TO_PAGE: 'Window.GO_TO_PAGE', CLOSE_PAGE: 'Window.CLOSE_PAGE', SHOW_MODAL_MAIN: 'Window.SHOW_MODAL_MAIN', SHOW_MODAL_PRICING: 'Window.SHOW_MODAL_PRICING', SHOW_MODAL_UPGRADE: 'Window.SHOW_MODAL_UPGRADE', SHOW_MODAL_ACTIVATION: 'Window.SHOW_MODAL_ACTIVATION', SHOW_MODAL_PROFILE: 'Window.SHOW_MODAL_PROFILE', SHOW_MODAL_FAQ: 'Window.SHOW_MODAL_FAQ', SEND_BROADCAST: 'Window.SEND_BROADCAST', }
```

# src/constants/index.ts

```ts
// src/constants/index.ts export * as Action from './action' export * as Setting from './setting' export const PRIMARY_ICON = 'tabler:message-2-down' export const Status = { SUCCESS: 'SUCCESS', IDLE: 'IDLE', PENDING: 'PENDING', FAILED: 'FAILED', RUNNING: 'RUNNING', SCHEDULER: 'SCHEDULER', CANCELLED: 'CANCELLED', PAUSED: 'PAUSED', DRAFT: 'DRAFT', POSTED: 'POSTED', } export const Page = { HOME: 'Page.HOME', DIRECT_CHAT: 'Page.DIRECT_CHAT', PRIVACY: 'Page.PRIVACY', EXPORT: 'Page.EXPORT', FAQ: 'Page.FAQ', UPGRADE: 'Page.UPGRADE', ACTIVATE: 'Page.ACTIVATE', PROFILE: 'Page.PROFILE', } export const Account = { BUSINESS: 'BUSINESS', PERSONAL: 'PERSONAL', } export const Message = { TEXT: 'TEXT', MEDIA: 'MEDIA', IMAGE: 'IMAGE', VIDEO: 'VIDEO', AUDIO: 'AUDIO', FILE: 'FILE', LOCATION: 'LOCATION', VCARD: 'VCARD', BUTTON: 'BUTTON', LIST: 'LIST', POLL: 'POLL', } export const Media = { BROADCAST: 'BROADCAST', BROADCAST_TEMPLATE: 'BROADCAST_TEMPLATE', STATUS_CONTENT: 'STATUS_CONTENT', QUICK_REPLY: 'QUICK_REPLY', } export const ContactType = { ALL: 'CONTACT_TYPE_ALL', SAVED_CONTACTS: 'CONTACT_TYPE_SAVED_CONTACTS', UNSAVED_CONTACTS: 'CONTACT_TYPE_UNSAVED_CONTACTS', } export const AccountType = { ALL: 'ACCOUNT_TYPE_ALL', PERSONAL: 'ACCOUNT_TYPE_PERSONAL', BUSINESS: 'ACCOUNT_TYPE_BUSINESS', } export const MessageType = { ALL: 'MESSAGE_TYPE_ALL', HAVE_UNREAD_MESSAGES: 'MESSAGE_TYPE_HAVE_UNREAD_MESSAGES', NO_UNREAD_MESSAGES: 'MESSAGE_TYPE_NO_UNREAD_MESSAGES', } export const SaveAs = { CSV: 'SAVE_AS_CSV', EXCEL: 'SAVE_AS_EXCEL', PDF: 'SAVE_AS_PDF', JSON: 'SAVE_AS_JSON', MARKDOWN: 'SAVE_AS_MARKDOWN', HTML: 'SAVE_AS_HTML', VCARD: 'SAVE_AS_VCARD', TXT: 'SAVE_AS_TXT', // ++ ADDED: New constant for TXT export }
```

# src/constants/setting.ts

```ts
export const LICENSE_KEY = 'SETTING_LICENSE_KEY' export const LICENSE_INSTANCE_ID = 'SETTING_LICENSE_INSTANCE_ID' export const LICENSE_DATA_CACHE = 'SETTING_LICENSE_DATA_CACHE' export const IS_FIRST_TIME = 'SETTING_IS_FIRST_TIME' export const NEED_TO_OPEN = 'SETTING_NEED_TO_OPEN' export const HAS_ACKNOWLEDGED_BROADCAST_WARNING = 'SETTING.HAS_ACKNOWLEDGED_BROADCAST_WARNING' export const BLUR_PROFILE_PICTURES = 'SETTING.BLUR_PROFILE_PICTURES' export const BLUR_MESSAGES = 'SETTING.BLUR_MESSAGES' export const BLUR_USER_GROUP_NAMES = 'SETTING.BLUR_USER_GROUP_NAMES' export const BLUR_RECENT_MESSAGES = 'SETTING.BLUR_RECENT_MESSAGES' export const EXPORT_COLUMNS = 'SETTING_EXPORT_COLUMNS'
```

# src/contents/inject-script.ts

```ts
import { Action } from '@/constants' import wa from '@/libs/wa' import { initInjectScriptRelays } from '@/relays' import { postMessage } from '@/utils/util' import type { PlasmoCSConfig } from 'plasmo' export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], world: 'MAIN', } initInjectScriptRelays() wa.on.ready(() => { setTimeout(() => { onReady() }, 2000) }) const onReady = () => { setTimeout(() => { window.postMessage({ action: Action.Window.READY, body: {}, }) WPP.on('chat.active_chat', (chat) => { const body = { name: chat.contact?.__x_pushname || chat.contact?.__x_verifiedName || chat.name || chat.formattedTitle, number: chat.id.user, formattedNumber: chat.id._serialized, isUser: chat.id._serialized.includes('@c.us'), isGroup: chat.id._serialized.includes('@g.us'), isBusiness: chat.contact?.__x_isBusiness, } postMessage(Action.Window.ACTIVE_CHAT, body) }) }, 1000) }
```

# src/contents/main.tsx

```tsx
import AppMenu from '@/components/AppMenu' import ToastProvider from '@/components/Toast/ToastProvider' import theme from '@/libs/theme' import style from '@/utils/style' import { MantineProvider } from '@mantine/core' import type { PlasmoCSConfig, PlasmoGetShadowHostId } from 'plasmo' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-main` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Main = () => { return ( <> <MantineProvider theme={theme} //@ts-ignore cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-main') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <AppMenu /> <ToastProvider /> </MantineProvider> </> ) } export default Main
```

# src/features/group-member-exporter/PageGroupMemberExporter.tsx

```tsx
// src/features/group-member-exporter/PageGroupMemberExporter.tsx import InputSelectGroup from '@/components/Input/InputSelectGroup' import LayoutPage from '@/components/Layout/LayoutPage' import { SaveAs } from '@/constants' import { Icon } from '@iconify/react' import { Avatar, Badge, Button, Checkbox, CopyButton, Group, Menu, Popover, SegmentedControl, Stack, Text, TextInput, // ADDED: Import TextInput for the search bar } from '@mantine/core' import { DataTable } from 'mantine-datatable' import React from 'react' import { ALL_COLUMNS, useGroupMemberExporter } from './useGroupMemberExporter' const PageGroupMemberExporter: React.FC = () => { const { isLoading, members, processedData, adminFilter, setAdminFilter, contactFilter, setContactFilter, selectedGroupIds, setSelectedGroupIds, selectedColumns, setSelectedColumns, getSelectedNumbers, handleExport, // ADDED: Get search state and handler from the hook searchQuery, setSearchQuery, } = useGroupMemberExporter() return ( <LayoutPage> <InputSelectGroup value={selectedGroupIds} onChange={setSelectedGroupIds} disabled={isLoading} /> <Stack> {/* MODIFIED: Added a search input field */} <Group justify="space-between"> <TextInput placeholder="Search by name or number..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} onChange={(e) => setSearchQuery(e.currentTarget.value)} disabled={isLoading || members.length === 0} style={{ flex: 1 }} /> <Group> <SegmentedControl disabled={isLoading || members.length === 0} value={adminFilter} onChange={setAdminFilter as (value: string) => void} data={[ { label: 'All Roles', value: 'ALL' }, { label: 'Admins', value: 'ADMIN' }, { label: 'Non-Admins', value: 'NON_ADMIN' }, ]} /> <SegmentedControl disabled={isLoading || members.length === 0} value={contactFilter} onChange={setContactFilter as (value: string) => void} data={[ { label: 'All Contacts', value: 'ALL' }, { label: 'Saved', value: 'SAVED' }, { label: 'Unsaved', value: 'UNSAVED' }, ]} /> </Group> </Group> <Group justify="space-between"> <Text fw={500}>{processedData.length} members found</Text> <Group> <Popover width={250} position="bottom-end" withArrow shadow="md"> <Popover.Target> <Button variant="outline" size="xs" leftSection={<Icon icon="tabler:columns" />} disabled={isLoading || members.length === 0} > Customize Columns </Button> </Popover.Target> <Popover.Dropdown> <Checkbox.Group label="Select columns to export" value={selectedColumns} onChange={setSelectedColumns} > <Stack mt="xs" gap="xs"> {ALL_COLUMNS.map((col) => ( <Checkbox key={col.value} value={col.value} label={col.label} /> ))} </Stack> </Checkbox.Group> </Popover.Dropdown> </Popover> <Menu shadow="md" width={200} disabled={isLoading || processedData.length === 0} > <Menu.Target> <Button size="xs" leftSection={<Icon icon="tabler:download" />}> Export Data </Button> </Menu.Target> <Menu.Dropdown> <Menu.Label>Export Formats</Menu.Label> <Menu.Item leftSection={<Icon icon="tabler:file-type-csv" />} onClick={() => handleExport(SaveAs.CSV)} > Export as CSV </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:file-type-xls" />} onClick={() => handleExport(SaveAs.EXCEL)} > Export as Excel </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:file-type-pdf" />} onClick={() => handleExport(SaveAs.PDF)} > Export as PDF </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:json" />} onClick={() => handleExport(SaveAs.JSON)} > Export as JSON </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:file-type-txt" />} onClick={() => handleExport(SaveAs.TXT)} > Export as TXT </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:id" />} onClick={() => handleExport(SaveAs.VCARD)} > Export as vCard (.vcf) </Menu.Item> <Menu.Divider /> <CopyButton value={getSelectedNumbers}> {({ copied, copy }) => ( <Menu.Item leftSection={<Icon icon="tabler:clipboard" />} onClick={copy} > {copied ? 'Copied Numbers!' : 'Copy Phone Numbers'} </Menu.Item> )} </CopyButton> </Menu.Dropdown> </Menu> </Group> </Group> <DataTable height={350} withTableBorder borderRadius="sm" striped highlightOnHover records={processedData} fetching={isLoading} noRecordsText="No members to display. Select a group to get started." columns={[ { accessor: 'savedName', title: 'Name', render: ({ savedName, avatar }) => ( <Group gap="sm"> <Avatar src={avatar} size={30} radius="xl" /> <Text fz="sm" fw={500}> {savedName} </Text> </Group> ), }, { accessor: 'phoneNumber', title: 'Phone Number', }, { accessor: 'isAdmin', title: 'Role', textAlign: 'center', render: ({ isAdmin, isSuperAdmin }) => ( <Badge color={isSuperAdmin ? 'red' : isAdmin ? 'teal' : 'gray'}> {isSuperAdmin ? 'Super Admin' : isAdmin ? 'Admin' : 'Member'} </Badge> ), }, { accessor: 'isMyContact', title: 'Contact Status', textAlign: 'center', render: ({ isMyContact }) => ( <Badge variant="light" color={isMyContact ? 'blue' : 'gray'}> {isMyContact ? 'Saved' : 'Unsaved'} </Badge> ), }, { accessor: 'groupName', title: 'Group', }, ]} /> </Stack> </LayoutPage> ) } export default PageGroupMemberExporter
```

# src/features/group-member-exporter/useGroupMemberExporter.ts

```ts
// src/features/group-member-exporter/useGroupMemberExporter.ts import { SaveAs } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import toast from '@/utils/toast' import { getContactName } from '@/utils/util' import FileSaver from 'file-saver' import jsPDF from 'jspdf' import _ from 'lodash' import { useEffect, useMemo, useState } from 'react' import * as XLSX from 'xlsx' // Define types for clarity export interface Member { id: string phoneNumber: string savedName: string isMyContact: boolean isAdmin: boolean isSuperAdmin: boolean avatar: string | null | undefined groupSource: string groupName: string } export type FilterStatus = 'ALL' | 'ADMIN' | 'NON_ADMIN' export type ContactFilterStatus = 'ALL' | 'SAVED' | 'UNSAVED' // MODIFIED: All available columns for export customization, with 'isBusiness' removed. export const ALL_COLUMNS = [ { value: 'phoneNumber', label: 'Phone Number' }, { value: 'savedName', label: 'Name' }, { value: 'isAdmin', label: 'Is Admin' }, { value: 'isMyContact', label: 'Is My Contact' }, { value: 'groupName', label: 'Group Name' }, ] export const useGroupMemberExporter = () => { const { groups } = useAppStore() const license = useLicense() // License hook for feature checks const [isLoading, setIsLoading] = useState(false) const [members, setMembers] = useState<Member[]>([]) const [adminFilter, setAdminFilter] = useState<FilterStatus>('ALL') const [contactFilter, setContactFilter] = useState<ContactFilterStatus>('ALL') const [selectedGroupIds, setSelectedGroupIds] = useState<string[]>([]) const [selectedColumns, setSelectedColumns] = useState<string[]>( ALL_COLUMNS.map((c) => c.value), ) // ADDED: State for handling the search query. const [searchQuery, setSearchQuery] = useState('') const serializeData = async (data: any[]) => { let filteredData = [...data] if (license.isFree() && filteredData.length > 10) { filteredData = filteredData.map((item, index) => index >= 10 ? _.mapValues(item, () => '********') : item, ) } return filteredData } const defaultFilename = () => { return `export_${new Date().toISOString().slice(0, 10)}` } // --- START: File Saving Logic --- const saveAsCSV = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } const saveAsExcel = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet 1') XLSX.writeFile(workbook, `${filename}.xlsx`) } const saveAsJson = (data: any[], filename: string) => { const json = JSON.stringify(data, null, 2) const blob = new Blob([json], { type: 'application/json' }) FileSaver.saveAs(blob, `${filename}.json`) } const saveAsVCard = (data: any[]) => { const vcardContent = data .map((contact) => { const name = contact.savedName || 'Unknown' const phone = contact.phoneNumber ? `+${contact.phoneNumber}` : '' return `BEGIN:VCARD\nVERSION:3.0\nFN:${name}\nTEL;TYPE=CELL:${phone}\nEND:VCARD` }) .join('\n') const blob = new Blob([vcardContent], { type: 'text/vcard' }) FileSaver.saveAs(blob, `${defaultFilename()}.vcf`) } const saveAsTXT = (data: any[], filename: string) => { if (!data || data.length === 0) return const headers = Object.keys(data[0]) let txtContent = headers.join('\t\t') + '\n' txtContent += '-'.repeat(headers.length * 15) + '\n' data.forEach((row) => { const rowValues = headers.map((header) => row[header]) txtContent += rowValues.join('\t\t') + '\n' }) const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8;', }) FileSaver.saveAs(blob, `${filename}.txt`) } const saveAsPDF = async (data: any[], filename: string) => { if (!data || data.length === 0) return try { const doc = new jsPDF({ orientation: 'landscape', unit: 'px', format: 'a4', }) const selectedColumnDetails = ALL_COLUMNS.filter((col) => selectedColumns.includes(col.value), ) const headers = selectedColumnDetails.map((col) => col.label) const body = data.map((row) => selectedColumnDetails.map((col) => typeof row[col.value] === 'boolean' ? row[col.value] ? 'Yes' : 'No' : String(row[col.value] ?? '-'), ), ) const pageHeight = doc.internal.pageSize.getHeight() const pageWidth = doc.internal.pageSize.getWidth() const margin = 30 const rowHeight = 25 const fontSize = 10 const cellPadding = 5 let y = margin + 30 doc.setFontSize(18) doc.text('WhatsApp Group Members Export', pageWidth / 2, margin, { align: 'center', }) doc.setFontSize(fontSize) const drawHeaders = () => { const colWidth = (pageWidth - margin * 2) / headers.length doc.setFont('helvetica', 'bold') headers.forEach((header, i) => { doc.setFillColor(240, 240, 240) doc.rect(margin + i * colWidth, y, colWidth, rowHeight, 'F') doc.setDrawColor(150, 150, 150) doc.rect(margin + i * colWidth, y, colWidth, rowHeight) doc.text( header, margin + i * colWidth + cellPadding, y + rowHeight / 2 + 4, ) }) y += rowHeight } drawHeaders() const colWidth = (pageWidth - margin * 2) / headers.length doc.setFont('helvetica', 'normal') body.forEach((row) => { if (y + rowHeight > pageHeight - margin) { doc.addPage() y = margin drawHeaders() } row.forEach((cell, cellIndex) => { doc.setDrawColor(150, 150, 150) doc.rect(margin + cellIndex * colWidth, y, colWidth, rowHeight) const textLines = doc.splitTextToSize( cell, colWidth - cellPadding * 2, ) doc.text( textLines, margin + cellIndex * colWidth + cellPadding, y + rowHeight / 2 + 4, ) }) y += rowHeight }) doc.save(`${filename}.pdf`) } catch (error) { console.error('Failed to generate PDF:', error) toast.error('An unexpected error occurred while generating the PDF.') } } const saveAs = async (fileType: string, data: any[], filename?: string) => { const processedData = await serializeData(data) const finalFilename = filename || defaultFilename() switch (fileType) { case SaveAs.CSV: saveAsCSV(processedData, finalFilename) break case SaveAs.EXCEL: saveAsExcel(processedData, finalFilename) break case SaveAs.PDF: await saveAsPDF(processedData, finalFilename) break case SaveAs.JSON: saveAsJson(processedData, finalFilename) break case SaveAs.TXT: saveAsTXT(processedData, finalFilename) break case SaveAs.VCARD: saveAsVCard(processedData) break default: console.error(`Unsupported file type: ${fileType}`) break } } // --- END: File Saving Logic --- useEffect(() => { setIsLoading(true) const filteredGroups = _.filter(groups, (group) => _.includes(selectedGroupIds, group.id), ) const results = filteredGroups.map((group) => { return group.participants.map((participant: any) => ({ groupName: group?.name || 'Unknown Group', id: participant.contact.id, phoneNumber: participant.contact.phoneNumber, savedName: getContactName(participant.contact), avatar: participant.contact.avatar, isMyContact: participant.contact.isMyContact, isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, groupSource: group.id, })) }) const allMembers = _.chain(results).flatten().uniqBy('id').value() setMembers(allMembers) setIsLoading(false) }, [selectedGroupIds, groups]) // MODIFIED: Added search logic to the memoized data processing. const processedData = useMemo(() => { let filtered = [...members] // Apply filters if (adminFilter !== 'ALL') { filtered = filtered.filter((m) => adminFilter === 'ADMIN' ? m.isAdmin : !m.isAdmin, ) } if (contactFilter !== 'ALL') { filtered = filtered.filter((m) => contactFilter === 'SAVED' ? m.isMyContact : !m.isMyContact, ) } // Apply search query if (searchQuery) { const lowercasedQuery = searchQuery.toLowerCase() filtered = filtered.filter( (m) => m.savedName?.toLowerCase().includes(lowercasedQuery) || m.phoneNumber?.includes(lowercasedQuery), ) } return filtered }, [members, adminFilter, contactFilter, searchQuery]) const getSelectedNumbers = useMemo(() => { return processedData.map((m) => m.phoneNumber).join('\n') }, [processedData]) const handleExport = (format: string) => { if (processedData.length === 0) return const dataToExport = processedData.map((member) => _.pick(member, selectedColumns), ) if (format === SaveAs.VCARD) { const vCardData = processedData.map(({ savedName, phoneNumber }) => ({ savedName, phoneNumber, })) saveAs(format, vCardData, 'whatsapp_group_contacts') return } saveAs(format, dataToExport, 'whatsapp_group_members') } return { isLoading, members, processedData, adminFilter, setAdminFilter, contactFilter, setContactFilter, selectedGroupIds, setSelectedGroupIds, selectedColumns, setSelectedColumns, getSelectedNumbers, handleExport, // ADDED: Expose search state handlers to the component. searchQuery, setSearchQuery, } }
```

# src/hooks/useAi.ts

```ts
// src/hooks/useAi.ts import { AI } from '@/constants/action' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' const useAi = () => { const rewriteMessage = async ( prompt: string, message: string, system: | string | null = 'You are an expert copywriter. Your task is to rewrite the user message based on their instruction.', ): Promise<Response<string>> => { // Send the request to the background relay defined in `ai.relay.ts` return await sendToBackgroundViaRelay({ //@ts-ignore name: 'ai', body: { prompt, message, system }, }) } return { rewriteMessage, } } export default useAi
```

# src/hooks/useDataQuery.ts

```ts
import type { EntityTable } from 'dexie' import { useLiveQuery } from 'dexie-react-hooks' import { useMemo, useState } from 'react' type SortDirection = 'asc' | 'desc' interface Sort { field: string direction: SortDirection } type SortState = Sort | null type FilterOperator = | 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'between' interface Filter { field: string operator: FilterOperator value: any secondValue?: any } interface useDataQueryOptions<T> { //@ts-ignore table: EntityTable<T, 'id'> initialPageSize?: number searchField?: string initialSort?: Sort initialFilters?: Filter[] } export const useDataQuery = <T>(options: useDataQueryOptions<T>) => { const { table, initialPageSize = 10, searchField = 'name', initialSort = { field: 'id', direction: 'desc' }, initialFilters = [], } = options const [page, setPage] = useState(1) const [pageSize, setPageSize] = useState(initialPageSize) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<T[]>([]) const [sort, setSort] = useState<SortState>(initialSort) const [filters, setFilters] = useState<Filter[]>(initialFilters) const applyFilter = (query: any, filter: Filter) => { const { field, operator, value, secondValue } = filter switch (operator) { case 'equals': return query.filter((item: any) => item[field] === value) case 'contains': return query.filter((item: any) => String(item[field]) .toLowerCase() .includes(String(value).toLowerCase()), ) case 'startsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .startsWith(String(value).toLowerCase()), ) case 'endsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .endsWith(String(value).toLowerCase()), ) case 'greaterThan': return query.filter((item: any) => item[field] > value) case 'lessThan': return query.filter((item: any) => item[field] < value) case 'between': return query.filter( (item: any) => item[field] >= value && item[field] <= (secondValue ?? value), ) default: return query } } const data = useLiveQuery(async () => { if (pageSize <= 0) return { data: [], totalItems: 0, hasMore: false } const startIndex = (page - 1) * pageSize let query = search ? table.where(searchField).startsWithIgnoreCase(search) : table.toCollection() let results = await query.toArray() filters.forEach((filter) => { results = applyFilter(results, filter) }) if (sort) { results.sort((a: any, b: any) => { const aValue = a[sort.field] const bValue = b[sort.field] if (aValue === bValue) return 0 const comparison = aValue > bValue ? 1 : -1 return sort.direction === 'asc' ? comparison : -comparison }) } const paginatedResults = results.slice(startIndex, startIndex + pageSize) return { data: paginatedResults, totalItems: results.length, hasMore: startIndex + paginatedResults.length < results.length, } }, [page, pageSize, search, sort, filters]) const _delete = async (id: any) => { if (confirm('Are you sure?')) { await table.delete(id) } } const toggleSort = (field: string) => { setSort((currentSort) => { // Case 1: No current sort, or a new column is clicked. Start with 'asc'. if (!currentSort || currentSort.field !== field) { return { field, direction: 'asc' } } // Case 2: Currently sorted 'asc'. Switch to 'desc'. if (currentSort.direction === 'asc') { return { field, direction: 'desc' } } // Case 3: Currently sorted 'desc'. Switch to null to remove sorting. if (currentSort.direction === 'desc') { return null } // Fallback, should not be reached. return currentSort }) } const addFilter = (filter: Filter) => { setFilters((prev) => [...prev, filter]) setPage(1) } const removeFilter = (index: number) => { setFilters((prev) => prev.filter((_, i) => i !== index)) setPage(1) } const updateFilter = (index: number, filter: Filter) => { setFilters((prev) => prev.map((f, i) => (i === index ? filter : f))) setPage(1) } const clearFilters = () => { setFilters([]) setPage(1) } const derivedData = useMemo( () => ({ data: data?.data ?? [], totalRecords: data?.totalItems ?? 0, hasMore: data?.hasMore ?? false, }), [data], ) return { ...derivedData, selectedRecords, page, pageSize, search, sort, filters, setPage, setPageSize, setSelectedRecords, setSearch, toggleSort, addFilter, removeFilter, updateFilter, clearFilters, _delete, searchField, } } export default useDataQuery
```

# src/hooks/useFile.ts

```ts
// src/utils/file.ts import { SaveAs, Setting } from '@/constants' import { storage } from '@/libs/storage' import FileSaver from 'file-saver' import _ from 'lodash' import * as XLSX from 'xlsx' import useLicense from './useLicense' const useFile = () => { const license = useLicense() const getSelectedColumns = async () => { return ( (await storage.get<Record<string, boolean>>(Setting.EXPORT_COLUMNS)) || { phoneNumber: true, publicName: true, savedName: true, isBlocked: true, isBusiness: true, isMyContact: true, } ) } const serializeData = async (data: any[]) => { const selectedColumns = await getSelectedColumns() let filteredData = data.map((item: any) => _.pickBy(item, (_, key) => selectedColumns[key] === true), ) if (license.isFree() && filteredData.length > 10) { filteredData = filteredData.map((item, index) => index >= 10 ? _.mapValues(item, () => '********') : item, ) } return filteredData } const defaultFilename = () => { return `export_${new Date().toISOString().slice(0, 10)}` } const saveAsCSV = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } const saveAsExcel = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet 1') XLSX.writeFile(workbook, `${filename}.xlsx`) } const saveAsJson = (data: any[], filename: string) => { const json = JSON.stringify(data, null, 2) const blob = new Blob([json], { type: 'application/json' }) FileSaver.saveAs(blob, `${filename}.json`) } const saveAsVCard = (data: any[]) => { const vcardContent = data .map((contact) => { const name = contact.savedName || contact.publicName || 'Unknown' const phone = contact.phoneNumber ? `+${contact.phoneNumber}` : '' return `BEGIN:VCARD\nVERSION:3.0\nFN:${name}\nTEL;TYPE=CELL:${phone}\nEND:VCARD` }) .join('\n') const blob = new Blob([vcardContent], { type: 'text/vcard' }) FileSaver.saveAs(blob, `${defaultFilename()}.vcf`) } /** * Main function to save data in various formats. * @param fileType The format to save as (e.g., 'csv', 'xlsx'). * @param data The array of data objects to save. * @param filename (Optional) The base name for the file, without extension. */ const saveAs = async (fileType: string, data: any[], filename?: string) => { const processedData = await serializeData(data) const finalFilename = filename || defaultFilename() switch (fileType) { case SaveAs.CSV: saveAsCSV(processedData, finalFilename) break case SaveAs.EXCEL: saveAsExcel(processedData, finalFilename) break case SaveAs.JSON: saveAsJson(processedData, finalFilename) break case SaveAs.VCARD: saveAsVCard(processedData) // VCard has its own filename logic break // Other formats like Markdown and HTML can be added here. default: console.error(`Unsupported file type: ${fileType}`) break } } return { saveAs } } export default useFile
```

# src/hooks/useLicense.ts

```ts
// src/hooks/useLicense.ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import type { License } from '@/types' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { sendToBackground } from '@plasmohq/messaging' import { isPast } from 'date-fns' // English: Define a type for the cache entry, including the data and a timestamp. interface CachedLicense { data: License timestamp: number } const useLicense = () => { const { license, setLicense } = useAppStore() const callLemonSqueezyApi = async (action: string, body: any) => { return await sendToBackground({ name: 'lemonsqueezy', body: { action, body }, }) } const init = async () => { // Check for a cached license entry. const cachedEntry = await storage.get<CachedLicense | null>( Setting.LICENSE_DATA_CACHE, ) if (cachedEntry) { const twoDaysInMs = 2 * 24 * 60 * 60 * 1000 const isCacheStale = Date.now() - cachedEntry.timestamp > twoDaysInMs // Use the cache only if it's not stale and the license is active. if (!isCacheStale && cachedEntry.data.license_key.status === 'active') { setLicense(cachedEntry.data) return } } // If no valid cache, proceed with the standard validation flow. const licenseKey = await storage.get<string | null>(Setting.LICENSE_KEY) if (!licenseKey) { setLicense(null) await storage.remove(Setting.LICENSE_DATA_CACHE) return } const response = await callLemonSqueezyApi('validateLicense', { licenseKey, }) if (response.error) { // Validation failed, clear all license-related storage. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is invalid or has been deactivated. You have been switched to the Free plan.', 'License Invalid', ) return } if (response.data.meta.store_id.toString() !== getStoreId()) { await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is for a different product. You have been switched to the Free plan.', 'License Error', ) return } // Validation successful, update app state and cache the license data if active. setLicense(response.data) if (response.data.license_key.status === 'active') { // Store the license data along with the current timestamp. const cacheEntry: CachedLicense = { data: response.data, timestamp: Date.now(), } await storage.set(Setting.LICENSE_DATA_CACHE, cacheEntry) } if ( response.data.license_key.expires_at && isPast(new Date(response.data.license_key.expires_at)) ) { toast.info( 'Your license has expired. You have been switched to the Free plan.', 'License Expired', ) await storage.remove(Setting.LICENSE_DATA_CACHE) } } const isFree = (): boolean => { if (!license) { return true } return license.license_key.status !== 'active' } const isPro = () => { if (!license) { return false } return license.license_key.status === 'active' } const isExpired = () => { if (!license || !license.license_key.expires_at) { return false } return isPast(new Date(license.license_key.expires_at)) } const getLicense = () => { return license } const activate = async (licenseKey: string) => { const response = await callLemonSqueezyApi('activateLicense', { licenseKey, }) if (!response.error) { setLicense(response.data) await storage.set(Setting.LICENSE_KEY, licenseKey) await storage.set(Setting.LICENSE_INSTANCE_ID, response.data.instance.id) // Cache the license data with the timestamp on successful activation. if (response.data.license_key.status === 'active') { const cacheEntry: CachedLicense = { data: response.data, timestamp: Date.now(), } await storage.set(Setting.LICENSE_DATA_CACHE, cacheEntry) } } return response } const deactivate = async () => { const licenseKey = await storage.get(Setting.LICENSE_KEY) const instanceId = await storage.get(Setting.LICENSE_INSTANCE_ID) try { const response = await callLemonSqueezyApi('deactivateLicense', { licenseKey, instanceId, }) if (response.data.deactivated) { // Clear all license-related data from storage on deactivation. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.success('Your license has been deactivated from this device.') } else { toast.error('Failed to deactivate the license. Please contact support.') } } catch (e) { toast.error('An error occurred during deactivation.') } } const goToMyOrders = async () => { if (!license?.meta?.customer_id) { toast.error('Could not find customer information.') return } try { const response = await callLemonSqueezyApi('getCustomer', { customerId: license.meta.customer_id, }) if (response.error) { toast.error('Could not retrieve customer portal link.') return } window.open( response.data.data.attributes.urls.customer_portal, '_blank', 'noopener,noreferrer', ) } catch (e) { toast.error('An error occurred while fetching your subscription details.') } } return { init, isFree, isPro, isExpired, activate, getLicense, goToMyOrders, deactivate, } } export default useLicense
```

# src/hooks/useRuntimeMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = ( message: T, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void, ) => void | boolean /** * A React hook for handling Chrome runtime messages * @param listener The callback function to handle incoming messages * @returns void * * @example * useRuntimeMessage((message, sender, sendResponse) => { * if (message.type === 'getData') { * sendResponse({ data: 'example' }) * } * // Return true to keep the message channel open for async responses * return true * }) */ const useRuntimeMessage = <T = any>(listener: MessageListener<T>): void => { const memoizedHandler = useCallback<MessageListener<T>>( (message, sender, sendResponse) => { return listener(message, sender, sendResponse) }, [listener], ) useEffect(() => { chrome.runtime.onMessage.addListener(memoizedHandler) return () => { chrome.runtime.onMessage.removeListener(memoizedHandler) } }, [memoizedHandler]) } export default useRuntimeMessage
```

# src/hooks/useWa.ts

```ts
import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' const useWa = () => { const { isReady, activeChat } = useAppStore() return { isReady, activeChat, ...wa, } } export default useWa
```

# src/hooks/useWindowMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = (event: MessageEvent<T>) => void const useWindowMessage = <T = any>(listener: MessageListener<T>): void => { const handleMessage = useCallback<MessageListener<T>>( (event) => { listener(event) }, [listener], ) useEffect(() => { window.addEventListener('message', handleMessage) return () => window.removeEventListener('message', handleMessage) }, [handleMessage]) } export default useWindowMessage
```

# src/libs/db.ts

```ts
// src/libs/db.ts import Dexie, { type EntityTable } from 'dexie' import packageJson from '../../package.json' export interface Media { id: number parentId: number type: string name: string file: File ext: string } export interface Broadcast { id: number name?: string | null type: string message: any isTyping: number isScheduler: number status: string delayMin?: number delayMax?: number pauseEnabled?: number pauseAfter?: number pauseDuration?: number pausedUntil?: Date | null } export interface BroadcastContact { id: number broadcastId: number number: string name?: string | null status: string error?: string | null scheduledAt?: Date | null sendAt?: Date | null } export interface BroadcastTemplate { id: number name: string type: string message: any } export interface BroadcastRecipient { id: number name: string recipients: { name: string; number: string; source: string }[] createdAt: Date } export interface Label { id: number label: string value: string show: number custom: number numbers?: any[] color?: string group?: string isPinned?: number } export interface DirectChatTemplate { id: number name: string message: string } export interface QuickReply { id: number name: string type: string message: any isPinned?: number createdAt?: Date } // ++ ADDED: Interface for the new Group Link History feature export interface GroupLinkHistory { id?: number groupId: string groupName: string link: string createdAt: Date } const db = new Dexie(packageJson.name) as Dexie & { media: EntityTable<Media, 'id'> broadcasts: EntityTable<Broadcast, 'id'> broadcastContacts: EntityTable<BroadcastContact, 'id'> broadcastTemplates: EntityTable<BroadcastTemplate, 'id'> broadcastRecipients: EntityTable<BroadcastRecipient, 'id'> labels: EntityTable<Label, 'id'> directChatTemplates: EntityTable<DirectChatTemplate, 'id'> quickReplies: EntityTable<QuickReply, 'id'> groupLinkHistories: EntityTable<GroupLinkHistory, 'id'> } // NOTE: Dexie cannot index boolean values. Fields intended for use in `where()` clauses // have been changed from `boolean` to `number` (0 for false, 1 for true). db.version(1).stores({ media: '++id, parentId, type, name, file, ext', broadcasts: '++id, name, type, message, isTyping, isScheduler, status, delayMin, delayMax, pauseEnabled, pauseAfter, pauseDuration, pausedUntil', broadcastContacts: '++id, broadcastId, number, name, status, error, scheduledAt, sendAt, [broadcastId+status]', broadcastTemplates: '++id, name, type, message', broadcastRecipients: '++id, name, createdAt', labels: '++id, label, value, show, custom, color, group, isPinned, *numbers', directChatTemplates: '++id, name', quickReplies: '++id, name, type, isPinned, createdAt', groupLinkHistories: '++id, groupId, groupName, link, createdAt', }) export default db
```

# src/libs/http.ts

```ts
import fetchAdapter from '@haverstack/axios-fetch-adapter' import axios from 'axios' const http = axios.create({ adapter: fetchAdapter, }) export default http
```

# src/libs/ls.ts

```ts
import * as lemon from '@lemonsqueezy/lemonsqueezy.js' lemon.lemonSqueezySetup({}) const lemonSqueezy = lemon export default lemonSqueezy
```

# src/libs/storage.ts

```ts
import { Storage } from '@plasmohq/storage' export const storage = new Storage({})
```

# src/libs/theme.ts

```ts
import { Button, createTheme, FileInput, Menu, Modal, MultiSelect, NumberInput, Popover, Radio, Select, Switch, TagsInput, Text, Textarea, TextInput, Tooltip, } from '@mantine/core' const theme = createTheme({ colors: { emerald: [ '#effbf3', '#ddf4e5', '#b6eac7', '#8cdfa7', '#6bd68c', '#56d07b', '#4acd72', '#3bb560', '#31a154', '#145229', ], }, primaryColor: 'teal', cursorType: 'pointer', components: { Button: Button.extend({ defaultProps: { size: 'sm', }, }), FileInput: FileInput.extend({ defaultProps: { size: 'md', }, }), Menu: Menu.extend({ defaultProps: { withinPortal: false } }), Modal: Modal.extend({ defaultProps: { size: 'xl', withCloseButton: false, withOverlay: false, withinPortal: false, }, }), NumberInput: NumberInput.extend({ defaultProps: { size: 'md' } }), MultiSelect: MultiSelect.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Popover: Popover.extend({ defaultProps: { withinPortal: false, }, }), Radio: Radio.extend({ defaultProps: { size: 'md', }, }), Select: Select.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Switch: Switch.extend({ defaultProps: { size: 'md', }, }), TagsInput: TagsInput.extend({ defaultProps: { size: 'md', }, }), Text: Text.extend({ defaultProps: { size: 'md', }, }), Textarea: Textarea.extend({ defaultProps: { size: 'md', }, }), TextInput: TextInput.extend({ defaultProps: { size: 'md', }, }), Tooltip: Tooltip.extend({ defaultProps: { position: 'left', withinPortal: false, withArrow: true, }, }), }, }) export default theme
```

# src/libs/wa/blocklist.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' export const all = async (): Promise<Wid[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.ALL, body: {}, }) } export const blockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.BLOCK_CONTACT, body: chatId, }) } export const isBlocked = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.IS_BLOCKED, body: chatId, }) } export const unblockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.UNBLOCK_CONTACT, body: chatId, }) }
```

# src/libs/wa/cart.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { SendMessageOptions } from '@wppconnect/wa-js/dist/chat' /** * Add product in cart * * @example * \`\`\`javascript * const cart = wa.cart.add('[number]@c.us', [ * { id: 'productId', qnt: 2 }, * ]); * \`\`\` */ export const add = async ( chatId: string, products: { id: string qnt: number }[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.ADD, body: { chatId, products }, }) } /** * Clear all items of cart * */ export const clear = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.CLEAR, body: wid, }) } /** * Get products in cart chat * * @example * \`\`\`javascript * const cart = wa.cart.get('[number]@c.us'); * \`\`\` */ export const get = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET, body: wid, }) } /** * Get thumb of a cart * * @example * \`\`\`javascript * const cart = wa.cart.getThumbFromCart('[number]@c.us'); * \`\`\` */ export const getThumbFromCart = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET_THUMB_FROM_CART, body: wid, }) } /** * Remove a product in cart * * @example * \`\`\`javascript * const cart = wa.cart.remove('[number]@c.us', '6987301181294productId'); * \`\`\` */ export const remove = async ( chatId: string, productId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.REMOVE, body: { chatId, productId }, }) } /** * Send a request order to business chat * * @example * \`\`\`javascript * const cart = wa.cart.submit('[number]@c.us'); * \`\`\` * * @example * \`\`\`javascript * // Send cart with a custom message * const cart = wa.cart.submit('[number]@c.us', 'Custom message here'); * \`\`\` */ export const submit = async ( wid: string, msg?: string, options?: SendMessageOptions, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.SUBMIT, body: { wid, msg, options }, }) } /** * Update product in cart * * @example * \`\`\`javascript * const cart = wa.cart.update('[number]@c.us', '6987301181294productId', { quantity: 12 }); * \`\`\` */ export const update = async ( chatId: string, productId: string, options: { quantity: number }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.UPDATE, body: { chatId, productId, options }, }) }
```

# src/libs/wa/catalog.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { createProductParams } from '@wppconnect/wa-js/dist/catalog/functions/createProduct' import type { editProductParams } from '@wppconnect/wa-js/dist/catalog/functions/editProduct' /** * Add image on product * This function include additional images on product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.addProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const addProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.ADD_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Add image on product * This function change main image of product * for change additional images use @addProductImage * * @example * \`\`\`javascript * await wa.catalog.changeProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const changeProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CHANGE_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Create new collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.createCollection('Collection Name', ['565656589898']); * \`\`\` */ export const createCollection = async ( collectionName: string, productsId: string[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_COLLECTION, body: { collectionName, productsId }, }) } /** * Create new product * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.addProduct( { name: 'Product name', image: 'base64 image string', description: 'product description', price: '89.90', isHidden: false, url: 'https://wppconnect.io', retailerId: 'AKA001', } ); * \`\`\` */ export const createProduct = async ( params: createProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_PRODUCT, body: params, }) } /** * Delete a collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.deleteCollection("377095767832354"); * \`\`\` * * @return Return sucess or error */ export const deleteCollection = async (collectionId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_COLLECTION, body: collectionId, }) } /** * @example * \`\`\`javascript * * // Delete various products * const myCatalog = await wa.catalog.delProducts(['6104203702939361', '6104289702939361']); * \`\`\` */ export const deleteProduct = async (productsIds: string[]): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_PRODUCT, body: productsIds, }) } /** * @example * \`\`\`javascript * const myCatalog = await wa.catalog.EditCollection('565656589898', { collectionName: 'New Name for collection', productsToAdd: ['5656523223'], productsToRemove: ['5656523232']}); * \`\`\` */ interface paramsEditCollection { name?: string productsToAdd?: string[] productsToRemove?: string[] } export const editCollection = async ( collectionId: string, params: paramsEditCollection, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_COLLECTION, body: { collectionId, params }, }) } /** * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = wa.catalog.editProduct('5498255476885590', {name: 'Plano 01', price: '89990', description: 'Insert description for your product', isHidden: true, url: 'http://www.wppconnect.io', retailerId: 'AKA001'}); * \`\`\` */ export const editProduct = async ( productId: string, params: editProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_PRODUCT, body: { productId, params }, }) } /** * Get collections of catalog * * @example * \`\`\`javascript * // Retrieve 20 collections of chat * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20'); * * // Retrieve 20 collections of chat and products arrays limit with 10 products * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20', '10'); * \`\`\` */ export const getCollections = async ( chatId: string, qnt?: number, productsCount?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_COLLECTIONS, body: { chatId, qnt, productsCount }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ export const getMyCatalog = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_MY_CATALOG, body: {}, }) } /** * Retrieves product by id * * @example * \`\`\`javascript * // Retrieve data of product * await wa.catalog.getProductById('5521985565656@c.us', '68685985868923'); * \`\`\` */ export const getProductById = async ( chatId: string, productId: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCT_BY_ID, body: { chatId, productId }, }) } /** * Retrieves product by contact id * * @example * Get products of catalogs * \`\`\`javascript * await wa.catalog.getProducts('5521985625689@c.us', 10); * \`\`\` */ export const getProducts = async (chatId: string, qnt: number): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCTS, body: { chatId, qnt }, }) } /** * Remove image on product * This function remove additional images of product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.removeProductImage('68685985868923', '0'); * \`\`\` */ export const removeProductImage = async ( productId: string, index: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.REMOVE_PRODUCT_IMAGE, body: { productId, index }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` */ export const setProductVisibility = async ( productId: any, isHidden: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.SET_PRODUCT_VISIBILITY, body: { productId, isHidden }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` * * @return Return sucess of product visibility set */ export const updateCartEnabled = async (enabled: boolean): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.UPDAGE_CART_ENABLED, body: enabled, }) }
```

# src/libs/wa/chat.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions, DeleteMessageReturn, ForwardMessagesOptions, GetMessagesOptions, RawMessage, } from '@wppconnect/wa-js/dist/chat' import type { ParticipantStatusACK } from '@wppconnect/wa-js/dist/chat/functions/getMessageACK' import type { Stringable } from '@wppconnect/wa-js/dist/types' import type { MsgKey, MsgModel, Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { ACK } from '@wppconnect/wa-js/dist/whatsapp/enums' /** * Archive a chat * * @example * // Archive a chat * wa.chat.archive('[number]@c.us'); * * // Unarchive a chat * wa.chat.archive('[number]@c.us', false); * \`\`\` */ export const archive = async ( chatId: string | Wid, archive = true, ): Promise<{ wid: Wid archive: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.ARCHIVE, body: { chatId, archive }, }) } /** * Get if message can played * * @example * \`\`\`javascript * wa.chat.canMarkPlayed('[message_id]'); * \`\`\` */ export const canMarkPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MARK_PLAYED, body: messageId, }) } /** * Check if is possible to mute this chat * * @example * \`\`\`javascript * const canMute = wa.chat.canMute('[number]@c.us'); * \`\`\` */ export const canMute = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MUTE, body: chatId, }) } /** * Get if message can reply * * @example * \`\`\`javascript * wa.chat.canReply('[message_id]'); * \`\`\` */ export const canReply = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_REPLY, body: messageId, }) } /** * Clear a chat message * */ export const clear = async ( chatId: string | Wid, keepStarred = true, ): Promise<{ wid: Wid status: number keepStarred: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLEAR, body: { chatId, keepStarred }, }) } /** * Close the chat tab * * @example * \`\`\`javascript * await wa.chat.closeChat(); * \`\`\` * */ export const closeChat = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLOSE_CHAT, body: {}, }) } /** * Delete a chat * */ export const _delete = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE, body: chatId, }) } /** * Delete a message * * @example * \`\`\`javascript * // Delete a message * wa.chat.deleteMessage('[number]@c.us', 'msgid'); * // Delete a list of messages * wa.chat.deleteMessage('[number]@c.us', ['msgid1', 'msgid2]); * // Delete a message and delete media * wa.chat.deleteMessage('[number]@c.us', 'msgid', true); * // Revoke a message * wa.chat.deleteMessage('[number]@c.us', 'msgid', true, true); * \`\`\` * */ export const deleteMessage = async ( chatId: string | Wid, ids: string | string[], deleteMediaInDevice = false, revoke = false, ): Promise<DeleteMessageReturn | DeleteMessageReturn[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE_MESSAGE, body: { chatId, ids, deleteMediaInDevice, revoke }, }) } /** * Downloads media from a message * * @example * \`\`\`javascript * await wa.chat.downloadMedia('messageId'); * \`\`\` */ export const downloadMedia = async ( messageId: string | MsgKey, ): Promise<Blob | null> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DOWNLOAD_MEDIA, body: messageId, }) } export const find = async (chatId: string | Wid): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FIND, body: chatId, }) } /** * Forward messages to a chat * * @example * \`\`\`javascript * // Forward messages * wa.chat.forwardMessage('[number]@c.us', 'true_[number]@c.us_ABCDEF'); * \`\`\` */ export const forwardMessage = async ( toChatId: string | Wid, msgId: string | MsgKey, options: ForwardMessagesOptions = {}, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FORWARD_MESSAGE, body: { toChatId, msgId, options }, }) } /** * Find a chat by id * */ export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET, body: chatId, }) } export const getActiveChat = async () => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_ACTIVE_CHAT, body: {}, }) } /** * Get timestamp of last seen * @example * \`\`\`javascript * wa.chat.getLastSeen('[number]@c.us'); * \`\`\` */ export const getLastSeen = async ( chatId: string | Wid, ): Promise<number | boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_LAST_SEEN, body: chatId, }) } /** * Get message ACK from a message * * @example * \`\`\`javascript * // Get message ACK * const ackInfo = await WPP.chat.getMessageACK('true_[number]@c.us_ABCDEF'); * * console.log(ackInfo.deliveryRemaining); // Delivery Remaining * console.log(ackInfo.readRemaining); // Read Remaining * console.log(ackInfo.playedRemaining); // PlayedRemaining, for audio(ptt) only * * console.log(ackInfo.participants[0].deliveredAt); // Delivered At, in timestamp format * console.log(ackInfo.participants[0].readAt); // Read At, in timestamp format * console.log(ackInfo.participants[0].playedAt); // Played At, in timestamp format, for audio(ptt) only * * //To get only how was received * const received = ackInfo.participants.filter(p => p.deliveredAt || p.readAt || p.playedAt); * * //To get only how was read * const read = ackInfo.participants.filter(p => p.readAt || p.playedAt); * * //To get only how was played * const played = ackInfo.participants.filter(p => p.playedAt); * \`\`\` */ export const getMessageACK = async ( msgId: string | MsgKey, ): Promise<{ ack: ACK fromMe: boolean deliveryRemaining: number readRemaining: number playedRemaining: number participants: ParticipantStatusACK[] }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGE_ACK, body: msgId, }) } /** * Fetch messages from a chat * * @example * \`\`\`javascript * // Some messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * }); * * // All messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * }); * * // Last 20 unread messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * onlyUnread: true, * }); * * // All unread messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * onlyUnread: true, * }); * * // 20 messages before specific message * wa.chat.getMessages('[number]@c.us', { * count: 20, * direction: 'before', * id: '<full message id>' * }); * * // Only media messages (url, document and links) * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'all', * }); * * // Only image messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'image', * }); * * // Only document messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'document', * }); * * // Only link (url) messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'url', * }); * \`\`\` */ export const getMessages = async ( chatId: string | Wid, options: GetMessagesOptions = {}, ): Promise<any[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGES, body: { chatId, options }, }) } /** * Get notes from a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.getNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const getNotes = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_NOTES, body: chatId, }) } /** * Get the platform message from message ID * * The platform can be: * * android * * iphone * * web * * unknown * * @example * \`\`\`javascript * // to get platform from a message * const platform = wa.chat.getPlatformFromMessage('[message_id]'); * \`\`\` */ export const getPlatformFromMessage = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<'android' | 'iphone' | 'web' | 'unknown'> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_PLATFORM_MESSAGE, body: messageId, }) } /** * Return a list of chats * * @example * \`\`\`javascript * // All chats * const chats = await wa.chat.list(); * * // Some chats * const chats = wa.chat.list({count: 20}); * * // 20 chats before specific chat * const chats = wa.chat.list({count: 20, direction: 'before', id: '[number]@c.us'}); * * // Only users chats * const chats = await wa.chat.list({onlyUsers: true}); * * // Only groups chats * const chats = await wa.chat.list({onlyGroups: true}); * * // Only communities chats * const chats = await wa.chat.list({onlyCommunities: true}); * * // Only Newsletter * const chats = await wa.chat.list({onlyNewsletter: true}); * * // Only with label Text * const chats = await wa.chat.list({withLabels: ['Test']}); * * // Only with label id * const chats = await wa.chat.list({withLabels: ['1']}); * * // Only with label with one of text or id * const chats = await wa.chat.list({withLabels: ['Alfa','5']}); * \`\`\` * */ export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.LIST, body: options, }) } /** * Mark a chat to composing state * and keep sending "is writting a message" * * @example * \`\`\`javascript * // Mark is composing * wa.chat.markIsComposing('[number]@c.us'); * * // Mark is composing for 5 seconds * wa.chat.markIsComposing('[number]@c.us', 5000); * \`\`\` */ export const markIsComposing = async ( chatId: string | Wid, duration?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_COMPOSING, body: { chatId, duration }, }) } /** * Mark a chat is paused state * * @example * \`\`\`javascript * // Mark as recording * wa.chat.markIsPaused('[number]@c.us'); * \`\`\` */ export const markIsPaused = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_PAUSED, body: chatId, }) } /** * Mark a chat as read and send SEEN event * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsRead('[number]@c.us'); * \`\`\` */ export const markIsRead = async ( chatId: string, ): Promise<{ wid: Wid unreadCount: number }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_READ, body: chatId, }) } /** * Mark a chat to recording state * and keep sending "is recording" * * @example * \`\`\`javascript * // Mark is recording * wa.chat.markIsRecording('[number]@c.us'); * * // Mark is recording for 5 seconds * wa.chat.markIsRecording('[number]@c.us', 5000); * \`\`\` */ export const markIsRecording = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_RECORDING, body: chatId, }) } /** * Mark a chat as unread * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsUnread('[number]@c.us'); * \`\`\` */ export const markIsUnread = async ( chatId: string | Wid, ): Promise<{ wid: Wid }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_UNREAD, body: chatId, }) } /** * Mark message as played * * @example * \`\`\`javascript * wa.chat.markPlayed('[message_id]'); * \`\`\` */ export const markPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_PLAYED, body: messageId, }) } /** * Mute a chat, you can use duration or expiration * For expiration, use unix timestamp (seconds only) * For duration, use seconds * * @example * \`\`\`javascript * // Mute for 60 seconds * wa.chat.mute('[number]@c.us', {duration: 60}); * * // Mute util 2021-01-01 * wa.chat.mute('[number]@c.us', {expiration: 1641006000}); * * // or using date * const expiration = new Date('2022-01-01 00:00:00'); * wa.chat.mute('[number]@c.us', {expiration: expiration}); * \`\`\` * */ export const mute = async ( chatId: string | Wid, time: { expiration: number | Date } | { duration: number }, ): Promise<{ wid: Wid expiration: number isMuted: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MUTE, body: { chatId, time }, }) } /** * Open the chat in the WhatsApp interface in a specific message * * @example * \`\`\`javascript * await wa.chat.openChatAt('[number]@c.us', <message_id>); * \`\`\` * */ export const openChatAt = async ( chatId: string | Wid, messageId: string, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_AT, body: { chatId, messageId }, }) } /** * Open the chat in the WhatsApp interface in bottom position * * @example * \`\`\`javascript * await wa.chat.openChatBottom('[number]@c.us'); * \`\`\` * */ export const openChatBottom = async ( chatId: string, ): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_BOTTOM, body: chatId, }) } /** * Open the chat in the WhatsApp interface from first unread message * * @example * \`\`\`javascript * await wa.chat.openChatFromUnread('[number]@c.us'); * \`\`\` * */ export const openChatFromUnread = async ( chatId: string | Wid, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_FROM_UNREAD, body: chatId, }) } /** * Pin a message in chat * * @example * \`\`\`javascript * // Pin a message in chat * wa.chat.pinMsg('true_[number]@c.us_ABCDEF'); * * // Pin a message in chat for 30 days * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', 2592000); * * // Unpin a message * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', false); * \`\`\` */ export const pinMsg = async ( msgId: string | MsgKey, pin = true, seconds = 604800, // default 7 days ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN_MSG, body: { msgId, pin, seconds }, }) } /** * Set custom Chat list in panel of whatsapp * * @example * \`\`\`javascript * // Your custom list * wa.chat.setChatList('custom', ['number@c.us', 'number2@c.us']); * * // List only with unread chats * wa.chat.setChatList('unread'); * * // List only with favorites chats * wa.chat.setChatList('favorites'); * * // List only with groups chats * wa.chat.setChatList('group'); * * // List only labels chat * wa.chat.setChatList('labels', '454545_labelId'); * \`\`\` */ export const setChatList = async (type: string, ids?: string | string[]) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_CHAT_LIST, body: { type, ids }, }) } export const setInputText = async (text: string, chatId?: string | Wid) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_INPUT_TEXT, body: { text, chatId }, }) } /** * Set notes for a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.setNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const setNotes = async ( chatId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_NOTES, body: { chatId, content }, }) }
```

# src/libs/wa/conn.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Alternative login method using code * Get the Link Device Code for Authentication using the phone number * * @example * \`\`\`javascript * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]'); * * // Disable push notification * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]', false); * \`\`\` */ export const genLinkDeviceCodeForPhoneNumber = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }) } /** * Return the current auth code * * @example * \`\`\`javascript * const authCode = await wa.conn.getAuthCode(); * console.log(authCode.fullCode); // Output: a long string to generate a QRCode * \`\`\` */ export const getAuthCode = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_AUTH_CODE, }) } export const getMyUserId = async (): Promise<Wid | undefined> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_MY_USER_ID, }) }
```

# src/libs/wa/contact.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ContactListOptions } from '@wppconnect/wa-js/dist/contact' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Get a contact by id * * @example * \`\`\`javascript * await wa.contact.get('[number]@c.us'); * \`\`\` * */ export const get = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET, body: contactId, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getBusinessProfile('[number]@c.us'); * \`\`\` * */ export const getBusinessProfile = async ( contactId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_BUSINESS_PROFILE, body: contactId, }) } /** * Get all commons groups for the contact * * @example * \`\`\`javascript * const groups_ids = await wa.contact.getCommonGroups('[number]@c.us'); * \`\`\` * */ export const getCommonGroups = async (wid: Wid | string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_COMMON_GROUPS, body: wid, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getProfilePictureUrl('[number]@c.us'); * \`\`\` * */ export const getProfilePictureUrl = async ( contactId: string | Wid, full = true, ): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_PROFILE_PICTURE_URL, body: { contactId, full }, }) } /** * Get the current text status * * @example * \`\`\`javascript * await wa.contact.getStatus('[number]@c.us'); * \`\`\` */ export const getStatus = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_STATUS, body: contactId, }) } export const list = async (options: ContactListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.LIST, body: options, }) } export const isExist = async (contactId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.IS_EXIST, body: contactId, }) }
```

# src/libs/wa/group.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions } from '@wppconnect/wa-js/dist/chat' import type { GroupProperty } from '@wppconnect/wa-js/dist/group' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Add one or more participants to a group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.addParticipants('[group@g.us]', [number@c.us]); * * // Get participant result: * console.log(result['123@c.us'].code); * console.log(result['123@c.us'].invite_code); * console.log(result['123@c.us'].invite_code_exp); * console.log(result['123@c.us'].message); * console.log(result['123@c.us'].wid); * * const memberResult = result['123@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['123@c.us'].invite_code; * console.log(link); * \`\`\` */ export const addParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.ADD_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Approve a membership request to group * * @example * \`\`\`javascript * await wa.group.approve(12345645@g.us, 5554999999999@c.us); * \`\`\` * */ export const approve = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.APPROVE, body: { groupId, membershipIds }, }) } /** * Check if your account is allowed to add new participants * * @example * \`\`\`javascript * const result = await wa.group.canAdd('group@g.us'); * console.log(result); * \`\`\` */ export const canAdd = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_ADD, body: groupId, }) } /** * Check if your account is allowed to demote participants * * @example * \`\`\`javascript * await wa.group.canDemote('group@g.us'); * console.log(result); * \`\`\` */ export const canDemote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_DEMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to promote participants * * @example * \`\`\`javascript * await WPP.group.canPromote('group@g.us'); * console.log(result); * \`\`\` * */ export const canPromote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_PROMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to remove participants * * @example * \`\`\`javascript * const result = await wa.group.canRemove('group@g.us'); * console.log(result); * \`\`\` */ export const canRemove = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_REMOVE, body: { groupId, participantsIds }, }) } /** * Create a new group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.create('Test Group', ['number@c.us']); * * console.log(result.gid.toString()); // Get the group ID * * // Get participant result: * console.log(result['number@c.us'].code); * console.log(result['number@c.us'].invite_code); * console.log(result['number@c.us'].invite_code_exp); * console.log(result['number@c.us'].message); * console.log(result['number@c.us'].wid); * * const memberResult = result['number@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['number@c.us'].invite_code; * console.log(link); * * // Create a Subgroup for a community * const result = await wa.group.create('Test Group', ['number@c.us'], 'communit@g.us'); * \`\`\` */ export const create = async ( groupName: string, participantsIds: (string | Wid) | (string | Wid)[], parentGroup: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CREATE, body: { groupName, participantsIds, parentGroup }, }) } /** * @example * \`\`\`javascript * // One member * await wa.group.demoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.demoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const demoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.DEMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Get group info from an inviteCode * * @example * \`\`\`javascript * await wa.group.getGroupInfoFromInviteCode('<inviteCode>'); * \`\`\` */ export const getGroupInfoFromInviteCode = async ( inviteCode: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, body: inviteCode, }) } /** * Get the max number of participants for a group * * @example * \`\`\`javascript * const limit = await wa.group.getGroupSizeLimit(); * console.log(limit); * \`\`\` */ export const getGroupSizeLimit = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_SIZE_LIMIT, body: {}, }) } export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LIST, }) } /** * @description Sends a request to the background script to get a group's invite link. * @param groupId The ID of the group (e.g., '1234567890@g.us'). * @returns A promise that resolves with the invite link string. */ export const getInviteLink = async (groupId: string): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_INVITE_LINK, body: { groupId }, }) } /** * Retrieve a lista of a membership approval requests * * @example * \`\`\`javascript * await wa.group.getMembershipRequests(12345645@g.us); * \`\`\` */ export const getMembershipRequests = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_MEMBERSHIP_REQUESTS, body: groupId, }) } /** * Get an array of participants of a group * * @example * \`\`\`javascript * wa.group.getParticipants('[group-id]@g.us'); * \`\`\` */ export const getParticipants = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_PARTICIPANTS, body: groupId, }) } export const iAmAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_ADMIN, body: groupId, }) } export const iAmMember = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_MEMBER, body: groupId, }) } export const iAmRestrictedMember = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_RESTRICTED_MEMBER, body: groupId, }) } export const iAmSuperAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_SUPER_ADMIN, body: groupId, }) } /** * Join in a group from an invite code. * * @example * \`\`\`javascript * await wa.group.join('abcde....'); * \`\`\` */ export const join = async (inviteCode: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.JOIN, body: inviteCode, }) } /** * Leave from a group. * * @example * \`\`\`javascript * await wa.group.leave('[number]@g.us'); * \`\`\` */ export const leave = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LEAVE, body: groupId, }) } /** * Promote group member to admin * * @example * \`\`\`javascript * // One member * await wa.group.promoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.promoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` * * @category Group */ export const promoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.PROMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Reject a membership request to group * * @example * \`\`\`javascript * await wa.group.reject(12345645@g.us, 5554999999999@c.us); * \`\`\` */ export const reject = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REJECT, body: { groupId, membershipIds }, }) } /** * Remove the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.removeIcon('[group@g.us]'); * \`\`\` */ export const removeIcon = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_ICON, body: groupId, }) } /** * Remove participants of a group * * @example * \`\`\`javascript * // One member * await wa.group.removeParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.removeParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const removeParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Revoke the current invite code and generate new one. * * @example * \`\`\`javascript * const code = WPP.group.revokeInviteCode('[group-id]@g.us'); * const link = 'https://chat.whatsapp.com/' + code; * \`\`\` */ export const revokeInviteCode = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REVOKE_INVITE_CODE, body: groupId, }) } /** * Define the group description * * @example * \`\`\`javascript * await wa.group.setDescription('[group-id]@g.us', 'new group description'); * \`\`\` */ export const setDescription = async ( groupId: string | Wid, description: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_DESCRIPTION, body: { groupId, description }, }) } /** * Set the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.setIcon('[group@g.us]', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const setIcon = async ( groupId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_ICON, body: { groupId, content }, }) } /** * Set the group property * * @example * \`\`\`javascript * // Only admins can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', true); * * // All can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', false); * * // Disatble temporary messages * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 0); * * // Enable temporary messages for 24 hours * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 86400); * * // Enable temporary messages for 7 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 604800); * * // Enable temporary messages for 90 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 7776000); * * // Only admins can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', true); * * // All can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', false); * \`\`\` */ export const setProperty = async ( groupId: string | Wid, property: GroupProperty, value: 0 | 1 | 86400 | 604800 | 7776000 | boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_PROPERTY, body: { groupId, property, value }, }) } /** * Define the group subject * * @example * \`\`\`javascript * await wa.group.setSubject('[group-id]@g.us', 'new group subject'); * \`\`\` */ export const setSubject = async ( groupId: string | Wid, subject: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_SUBJECT, body: { groupId, subject }, }) }
```

# src/libs/wa/index.ts

```ts
import * as chat from './chat' import * as conn from './conn' import * as contact from './contact' import * as group from './group' import * as on from './on' import * as send from './send' export default { on, conn, send, contact, chat, group, }
```

# src/libs/wa/newsletter.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' /** * Create a newsletter * * @example * \`\`\`javascript * // To edit name * wa.newsletter.create('Name for your newsletter', { * description: 'Description for that', * picture: '<base64_string', * }); * \`\`\` */ export const create = async ( name: string, opts: { description?: string; picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.CREATE, body: { name, opts }, }) } /** * Delete a newsletter * * @example * \`\`\`javascript * const code = wa.newsletter.destroy('[newsletter-id]@newsletter'); * \`\`\` */ export const destroy = async (id: string): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.DESTROY, body: id, }) } /** * Edit the newsletter data * * @example * \`\`\`javascript * // To edit name * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * name: 'New Name' * }); * * // To edit description * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * description: 'New description' * }); * * // To change picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: '<base64_image>' * }); * * // To remove picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: null * }); * \`\`\` */ export const edit = async ( newsletterId: string, opts: { name?: string description?: string picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.EDIT, body: { newsletterId, opts }, }) } /** * Get subscribers of a newsletters * * @example * \`\`\`javascript * const code = wa.newsletter.getSubscribers('[newsletter-id]@newsletter'); * \`\`\` */ export const getSubscribers = async (id: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.GET_SUBSCRIBERS, body: id, }) } /** * Mute and unmute a newsletter * * @example * // Mute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', true); * \`\`\` * * // Unmute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', false); * \`\`\` */ export const mute = async ( newsletterId: string, value?: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.MUTE, body: { newsletterId, value }, }) }
```

# src/libs/wa/on.ts

```ts
export const ready = (callback = () => {}) => { const targetSelector = '#side' // WhatsApp left-panel root const node = document.querySelector(targetSelector) if (node) { require('@wppconnect/wa-js/dist/wppconnect-wa') callback() return } // Wait for the node to appear only once const observer = new MutationObserver(() => { const el = document.querySelector(targetSelector) if (el) { console.log('') observer.disconnect() // stop watching require('@wppconnect/wa-js/dist/wppconnect-wa') callback() } }) observer.observe(document.body, { childList: true, subtree: true, }) }
```

# src/libs/wa/profile.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { BusinessProfileModel } from '@wppconnect/wa-js/dist/whatsapp' /** * Update your business profile * * @example * \`\`\`javascript * await wa.profile.editBusinessProfile({description: 'New description for profile'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({categories: { id: "133436743388217", localized_display_name: "Artes e entretenimento", not_a_biz: false, }}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({email: 'test@test.com.br'}); * \`\`\` * * Change website of profile (max 2 sites) * \`\`\`javascript * await wa.profile.editBusinessProfile({website: [ "https://www.wppconnect.io", "https://www.teste2.com.br", ]}); * \`\`\` * * Change businessHours for Specific Hours * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { * { tue: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, wed: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, thu: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, fri: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sat: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sun: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, } }, timezone: "America/Sao_Paulo" }); * * Change businessHours for Always Opened * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "open_24h", }, tue: { mode: "open_24h", }, wed: { mode: "open_24h", }, thu: { mode: "open_24h", }, fri: { mode: "open_24h", }, sat: { mode: "open_24h", }, sun: { mode: "open_24h", }, } timezone: "America/Sao_Paulo" }); * * Change businessHours for Appointment Only * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "appointment_only", }, tue: { mode: "appointment_only", }, wed: { mode: "appointment_only", }, thu: { mode: "appointment_only", }, fri: { mode: "appointment_only", }, sat: { mode: "appointment_only", }, sun: { mode: "appointment_only", }, } timezone: "America/Sao_Paulo" }); * * */ export const editBusinessProfile = async ( params: BusinessProfileModel, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.EDIT_BUSINESS_PROFILE, body: params, }) } /** * Get your current profile name * * @example * \`\`\`javascript * const myProfileName = wa.profile.getMyProfileName(); * \`\`\` */ export const getMyProfileName = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_NAME, body: {}, }) } /** * Get your current profile picture * * @example * \`\`\`javascript * await wa.profile.getMyProfilePicture(); * \`\`\` */ export const getMyProfilePicture = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_PICTURE, body: {}, }) } /** * Get your current text status * * @example * \`\`\`javascript * await wa.profile.getMyStatus(); * \`\`\` */ export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_STATUS, body: {}, }) } /** * Return the current logged user is Bussiness or not * * @example * \`\`\`javascript * wa.profile.isBusiness(); * \`\`\` */ export const isBusiness = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.IS_BUSINESS, body: {}, }) } /** * Remove your profile picture * * @example * \`\`\`javascript * await wa.profile.removeMyProfilePicture(); * \`\`\` */ export const removeMyProfilePicture = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.REMOVE_MY_PROFILE_PICTURE, body: {}, }) } /** * Update your current profile name * * @example * \`\`\`javascript * await wa.profile.setMyProfileName('My new name'); * \`\`\` */ export const setMyProfileName = async (name: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_NAME, body: {}, }) } /** * Update your profile picture * * @example * \`\`\`javascript * await wa.profile.setMyProfilePicture('data:image/jpeg;base64,.....'); * \`\`\` */ export const setMyProfilePicture = async (content: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_PICTURE, body: content, }) } /** * Update your current text status * * @example * \`\`\`javascript * await wa.profile.setMyStatus('Example text'); * \`\`\` */ export const setMyStatus = async (statusText: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_STATUS, body: statusText, }) }
```

# src/libs/wa/send.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { AudioMessageOptions, AutoDetectMessageOptions, DocumentMessageOptions, ImageMessageOptions, LocationMessageOptions, PoolMessageOptions, SendMessageOptions, StickerMessageOptions, TextMessageOptions, VCardContact, VideoMessageOptions, } from '@wppconnect/wa-js/dist/chat' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { SendMsgResult } from '@wppconnect/wa-js/dist/whatsapp/enums' export const text = async ( chatId: any, content: any, options: TextMessageOptions = {}, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.TEXT, body: { chatId, content, options, }, }) } export const file = async ( chatId: string | Wid, content: string | Blob | File, options: | AutoDetectMessageOptions | AudioMessageOptions | DocumentMessageOptions | ImageMessageOptions | VideoMessageOptions | StickerMessageOptions | TextMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.FILE, body: { chatId, content, options, }, }) } export const location = async ( chatId: string | Wid, options: LocationMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.LOCATION, body: { chatId, options, }, }) } export const poll = async ( chatId: any, name: string, choices: string[], options?: PoolMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.POLL, body: { chatId, name, choices, options, }, }) } export const vcard = async ( chatId: string | Wid, contacts: string | Wid | VCardContact | (string | Wid | VCardContact)[], options?: SendMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.VCARD, body: { chatId, contacts, options, }, }) }
```

# src/libs/wa/status.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ImageStatusOptions, TextStatusOptions, VideoStatusOptions, } from '@wppconnect/wa-js/dist/status' import type { MsgKey, Wid } from '@wppconnect/wa-js/dist/whatsapp' export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET, body: chatId, }) } export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET_MY_STATUS, body: {}, }) } export const remove = async (msgId: string | MsgKey): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.REMOVE, body: msgId, }) } /** * Send a image message to status stories * * @example * \`\`\`javascript * wa.status.sendImageStatus('data:image/jpeg;base64,<a long base64 file...>'); * \`\`\` */ export const sendImageStatus = async ( content: any, options: ImageStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_IMAGE_STATUS, body: { content, options }, }) } /** * Mark status as read/seen * * @example * \`\`\`javascript * wa.status.sendReadStatus('[phone_number]@c.us', 'false_status@broadcast_3A169E0FD4BC6E92212F_5521526232927@c.us'); * \`\`\` */ export const sendReadStatus = async ( chatId: string | Wid, statusId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_READ_STATUS, body: { chatId, statusId }, }) } /** * Send a text message to status stories * * @example * \`\`\`javascript * wa.status.sendTextStatus(`Bootstrap primary color: #0275d8`, { backgroundColor: '#0275d8', font: 2}); * \`\`\` */ export const sendTextStatus = async ( content: any, options: TextStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_TEXT_STATUS, body: { content, options }, }) } /** * Send a video message to status stories * * @example * \`\`\`javascript * wa.status.sendVideoStatus('data:video/mp4;base64,<a long base64 file...>'); * \`\`\` */ export const sendVideoStatus = async ( content: any, options: VideoStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_VIDEO_STATUS, body: { content, options }, }) } /** * Define a custom list of participants to send the status message * * @example * \`\`\`javascript * // Use a custom list * await wa.status.updateParticipants(['123@c.us', '456@c.us']); * // Use the contacts by default * await wa.status.updateParticipants(null); * \`\`\` */ export const updateParticipants = async ( ids?: (string | Wid)[] | null, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.UPDATE_PARTICIPANTS, body: ids, }) }
```

# src/relays/blocklist.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const blockContact = () => { relay( { name: Action.Blocklist.BLOCK_CONTACT, }, async ({ body }) => { return await WPP.blocklist.blockContact(body) }, ) } const isBlocked = () => { relay( { name: Action.Blocklist.IS_BLOCKED, }, async ({ body }) => { return WPP.blocklist.isBlocked(body) }, ) } const unblockContact = () => { relay( { name: Action.Blocklist.UNBLOCK_CONTACT, }, async ({ body }) => { return WPP.blocklist.unblockContact(body) }, ) } const initBlocklistRelays = () => { all() blockContact() isBlocked() unblockContact() } export default initBlocklistRelays
```

# src/relays/cart.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const add = () => { relay( { name: Action.Cart.ADD, }, async ({ body }) => { const { chatId, products } = body return await WPP.cart.add(chatId, products) }, ) } const clear = () => { relay( { name: Action.Cart.CLEAR, }, async ({ body }) => { return await WPP.cart.clear(body) }, ) } const get = () => { relay( { name: Action.Cart.GET, }, async ({ body }) => { return WPP.cart.get(body) }, ) } const getThumbFromCart = () => { relay( { name: Action.Cart.GET_THUMB_FROM_CART, }, async ({ body }) => { return await WPP.cart.getThumbFromCart(body) }, ) } const remove = () => { relay( { name: Action.Cart.REMOVE, }, async ({ body }) => { const { chatId, productId } = body return WPP.cart.remove(chatId, productId) }, ) } const submit = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { wid, msg, options } = body return WPP.cart.submit(wid, msg, options) }, ) } const update = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { chatId, productId, options } = body return WPP.cart.update(chatId, productId, options) }, ) } const initCartRelays = () => { add() clear() get() getThumbFromCart() remove() submit() update() } export default initCartRelays
```

# src/relays/catalog.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const addProductImage = () => { relay( { name: Action.Catalog.ADD_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.addProductImage(productId, content) }, ) } const changeProductImage = () => { relay( { name: Action.Catalog.CHANGE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.changeProductImage(productId, content) }, ) } const createCollection = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { const { collectionName, productsId } = body return await WPP.catalog.createCollection(collectionName, productsId) }, ) } const createProduct = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.createProduct(body) }, ) } const deleteCollection = () => { relay( { name: Action.Catalog.DELETE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.deleteCollection(body) }, ) } const deleteProduct = () => { relay( { name: Action.Catalog.DELETE_PRODUCT, }, async ({ body }) => { return await WPP.catalog.delProducts(body) }, ) } const editCollection = () => { relay( { name: Action.Catalog.EDIT_COLLECTION, }, async ({ body }) => { const { collectionId, params } = body return await WPP.catalog.editCollection(collectionId, params) }, ) } const editProduct = () => { relay( { name: Action.Catalog.EDIT_PRODUCT, }, async ({ body }) => { const { productId, params } = body return await WPP.catalog.editProduct(productId, params) }, ) } const getCollections = () => { relay( { name: Action.Catalog.GET_COLLECTIONS, }, async ({ body }) => { const { chatId, qnt, productsCount } = body return await WPP.catalog.getCollections(chatId, qnt, productsCount) }, ) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ const getMyCatalog = () => { relay( { name: Action.Catalog.GET_MY_CATALOG, }, async ({ body }) => { return await WPP.catalog.getMyCatalog() }, ) } const getProductById = () => { relay( { name: Action.Catalog.GET_PRODUCT_BY_ID, }, async ({ body }) => { const { chatId, productId } = body return await WPP.catalog.getProductById(chatId, productId) }, ) } const getProducts = () => { relay( { name: Action.Catalog.GET_PRODUCTS, }, async ({ body }) => { const { chatId, qnt } = body return await WPP.catalog.getProducts(chatId, qnt) }, ) } const removeProductImage = () => { relay( { name: Action.Catalog.REMOVE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, index } = body return await WPP.catalog.removeProductImage(productId, index) }, ) } const setProductVisibility = () => { relay( { name: Action.Catalog.SET_PRODUCT_VISIBILITY, }, async ({ body }) => { const { productId, isHidden } = body return await WPP.catalog.setProductVisibility(productId, isHidden) }, ) } const updateCartEnabled = () => { relay( { name: Action.Catalog.UPDAGE_CART_ENABLED, }, async ({ body }) => { return await WPP.catalog.updateCartEnabled(body) }, ) } const initCatalogRelays = () => { addProductImage() changeProductImage() createCollection() createProduct() deleteCollection() deleteProduct() editCollection() editProduct() getCollections() getMyCatalog() getProductById() getProducts() removeProductImage() setProductVisibility() updateCartEnabled() } export default initCatalogRelays
```

# src/relays/chat.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const archive = () => { relay( { name: Action.Chat.ARCHIVE, }, async ({ body }) => { return await WPP.chat.archive(body) }, ) } const canMarkPlayed = () => { relay( { name: Action.Chat.CAN_MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.canMarkPlayed(body) }, ) } const canMute = () => { relay( { name: Action.Chat.CAN_MUTE, }, async ({ body }) => { return WPP.chat.canMute(body) }, ) } const canReply = () => { relay( { name: Action.Chat.CAN_REPLY, }, async ({ body }) => { return await WPP.chat.canReply(body) }, ) } const clear = () => { relay( { name: Action.Chat.CLEAR, }, async ({ body }) => { return await WPP.chat.clear(body) }, ) } const closeChat = () => { relay( { name: Action.Chat.CLOSE_CHAT, }, async ({ body }) => { return await WPP.chat.closeChat() }, ) } const _delete = () => { relay( { name: Action.Chat.DELETE, }, async ({ body }) => { return await WPP.chat.delete(body) }, ) } const deleteMessage = () => { relay( { name: Action.Chat.DELETE_MESSAGE, }, async ({ body }) => { const { chatId, ids, deleteMediaInDevice, revoke } = body return await WPP.chat.deleteMessage( chatId, ids, deleteMediaInDevice, revoke, ) }, ) } const list = () => { relay( { name: Action.Chat.LIST, }, async ({ body }) => { console.log('body', body) return (await WPP.chat.list(body)).map(serialize.chat) }, ) } const find = () => { relay( { name: Action.Chat.FIND, }, async (req) => { try { const chatId = req.body const chat = await WPP.chat.find(chatId) return response.success(serialize.chat(chat)) } catch (error) { return response.error(error.message) } }, ) } const forwardMessage = () => { relay( { name: Action.Chat.FORWARD_MESSAGE, }, async ({ body }) => { const { toChatId, msgId, options } = body return await WPP.chat.forwardMessage(toChatId, msgId, options) }, ) } const get = () => { relay( { name: Action.Chat.GET, }, async ({ body }) => { try { const chat = WPP.chat.get(body) return serialize.chat(chat) } catch (error) {} }, ) } const getActiveChat = () => { relay( { name: Action.Chat.GET_ACTIVE_CHAT, }, async (req) => { try { const chat = WPP.chat.getActiveChat() if (!chat) { return null } return serialize.chat(chat) } catch (error) { return null } }, ) } const getLastSeen = () => { relay( { name: Action.Chat.GET_LAST_SEEN, }, async ({ body }) => { return await WPP.chat.getLastSeen(body) }, ) } const getMessageACK = () => { relay( { name: Action.Chat.GET_MESSAGE_ACK, }, async ({ body }) => { return await WPP.chat.getMessageACK(body) }, ) } const getMessages = () => { relay( { name: Action.Chat.GET_MESSAGES, }, async ({ body }) => { const { chatId, options } = body const messages = await WPP.chat.getMessages(chatId, options) return messages.map(serialize.message) }, ) } const getNotes = () => { relay( { name: Action.Chat.GET_NOTES, }, async ({ body }) => { return await WPP.chat.getNotes(body) }, ) } const getPlatformFromMessage = () => { relay( { name: Action.Chat.GET_PLATFORM_MESSAGE, }, async ({ body }) => { return WPP.chat.getPlatformFromMessage(body) }, ) } const markIsComposing = () => { relay( { name: Action.Chat.MARK_IS_COMPOSING, }, async ({ body }) => { const { chatId, duration } = body return WPP.chat.markIsComposing(chatId, duration) }, ) } const markIsPaused = () => { relay( { name: Action.Chat.MARK_IS_PAUSED, }, async ({ body }) => { return await WPP.chat.markIsPaused(body) }, ) } const markIsRead = () => { relay( { name: Action.Chat.MARK_IS_READ, }, async ({ body }) => { return await WPP.chat.markIsRead(body) }, ) } const markIsRecording = () => { relay( { name: Action.Chat.MARK_IS_RECORDING, }, async ({ body }) => { return await WPP.chat.markIsRecording(body) }, ) } const markIsUnread = () => { relay( { name: Action.Chat.MARK_IS_UNREAD, }, async ({ body }) => { return await WPP.chat.markIsUnread(body) }, ) } const markPlayed = () => { relay( { name: Action.Chat.MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.markPlayed(body) }, ) } const mute = () => { relay( { name: Action.Chat.MUTE, }, async ({ body }) => { const { chatId, time } = body return await WPP.chat.mute(chatId, time) }, ) } const openChatAt = () => { relay( { name: Action.Chat.OPEN_CHAT_AT, }, async ({ body }) => { const { chatId, messageId } = body return await WPP.chat.openChatAt(chatId, messageId) }, ) } const openChatFromUnread = () => { relay( { name: Action.Chat.OPEN_CHAT_FROM_UNREAD, }, async ({ body }) => { return await WPP.chat.openChatFromUnread(body) }, ) } const pinMsg = () => { relay( { name: Action.Chat.PIN_MSG, }, async ({ body }) => { const { msgId, pin, seconds } = body return await WPP.chat.pinMsg(msgId, pin, seconds) }, ) } const openChatBottom = () => { relay( { name: Action.Chat.OPEN_CHAT_BOTTOM, }, async (req) => { try { const chatId = req.body return await WPP.chat.openChatBottom(chatId) } catch (error) { return false } }, ) } const setChatList = () => { relay( { name: Action.Chat.SET_CHAT_LIST, }, async (req) => { try { const { type, ids } = req.body await WPP.chat.setChatList(type, ids) } catch (error) { console.error(`setChatList: ${error}`) } }, ) } const setInputText = () => { relay( { name: Action.Chat.SET_INPUT_TEXT, }, async ({ body }) => { const { text, chatId } = body return await WPP.chat.setInputText(text, chatId) }, ) } const setNotes = () => { relay( { name: Action.Chat.SET_NOTES, }, async ({ body }) => { const { chatId, content } = body return await WPP.chat.setNotes(chatId, content) }, ) } const downloadMedia = () => { relay( { name: Action.Chat.DOWNLOAD_MEDIA, }, async ({ body: messageId }) => { try { const media = await Promise.race([ WPP.chat.downloadMedia(messageId), new Promise((_, reject) => setTimeout(() => reject(new Error('Error download media')), 3000), ), ]) return media } catch (error) { return null } }, ) } const initChatRelay = () => { archive() canMarkPlayed() canMute() canReply() clear() closeChat() _delete() deleteMessage() downloadMedia() find() forwardMessage() get() getActiveChat() getLastSeen() getMessageACK() getMessages() getNotes() getPlatformFromMessage() markIsComposing() markIsPaused() markIsRead() markIsRecording() markIsUnread() markPlayed() mute() list() openChatBottom() openChatAt() openChatFromUnread() pinMsg() setChatList() setInputText() setNotes() } export default initChatRelay
```

# src/relays/community.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const initCommunityRelays = () => { all() } export default initCommunityRelays
```

# src/relays/conn.relay.ts

```ts
import { Account, Action } from '@/constants' import country from '@/utils/country' import { delay } from '@/utils/util' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const genLinkDeviceCodeForPhoneNumber = () => { relay( { name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }, async ({ body }) => { const { phone, sendPushNotification } = body return await WPP.conn.genLinkDeviceCodeForPhoneNumber( phone, sendPushNotification, ) }, ) } const getAuthCode = () => { relay( { name: Action.Conn.GET_AUTH_CODE, }, async ({ body }) => { return await WPP.conn.getAuthCode() }, ) } const getMyUserId = () => { relay( { name: Action.Conn.GET_MY_USER_ID, }, async (req) => { return WPP.conn.getMyUserId() }, ) } const getProfile = () => { relay( { name: Action.Conn.GET_PROFILE, }, async (req) => { await delay(1000) const { user: number } = WPP.conn.getMyUserId() const contact = await WPP.contact.get(`${number}@c.us`) const countryCode = await WPP.whatsapp.functions.getCountryShortcodeByPhone(contact.id.user) const selectedCountry = country.getCountryByCode(countryCode) return { name: contact.pushname || contact.formattedName || contact.name || contact.verifiedName, number, type: contact.isBusiness ? Account.BUSINESS : Account.PERSONAL, country: selectedCountry.label, } }, ) } const initConnRelays = () => { genLinkDeviceCodeForPhoneNumber() getAuthCode() getMyUserId() getProfile() } export default initConnRelays
```

# src/relays/contact.relay.ts

```ts
import { Action } from '@/constants' import filterBy from '@/utils/filterBy' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Contact.GET, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getBusinessProfile = () => { relay( { name: Action.Contact.GET_BUSINESS_PROFILE, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getCommonGroups = () => { relay( { name: Action.Contact.GET_COMMON_GROUPS, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getProfilePictureUrl = () => { relay( { name: Action.Contact.GET_PROFILE_PICTURE_URL, }, async ({ body }) => { const { contactId, full } = body return await WPP.contact.getProfilePictureUrl(contactId, full) }, ) } const getStatus = () => { relay( { name: Action.Contact.GET_STATUS, }, async ({ body }) => { return await WPP.contact.getStatus(body) }, ) } const list = () => { relay( { name: Action.Contact.LIST, }, async (req) => { const options = req.body const contacts = ((await WPP.contact.list(options)) ?? []) .filter(filterBy.dontIncludeLid) .map(serialize.contact) return contacts }, ) } const isExist = () => { relay( { name: Action.Contact.IS_EXIST, }, async (req) => { try { const contactId = req.body const result = await WPP.contact.queryExists(contactId) return !!result } catch (error) { return false } }, ) } const initContactRelay = () => { get() getBusinessProfile() getCommonGroups() getProfilePictureUrl() getStatus() isExist() list() } export default initContactRelay
```

# src/relays/group.relay.ts

```ts
import { Action } from '@/constants' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' import { contact } from '@wppconnect/wa-js' import _ from 'lodash' const addParticipants = () => { relay( { name: Action.Group.ADD_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.addParticipants(groupId, participantsIds) }, ) } const approve = () => { relay( { name: Action.Group.APPROVE, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.approve(groupId, membershipIds) }, ) } const canAdd = () => { relay( { name: Action.Group.CAN_ADD, }, async ({ body }) => { return await WPP.group.canAdd(body) }, ) } const canDemote = () => { relay( { name: Action.Group.CAN_DEMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canDemote(groupId, participantsIds) }, ) } const canPromote = () => { relay( { name: Action.Group.CAN_PROMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canPromote(groupId, participantsIds) }, ) } const canRemove = () => { relay( { name: Action.Group.CAN_REMOVE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canRemove(groupId, participantsIds) }, ) } const create = () => { relay( { name: Action.Group.CREATE, }, async ({ body }) => { const { groupName, participantsIds, parentGroup } = body return await WPP.group.create(groupName, participantsIds, parentGroup) }, ) } const demoteParticipants = () => { relay( { name: Action.Group.DEMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.demoteParticipants(groupId, participantsIds) }, ) } const getGroupInfoFromInviteCode = () => { relay( { name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, }, async ({ body }) => { return await WPP.group.getGroupInfoFromInviteCode(body) }, ) } const getGroupSizeLimit = () => { relay( { name: Action.Group.GET_GROUP_SIZE_LIMIT, }, async ({ body }) => { return await WPP.group.getGroupSizeLimit() }, ) } const list = () => { relay( { name: Action.Group.LIST, }, async ({ body }) => { try { const me = WPP.conn.getMyUserId() const groups = (await WPP.chat.list({ onlyGroups: true })).map( (group) => { const participants = group.groupMetadata.participants .getModelsArray() .map(serialize.participant) .filter( (participant) => participant.contact.phoneNumber?.user !== me.user, ) const id = `${group.id.user}@${group.id.server}` return { id, name: group.name || group.formattedTitle, desc: group.groupMetadata?.desc, avatar: group.contact?.getProfilePicThumb().__x_eurl, size: group.groupMetadata?.size, participants, isAdmin: group.groupMetadata?.participants?.iAmAdmin(), isSuperAdmin: group.groupMetadata?.participants?.iAmSuperAdmin(), superAdmin: serialize.contact( group.groupMetadata?.participants?.getSuperAdmin()?.contact, ), admins: group.groupMetadata?.participants ?.getAdmins() .map((participant) => serialize.contact(participant.contact)), } }, ) return _.sortBy(groups, 'name') } catch (error) { return [] } }, ) } const getInviteLink = () => { relay( { name: Action.Group.GET_INVITE_LINK, }, async (req) => { try { const { groupId } = req.body const link = await WPP.group.getInviteCode(groupId) return `https://chat.whatsapp.com/${link}` } catch (error) { console.error(`getInviteLink relay error: ${error}`) return null } }, ) } const getMembershipRequests = () => { relay( { name: Action.Group.GET_MEMBERSHIP_REQUESTS, }, async ({ body }) => { return await WPP.group.getMembershipRequests(body) }, ) } const getParticipants = () => { relay( { name: Action.Group.GET_PARTICIPANTS, }, async ({ body }) => { try { const participants = await WPP.group.getParticipants(body) return participants.map(serialize.participant) } catch (error) { return [] } }, ) } const iAmAdmin = () => { relay( { name: Action.Group.IAM_ADMIN, }, async ({ body }) => { return await WPP.group.iAmAdmin(body) }, ) } const iAmMember = () => { relay( { name: Action.Group.IAM_MEMBER, }, async ({ body }) => { return await WPP.group.iAmMember(body) }, ) } const iAmRestrictedMember = () => { relay( { name: Action.Group.IAM_RESTRICTED_MEMBER, }, async ({ body }) => { return await WPP.group.iAmRestrictedMember(body) }, ) } const iAmSuperAdmin = () => { relay( { name: Action.Group.IAM_SUPER_ADMIN, }, async ({ body }) => { return await WPP.group.iAmSuperAdmin(body) }, ) } const join = () => { relay( { name: Action.Group.JOIN, }, async ({ body }) => { return await WPP.group.join(body) }, ) } const leave = () => { relay( { name: Action.Group.LEAVE, }, async ({ body }) => { return await WPP.group.leave(body) }, ) } const promoteParticipants = () => { relay( { name: Action.Group.PROMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.promoteParticipants(groupId, participantsIds) }, ) } const reject = () => { relay( { name: Action.Group.REJECT, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.reject(groupId, membershipIds) }, ) } const removeIcon = () => { relay( { name: Action.Group.REMOVE_ICON, }, async ({ body }) => { return await WPP.group.removeIcon(body) }, ) } const removeParticipants = () => { relay( { name: Action.Group.REMOVE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.removeParticipants(groupId, participantsIds) }, ) } const revokeInviteCode = () => { relay( { name: Action.Group.REVOKE_INVITE_CODE, }, async ({ body }) => { return await WPP.group.revokeInviteCode(body) }, ) } const setDescription = () => { relay( { name: Action.Group.SET_DESCRIPTION, }, async ({ body }) => { const { groupId, description } = body return await WPP.group.setDescription(groupId, description) }, ) } const setIcon = () => { relay( { name: Action.Group.SET_ICON, }, async ({ body }) => { const { groupId, content } = body return await WPP.group.setIcon(groupId, content) }, ) } const setProperty = () => { relay( { name: Action.Group.SET_PROPERTY, }, async ({ body }) => { const { groupId, property, value } = body return await WPP.group.setProperty(groupId, property, value) }, ) } const setSubject = () => { relay( { name: Action.Group.SET_SUBJECT, }, async ({ body }) => { const { groupId, subject } = body return await WPP.group.setSubject(groupId, subject) }, ) } const initGroupRelay = () => { addParticipants() approve() canAdd() canDemote() canPromote() canRemove() create() demoteParticipants() getInviteLink() getGroupInfoFromInviteCode() getGroupSizeLimit() getMembershipRequests() getParticipants() list() iAmAdmin() iAmMember() iAmRestrictedMember() iAmSuperAdmin() join() leave() promoteParticipants() reject() removeIcon() removeParticipants() revokeInviteCode() setDescription() setIcon() setProperty() setSubject() } export default initGroupRelay
```

# src/relays/index.ts

```ts
import initBlocklistRelays from './blocklist.relay' import initCartRelays from './cart.relay' import initChatRelay from './chat.relay' import initConnRelays from './conn.relay' import initContactRelay from './contact.relay' import initGroupRelay from './group.relay' import initSendRelay from './send.relay' import initStatusRelay from './status.relay' export const initInjectScriptRelays = () => { initBlocklistRelays() initCartRelays() initChatRelay() initConnRelays() initContactRelay() initGroupRelay() initSendRelay() initStatusRelay() }
```

# src/relays/newsletter.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const create = () => { relay( { name: Action.Newsletter.CREATE, }, async ({ body }) => { const { name, opts } = body return await WPP.newsletter.create(name, opts) }, ) } const destroy = () => { relay( { name: Action.Newsletter.DESTROY, }, async ({ body }) => { return await WPP.newsletter.destroy(body) }, ) } const edit = () => { relay( { name: Action.Newsletter.EDIT, }, async ({ body }) => { const { newsletterId, opts } = body return await WPP.newsletter.edit(newsletterId, opts) }, ) } const getSubscribers = () => { relay( { name: Action.Newsletter.GET_SUBSCRIBERS, }, async ({ body }) => { return await WPP.newsletter.getSubscribers(body) }, ) } const mute = () => { relay( { name: Action.Newsletter.MUTE, }, async ({ body }) => { const { newsletterId, value } = body return await WPP.newsletter.mute(newsletterId, value) }, ) } const initNewsletterRelay = () => { create() destroy() edit() getSubscribers() mute() } export default initNewsletterRelay
```

# src/relays/profile.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Profile.EDIT_BUSINESS_PROFILE, }, async ({ body }) => { return WPP.status.get(body) }, ) } const initProfileRelays = () => { get() } export default initProfileRelays
```

# src/relays/send.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const sendText = () => { relay( { name: Action.Send.TEXT, }, async (req) => { try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendTextMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendFile = () => { relay( { name: Action.Send.FILE, }, async (req) => { console.log('req', req) try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendFileMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendLocation = () => { relay( { name: Action.Send.LOCATION, }, async (req) => { try { const { chatId, options } = req.body const { sendMsgResult } = await WPP.chat.sendLocationMessage( chatId, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendPoll = () => { relay( { name: Action.Send.POLL, }, async (req) => { try { const { chatId, name, choices, options } = req.body const { sendMsgResult } = await WPP.chat.sendCreatePollMessage( chatId, name, choices, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendVCard = () => { relay( { name: Action.Send.VCARD, }, async (req) => { try { const { chatId, contacts, options } = req.body const { sendMsgResult } = await WPP.chat.sendVCardContactMessage( chatId, contacts, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const initSendRelay = () => { sendText() sendFile() sendLocation() sendPoll() sendVCard() } export default initSendRelay
```

# src/relays/status.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Status.GET, }, async ({ body }) => { return WPP.status.get(body) }, ) } const getMyStatus = () => { relay( { name: Action.Status.GET_MY_STATUS, }, async ({ body }) => { return await WPP.status.getMyStatus() }, ) } const remove = () => { relay( { name: Action.Status.REMOVE, }, async ({ body }) => { return await WPP.status.remove(body) }, ) } const sendImageStatus = () => { relay( { name: Action.Status.SEND_IMAGE_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendImageStatus(content, options) }, ) } const sendReadStatus = () => { relay( { name: Action.Status.SEND_READ_STATUS, }, async ({ body }) => { const { chatId, statusId } = body return await WPP.status.sendReadStatus(chatId, statusId) }, ) } const sendTextStatus = () => { relay( { name: Action.Status.SEND_TEXT_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendTextStatus(content, options) }, ) } const sendVideoStatus = () => { relay( { name: Action.Status.SEND_VIDEO_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendVideoStatus(content, options) }, ) } const updateParticipants = () => { relay( { name: Action.Status.UPDATE_PARTICIPANTS, }, async ({ body }) => { return await WPP.status.updateParticipants(body) }, ) } const initStatusRelay = () => { get() getMyStatus() remove() sendImageStatus() sendReadStatus() sendTextStatus() sendVideoStatus() updateParticipants() } export default initStatusRelay
```

# src/stores/app.ts

```ts
import type { License } from '@/types' import { create } from 'zustand' interface AppState { isReady: boolean setIsReady: (isReady: boolean) => void profile: any setProfile: (profile: any) => void license?: License | null setLicense: (license: any) => void groups: any[] setGroups: (groups: []) => void isLoading: boolean setIsLoading: (state: boolean) => void activeChat: any setActiveChat: (chat: any) => void } export const useAppStore = create<AppState>((set) => ({ isReady: false, setIsReady: (isReady: boolean) => set({ isReady }), license: null, setLicense: (license: any) => set({ license: license }), groups: [], setGroups: (groups: []) => set({ groups }), profile: {}, setProfile: (profile: any) => set({ profile }), isLoading: false, setIsLoading: (state: any) => set({ isLoading: state }), activeChat: {}, setActiveChat: (chat: any) => set({ activeChat: chat }), }))
```

# src/stores/toast.ts

```ts
import { create } from 'zustand' export interface Toast { id: number type: 'success' | 'error' | 'info' | 'warning' title: string message: string duration?: number } interface ToastState { toasts: Toast[] addToast: (toast: Omit<Toast, 'id'>) => void removeToast: (id: number) => void } export const useToastStore = create<ToastState>((set) => ({ toasts: [], addToast: (toast) => set((state) => ({ toasts: [...state.toasts, { ...toast, id: Date.now() }], })), removeToast: (id) => set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id), })), }))
```

# src/styles/globals.css

```css
div.plasmo-csui-container { margin: 0; color-scheme: var(--mantine-color-scheme); font-family: var(--mantine-font-family); font-size: var(--mantine-font-size-md); line-height: var(--mantine-line-height); background-color: var(--mantine-color-body); color: var(--mantine-color-text); -webkit-font-smoothing: var(--mantine-webkit-font-smoothing); -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing); right: 0px; left: auto !important; } .root { position: fixed; top: '30%'; left: '50%'; transform: 'translate(-50%, -50%)'; z-index: 1001; background-color: red; } #plasmo-inline { background: transparent; }
```

# src/tabs/landing-page.tsx

```tsx
// src/tabs/landing-page.tsx import { PRIMARY_ICON } from '@/constants' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { Accordion, Anchor, Avatar, Badge, Box, Button, Card, Center, Container, Divider, Grid, Group, List, MantineProvider, Paper, Stack, Table, Text, ThemeIcon, Title, Tooltip, Transition, } from '@mantine/core' import '@mantine/core/styles.css' import { useWindowScroll } from '@mantine/hooks' import React, { useEffect, useState } from 'react' // --- Start: Updated Config for Group Link Generator Focus --- // Define a structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // Centralized list of features for easy management and comparison const comparisonFeatures: PlanFeature[] = [ { feature: 'Generate Invite Links for Groups', free: true, pro: true }, { feature: 'Select a Single Group', free: true, pro: true }, { feature: 'Revoke Links from History', free: true, pro: true }, { feature: 'Select Multiple Groups at Once', free: false, pro: true }, { feature: 'Generate & Download QR Codes for Links', free: false, pro: true }, { feature: 'Export Links to CSV/Excel', free: false, pro: true }, { feature: 'Link Generation History', free: 'Last 5 Links', pro: 'Unlimited', }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, ] // Define plan objects for the pricing cards. const plans = [ { name: 'Free', isFree: true, description: 'For basic group link management.', price: '$0', placeholderPrice: null, link: '#', features: [ 'Generate unlimited links (one by one)', 'Revoke links anytime', 'View recent link history (last 5)', 'Standard support', ], }, { name: 'Pro Lifetime', isFree: false, description: 'Pay once, unlock powerful tools to manage all your groups.', placeholderPrice: '$89', price: '$29', link: 'https://extdotninja.lemonsqueezy.com/buy/53f1c17b-8636-49cf-b454-ab0ad2700418?media=0&logo=0&desc=0&discount=0', features: [ 'Generate Links for Multiple Groups at Once', 'Generate & Download QR Codes', 'Export Links to CSV & Excel', 'Unlimited Link History', 'Priority Customer Support', 'All Future Updates Included', ], }, ] // --- End: Updated Config --- const CheckIcon = () => ( <Icon icon="tabler:check" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-teal-6)" /> ) const CrossIcon = () => ( <Icon icon="tabler:x" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-red-6)" /> ) // --- Countdown Timer Logic --- interface TimeLeft { days: number hours: number minutes: number seconds: number } const calculateTimeLeft = (offerEndDate: Date): TimeLeft | null => { const difference = +offerEndDate - +new Date() if (difference <= 0) { return null } return { days: Math.floor(difference / (1000 * 60 * 60 * 24)), hours: Math.floor((difference / (1000 * 60 * 60)) % 24), minutes: Math.floor((difference / 1000 / 60) % 60), seconds: Math.floor((difference / 1000) % 60), } } const TimeSegment: React.FC<{ value: number; label: string }> = ({ value, label, }) => ( <Stack align="center" gap={0}> <Text fz={32} fw={700} c="yellow.6"> {' '} {String(value).padStart(2, '0')}{' '} </Text> <Text size="xs" c="dimmed"> {' '} {label}{' '} </Text> </Stack> ) const CountdownTimer: React.FC<{ offerEndDate: Date; isMini?: boolean }> = ({ offerEndDate, isMini = false, }) => { const [timeLeft, setTimeLeft] = useState<TimeLeft | null>( calculateTimeLeft(offerEndDate), ) useEffect(() => { const timer = setInterval(() => { setTimeLeft(calculateTimeLeft(offerEndDate)) }, 1000) return () => clearInterval(timer) }, [offerEndDate]) if (!timeLeft) { return ( <Text c="red.7" fw={700} size="lg"> {' '} Offer has ended!{' '} </Text> ) } if (isMini) { return ( <Text c="white" size="sm" fw={500}> {' '} Offer Ends In: {String(timeLeft.days).padStart(2, '0')}: {String(timeLeft.hours).padStart(2, '0')}: {String(timeLeft.minutes).padStart(2, '0')}: {String(timeLeft.seconds).padStart(2, '0')} </Text> ) } return ( <Group justify="center" gap="lg"> <TimeSegment value={timeLeft.days} label="DAYS" /> <TimeSegment value={timeLeft.hours} label="HOURS" /> <TimeSegment value={timeLeft.minutes} label="MINUTES" /> <TimeSegment value={timeLeft.seconds} label="SECONDS" /> </Group> ) } // --- End Countdown Timer Logic --- // --- Section Components --- const HeroSection = () => ( <Center p="xl" pt={80}> <Stack align="center" gap="xl" ta="center" maw={700}> <ThemeIcon size={80} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon="tabler:ticket" fontSize={48} /> </ThemeIcon> <Title order={1} fz={{ base: 36, sm: 48 }}> {' '} Instantly Get Invite Links for All Your WhatsApp Groups.{' '} </Title> <Text c="dimmed" fz="lg"> {' '} The fastest way to generate, share, and manage invite links for multiple groups at once. Stop wasting time digging through settingsget all your links in seconds.{' '} </Text> <Stack align="center"> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > {' '} Get Lifetime Access to Pro Features{' '} </Button> <Text size="xs" c="dimmed"> {' '} Includes 30-day money-back guarantee{' '} </Text> </Stack> </Stack> </Center> ) const FeaturesSection = () => { const featuresData = [ { icon: 'tabler:ticket', title: 'Bulk Link Generation', description: 'Select multiple groups you admin and generate all their invite links with a single click. Perfect for community managers and event organizers.', }, { icon: 'tabler:share', title: 'Easy Sharing Options', description: 'Copy links with a custom message, generate a downloadable QR code for easy sharing, or export your entire list to CSV/Excel for your records (Pro Features).', }, { icon: 'tabler:shield-lock', title: 'Private & Secure', description: 'Your group information and links are managed directly via WhatsApp Web. We never see, store, or have access to your groups or conversations.', }, { icon: 'tabler:history', title: 'Manage Link History', description: 'Keep track of every link you generate. See when it was created and easily revoke old links directly from the history panel when you no longer need them.', }, { icon: 'tabler:rocket', title: 'Simple & Fast', description: 'A clean, intuitive interface integrated into WhatsApp Web, designed to get your group links in seconds, not minutes.', }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>A Smarter Way to Manage Groups</Title> <Text c="dimmed"> {' '} Unlock powerful features that make managing group invites faster and more efficient.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {featuresData.map((feature) => ( <Grid.Col span={{ base: 12, md: 4 }} key={feature.title}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon={feature.icon} fontSize={22} /> </ThemeIcon> <Text fw={700} fz="lg"> {' '} {feature.title}{' '} </Text> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} {feature.description}{' '} </Text> </Card> </Grid.Col> ))} </Grid> </Box> ) } const UserPersonaSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Built For Community Builders</Title> <Text c="dimmed"> {' '} Whether you're managing a business community or a personal group, we've got you covered.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:briefcase" fontSize={22} /> </ThemeIcon> <Title order={3}>For Community & Marketing Managers</Title> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} Effortlessly onboard new members to multiple communities, share links in marketing campaigns, or provide support staff with easy access to all group invites.{' '} </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> {' '} Generate links for all your regional or product-specific groups at once.{' '} </List.Item> <List.Item> {' '} Export a list of links for use in email newsletters or social media posts.{' '} </List.Item> <List.Item> {' '} Generate QR codes for posters and event flyers.{' '} </List.Item> </List> <Button component="a" href="#pricing" mt="auto" variant="light" color="teal" > {' '} Upgrade for Business Needs{' '} </Button> </Stack> </Card> </Grid.Col> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:users" fontSize={22} /> </ThemeIcon> <Title order={3}>For Event & Group Organizers</Title> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} Quickly get invite links for your hobby groups, family events, or study circles. Share links easily with friends and new members without the hassle.{' '} </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> {' '} Get a link for your new book club or sports team.{' '} </List.Item> <List.Item> {' '} Generate a QR code to let friends join a party group.{' '} </List.Item> <List.Item> {' '} Revoke old links after an event is over to maintain privacy.{' '} </List.Item> </List> <Button component="a" href="#pricing" mt="auto" variant="light" color="teal" > {' '} Get More Convenience{' '} </Button> </Stack> </Card> </Grid.Col> </Grid> </Box> ) const CaseStudySection = () => { const caseStudies = [ { icon: 'tabler:building-community', title: 'Onboarding New Team Members', description: 'A company manager needs to add new hires to five different project and social groups. Instead of opening each group manually, they use the extension to generate all five links at once and share them in a single welcome email.', features: ['Bulk Generation', 'Time-Saving'], }, { icon: 'tabler:podium', title: 'Promoting a Workshop', description: 'An event organizer wants to let attendees join a pre-event WhatsApp group. They generate an invite link and a QR code, which they add to their presentation slides and promotional flyers for easy access.', features: ['QR Code Generation', 'Easy Sharing'], }, { icon: 'tabler:user-off', title: 'Securing a Private Group', description: "After a project concludes, a team leader needs to prevent new members from joining a temporary group. They find the link in their history and instantly revoke it, securing the group's privacy without needing to find the original link.", features: ['Link History', 'Revoke Links'], }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Solves Real-World Problems</Title> <Text c="dimmed"> {' '} See how people use our tool to make communication faster and easier.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {caseStudies.map((study) => ( <Grid.Col span={{ base: 12, md: 4 }} key={study.title}> <Card withBorder radius="lg" p="xl" style={{ height: '100%', display: 'flex', flexDirection: 'column', }} > <Stack style={{ flexGrow: 1 }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon={study.icon} fontSize={22} /> </ThemeIcon> <Title order={4}>{study.title}</Title> </Group> <Text c="dimmed" size="sm" mt="sm"> {' '} {study.description}{' '} </Text> </Stack> <Group gap="xs" mt="lg"> {study.features.map((feature) => ( <Badge key={feature} variant="light" color="teal"> {feature} </Badge> ))} </Group> </Card> </Grid.Col> ))} </Grid> </Box> ) } const PricingSection: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => ( <Box mt={80} id="pricing"> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Get a Lifetime License</Title> <Text c="dimmed">One single payment. All Pro features forever.</Text> </Stack> </Center> <Group justify="center" align="stretch" mt="xl" gap="lg"> {plans.map((plan, index) => ( <Paper key={index} withBorder w={{ base: '100%', sm: 380 }} radius={'lg'} p="xl" style={{ border: !plan.isFree ? '2px solid var(--mantine-color-teal-6)' : undefined, boxShadow: !plan.isFree ? 'var(--mantine-shadow-lg)' : 'var(--mantine-shadow-sm)', position: 'relative', }} > <Stack justify="space-between" style={{ height: '100%' }}> <Box ta="center"> <Title order={2}>{plan.name}</Title> <Text c="dimmed" mt={4} size="sm"> {' '} {plan.description}{' '} </Text> </Box> <Box my="lg" ta="center"> {!plan.isFree && ( <Stack mb="lg"> <Title order={4} c="orange.7"> {' '} LAUNCH OFFER: 56% OFF ENDS SOON!{' '} </Title> <CountdownTimer offerEndDate={offerEndDate} /> <Text size="xs" c="dimmed" mt="xs"> {' '} Don't miss out on saving $50. Price returns to normal after the timer ends.{' '} </Text> </Stack> )} <Box pos="relative"> <Group gap={8} align={'baseline'} justify="center"> {plan.placeholderPrice && ( <Title order={3} c={'dimmed'} style={{ textDecorationLine: 'line-through' }} > {' '} {plan.placeholderPrice}{' '} </Title> )} <Title order={1} fz={52}> {' '} {plan.price}{' '} </Title> </Group> </Box> </Box> <Divider label="Key Features" labelPosition="center" my="sm" /> <Stack gap="sm" mb="lg"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="sm" wrap="nowrap" align="flex-start"> <ThemeIcon variant="light" color={plan.isFree ? 'gray' : 'teal'} size="sm" radius="xl" > {plan.isFree ? ( <Icon icon="tabler:circle-check" fontSize={16} /> ) : ( <Icon icon="tabler:star" fontSize={16} /> )} </ThemeIcon> <Text size="sm">{feature}</Text> </Group> ))} </Stack> <Box mt="auto"> {plan.isFree ? ( <Button size="md" variant="default" fullWidth disabled> {' '} Your Current Plan{' '} </Button> ) : ( <Stack gap="xs"> <Button size="lg" component="a" href={plan.link} target="_blank" fullWidth leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Upgrade to Pro{' '} </Button> <Stack gap={4} align="center" mt="xs"> <Group justify="center" gap={6}> <Icon icon="tabler:lock" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> {' '} 100% Secure Payment via Lemon Squeezy{' '} </Text> </Group> <Group justify="center" gap={6}> <Icon icon="tabler:shield-check" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> {' '} 30-Day Money-Back Guarantee{' '} </Text> </Group> </Stack> </Stack> )} </Box> </Stack> </Paper> ))} </Group> </Box> ) const NoSubscriptionSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>No Monthly Fees. Own It Forever.</Title> <Text c="dimmed"> {' '} Forget recurring subscription costs. With the Pro version, you pay once for lifetime access to all current features and future updates.{' '} </Text> <Card withBorder p="xl" radius="lg" mt="md" w="100%"> <Grid align="center"> <Grid.Col span={5} ta="center"> <Stack align="center"> <Icon icon="tabler:calendar-dollar" fontSize={48} color="var(--mantine-color-red-6)" /> <Text fw={500}>Endless Subscriptions</Text> <Icon icon="tabler:x" fontSize={32} color="var(--mantine-color-red-6)" /> </Stack> </Grid.Col> <Grid.Col span={2}> <Center> <Divider orientation="vertical" /> </Center> </Grid.Col> <Grid.Col span={5} ta="center"> <Stack align="center"> <Icon icon="tabler:pig-money" fontSize={48} color="var(--mantine-color-teal-6)" /> <Text fw={500}>One-Time Payment</Text> <Icon icon="tabler:check" fontSize={32} color="var(--mantine-color-teal-6)" /> </Stack> </Grid.Col> </Grid> </Card> </Stack> </Center> </Box> ) const FeatureComparisonTable = () => ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> {' '} Features Comparison{' '} </Title> </Center> <Card withBorder radius="lg" p={0}> <Table striped highlightOnHover verticalSpacing="md" fz="sm"> <Table.Thead> <Table.Tr> <Table.Th w="40%">Feature</Table.Th> <Table.Th ta="center">Free</Table.Th> <Table.Th ta="center">Pro</Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {comparisonFeatures.map((item) => ( <Table.Tr key={item.feature} style={{ backgroundColor: item.free === false ? 'var(--mantine-color-teal-0)' : undefined, }} > <Table.Td> <Group gap="xs" justify="space-between"> <Text fw={500}>{item.feature}</Text> </Group> </Table.Td> <Table.Td ta="center"> {typeof item.free === 'boolean' ? ( item.free ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Text size="sm">{item.free}</Text> )} </Table.Td> <Table.Td ta="center"> {typeof item.pro === 'boolean' ? ( item.pro ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Badge color="teal" variant="light"> {' '} {item.pro}{' '} </Badge> )} </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </Card> </Box> ) const SecuritySection = () => ( <Box mt={80}> <Card withBorder p="xl" radius="lg" bg="gray.0"> <Grid align="center"> <Grid.Col span={{ base: 12, md: 2 }} ta="center"> <ThemeIcon size={80} radius="xl" variant="light" color="teal"> <Icon icon="tabler:shield-lock" fontSize={48} /> </ThemeIcon> </Grid.Col> <Grid.Col span={{ base: 12, md: 10 }}> <Title order={2}>Your Privacy is Our Top Priority</Title> <Text c="dimmed" mt="md"> {' '} We designed this extension with a "privacy-first" approach. You have complete and total control over your data, always.{' '} </Text> <List mt="md" spacing="xs" size="sm" icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> {' '} <b>Direct Actions:</b> Your links are generated directly through the official WhatsApp Web interface.{' '} </List.Item> <List.Item> {' '} <b>No Data Storage:</b> We never see, save, or have access to your groups, contacts, or conversations.{' '} </List.Item> <List.Item> {' '} <b>You Are in Control:</b> All actions happen on your own computer, under your control.{' '} </List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const TestimonialsSection = () => { const testimonialsData = [ { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-5.png', name: 'David G.', role: 'Community Manager', quote: 'Managing over 20 WhatsApp groups was a nightmare. This tool lets me get all my invite links in a single click. The <b>ability to export to Excel and generate QR codes</b> has streamlined my entire workflow. An absolute must-have for any community manager.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-4.png', name: 'Alisha C.', role: 'Event Coordinator', quote: "For my events, I create temporary groups. This extension not only lets me generate the link quickly but also <b>lets me revoke it from the history</b> once the event is over. It's brilliant for maintaining control and privacy.", }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-8.png', name: 'Sarah L.', role: 'Small Business Owner', quote: 'I run several local business groups. Being able to <b>generate multiple links at once</b> saves me so much time when I cross-promote them. The Pro upgrade was an immediate purchase for me.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-2.png', name: 'Mike P.', role: 'Hobby Group Admin', quote: 'Just needed a quick way to get an invite link without all the clicking. This does exactly that. Simple, fast, and works perfectly. The <b>link history is a nice touch</b>!', }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Trusted by Users Like You</Title> <Text c="dimmed"> {' '} See what our happy customers are saying about the Pro version.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {testimonialsData.map((testimonial) => ( <Grid.Col span={{ base: 12, md: 6 }} key={testimonial.name}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack> <Text c="dimmed" dangerouslySetInnerHTML={{ __html: testimonial.quote }} /> <Group mt="md"> <Avatar src={testimonial.avatar} alt={testimonial.name} radius="xl" /> <div> <Text fw={500}>{testimonial.name}</Text> <Text size="xs" c="dimmed"> {' '} {testimonial.role}{' '} </Text> </div> </Group> </Stack> </Card> </Grid.Col> ))} </Grid> </Box> ) } const GuaranteeSection = () => ( <Paper bg="teal.0" radius="lg" p="xl" mt={80} style={{ border: '2px dashed var(--mantine-color-teal-4)' }} > <Group justify="center" align="center"> <ThemeIcon variant="light" color="teal" size={60} radius="xl"> <Icon icon="tabler:shield-check" fontSize={32} /> </ThemeIcon> <Stack gap={0} ta={{ base: 'center', sm: 'left' }}> <Title order={3}>Our 100% 'Peace of Mind' Full Guarantee</Title> <Text c="dimmed" maw={500}> {' '} We're confident you'll love the Pro features. If you're not 100% satisfied, contact us within 30 days of your purchase for a full, no-questions-asked refund.{' '} </Text> </Stack> </Group> </Paper> ) const FaqSection = () => { const faqData = [ { icon: 'tabler:rocket', question: 'What are the main benefits of upgrading to Pro?', answer: 'Pro turns the tool into a powerful management suite. You can <b>generate links for multiple groups at once</b>, which is a huge time-saver. You also unlock <b>QR code generation</b> for easy sharing and the ability to <b>export your links to CSV or Excel</b> for record-keeping.', }, { icon: 'tabler:key', question: 'Is this a one-time payment or a subscription?', answer: 'It is a <b>one-time payment</b>. You pay once and get lifetime access to all current and future Pro features. No monthly fees, no subscriptions, ever.', }, { icon: 'tabler:alert-circle', question: "Can I generate a link for a group I'm not an admin of?", answer: 'No. For security reasons, WhatsApp only allows group administrators to generate invite links. The extension will automatically show you a list of only the groups where you have admin privileges.', }, { icon: 'tabler:shield-check', question: 'Is it safe to use?', answer: 'Absolutely. The extension uses the official WhatsApp Web interface to generate and manage links. It operates <b>locally on your computer</b>, and we do not store your group data or have access to your account.', }, ] return ( <Box mt={80} id="faq"> <Center> <Title order={2} ta="center" mb="xl"> {' '} Frequently Asked Questions{' '} </Title> </Center> <Accordion variant="separated" radius="lg"> {faqData.map((item, index) => ( <Accordion.Item key={index} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > <Text fw={500}>{item.question}</Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} /> </Accordion.Panel> </Accordion.Item> ))} </Accordion> </Box> ) } const ValueStackSection = () => ( <Box mt={80}> <Card withBorder radius="lg" p="xl"> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Here's Everything You Get</Title> <Text c="dimmed"> {' '} Your Pro Lifetime License is a complete package for powerful group management.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Bulk Invite Link Generation</List.Item> <List.Item>QR Code Generation & Download</List.Item> <List.Item>Export Links to CSV & Excel</List.Item> </List> </Grid.Col> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Unlimited Link History</List.Item> <List.Item>Priority Customer Support</List.Item> <List.Item>30-Day Money-Back Guarantee</List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const ContactUsSection = () => ( <Box mt={80}> <Card withBorder p="xl" shadow="sm" radius="lg"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still Have Questions?</Title> <Text c="dimmed" size="sm"> {' '} Our team is ready to help. Contact us for any inquiries.{' '} </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > {' '} extdotninja@gmail.com{' '} </Anchor> </Stack> </Group> </Card> </Box> ) const Footer = () => ( <Box mt={80} py="xl"> <Divider /> <Stack align="center" ta="center" mt="xl" gap={4}> <Text size="sm"> {' '} Copyright  {new Date().getFullYear()}. All Rights Reserved.{' '} </Text> <Text size="xs" c="dimmed" maw={500}> {' '} This is an independent software and is not affiliated with, sponsored, or endorsed by WhatsApp LLC.{' '} </Text> </Stack> </Box> ) const StickyHeader: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => { const [scroll] = useWindowScroll() return ( <Transition mounted={scroll.y > 200} transition="slide-down" duration={300} timingFunction="ease" > {(styles) => ( <Paper shadow="md" radius={0} p="xs" style={{ ...styles, position: 'fixed', top: 0, left: 0, right: 0, zIndex: 1000, backgroundColor: 'var(--mantine-color-dark-8)', }} > <Container size="md"> <Group justify="space-between"> <CountdownTimer offerEndDate={offerEndDate} isMini /> <Button size="sm" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={18} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Get Lifetime Access for Just $29!{' '} </Button> </Group> </Container> </Paper> )} </Transition> ) } const getOfferEndDate = (): Date => { const storedEndDate = localStorage.getItem('offerEndDate') if (storedEndDate && new Date(storedEndDate) > new Date()) { return new Date(storedEndDate) } const newEndDate = new Date() newEndDate.setDate(newEndDate.getDate() + 3) localStorage.setItem('offerEndDate', newEndDate.toISOString()) return newEndDate } const LandingPage = () => { const [notification, setNotification] = useState<{ city: string country: string } | null>(null) const [offerEndDate] = useState(getOfferEndDate) useEffect(() => { const locations = [ { city: 'Torino', country: 'Italy' }, { city: 'Shaqra', country: 'Saudi Arabia' }, { city: 'Miami', country: 'United States' }, ] let timeoutId: NodeJS.Timeout const scheduleNextNotification = () => { clearTimeout(timeoutId) const randomDelay = Math.floor(Math.random() * (15000 - 8000 + 1)) + 8000 // 8-15 seconds timeoutId = setTimeout(() => { const randomLocation = locations[Math.floor(Math.random() * locations.length)] setNotification(randomLocation) timeoutId = setTimeout(() => { setNotification(null) scheduleNextNotification() }, 4000) // Show for 4 seconds }, randomDelay) } timeoutId = setTimeout(scheduleNextNotification, 5000) // First one after 5 seconds return () => clearTimeout(timeoutId) }, []) return ( <MantineProvider theme={theme}> <StickyHeader offerEndDate={offerEndDate} /> <Container size="md" py="xl"> <Stack gap={80}> <HeroSection /> <FeaturesSection /> <UserPersonaSection /> <CaseStudySection /> <PricingSection offerEndDate={offerEndDate} /> <NoSubscriptionSection /> <FeatureComparisonTable /> <SecuritySection /> <TestimonialsSection /> <GuaranteeSection /> <FaqSection /> <ValueStackSection /> <ContactUsSection /> <Center mt={40}> <Stack align="center" gap="lg"> <Title order={2}> Ready to Supercharge Your Group Management? </Title> <Text c="dimmed" size="lg"> {' '} Get all Pro features for a one-time payment.{' '} </Text> <Stack align="center"> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > {' '} Get Lifetime Access Now for Just $29{' '} </Button> <Text size="xs" c="dimmed"> {' '} 30-day no-questions-asked money-back guarantee.{' '} </Text> </Stack> </Stack> </Center> <Footer /> </Stack> </Container> <Transition mounted={!!notification} transition="slide-right" duration={500} timingFunction="ease" > {(styles) => ( <Paper shadow="lg" p="sm" radius="md" withBorder style={{ ...styles, position: 'fixed', bottom: 20, left: 20, zIndex: 2000, }} > <Group> <ThemeIcon color="teal" size={36} radius="xl"> <Icon icon="tabler:shield-check" fontSize={22} /> </ThemeIcon> <Stack gap={0}> <Text fw={500} size="sm"> {' '} Just upgraded to Pro!{' '} </Text> <Text size="xs" c="dimmed"> {' '} {`Someone from ${notification?.city}, ${notification?.country}`}{' '} </Text> </Stack> </Group> </Paper> )} </Transition> </MantineProvider> ) } export default LandingPage
```

# src/tabs/resource-page.tsx

```tsx
// src/tabs/resource-page.tsx // English: This file provides promotional materials for the Chrome Web Store listing. import PromoIcon from '@/components/Promo/PromoIcon' import ScreenshotWrapper from '@/components/Promo/ScreenshotWrapper' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Card, Center, Code, Container, CopyButton, Grid, Group, List, MantineProvider, Paper, Stack, Table, Tabs, Text, Textarea, TextInput, ThemeIcon, Title, Tooltip, } from '@mantine/core' import '@mantine/core/styles.css' import { DataTable } from 'mantine-datatable' import 'mantine-datatable/styles.layer.css' import { PRIMARY_ICON } from '@/constants' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import { QRCodeCanvas } from 'qrcode.react' import React, { useRef } from 'react' // English: Using a darker gradient that matches the landing page's teal-to-lime theme with darker shades for a more prominent look. const PROMO_GRADIENT_BACKGROUND = 'linear-gradient(135deg, var(--mantine-color-teal-8), var(--mantine-color-lime-8))' // --- Marquee Promo Tiles (1280x800px) --- // const MarqueeTileFeatureShowcase = () => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center"> <Grid.Col span={4}> <Stack> <ThemeIcon size={90} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon="tabler:ticket" fontSize={70} /> </ThemeIcon> <Title fz={48} lh={1.2} c="white"> {' '} Bulk Group Invite Link Generator{' '} </Title> <Title order={2} c="white" fw={500} mt="md"> {' '} Generate invite links, create QR codes, and export your list right from WhatsApp Web.{' '} </Title> </Stack> </Grid.Col> <Grid.Col span={5}> <Stack gap="lg"> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={60} > <Icon icon="tabler:list-details" fontSize={45} /> </ThemeIcon> <Title order={1} fw={700}> {' '} Bulk Generate Links{' '} </Title> </Group> <Title size={26} c="gray.7" fw={500} mt="md"> {' '} Select multiple groups at once.{' '} </Title> </Card> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={60} > <Icon icon="tabler:qrcode" fontSize={45} /> </ThemeIcon> <Title order={1} fw={700}> {' '} Create QR Codes{' '} </Title> </Group> <Title size={26} c="gray.7" fw={500} mt="md"> {' '} Easily share your group invites.{' '} </Title> </Card> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={60} > <Icon icon="tabler:file-export" fontSize={45} /> </ThemeIcon> <Title order={1} fw={700}> {' '} Export to Excel/CSV{' '} </Title> </Group> <Title size={26} c="gray.7" fw={500} mt="md"> {' '} Save your generated link lists.{' '} </Title> </Card> </Stack> </Grid.Col> </Grid> </Stack> </Paper> ) // --- Feature Mockups for Screenshots --- // const FeatureMockupSelectGroups = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={4}>Generate Invite Links in Bulk</Title> <Text c="dimmed" size="sm"> {' '} Save time by selecting multiple groups at once.{' '} </Text> <Paper p="lg" withBorder radius="md" mt="md"> <Stack> {/* This is a simplified mockup of the MultiSelect component */} <Text size="sm" fw={500}> Select Group(s) </Text> <Paper withBorder radius="sm" p="xs"> <Group gap="xs"> <Badge variant="light" rightSection={ <ActionIcon size="xs" color="blue" radius="xl" variant="transparent" > <Icon icon="tabler:x" /> </ActionIcon> } > Project Alpha (15 members) </Badge> <Badge variant="light" rightSection={ <ActionIcon size="xs" color="blue" radius="xl" variant="transparent" > <Icon icon="tabler:x" /> </ActionIcon> } > Marketing Team (8 members) </Badge> <Badge variant="light" rightSection={ <ActionIcon size="xs" color="blue" radius="xl" variant="transparent" > <Icon icon="tabler:x" /> </ActionIcon> } > Community Event (120 members) </Badge> </Group> </Paper> <Textarea label="Custom Message Template" description="Use {link} as a placeholder for the invite link." value={'Please join our group: {link}'} readOnly /> <Button mt="sm" leftSection={<Icon icon="tabler:refresh-dot" />}> Generate 3 Link(s) </Button> </Stack> </Paper> </Stack> </Card> ) const FeatureMockupGeneratedLinks = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={4}>Your Invite Links are Ready!</Title> <Text c="dimmed" size="sm"> {' '} Easily copy links or generate a QR code for each group.{' '} </Text> <Stack mt="md" gap="lg"> <TextInput label="Project Alpha" readOnly value="https://chat.whatsapp.com/AbC123DeF456" rightSection={ <Group gap="xs" wrap="nowrap"> <Tooltip label="Copy Options"> <ActionIcon variant="subtle"> <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> <Tooltip label="Generate QR Code"> <ActionIcon variant="subtle"> <Icon icon="tabler:qrcode" /> </ActionIcon> </Tooltip> </Group> } /> <TextInput label="Marketing Team" readOnly value="https://chat.whatsapp.com/GhI789JkL101" rightSection={ <Group gap="xs" wrap="nowrap"> <Tooltip label="Copy Options"> <ActionIcon variant="subtle"> <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> <Tooltip label="Generate QR Code"> <ActionIcon variant="subtle"> <Icon icon="tabler:qrcode" /> </ActionIcon> </Tooltip> </Group> } /> </Stack> </Stack> </Card> ) const FeatureMockupQRCode = () => ( <Card withBorder radius="md" p="xl" w={400}> <Stack align="center" p="md"> <Title order={4} ta="center"> {' '} QR Code for "Marketing Team"{' '} </Title> <Paper p="md" mt="md" withBorder radius="md"> <QRCodeCanvas value="https://chat.whatsapp.com/GhI789JkL101" size={200} level="H" /> </Paper> <Button mt="lg" leftSection={<Icon icon="tabler:download" />}> {' '} Download Image{' '} </Button> </Stack> </Card> ) const FeatureMockupHistoryAndExport = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Group justify="space-between"> <Title order={4}>Link History & Export</Title> <Group> <Button variant="light" size="xs" leftSection={<Icon icon="tabler:file-type-csv" />} > Export as CSV </Button> <Button variant="light" size="xs" leftSection={<Icon icon="tabler:file-type-xls" />} > Export as Excel </Button> </Group> </Group> <Text c="dimmed" size="sm"> {' '} Review your generated link history, export it, or revoke links as needed.{' '} </Text> <DataTable minHeight={150} records={[ { groupName: 'Project Alpha', link: 'https://chat.whatsapp.com/AbC123...', createdAt: '2025-09-14 10:30', }, { groupName: 'Marketing Team', link: 'https://chat.whatsapp.com/GhI789...', createdAt: '2025-09-14 10:30', }, { groupName: 'Community Event', link: 'https://chat.whatsapp.com/Klm112...', createdAt: '2025-09-13 15:00', }, ]} columns={[ { accessor: 'groupName', title: 'Group Name' }, { accessor: 'link', title: 'Invite Link' }, { accessor: 'createdAt', title: 'Generated At' }, { accessor: 'actions', title: 'Actions', textAlign: 'right', render: () => ( <Group gap="xs" justify="right" wrap="nowrap"> <ActionIcon color="blue" variant="subtle"> <Icon icon="tabler:copy" /> </ActionIcon> <ActionIcon color="teal" variant="subtle"> <Icon icon="tabler:qrcode" /> </ActionIcon> <ActionIcon color="red" variant="subtle"> <Icon icon="tabler:trash" /> </ActionIcon> </Group> ), }, ]} /> </Stack> </Card> ) // --- New Reusable Marquee Tile for Feature Details --- interface MarqueeTileFeatureDetailProps { icon: string title: string description: string featureComponent: React.ReactNode } const MarqueeTileFeatureDetail: React.FC<MarqueeTileFeatureDetailProps> = ({ icon, title, description, featureComponent, }) => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center"> <Grid.Col span={4}> <Stack> <ThemeIcon size={90} radius="lg"> <Icon icon={icon} fontSize={60} /> </ThemeIcon> <Title order={1} fz={50} lh={1.2} c="white"> {' '} {title}{' '} </Title> <Title order={2} fw={500} c="gray.1" mt="md"> {' '} {description}{' '} </Title> </Stack> </Grid.Col> <Grid.Col span={6}> <Center h="100%">{featureComponent}</Center> </Grid.Col> </Grid> </Stack> </Paper> ) const ScreenshotGallery: React.FC = () => { const screenshotData = [ { title: 'Marquee Promo Tile: Feature Showcase (1280x800)', filename: 'marquee_promo_tile_features.png', component: <MarqueeTileFeatureShowcase />, }, { title: 'Feature Screenshot: Select Multiple Groups (1280x800)', filename: 'feature_select_groups.png', component: ( <MarqueeTileFeatureDetail icon="tabler:list-details" title="Bulk Link Generation" description="Select as many groups as you need and generate all their invite links in a single click." featureComponent={<FeatureMockupSelectGroups />} /> ), }, { title: 'Feature Screenshot: View Generated Links (1280x800)', filename: 'feature_generated_links.png', component: ( <MarqueeTileFeatureDetail icon="tabler:link" title="Instant Link Access" description="Your generated links appear instantly. Copy them with a custom message or move on to creating a QR code." featureComponent={<FeatureMockupGeneratedLinks />} /> ), }, { title: 'Feature Screenshot: QR Code Generation (1280x800)', filename: 'feature_qr_code.png', component: ( <MarqueeTileFeatureDetail icon="tabler:qrcode" title="One-Click QR Codes" description="Generate and download a high-resolution QR code for any group invite, perfect for flyers and digital sharing." featureComponent={<FeatureMockupQRCode />} /> ), }, { title: 'Feature Screenshot: History and Export (1280x800)', filename: 'feature_history_export.png', component: ( <MarqueeTileFeatureDetail icon="tabler:file-export" title="History & Export" description="Keep track of all generated links in your history. Export your list to CSV or Excel for record-keeping." featureComponent={<FeatureMockupHistoryAndExport />} /> ), }, ] return ( <Stack> <Text c="dimmed" mb="md"> {' '} Generate and download high-resolution promotional assets for the Chrome Web Store.{' '} </Text> <Stack gap="xl"> {screenshotData.map((item) => ( <ScreenshotWrapper key={item.title} title={item.title} filename={item.filename} > {item.component} </ScreenshotWrapper> ))} </Stack> </Stack> ) } // --- End of Embedded Screenshot Components --- const ResourcePage = () => { const iconRef = useRef<HTMLDivElement>(null) const icons = [ { component: <PromoIcon size={128} icon={'tabler:ticket'} />, ref: iconRef, name: 'promotional_icon.png', }, ] const storeListingText = { titles: [ 'Group Link Generator for WhatsApp', 'Bulk WhatsApp Group Link Maker', 'WA Group Invite Link Generator', ], shortDescriptions: [ 'Generate WhatsApp group invite links in bulk, create QR codes, and export your list right from WhatsApp Web.', 'The easiest way to get invite links for multiple WhatsApp groups at once. Includes QR code and export features.', 'Save time managing your WhatsApp groups. Quickly generate invite links for one or many groups simultaneously.', ], longDescription: ` The Ultimate Tool for WhatsApp Group Admins Tired of manually generating invite links for your WhatsApp groups one by one? The Group Link Generator for WhatsApp streamlines your workflow, allowing you to generate, manage, and share group invites with ease and efficiency, right from WhatsApp Web.  Key Features - **Bulk Link Generation**: Select multiple groups at once and generate all their invite links in a single click. (Pro) - **QR Code Creation**: Instantly create and download a high-resolution QR code for any group invite, perfect for sharing online or on printed materials. (Pro) - **Export to CSV/Excel**: Keep a record of your generated links by exporting them to a CSV or Excel file for easy management. (Pro) - **Link History**: View a history of all the links you've created. - **Revoke Links**: Easily revoke an old invite link directly from the history, ensuring your groups remain secure. - **Custom Copy Message**: Create a custom message template to go along with your invite link when you copy it.  Safe & Secure Your privacy is important. This extension operates locally in your browser and does not collect, store, or transmit any of your personal data or chat information.  Who Is This For? - **Community Managers**: Effortlessly create and share links for multiple community groups. - **Event Organizers**: Quickly generate invite links for event-specific WhatsApp groups. - **Business Owners**: Onboard new team members or clients to different groups efficiently. - **Anyone managing multiple WhatsApp groups**: Stop wasting time with repetitive tasks and manage your group invites like a pro.  Boost your productivity and take control of your WhatsApp group management today! WhatsApp is a trademark of WhatsApp Inc., registered in the U.S. and other countries. This extension is an independent project and has no relationship to WhatsApp or WhatsApp Inc.`, } const justificationTexts = { singlePurpose: `The extension's single purpose is to allow users to generate and manage WhatsApp group invite links. All featuresincluding selecting groups, generating links, creating QR codes, exporting lists, and viewing historyare directly tied to this core function of group invite link management within the WhatsApp Web interface.`, storage: `The 'storage' permission is used to locally store user settings and license information. This includes: the user's license key for Pro features, an instance ID for license management, and saved preferences like custom message templates. This data is kept on the user's device to ensure a consistent experience without needing a remote server.`, scripting: `Content scripts are essential to inject the extension's user interface (the link generator modal) onto the web.whatsapp.com page. They also communicate with the WhatsApp Web application's context to securely fetch the user's group list and to call the functions necessary for generating and revoking invite links, fulfilling the extension's core purpose.`, hostWhatsapp: `Permission for "https://web.whatsapp.com/*" is required for the extension to function. It allows the content scripts to run on WhatsApp Web, enabling the injection of its UI and interaction with the page to retrieve group data and generate invite links for the user.`, hostLemonSqueezy: `Permission for "https://api.lemonsqueezy.com/*" is used for secure license management. When a user activates a Pro license, the extension communicates with this API to verify, activate, or deactivate the license key. This is a standard and secure method for handling software licensing and does not involve any personal chat data.`, } const keywords = [ 'whatsapp group', 'invite link', 'whatsapp tool', 'bulk generate', 'qr code', 'export whatsapp', 'group admin', 'whatsapp automation', 'link generator', 'whatsapp marketing', ] const keywordsString = keywords.join(', ') const handleDownloadIcon = async ( ref: React.RefObject<HTMLDivElement>, filename: string, ) => { if (!ref.current) return const canvas = await html2canvas(ref.current, { backgroundColor: null, // Transparent background }) canvas.toBlob((blob) => { if (blob) FileSaver.saveAs(blob, filename) }) } return ( <MantineProvider theme={theme}> <Container size="lg" py="xl"> <Stack gap="xl"> <Title order={1} ta="center"> {' '} Chrome Web Store - Promotional Resources{' '} </Title> <Text c="dimmed" ta="center"> {' '} Use these assets and text to create your store listing page.{' '} </Text> <Tabs defaultValue="screenshots"> <Tabs.List grow> <Tabs.Tab value="text" leftSection={<Icon icon="tabler:file-text" />} > {' '} Store Listing Text{' '} </Tabs.Tab> <Tabs.Tab value="icons" leftSection={<Icon icon="tabler:photo" />} > {' '} Promotional Icons{' '} </Tabs.Tab> <Tabs.Tab value="screenshots" leftSection={<Icon icon="tabler:camera" />} > {' '} Screenshots & Tiles{' '} </Tabs.Tab> <Tabs.Tab value="keywords" leftSection={<Icon icon="tabler:tags" />} > {' '} Keywords (SEO){' '} </Tabs.Tab> <Tabs.Tab value="privacy" leftSection={<Icon icon="tabler:shield-lock" />} > {' '} Privacy Justifications{' '} </Tabs.Tab> </Tabs.List> <Tabs.Panel value="text" pt="lg"> <Stack gap="xl"> <Stack> <Title order={3}>Titles</Title> {storeListingText.titles.map((title, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={title.length > 30 ? 'red' : 'dimmed'} > {' '} {title.length} / 30 chars{' '} </Text> </Group> <Group mt="sm" justify="space-between"> <Code>{title}</Code> <CopyButton value={title}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Stack> <Title order={3}>Short Descriptions</Title> {storeListingText.shortDescriptions.map((desc, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={desc.length > 132 ? 'red' : 'dimmed'} > {' '} {desc.length} / 132 chars{' '} </Text> </Group> <Textarea mt="sm" readOnly value={desc} autosize maxRows={4} /> <Group justify="flex-end" mt="sm"> <CopyButton value={desc}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Card withBorder radius="md"> <Title order={3}>Detailed Description</Title> <Textarea mt="sm" readOnly value={storeListingText.longDescription} autosize minRows={15} /> <Group justify="flex-end" mt="sm"> <CopyButton value={storeListingText.longDescription}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> </Stack> </Tabs.Panel> <Tabs.Panel value="icons" pt="lg"> <Center> <Card withBorder radius="md" p="xl" w={300}> <Stack align="center" justify="space-between"> <div ref={iconRef}>{icons[0].component}</div> <Stack align="center" gap="md" mt="md"> <Text fw={500}>Promotional Icon (128x128 px)</Text> <Button variant="light" onClick={() => handleDownloadIcon(icons[0].ref, icons[0].name) } > {' '} Download{' '} </Button> </Stack> </Stack> </Card> </Center> </Tabs.Panel> <Tabs.Panel value="screenshots" pt="lg"> <ScreenshotGallery /> </Tabs.Panel> <Tabs.Panel value="keywords" pt="lg"> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={3}>Keywords for Store Listing</Title> <CopyButton value={keywordsString}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} leftSection={<Icon icon="tabler:copy" />} > {' '} {copied ? 'Copied All' : 'Copy All'}{' '} </Button> )} </CopyButton> </Group> <Text c="dimmed" size="sm" mt="xs"> {' '} Use these keywords in your store listing's metadata to improve search visibility.{' '} </Text> <Paper withBorder p="md" mt="md" radius="sm"> <Group gap="xs"> {keywords.map((keyword) => ( <Badge key={keyword} variant="light" color="gray" size="lg" > {' '} {keyword}{' '} </Badge> ))} </Group> </Paper> </Card> </Tabs.Panel> <Tabs.Panel value="privacy" pt="lg"> <Stack gap="xl"> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Single Purpose Justification</Title> <CopyButton value={justificationTexts.singlePurpose}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.singlePurpose} autosize minRows={4} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Storage Permission Justification</Title> <CopyButton value={justificationTexts.storage}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.storage} autosize minRows={5} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Content Scripting Justification</Title> <CopyButton value={justificationTexts.scripting}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.scripting} autosize minRows={5} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}> {' '} Host Permission: https://web.whatsapp.com/*{' '} </Title> <CopyButton value={justificationTexts.hostWhatsapp}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.hostWhatsapp} autosize minRows={4} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}> {' '} Host Permission: https://api.lemonsqueezy.com/*{' '} </Title> <CopyButton value={justificationTexts.hostLemonSqueezy}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {copied ? 'Copied' : 'Copy'} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.hostLemonSqueezy} autosize minRows={4} /> </Card> </Stack> </Tabs.Panel> </Tabs> </Stack> </Container> </MantineProvider> ) } export default ResourcePage
```

# src/types/globals.d.ts

```ts
import type * as wajs from '@wppconnect/wa-js' declare global { interface Window { WPP: typeof wajs } const WPP: typeof wajs }
```

# src/types/index.d.ts

```ts
import type { Status } from '@/constants' export interface Response<T> { status: keyof typeof Status | string data?: T | null error?: string | null } interface LicenseInstance { createt_at: Date id: string name: string } interface LicenseKey { activation_limit: number activation_usage: number create_at: Date expires_at: Date id: number status: string test_mode: boolean } interface LicenseMeta { customer_email: string customer_id: number customer_name: string order_id: number order_item_id: number product_id: number store_id: number variant_id: number variant_name: string } export interface License { activated?: boolean | null valid?: boolean | null instance?: LicenseInstance | null license_key: LicenseKey meta: LicenseMeta }
```

# src/utils/country.ts

```ts
const countries = { AD: { label: ' Andorra', phone: '376' }, AE: { label: ' United Arab Emirates', phone: '971' }, AF: { label: ' Afghanistan', phone: '93' }, AG: { label: ' Antigua and Barbuda', phone: '1-268' }, AI: { label: ' Anguilla', phone: '1-264' }, AL: { label: ' Albania', phone: '355' }, AM: { label: ' Armenia', phone: '374' }, AO: { label: ' Angola', phone: '244' }, AQ: { label: ' Antarctica', phone: '672' }, AR: { label: ' Argentina', phone: '54' }, AS: { label: ' American Samoa', phone: '1-684' }, AT: { label: ' Austria', phone: '43' }, AU: { label: ' Australia', phone: '61' }, AW: { label: ' Aruba', phone: '297' }, AX: { label: ' Alland Islands', phone: '358' }, AZ: { label: ' Azerbaijan', phone: '994' }, BA: { label: ' Bosnia and Herzegovina', phone: '387' }, BB: { label: ' Barbados', phone: '1-246' }, BD: { label: ' Bangladesh', phone: '880' }, BE: { label: ' Belgium', phone: '32' }, BF: { label: ' Burkina Faso', phone: '226' }, BG: { label: ' Bulgaria', phone: '359' }, BH: { label: ' Bahrain', phone: '973' }, BI: { label: ' Burundi', phone: '257' }, BJ: { label: ' Benin', phone: '229' }, BL: { label: ' Saint Barthelemy', phone: '590' }, BM: { label: ' Bermuda', phone: '1-441' }, BN: { label: ' Brunei Darussalam', phone: '673' }, BO: { label: ' Bolivia', phone: '591' }, BR: { label: ' Brazil', phone: '55' }, BS: { label: ' Bahamas', phone: '1-242' }, BT: { label: ' Bhutan', phone: '975' }, BV: { label: ' Bouvet Island', phone: '47' }, BW: { label: ' Botswana', phone: '267' }, BY: { label: ' Belarus', phone: '375' }, BZ: { label: ' Belize', phone: '501' }, CA: { label: ' Canada', phone: '1' }, CC: { label: ' Cocos (Keeling) Islands', phone: '61' }, CD: { label: ' Congo, Democratic Republic of the', phone: '243' }, CF: { label: ' Central African Republic', phone: '236' }, CG: { label: ' Congo, Republic of the', phone: '242' }, CH: { label: ' Switzerland', phone: '41' }, CI: { label: " Cote d'Ivoire", phone: '225' }, CK: { label: ' Cook Islands', phone: '682' }, CL: { label: ' Chile', phone: '56' }, CM: { label: ' Cameroon', phone: '237' }, CN: { label: ' China', phone: '86' }, CO: { label: ' Colombia', phone: '57' }, CR: { label: ' Costa Rica', phone: '506' }, CU: { label: ' Cuba', phone: '53' }, CV: { label: ' Cape Verde', phone: '238' }, CW: { label: ' Curacao', phone: '599' }, CX: { label: ' Christmas Island', phone: '61' }, CY: { label: ' Cyprus', phone: '357' }, CZ: { label: ' Czech Republic', phone: '420' }, DE: { label: ' Germany', phone: '49' }, DJ: { label: ' Djibouti', phone: '253' }, DK: { label: ' Denmark', phone: '45' }, DM: { label: ' Dominica', phone: '1-767' }, DO: { label: ' Dominican Republic', phone: '1-809' }, DZ: { label: ' Algeria', phone: '213' }, EC: { label: ' Ecuador', phone: '593' }, EE: { label: ' Estonia', phone: '372' }, EG: { label: ' Egypt', phone: '20' }, EH: { label: ' Western Sahara', phone: '212' }, ER: { label: ' Eritrea', phone: '291' }, ES: { label: ' Spain', phone: '34' }, ET: { label: ' Ethiopia', phone: '251' }, FI: { label: ' Finland', phone: '358' }, FJ: { label: ' Fiji', phone: '679' }, FK: { label: ' Falkland Islands (Malvinas)', phone: '500' }, FM: { label: ' Micronesia, Federated States of', phone: '691' }, FO: { label: ' Faroe Islands', phone: '298' }, FR: { label: ' France', phone: '33' }, GA: { label: ' Gabon', phone: '241' }, GB: { label: ' United Kingdom', phone: '44' }, GD: { label: ' Grenada', phone: '1-473' }, GE: { label: ' Georgia', phone: '995' }, GF: { label: ' French Guiana', phone: '594' }, GG: { label: ' Guernsey', phone: '44' }, GH: { label: ' Ghana', phone: '233' }, GI: { label: ' Gibraltar', phone: '350' }, GL: { label: ' Greenland', phone: '299' }, GM: { label: ' Gambia', phone: '220' }, GN: { label: ' Guinea', phone: '224' }, GP: { label: ' Guadeloupe', phone: '590' }, GQ: { label: ' Equatorial Guinea', phone: '240' }, GR: { label: ' Greece', phone: '30' }, GS: { label: ' South Georgia and the South Sandwich Islands', phone: '500', }, GT: { label: ' Guatemala', phone: '502' }, GU: { label: ' Guam', phone: '1-671' }, GW: { label: ' Guinea-Bissau', phone: '245' }, GY: { label: ' Guyana', phone: '592' }, HK: { label: ' Hong Kong', phone: '852' }, HM: { label: ' Heard Island and McDonald Islands', phone: '672' }, HN: { label: ' Honduras', phone: '504' }, HR: { label: ' Croatia', phone: '385' }, HT: { label: ' Haiti', phone: '509' }, HU: { label: ' Hungary', phone: '36' }, ID: { label: ' Indonesia', phone: '62' }, IE: { label: ' Ireland', phone: '353' }, IL: { label: ' Israel', phone: '972' }, IM: { label: ' Isle of Man', phone: '44' }, IN: { label: ' India', phone: '91' }, IO: { label: ' British Indian Ocean Territory', phone: '246' }, IQ: { label: ' Iraq', phone: '964' }, IR: { label: ' Iran, Islamic Republic of', phone: '98' }, IS: { label: ' Iceland', phone: '354' }, IT: { label: ' Italy', phone: '39' }, JE: { label: ' Jersey', phone: '44' }, JM: { label: ' Jamaica', phone: '1-876' }, JO: { label: ' Jordan', phone: '962' }, JP: { label: ' Japan', phone: '81' }, KE: { label: ' Kenya', phone: '254' }, KG: { label: ' Kyrgyzstan', phone: '996' }, KH: { label: ' Cambodia', phone: '855' }, KI: { label: ' Kiribati', phone: '686' }, KM: { label: ' Comoros', phone: '269' }, KN: { label: ' Saint Kitts and Nevis', phone: '1-869' }, KP: { label: " Korea, Democratic People's Republic of", phone: '850' }, KR: { label: ' Korea, Republic of', phone: '82' }, KW: { label: ' Kuwait', phone: '965' }, KY: { label: ' Cayman Islands', phone: '1-345' }, KZ: { label: ' Kazakhstan', phone: '7' }, LA: { label: " Lao People's Democratic Republic", phone: '856' }, LB: { label: ' Lebanon', phone: '961' }, LC: { label: ' Saint Lucia', phone: '1-758' }, LI: { label: ' Liechtenstein', phone: '423' }, LK: { label: ' Sri Lanka', phone: '94' }, LR: { label: ' Liberia', phone: '231' }, LS: { label: ' Lesotho', phone: '266' }, LT: { label: ' Lithuania', phone: '370' }, LU: { label: ' Luxembourg', phone: '352' }, LV: { label: ' Latvia', phone: '371' }, LY: { label: ' Libya', phone: '218' }, MA: { label: ' Morocco', phone: '212' }, MC: { label: ' Monaco', phone: '377' }, MD: { label: ' Moldova, Republic of', phone: '373' }, ME: { label: ' Montenegro', phone: '382' }, MF: { label: ' Saint Martin (French part)', phone: '590' }, MG: { label: ' Madagascar', phone: '261' }, MH: { label: ' Marshall Islands', phone: '692' }, MK: { label: ' Macedonia, the Former Yugoslav Republic of', phone: '389' }, ML: { label: ' Mali', phone: '223' }, MM: { label: ' Myanmar', phone: '95' }, MN: { label: ' Mongolia', phone: '976' }, MO: { label: ' Macao', phone: '853' }, MP: { label: ' Northern Mariana Islands', phone: '1-670' }, MQ: { label: ' Martinique', phone: '596' }, MR: { label: ' Mauritania', phone: '222' }, MS: { label: ' Montserrat', phone: '1-664' }, MT: { label: ' Malta', phone: '356' }, MU: { label: ' Mauritius', phone: '230' }, MV: { label: ' Maldives', phone: '960' }, MW: { label: ' Malawi', phone: '265' }, MX: { label: ' Mexico', phone: '52' }, MY: { label: ' Malaysia', phone: '60' }, MZ: { label: ' Mozambique', phone: '258' }, NA: { label: ' Namibia', phone: '264' }, NC: { label: ' New Caledonia', phone: '687' }, NE: { label: ' Niger', phone: '227' }, NF: { label: ' Norfolk Island', phone: '672' }, NG: { label: ' Nigeria', phone: '234' }, NI: { label: ' Nicaragua', phone: '505' }, NL: { label: ' Netherlands', phone: '31' }, NO: { label: ' Norway', phone: '47' }, NP: { label: ' Nepal', phone: '977' }, NR: { label: ' Nauru', phone: '674' }, NU: { label: ' Niue', phone: '683' }, NZ: { label: ' New Zealand', phone: '64' }, OM: { label: ' Oman', phone: '968' }, PA: { label: ' Panama', phone: '507' }, PE: { label: ' Peru', phone: '51' }, PF: { label: ' French Polynesia', phone: '689' }, PG: { label: ' Papua New Guinea', phone: '675' }, PH: { label: ' Philippines', phone: '63' }, PK: { label: ' Pakistan', phone: '92' }, PL: { label: ' Poland', phone: '48' }, PM: { label: ' Saint Pierre and Miquelon', phone: '508' }, PN: { label: ' Pitcairn', phone: '870' }, PR: { label: ' Puerto Rico', phone: '1' }, PS: { label: ' Palestine, State of', phone: '970' }, PT: { label: ' Portugal', phone: '351' }, PW: { label: ' Palau', phone: '680' }, PY: { label: ' Paraguay', phone: '595' }, QA: { label: ' Qatar', phone: '974' }, RE: { label: ' Reunion', phone: '262' }, RO: { label: ' Romania', phone: '40' }, RS: { label: ' Serbia', phone: '381' }, RU: { label: ' Russian Federation', phone: '7' }, RW: { label: ' Rwanda', phone: '250' }, SA: { label: ' Saudi Arabia', phone: '966' }, SB: { label: ' Solomon Islands', phone: '677' }, SC: { label: ' Seychelles', phone: '248' }, SD: { label: ' Sudan', phone: '249' }, SE: { label: ' Sweden', phone: '46' }, SG: { label: ' Singapore', phone: '65' }, SH: { label: ' Saint Helena', phone: '290' }, SI: { label: ' Slovenia', phone: '386' }, SJ: { label: ' Svalbard and Jan Mayen', phone: '47' }, SK: { label: ' Slovakia', phone: '421' }, SL: { label: ' Sierra Leone', phone: '232' }, SM: { label: ' San Marino', phone: '378' }, SN: { label: ' Senegal', phone: '221' }, SO: { label: ' Somalia', phone: '252' }, SR: { label: ' Suriname', phone: '597' }, SS: { label: ' South Sudan', phone: '211' }, ST: { label: ' Sao Tome and Principe', phone: '239' }, SV: { label: ' El Salvador', phone: '503' }, SX: { label: ' Sint Maarten (Dutch part)', phone: '1-721' }, SY: { label: ' Syrian Arab Republic', phone: '963' }, SZ: { label: ' Swaziland', phone: '268' }, TC: { label: ' Turks and Caicos Islands', phone: '1-649' }, TD: { label: ' Chad', phone: '235' }, TF: { label: ' French Southern Territories', phone: '262' }, TG: { label: ' Togo', phone: '228' }, TH: { label: ' Thailand', phone: '66' }, TJ: { label: ' Tajikistan', phone: '992' }, TK: { label: ' Tokelau', phone: '690' }, TL: { label: ' Timor-Leste', phone: '670' }, TM: { label: ' Turkmenistan', phone: '993' }, TN: { label: ' Tunisia', phone: '216' }, TO: { label: ' Tonga', phone: '676' }, TR: { label: ' Turkey', phone: '90' }, TT: { label: ' Trinidad and Tobago', phone: '1-868' }, TV: { label: ' Tuvalu', phone: '688' }, TW: { label: ' Taiwan, Province of China', phone: '886' }, TZ: { label: ' United Republic of Tanzania', phone: '255' }, UA: { label: ' Ukraine', phone: '380' }, UG: { label: ' Uganda', phone: '256' }, US: { label: ' United States', phone: '1' }, UY: { label: ' Uruguay', phone: '598' }, UZ: { label: ' Uzbekistan', phone: '998' }, VA: { label: ' Holy See (Vatican City State)', phone: '379' }, VC: { label: ' Saint Vincent and the Grenadines', phone: '1-784' }, VE: { label: ' Venezuela', phone: '58' }, VG: { label: ' British Virgin Islands', phone: '1-284' }, VI: { label: ' US Virgin Islands', phone: '1-340' }, VN: { label: ' Vietnam', phone: '84' }, VU: { label: ' Vanuatu', phone: '678' }, WF: { label: ' Wallis and Futuna', phone: '681' }, WS: { label: ' Samoa', phone: '685' }, XK: { label: ' Kosovo', phone: '383' }, YE: { label: ' Yemen', phone: '967' }, YT: { label: ' Mayotte', phone: '262' }, ZA: { label: ' South Africa', phone: '27' }, ZM: { label: ' Zambia', phone: '260' }, ZW: { label: ' Zimbabwe', phone: '263' }, } const getCountryByCode = (code: string) => { return countries[code] ?? { label: '-', phone: '-' } } export default { getCountryByCode, countries, }
```

# src/utils/env.ts

```ts
const isProduction = () => { return process.env.NODE_ENV === 'production' } const isDevelopment = () => { return process.env.NODE_ENV === 'development' } export const isStaging = () => { return process.env.PLASMO_PUBLIC_STAGING === 'true' } export default { isProduction, isDevelopment, isStaging, }
```

# src/utils/ext.ts

```ts
import type { Tabs } from 'webextension-polyfill' import browser from 'webextension-polyfill' export async function getCurrentTab(): Promise<Tabs.Tab> { const queryOptions = { active: true, currentWindow: true } const [tab] = await browser.tabs.query(queryOptions) return tab } export async function getTabs(): Promise<Tabs.Tab[]> { return new Promise(async (resolve, reject) => { try { const tabs = await browser.tabs.query({ currentWindow: true }) const filteredTabs = tabs.filter( (tab) => !tab.url?.startsWith('chrome://'), ) return resolve(filteredTabs) } catch (error) { reject(error) } }) } export async function getTabByUrl(url: string): Promise<Tabs.Tab | null> { const queryOptions = { url: url } const tabs = await browser.tabs.query(queryOptions) return tabs.length > 0 ? tabs[0] : null } export const openWa = async () => { await browser.tabs.create({ url: 'https://web.whatsapp.com' }) } export const isWaTabActive = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return result?.active } export const isWaTabAvailable = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return !!result }
```

# src/utils/filterBy.ts

```ts
import { AccountType, ContactType, MessageType } from '@/constants' import type { ContactModel } from '@wppconnect/wa-js/dist/whatsapp' const dontIncludeLid = (contact: ContactModel) => contact.id.server !== 'lid' const dontIncludeMe = (contact: any, number: any) => contact.phoneNumber !== number const accountType = (contact: any, type: string) => { switch (type) { case AccountType.ALL: return true case AccountType.PERSONAL: return contact.isBusiness === false case AccountType.BUSINESS: return contact.isBusiness === true default: return true } } const contactType = (contact: any, type: string): boolean => { switch (type) { case ContactType.ALL: return true case ContactType.SAVED_CONTACTS: return contact.isMyContact === true case ContactType.UNSAVED_CONTACTS: return contact.isMyContact === false default: return true } } const includeAdmin = (data: any, isIncludeAdmin: boolean) => { if (isIncludeAdmin) { if (data.isAdmin) { return true } } else { if (data.isAdmin) return false } return true } const onlyMyContact = (data: any, onlyMyContact: boolean) => { if (onlyMyContact) { return data.isMyContact === true } else { return data.isMyContact !== true } } const messageType = (contact: any, type: string): boolean => { switch (type) { case MessageType.ALL: return true case MessageType.HAVE_UNREAD_MESSAGES: return contact.hasUnread === true case MessageType.NO_UNREAD_MESSAGES: return contact.hasUnread === false default: return true } } const country = (contact: any, country: string) => { const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) return countryCode === country } export default { dontIncludeLid, dontIncludeMe, accountType, includeAdmin, onlyMyContact, contactType, messageType, country, }
```

# src/utils/page.ts

```ts
import { Action } from '@/constants' import { postMessage } from './util' const goTo = (page: string) => { postMessage(Action.Window.GO_TO_PAGE, page) } export default { goTo, }
```

# src/utils/response.ts

```ts
import { Status } from '@/constants' import type { Response } from '@/types' const success = <T = any>(data?: T | null): Response<T | undefined | null> => { return { status: Status.SUCCESS, data: data, } } const error = (error: string | undefined | null): Response<null> => { return { status: Status.FAILED, error: error, } } export const response = { success, error, }
```

# src/utils/serialize.ts

```ts
import type { ChatModel, ContactModel, GroupMetadataModel, MediaDataModel, MsgModel, ParticipantModel, } from '@wppconnect/wa-js/dist/whatsapp' import _ from 'lodash' const button = (buttons: any[]) => { return buttons .map(({ type, label, value }) => { switch (type) { case 'text': return { text: value } case 'url': return { text: label, url: value } case 'phoneNumber': return { text: label, phoneNumber: value } default: break } }) .filter((button) => !!button) } const list = (rows: any[]) => { return rows.filter((row) => row.title !== '') } const contact = (contact: ContactModel) => { if (!contact) return {} const hasUnread = WPP.chat.get(contact.id._serialized)?.hasUnread ?? false return { id: contact.id._serialized, //@ts-ignore phoneNumber: contact?.phoneNumber?.user || contact.id?.user, avatar: contact.getProfilePicThumb().__x_eurl, name: contact.name, pushname: contact.pushname, shortname: contact.shortName, notifyName: contact.notifyName, formattedName: contact.formattedName, formattedPhone: contact.formattedPhone, formattedShortName: contact.formattedShortName, formattedShortNameWithNonBreakingSpaces: contact.formattedShortNameWithNonBreakingSpaces, formattedUser: contact.formattedUser, isBusiness: contact.isBusiness, isContactBlocked: contact.isContactBlocked, //@ts-ignore isFavorite: contact.isFavorite, isGroup: contact.isGroup, isMe: contact.isMe, isMyContact: contact.isMyContact, isUser: contact.isUser, isWaContact: contact.isWAContact, labels: contact.labels, hasUnread, } } const mediaData = (data?: MediaDataModel) => { if (!data) return {} return { mimeType: data?.mimetype, size: data?.size, base64: data?.preview?.base64, height: data?.fullHeight, width: data?.fullWidth, } } const message = (msgModel: MsgModel) => { return { id: msgModel.id._serialized, ack: msgModel.ack, body: msgModel.body, from: msgModel.from, isViewOnce: msgModel.isViewOnce, timestamp: msgModel.t * 1000, to: msgModel.to, type: msgModel.type, mimetype: msgModel.mimetype, size: msgModel.size, filename: msgModel.filename, caption: msgModel.caption, duration: msgModel.duration, height: msgModel.height, width: msgModel.width, quotedMessage: msgModel.quotedMsg, contact: contact(msgModel.senderObj), } } const groupMetadata = (data: GroupMetadataModel) => { return { id: data?.id?._serialized, description: data?.desc, size: data?.size, subject: data?.subject, creation: data?.creation * 1000, participants: data?.participants?.getModelsArray().map(participant), } } const chat = (chat: ChatModel) => { return { id: chat.id._serialized, name: chat.name, messages: chat.msgs.getModelsArray().map(message), contact: contact(chat.contact), groupMetadata: groupMetadata(chat.groupMetadata), } } const participant = (participant: ParticipantModel) => { return { isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, contact: contact(participant.contact), } } export default { button, list, contact, chat, participant, message, }
```

# src/utils/style.ts

```ts
import appMenuStyle from 'data-text:@/components/AppMenu.module.css' import layoutStyle from 'data-text:@/components/Layout/LayoutPage.module.css' import toastStyle from 'data-text:@/components/Toast/Toast.module.css' import globalsStyle from 'data-text:@/styles/globals.css' import coreStyle from 'data-text:@mantine/core/styles.css' import dateStyle from 'data-text:@mantine/dates/styles.css' import dropzoneStyle from 'data-text:@mantine/dropzone/styles.css' import tableStyle from 'data-text:mantine-datatable/styles.layer.css' const styles = [ coreStyle, dateStyle, dropzoneStyle, tableStyle, toastStyle, globalsStyle, layoutStyle, appMenuStyle, ] const generate = () => { return styles.join('') } export default { generate }
```

# src/utils/throwError.ts

```ts
const broadcastNotFound = () => { throw new Error('Broadcast not found') } const mediaNotFound = () => { throw new Error('Media not found') } const contactNotExist = () => { throw new Error('Contact not exist') } export default { broadcastNotFound, mediaNotFound, contactNotExist, }
```

# src/utils/toast.ts

```ts
import { useToastStore } from '@/stores/toast' const showSuccess = (message: string, title: string = 'Success') => { useToastStore.getState().addToast({ type: 'success', title, message }) } const showError = (message: string, title: string = 'Error') => { useToastStore.getState().addToast({ type: 'error', title, message }) } const showInfo = (message: string, title: string = 'Information') => { useToastStore.getState().addToast({ type: 'info', title, message }) } const showWarning = (message: string, title: string = 'Warning') => { useToastStore.getState().addToast({ type: 'warning', title, message }) } export default { success: showSuccess, error: showError, info: showInfo, // ADDED: Export the new 'warning' function. warning: showWarning, }
```

# src/utils/util.ts

```ts
// src/utils/util.ts import { Action, Message } from '@/constants' import type { UseFormReturnType } from '@mantine/form' import { sendToBackground } from '@plasmohq/messaging' import _ from 'lodash' export async function delay(timeoutMs = 1000) { await new Promise((resolve) => setTimeout(resolve, timeoutMs)) } export const generateRandomDelay = (min: number, max: number) => { // Calculate the range of multiples of 1000 const minThousand = Math.ceil(min / 1000) const maxThousand = Math.floor(max / 1000) // Generate a random integer in that range and multiply by 1000 const randomThousand = Math.floor(Math.random() * (maxThousand - minThousand + 1)) + minThousand return randomThousand * 1000 } export const truncate = (data: string, length: number = 30) => { return _.chain(data) .thru((str) => (str.length > length ? `${str.slice(0, length)}...` : str)) .value() } export const postMessage = (action: string, body: any = null) => { window.postMessage({ action, body }) } export const showModalPricing = () => { postMessage(Action.Window.SHOW_MODAL_PRICING) } export const showModalUpgrade = ( featureName = 'Pro Feature', featureBenefit = 'Upgrade to Pro to unlock this feature and many more!', ) => { postMessage(Action.Window.SHOW_MODAL_UPGRADE, { featureName, featureBenefit }) } export const showModalMain = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } export const showModalActivation = () => { postMessage(Action.Window.SHOW_MODAL_ACTIVATION) } export const showModalProfile = () => { postMessage(Action.Window.SHOW_MODAL_PROFILE) } export const showModalFaq = () => { postMessage(Action.Window.SHOW_MODAL_FAQ) } export const goToResourcePage = async () => { await sendToBackground({ name: 'resource-page', body: {}, }) } export const getStoreId = () => { return process.env.PLASMO_PUBLIC_STORE_ID } export const isTypeMessageMedia = (type: string) => { return [Message.MEDIA, Message.IMAGE, Message.VIDEO, Message.FILE].includes( type, ) } export const formHasErrors = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ): boolean => { let hasError = false if (form1.validate().hasErrors) { hasError = true } if (form2.validate().hasErrors) { hasError = true } return hasError } export const resetForms = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ) => { form1.reset() form2.reset() } /** * @description Generates a thumbnail from a video file. * @param {File} file The video file. * @returns {Promise<string>} A promise that resolves with a base64 data URL of the thumbnail. */ export const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve, reject) => { try { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.muted = true video.playsInline = true video.onloadeddata = () => { canvas.width = video.videoWidth canvas.height = video.videoHeight video.currentTime = 1 // Seek to 1 second to get a good frame video.onseeked = () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up memory resolve(thumbnailUrl) } else { reject(new Error('Could not get canvas context.')) } } } video.onerror = () => { URL.revokeObjectURL(video.src) reject(new Error('Failed to load video file for thumbnail.')) } video.src = URL.createObjectURL(file) } catch (error) { reject(error) } }) } export const getContactName = (contact: any) => { return ( contact.name || contact.pushname || contact.notifyName || contact.formattedName || '-' ) }
```

# tsconfig.json

```json
{ "extends": "plasmo/templates/tsconfig.base", "exclude": ["node_modules"], "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"], "compilerOptions": { "paths": { "@/*": ["src/*"] }, "baseUrl": "." } }
```

