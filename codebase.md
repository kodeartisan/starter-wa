# assets/icon.png

This is a binary file of the type: Image

# package.json

```json
{ "name": "whats-status", "shortName": "WhatsStatus", "displayName": "WhatsStatus - Automate & Schedule WA Status", "version": "1.0.0", "description": "Easily schedule whatsapp text, image, and video status automatically.", "author": "Extninja", "scripts": { "dev": "plasmo dev --no-cs-reload", "build": "plasmo build", "package": "plasmo package" }, "dependencies": { "@haverstack/axios-fetch-adapter": "^0.12.0", "@lemonsqueezy/lemonsqueezy.js": "^4.0.0", "@mantine/core": "^8.2.2", "@mantine/dates": "^8.2.2", "@mantine/dropzone": "^8.2.2", "@mantine/form": "^8.2.2", "@mantine/hooks": "^8.2.2", "@plasmohq/messaging": "0.7.1", "@plasmohq/storage": "^1.15.0", "@wppconnect/wa-js": "^3.18.0", "axios": "^1.11.0", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dayjs": "^1.11.13", "dexie": "^4.0.11", "dexie-react-hooks": "^1.1.7", "emoji-picker-react": "^4.13.2", "file-saver": "^2.0.5", "html2canvas": "^1.4.1", "jquery": "^3.7.1", "jspdf": "^3.0.1", "jszip": "^3.10.1", "lodash": "^4.17.21", "mantine-datatable": "^8.2.0", "plasmo": "0.90.5", "react": "18.2.0", "react-dom": "18.2.0", "react-if": "^4.1.6", "webextension-polyfill": "^0.12.0", "xlsx": "^0.18.5", "zustand": "^5.0.7" }, "devDependencies": { "@ianvs/prettier-plugin-sort-imports": "4.1.1", "@iconify/react": "^6.0.0", "@types/chrome": "0.0.258", "@types/file-saver": "^2.0.7", "@types/jquery": "^3.5.32", "@types/lodash": "^4.17.20", "@types/node": "20.11.5", "@types/react": "18.2.48", "@types/react-dom": "18.2.18", "@types/webextension-polyfill": "^0.12.3", "postcss": "^8.5.6", "postcss-preset-mantine": "1.17.0", "postcss-simple-vars": "^7.0.1", "prettier": "3.2.4", "typescript": "5.3.3" }, "manifest": { "host_permissions": [ "https://web.whatsapp.com/*", "https://api.lemonsqueezy.com/*" ], "permissions": [], "default_locale": "en" } }
```

# postcss.config.cjs

```cjs
module.exports = { plugins: { 'postcss-preset-mantine': {}, 'postcss-simple-vars': { variables: { 'mantine-breakpoint-xs': '36em', 'mantine-breakpoint-sm': '48em', 'mantine-breakpoint-md': '62em', 'mantine-breakpoint-lg': '75em', 'mantine-breakpoint-xl': '88em', }, }, }, }
```

# README.md

```md
This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo). ## Getting Started First, run the development server: \`\`\`bash pnpm dev # or npm run dev \`\`\` Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`. You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser. For further guidance, [visit our Documentation](https://docs.plasmo.com/) ## Making production build Run the following: \`\`\`bash pnpm build # or npm run build \`\`\` This should create a production bundle for your extension, ready to be zipped and published to the stores. ## Submit to the webstores The easiest way to deploy your Plasmo extension is to use the built-in [bpp](https://bpp.browser.market) GitHub action. Prior to using this action however, make sure to build your extension and upload the first version to the store to establish the basic credentials. Then, simply follow [this setup instruction](https://docs.plasmo.com/framework/workflows/submit) and you should be on your way for automated submission!
```

# src/background/index.ts

```ts
import { Action, Setting } from '@/constants' import { storage } from '@/libs/storage' import { getTabByUrl, openWa } from '@/utils/ext' import { sendToContentScript } from '@plasmohq/messaging' import browser from 'webextension-polyfill' browser.runtime.onInstalled.addListener(async (details) => { if (details.reason === 'install') { await storage.set(Setting.LICENSE_KEY, null) await storage.set(Setting.IS_FIRST_TIME, true) await storage.set(Setting.NEED_TO_OPEN, true) await openWa() } }) browser.action.onClicked.addListener(async () => { const waTab = await getTabByUrl('https://web.whatsapp.com/') if (waTab?.active) { sendToContentScript({ name: Action.Window.SHOW_MODAL_MAIN, }) return } await storage.set(Setting.NEED_TO_OPEN, true) await openWa() })
```

# src/background/messages/http.ts

```ts
import http from '@/libs/http' import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { url, method, data, config } = req.body const httpInstance = { POST: () => { return http.post(url, data, config) }, GET: () => { return http.get(url, config) }, } const result = await httpInstance[method]?.() return res.send(result.data) } export default handler
```

# src/background/messages/landing-page.ts

```ts
import type { PlasmoMessaging } from '@plasmohq/messaging' import browser from 'webextension-polyfill' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const url = browser.runtime.getURL('tabs/landing-page.html') await browser.tabs.create({ url }) return res.send({}) } export default handler
```

# src/background/messages/lemonsqueezy.ts

```ts
import lemonSqueezy from '@/libs/ls' import type { PlasmoMessaging } from '@plasmohq/messaging' import pkg from '../../../package.json' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body try { let response switch (action) { case 'validateLicense': response = await lemonSqueezy.validateLicense(body.licenseKey) break case 'activateLicense': response = await lemonSqueezy.activateLicense(body.licenseKey, pkg.name) break case 'deactivateLicense': response = await lemonSqueezy.deactivateLicense( body.licenseKey, body.instanceId, ) break case 'getCustomer': response = await lemonSqueezy.getCustomer(body.customerId) break default: return res.send({ error: 'Invalid Lemon Squeezy action' }) } res.send(response) } catch (error) { // Tangani error yang mungkin dilempar oleh SDK Lemon Squeezy res.send({ error: true, message: error.message || 'An unknown error occurred.', }) } } export default handler
```

# src/components/AppMenu.module.css

```css
.tab { &:hover, &[data-active] { background-color: var(--mantine-primary-color-filled-hover); } }
```

# src/components/AppMenu.tsx

```tsx
import { Action, Page, PRIMARY_ICON, Setting } from '@/constants' import PageLabel from '@/features/label/PageLabel' import useLicense from '@/hooks/useLicense' import useRuntimeMessage from '@/hooks/useRuntimeMessage' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import env from '@/utils/env' import { goToLandingPage } from '@/utils/util' import { Icon } from '@iconify/react' import { Box, Stack, Tabs, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' import classes from './AppMenu.module.css' import Modal from './Modal/Modal' import ModalActivation from './Modal/ModalActivation' import ModalFaq from './Modal/ModalFaq' import ModalProfile from './Modal/ModalProfile' import ModalUpgrade from './Modal/ModalUpgrade' const AppMenu: React.FC = () => { const { setIsReady, setActiveChat } = useAppStore() const license = useLicense() const [showModalMain, modalMain] = useDisclosure(env.isDevelopment()) const [showModalActivation, modalActivation] = useDisclosure(false) const [showModalFaq, modalFaq] = useDisclosure(false) const [showModalProfile, modalProfile] = useDisclosure(false) const [showModalUpgrade, modalUpgradeHandlers] = useDisclosure(false) const [upgradeInfo, setUpgradeInfo] = useState({ featureName: '', featureBenefit: '', }) const [needToOpen, setNeedToOpen] = useStorage(Setting.NEED_TO_OPEN, false) const [activeTab, setActiveTab] = useState<string | null>(Page.HOME) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.ACTIVE_CHAT: setActiveChat(body) break case Action.Window.GO_TO_PAGE: setActiveTab(body) break case Action.Window.SHOW_MODAL_UPGRADE: setUpgradeInfo({ featureName: body.featureName, featureBenefit: body.featureBenefit, }) modalUpgradeHandlers.open() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break case Action.Window.SHOW_MODAL_FAQ: modalFaq.toggle() break case Action.Window.SHOW_MODAL_PROFILE: modalProfile.toggle() break case Action.Window.SHOW_MODAL_MAIN: modalMain.toggle() break default: break } }) useRuntimeMessage((message, sender, sendResponse) => { switch (message.name) { case Action.Window.SHOW_MODAL_MAIN: modalMain.toggle() sendResponse() break default: break } // Return true to keep the message channel open for async responses return true }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { if (needToOpen) { modalMain.open() setNeedToOpen(false).then().catch(console.error) } }, [needToOpen]) const handleChangeTab = (value: string | null) => { if (Page.UPGRADE === value) { goToLandingPage() return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } if (Page.FAQ === value) { goToLandingPage() return } if (Page.PROFILE === value) { modalProfile.toggle() return } setActiveTab(value) } const renderTabList = () => { return ( <Tabs.List style={{ gap: 10, background: 'linear-gradient(180deg, var(--mantine-color-teal-7) 0%, var(--mantine-color-teal-9) 100%)', }} > <Stack justify="space-between" gap={0} style={{ height: '100%' }}> <Box> <Tabs.Tab value={Page.HOME} className={classes.tab}> <Tooltip label="Status" position="left"> <Icon icon={PRIMARY_ICON} fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> </Box> <Box> <Tabs.Tab value={Page.FAQ} className={classes.tab}> <Tooltip label="Faqs"> <Icon icon="tabler:world-question" fontSize={26} color="white" /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.UPGRADE} className={classes.tab}> <Tooltip label="Upgrade"> <Icon icon="tabler:crown" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab}> <Tooltip label="Activate"> <Icon icon="tabler:key" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PROFILE} className={classes.tab}> <Tooltip label="Profile"> <Icon icon="tabler:user-square-rounded" color="white" fontSize={26} /> </Tooltip> </Tabs.Tab> </Box> </Stack> </Tabs.List> ) } const renderTabPanel = () => { return ( <> <Tabs.Panel value={Page.HOME}> <PageLabel /> </Tabs.Panel> </> ) } return ( <> <Modal opened={showModalMain} onClose={modalMain.close} p={0}> <Tabs value={activeTab} onChange={handleChangeTab} variant="pills" orientation="vertical" radius={0} keepMounted={false} > {renderTabList()} {renderTabPanel()} </Tabs> </Modal> <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <ModalFaq opened={showModalFaq} onClose={modalFaq.close} /> <ModalProfile opened={showModalProfile} onClose={modalProfile.close} /> <ModalUpgrade opened={showModalUpgrade} onClose={modalUpgradeHandlers.close} featureName={upgradeInfo.featureName} featureBenefit={upgradeInfo.featureBenefit} /> </> ) } export default AppMenu
```

# src/components/Input/InputSendLater.tsx

```tsx
import useLicense from '@/hooks/useLicense' import { Badge, Group, Switch, Text } from '@mantine/core' import { DateTimePicker } from '@mantine/dates' import type { UseFormReturnType } from '@mantine/form' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputSendLater: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <> <Switch label={ <Group gap="xs"> <Text fw={500}>Schedule later</Text> </Group> } {...form.getInputProps('scheduler.enabled', { type: 'checkbox' })} /> <When condition={form.values.scheduler.enabled}> <DateTimePicker label="Date time" size="md" minDate={dayjs().add(2, 'minutes').toDate()} clearable {...form.getInputProps('scheduler.scheduledAt')} /> </When> </> ) } export default InputSendLater
```

# src/components/Input/Upload.tsx

```tsx
import { Icon } from '@iconify/react' import { Stack, Text } from '@mantine/core' import { Dropzone, IMAGE_MIME_TYPE, type FileRejection, } from '@mantine/dropzone' import React, { useEffect, useState } from 'react' interface Props { type: 'image' | 'video' | 'file' value: File | null onDrop: (file: File) => void onReject?: (fileRejections: FileRejection[]) => void | null } const Upload: React.FC<Props> = ({ type, value, onDrop, onReject = () => {}, }) => { const [preview, setPreview] = useState<string | null>(null) const [fileInfo, setFileInfo] = useState<{ name: string size: string } | null>(null) const mimes = { image: IMAGE_MIME_TYPE, video: ['video/mp4'], audio: [], file: [], } const maxSizes = { image: 3 * 1024 * 1024, // 3MB video: 8 * 1024 * 1024, // 8MB file: 8 * 1024 * 1024, // 8MB } const idleDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } const rejectDescriptions = { image: 'Max size: 3MB | Formats: JPG, PNG, GIF, WEBP', video: 'Max size: 8MB | Formats: MP4', file: 'Max size: 8MB', } useEffect(() => { // Cleanup function to revoke the object URL when the component unmounts // or when the preview changes, to prevent memory leaks. return () => { if (preview) { URL.revokeObjectURL(preview) } } }, [preview]) useEffect(() => { // This effect handles the display of a preview when a file 'value' is provided. if (value) { if (type === 'image') { const previewUrl = URL.createObjectURL(value) setPreview(previewUrl) } else if (type === 'video') { generateVideoThumbnail(value).then((thumbnail) => setPreview(thumbnail)) } else if (type === 'file') { const sizeInMB = (value.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: value.name, size: `${sizeInMB} MB` }) } } else { // If the value is cleared, reset the preview and file info. setPreview(null) setFileInfo(null) } }, [value, type]) const handleDrop = async (files: File[]) => { if (files.length > 0) { const file = files[0] onDrop(file) // Pass the file to the parent component. // Generate a preview based on the file type. if (type === 'video') { const thumbnail = await generateVideoThumbnail(file) setPreview(thumbnail) } else if (type === 'image') { const previewUrl = URL.createObjectURL(file) setPreview(previewUrl) } else if (type === 'file') { const sizeInMB = (file.size / (1024 * 1024)).toFixed(2) setFileInfo({ name: file.name, size: `${sizeInMB} MB` }) } } } const handleReject = (fileRejections: FileRejection[]) => { onReject(fileRejections) console.log(fileRejections) } const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve) => { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.src = URL.createObjectURL(file) video.addEventListener('loadeddata', () => { canvas.width = 200 canvas.height = 150 video.currentTime = 0 // Seek to the beginning video.addEventListener('seeked', () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up the object URL resolve(thumbnailUrl) } }) }) }) } return ( <Dropzone onDrop={handleDrop} onReject={handleReject} maxSize={maxSizes[type]} accept={mimes[type]} multiple={false} > {/* START: MODIFIED - Conditional Rendering for Dropzone states */} {/* This section checks if a file is already selected. If so, it shows the preview. */} {/* If not, it renders the different dropzone states (Idle, Accept, Reject). */} {type === 'file' && fileInfo ? ( <div style={{ textAlign: 'center' }}> <Stack justify="center" align="center"> <Icon icon="tabler:file-text" fontSize={50} /> <Text>File: {fileInfo.name}</Text> <Text size="sm">Size: {fileInfo.size}</Text> </Stack> </div> ) : preview ? ( <div style={{ textAlign: 'center' }}> <img src={preview} alt="Preview" style={{ maxWidth: '100%', height: 100, objectFit: 'contain' }} /> </div> ) : ( // This block provides enhanced visual feedback for the drag-and-drop interaction. <> {/* Default state when no file is being dragged. */} <Dropzone.Idle> <Stack justify="center" align="center"> <Icon icon={ type === 'image' ? 'tabler:photo' : type === 'video' ? 'tabler:video' : type === 'file' ? 'tabler:file-text' : 'tabler:file' } fontSize={50} /> <Text>Drag & drop here or click to select a file</Text> <Text size="xs" c="dimmed"> {idleDescriptions[type]} </Text> </Stack> </Dropzone.Idle> {/* State when a valid file is dragged over the component. */} <Dropzone.Accept> <Stack justify="center" align="center"> <Icon icon={'tabler:upload'} fontSize={50} /> <Text>Drop the file here...</Text> </Stack> </Dropzone.Accept> {/* State when an invalid file is dragged over. */} <Dropzone.Reject> <Stack justify="center" align="center"> <Icon icon={'tabler:x'} fontSize={50} /> <Text>{rejectDescriptions[type]}</Text> </Stack> </Dropzone.Reject> </> )} {/* END: MODIFIED */} </Dropzone> ) } export default Upload
```

# src/components/Layout/LayoutPage.module.css

```css
.header { border-bottom: 1px solid var(--mantine-color-gray-3); } .footer { border-top: 2px solid var(--mantine-color-gray-3); }
```

# src/components/Layout/LayoutPage.tsx

```tsx
// src/components/Layout/LayoutPage.tsx import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import env from '@/utils/env' import { goToLandingPage } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Loader, Menu, ScrollArea, Stack, Text, Title, type MantineSpacing, type StyleProp, } from '@mantine/core' import icon from 'data-base64:../../../assets/icon.png' import { When } from 'react-if' import packageJson from '../../../package.json' import classes from './LayoutPage.module.css' interface Props { width?: StyleProp<React.CSSProperties['width']> | null height?: StyleProp<React.CSSProperties['height']> | null p?: StyleProp<MantineSpacing> title?: string | null children: React.ReactNode } const LayoutPage: React.FC<Props> = ({ width = 900, height = 620, p = 'xl', children, title = null, }: Props) => { const wa = useWa() const license = useLicense() const renderBody = () => { return ( <Stack px={'xl'} py={'md'} w={width}> {children} </Stack> ) } return ( <> <Stack w={width} gap={0}> <Group justify="space-between" px={'lg'} py={'xs'} className={classes.header} > <Group gap={6}> <img width={32} height={32} src={icon} style={{ borderRadius: 10, }} /> <Title order={4} ml={2}> {title ? title : packageJson.displayName} </Title> <When condition={license.isPro() && env.isProduction()}> <Button radius={'lg'} size="compact-sm" variant="outline" px={'sm'} > <Text fw={500}>Pro</Text> </Button> </When> </Group> {/* MODIFIED: Changed button text to be more benefit-focused. */} <When condition={license.isFree()}> <Button variant="filled" color="yellow" size="xs" radius="md" leftSection={<Icon icon="tabler:crown" fontSize={16} />} onClick={goToLandingPage} > Go Pro </Button> </When> </Group> {wa.isReady ? ( <ScrollArea h={height}>{renderBody()}</ScrollArea> ) : ( <Center h={height}> <Loader /> </Center> )} </Stack> </> ) } export default LayoutPage
```

# src/components/Modal/Modal.tsx

```tsx
import { Icon } from '@iconify/react' import { ActionIcon, Box, Card, Paper, type MantineSpacing, type StyleProp, } from '@mantine/core' import React, { type CSSProperties } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void height?: string | number width?: string | number style?: CSSProperties withCloseButton?: boolean | false h?: StyleProp<React.CSSProperties['height']> w?: StyleProp<React.CSSProperties['width']> p?: StyleProp<MantineSpacing> children: React.ReactNode } const Modal: React.FC<Props> = ({ opened, onClose, style = {}, withCloseButton = false, p = 'lg', h, w, children, ...rest }: Props) => { if (!opened) return null return ( <> <div style={{ position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, zIndex: 399, width: '100%', height: '100%', backgroundColor: 'black', opacity: '0.15', }} onClick={onClose} ></div> <Box style={{ position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', zIndex: 1050, ...style, }} {...rest} > <Card shadow={'xs'} p={p} w={w} h={h} radius={'md'}> <When condition={withCloseButton}> <ActionIcon onClick={onClose} color="red" variant="transparent" style={{ position: 'absolute', right: 3, top: 1, }} > <Icon icon="tabler:x" fontSize={16} /> </ActionIcon> <Box mb={'md'} /> </When> {children} </Card> </Box> </> ) } export default Modal
```

# src/components/Modal/ModalActivation.tsx

```tsx
// src/components/Modal/ModalActivation.tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, rem, Stack, Text, TextInput, ThemeIcon, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalActivation: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const form = useForm({ initialValues: defaultValues, validate: { license: (value) => _.isEmpty(value) ? 'A license key is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) const handleOnClose = () => { form.reset() onClose() } const handleSubmit = async () => { const { hasErrors } = form.validate() if (hasErrors) { return } setLoading(true) form.clearErrors() try { const response = await license.activate(form.values.license) if (response.data.error) { form.setFieldError('license', response.data.error.replace(/_/g, ' ')) setLoading(false) return } if (response.data.meta.store_id.toString() !== getStoreId()) { form.setFieldError( 'license', 'This license key is not valid for this product.', ) setLoading(false) return } toast.success('Successfully activated! ðŸŽ‰') handleOnClose() } catch (err) { console.error('Activation error:', err) form.setFieldError( 'license', 'An unexpected error occurred. Please try again.', ) } finally { setLoading(false) } } return ( <Modal opened={opened} onClose={handleOnClose} w={500} p="xl" withCloseButton > <Stack gap="lg"> <Stack align="center" gap="xs"> <ThemeIcon color="teal" size={rem(60)} radius="xl"> <Icon icon="tabler:key" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> {' '} License Activation{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Enter your license key below to unlock all Pro features.{' '} </Text> </Stack> <Stack> <TextInput label="License Key" placeholder="xxxx-xxxx-xxxx-xxxx" required leftSection={<Icon icon="tabler:key" fontSize={18} />} {...form.getInputProps('license')} /> {/* MODIFIED: Replaced text with more reassuring microcopy. */} <Text size="xs" c="dimmed"> {' '} Your license key validates your purchase, ensuring you receive lifetime access and all future updates.{' '} </Text> </Stack> <Button loading={loading} onClick={handleSubmit} fullWidth size="md" mt="md" leftSection={<Icon icon="tabler:circle-check" fontSize={20} />} > {' '} Activate License{' '} </Button> </Stack> </Modal> ) } export default ModalActivation
```

# src/components/Modal/ModalFaq.tsx

```tsx
// src/components/Modal/ModalFaq.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Accordion, Anchor, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const faqData = [ { icon: 'tabler:rocket', question: 'What are the main benefits of upgrading to Pro?', answer: "With Pro, you get **Total Protection** by backing up all messages and media without limitsâ€”no more risk of losing important data or precious memories. You'll unlock **Exclusive Features** like custom date ranges, Excel/CSV exports, and upcoming premium tools. Plus, you receive **Priority Support**, ensuring our team assists you first whenever you need help.", }, { icon: 'tabler:key', question: 'Where can I find my license key?', answer: 'You will receive an email from Lemon Squeezy after making a purchase. This email usually contains your purchase details and your license key.', }, { icon: 'tabler:shield-lock', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our priority. This extension does not collect, store, or share any personal data from your WhatsApp account. All processes occur locally on your device.', }, { icon: 'tabler:mail-question', question: 'How can I get more help and support?', answer: 'If you have other questions or need assistance, please feel free to email us at extdotninja@gmail.com. Our team will be happy to help you.', }, ] const ModalFaq: React.FC<Props> = ({ opened, onClose }: Props) => { const handleOnClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleOnClose} withCloseButton w={700}> <Stack> <Stack align="center" gap={4} mb={'xl'}> <Icon icon="tabler:world-question" fontSize={48} color="var(--mantine-color-teal-6)" /> <Title order={3} ta="center"> Frequently Asked Questions </Title> </Stack> {/* Accordion */} <Accordion variant="separated" radius="md"> {faqData.map((item) => ( <Accordion.Item key={item.question} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > {/* MODIFIED: Changed the answer to markdown-like bolding for emphasis. */} <Text fw={500} dangerouslySetInnerHTML={{ __html: item.question.replace( /\*\*(.*?)\*\*/g, '<b>$1</b>', ), }} ></Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} ></Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> {/* Contact Support */} <Paper withBorder p="md" shadow="none" radius="md" mt="xl"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still have questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us via email. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Paper> </Stack> </Modal> ) } export default ModalFaq
```

# src/components/Modal/ModalProfile.tsx

```tsx
// src/features/profile/PageProfile.tsx import { Setting } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import { goToLandingPage, showModalActivation } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' import packageJson from '../../../package.json' import Modal from './Modal' interface Props { opened: boolean onClose: () => void } const ModalProfile: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const { profile, license: licenseData } = useAppStore() const [licenseKey] = useStorage(Setting.LICENSE_KEY) const handleDeactivate = async () => { if ( confirm( 'Are you sure you want to deactivate your license on this device?', ) ) { await license.deactivate() } } const handleUpgrade = () => { goToLandingPage() } const handleActivate = () => { showModalActivation() } const maskLicenseKey = (key: string | undefined | null) => { if (!key) return 'N/A' const keyParts = key.split('-') if (keyParts.length > 1) { return `****-****-****-${keyParts[keyParts.length - 1]}` } return '****' + key.slice(-4) } const InfoItem = ({ icon, label, value, }: { icon: string label: string value: React.ReactNode }) => ( <Group wrap="nowrap" gap="lg"> <ThemeIcon variant="light" size={36} radius="md"> <Icon icon={icon} fontSize={20} /> </ThemeIcon> <div> <Text size="xs" c="dimmed"> {label} </Text> <Text size="sm" fw={500}> {value || '-'} </Text> </div> </Group> ) return ( <Modal opened={opened} onClose={onClose} withCloseButton w={700}> <Stack> {/* Account Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Title order={5}>Account Details</Title> <Divider /> <InfoItem icon="tabler:info-circle" label="App Version" value={packageJson.version} /> </Stack> </Card> {/* License Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>License Status</Title> <Badge color={license.isPro() ? 'teal' : 'gray'} size="lg" variant="filled" > {license.isPro() ? 'Pro' : 'Free'} </Badge> </Group> <Divider /> <When condition={license.isPro()}> <Stack my="xs" gap="sm"> <InfoItem icon="tabler:user" label="Licensed To" value={licenseData?.meta.customer_name} /> <InfoItem icon="tabler:mail" label="Email" value={licenseData?.meta.customer_email} /> <InfoItem icon="tabler:key" label="License Key" value={maskLicenseKey(licenseKey)} /> <InfoItem icon="tabler:calendar-event" label="Expires On" value={ licenseData?.license_key.expires_at ? dayjs(licenseData.license_key.expires_at).format( 'DD MMMM YYYY', ) : 'Lifetime' } /> </Stack> </When> <Text size="sm" c="dimmed"> {license.isPro() ? 'Thank you for being a Pro user! You have access to all features.' : 'Upgrade to Pro to unlock all features.'} </Text> <Group justify="flex-end" mt="md"> <When condition={license.isFree()}> <Button onClick={handleUpgrade} color="teal" leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Pro </Button> <Button onClick={handleActivate} variant="outline" leftSection={<Icon icon="tabler:key" fontSize={18} />} > Activate License </Button> </When> <When condition={license.isPro()}> <Button onClick={license.goToMyOrders} variant="outline" leftSection={<Icon icon="tabler:credit-card" fontSize={18} />} > Manage Subscription </Button> <Button onClick={handleDeactivate} color="red" variant="light" leftSection={<Icon icon="tabler:key-off" fontSize={18} />} > Deactivate License </Button> </When> </Group> </Stack> </Card> <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between"> <Title order={5}>Data Privacy Guarantee</Title> <ThemeIcon variant="light" color="teal"> <Icon icon="tabler:shield-check" fontSize={20} /> </ThemeIcon> </Group> <Divider /> <Text size="sm" c="dimmed"> All your data is stored only on your computer and is never sent to our servers. You have 100% control over your data. </Text> </Stack> </Card> </Stack> </Modal> ) } export default ModalProfile
```

# src/components/Modal/ModalSourceExcel.tsx

```tsx
import Modal from '@/components/Modal/Modal' import { Center, Stack, Title } from '@mantine/core' import React from 'react' import ExcelUploader from '../Broadcast/Input/Excel/ExcelUploader' import ExcelUploadPopover from '../Broadcast/Input/Excel/ExcelUploadPopover' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } const ModalSourceExcel: React.FC<Props> = ({ opened, onClose, onSubmit }) => { // This handler receives the raw parsed data from the uploader and formats it // for the broadcast recipient list before passing it up to the parent. const handleConfirmUpload = (parsedData: any[]) => { const newRecipients = parsedData .map((item) => ({ number: item.number?.toString(), name: item.name?.toString() || 'From Excel', source: 'Excel', })) .filter((item) => item.number) if (newRecipients.length > 0) { onSubmit(newRecipients) } } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Numbers From Excel</Title> </Center> <ExcelUploader onConfirm={handleConfirmUpload} onClose={onClose} /> </Stack> </Modal> ) } export default ModalSourceExcel
```

# src/components/Modal/ModalUpgrade.tsx

```tsx
// src/components/Modal/ModalUpgrade.tsx import Modal from '@/components/Modal/Modal' import { goToLandingPage } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Group, rem, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void featureName: string featureBenefit: string } /** * English: A modal to inform free users about a Pro feature they've tried to access. * It provides context about the feature's benefits and offers a clear path to upgrade. */ const ModalUpgrade: React.FC<Props> = ({ opened, onClose, featureName, featureBenefit, }) => { const handleUpgrade = () => { goToLandingPage() onClose() } return ( <Modal opened={opened} onClose={onClose} w={500} p="xl" withCloseButton> <Stack gap="lg" align="center"> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} size={rem(60)} radius="xl" > <Icon icon="tabler:rocket" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> Unlock: {featureName} </Title> <Text c="dimmed" size="sm" ta="center"> {featureBenefit} </Text> <Text size="sm" ta="center" fw={500}> Upgrade to Pro to unlock this feature and many more! </Text> {/* MODIFIED: Wrapped CTA button and added trust signals. */} <Stack align="center" gap="xs" mt="md" w="100%"> <Group justify="center" style={{ width: '100%' }}> <Button variant="outline" onClick={onClose}> Maybe Later </Button> <Button onClick={handleUpgrade} leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > Upgrade Now </Button> </Group> {/* English: Add trust signals below the CTA to increase user confidence. */} <Group justify="center" gap={6} mt="xs"> <Icon icon="tabler:lock" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> Secure Payment & 30-Day Money-Back Guarantee </Text> </Group> </Stack> </Stack> </Modal> ) } export default ModalUpgrade
```

# src/components/Promo/PromoIcon.tsx

```tsx
// English: A simple, professional icon wrapper for branding. // This component is reusable for generating different icon sizes and types. import { Icon } from '@iconify/react' import { ThemeIcon } from '@mantine/core' import React from 'react' interface Props { size: number icon: string } const PromoIcon: React.FC<Props> = ({ size, icon }) => { return ( <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius={100} size={size} > {/* Use the Icon component for dynamic icon rendering */} <Icon icon={icon} style={{ width: '70%', height: '70%', color: 'white' }} /> </ThemeIcon> ) } export default PromoIcon
```

# src/components/Promo/ScreenshotWrapper.tsx

```tsx
// src/components/Promo/ScreenshotWrapper.tsx // English: A reusable wrapper to handle screenshot generation and download logic. // It takes a title, a child component to render, and a filename. import { Icon } from '@iconify/react' import { Button, Card, Group, Stack, Text, Title } from '@mantine/core' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import React, { useRef, useState } from 'react' interface Props { title: string filename: string children: React.ReactNode } const ScreenshotWrapper: React.FC<Props> = ({ title, filename, children }) => { const screenshotRef = useRef<HTMLDivElement>(null) const [isLoading, setIsLoading] = useState(false) const handleDownload = async () => { if (!screenshotRef.current) return setIsLoading(true) try { const canvas = await html2canvas(screenshotRef.current, { scale: 2, // Higher scale for better resolution useCORS: true, // Use component's own background and handle transparency correctly. backgroundColor: null, }) canvas.toBlob((blob) => { if (blob) { FileSaver.saveAs(blob, filename) } }) } catch (error) { console.error('Failed to generate screenshot:', error) } finally { setIsLoading(false) } } return ( <Card withBorder radius="md"> <Stack> <Group justify="space-between"> <Title order={4}>{title}</Title> <Button size="xs" variant="light" onClick={handleDownload} loading={isLoading} leftSection={<Icon icon="tabler:download" fontSize={16} />} > Download </Button> </Group> <div ref={screenshotRef} style={{ alignSelf: 'flex-start', }} > {children} </div> </Stack> </Card> ) } export default ScreenshotWrapper
```

# src/components/Toast/Toast.module.css

```css
@keyframes fadeIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .toast { animation: fadeIn 0.3s ease-out forwards; }
```

# src/components/Toast/Toast.tsx

```tsx
import { type Toast } from '@/stores/toast' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Text, ThemeIcon } from '@mantine/core' import { useEffect } from 'react' import classes from './Toast.module.css' interface ToastProps extends Toast { onClose: () => void } const ToastComponent: React.FC<ToastProps> = ({ id, type, title, message, duration = 2000, onClose, }) => { useEffect(() => { const timer = setTimeout(() => { onClose() }, duration) return () => clearTimeout(timer) }, [id, duration, onClose]) const toastConfig = { success: { icon: 'tabler:check', color: 'teal' }, error: { icon: 'tabler:x', color: 'red' }, info: { icon: 'tabler:info-circle', color: 'blue' }, // ADDED: Configuration for the new 'warning' type. warning: { icon: 'tabler:alert-triangle', color: 'orange' }, } const { icon, color } = toastConfig[type] return ( <Paper shadow="lg" p="sm" radius="md" withBorder className={classes.toast} style={{ minWidth: 350, maxWidth: 400 }} > <Group align="flex-start" wrap="nowrap"> <ThemeIcon color={color} size={36} radius="xl" mt={4}> <Icon icon={icon} fontSize={22} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Text fw={600} size="md"> {title} </Text> <Text size="sm" c="dimmed"> {message} </Text> </Stack> <ActionIcon variant="transparent" color="gray" onClick={onClose}> <Icon icon="tabler:x" /> </ActionIcon> </Group> </Paper> ) } export default ToastComponent
```

# src/components/Toast/ToastProvider.tsx

```tsx
import { useToastStore } from '@/stores/toast' import { Box } from '@mantine/core' import React from 'react' import ToastComponent from './Toast' const ToastProvider: React.FC = () => { const { toasts, removeToast } = useToastStore() return ( <Box style={{ position: 'fixed', top: 20, right: 20, zIndex: 2000, display: 'flex', flexDirection: 'column', gap: '10px', }} > {toasts.map((toast) => ( <ToastComponent key={toast.id} id={toast.id} type={toast.type} title={toast.title} message={toast.message} duration={toast.duration} onClose={() => removeToast(toast.id)} /> ))} </Box> ) } export default ToastProvider
```

# src/config/plans.ts

```ts
// src/config/plans.ts // English: Define a structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // English: Centralized list of features for easy management and comparison export const features: PlanFeature[] = [ { feature: 'Message Backups', free: 'Up to 10 messages', pro: 'Unlimited', }, { feature: 'Backup Media (Images, Videos, Docs)', free: false, pro: true, }, { feature: 'Advanced Date Range Filtering', free: 'Last 7 days only', pro: true, }, { feature: 'Multiple Keyword Filtering', free: '1 keyword', // MODIFIED: Changed from `false` to specify the limit. pro: 'Unlimited', // MODIFIED: Changed from `true` to be more descriptive. }, { feature: 'Export to Multiple Formats', free: 'HTML only', pro: 'PDF, CSV, Excel, JSON, TXT', }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, ] // English: Define plan objects for the pricing cards. // This array structure allows for easy side-by-side comparison in the UI. const plans = [ { name: 'Free', isFree: true, description: 'For basic chat backup needs.', price: '$0', placeholderPrice: null, link: '#', features: [ 'Backup up to 10 messages per chat', 'Text-only backups', 'Export to HTML format', 'Limited to the last 7 days', ], }, { name: 'Pro Lifetime', isFree: false, description: 'Pay once, access all features forever.', placeholderPrice: '$89', price: '$39', link: 'https://extdotninja.lemonsqueezy.com/buy/7f1401c0-fd00-4898-af64-15a869f9fb12?media=0&logo=0&desc=0&discount=0', features: [ 'Unlimited Message Backups', 'Backup All Media Types', 'Advanced Date & Keyword Filters', 'Multiple Export Formats', 'Priority Customer Support', 'All Future Updates Included', ], }, ] export default plans
```

# src/constants/action.ts

```ts
export const App = { HTTP: 'App.HTPP', AI: 'App.AI', } export const Blocklist = { ALL: 'Blocklist.ALL', BLOCK_CONTACT: 'Blocklist.BLOCK_CONTACT', IS_BLOCKED: 'Blocklist.IS_BLOCKED', UNBLOCK_CONTACT: 'Blocklist.UNBLOCK_CONTACT', } export const Cart = { ADD: 'Cart.ADD', CLEAR: 'Cart.CLEAR', GET: 'Cart.GET', GET_THUMB_FROM_CART: 'Cart.GET_THUMB_FROM_CART', REMOVE: 'Cart.REMOVE', SUBMIT: 'Cart.SUBMIT', UPDATE: 'Cart.UPDATE', } export const Catalog = { ADD_PRODUCT_IMAGE: 'Catalog.ADD_PRODUCT_IMAGE', CHANGE_PRODUCT_IMAGE: 'Catalog.CHANGE_PRODUCT_IMAGE', CREATE_COLLECTION: 'Catalog.CREATE_COLLECTION', CREATE_PRODUCT: 'Catalog.CREATE_PRODUCT', DELETE_COLLECTION: 'Catalog.DELETE_COLLECTION', DELETE_PRODUCT: 'Catalog.DELETE_PRODUCT', EDIT_COLLECTION: 'Catalog.EDIT_COLLECTION', EDIT_PRODUCT: 'Catalog.EDIT_PRODUCT', GET_COLLECTIONS: 'Catalog.GET_COLLECTIONS', GET_MY_CATALOG: 'Catalog.GET_MY_CATALOG', GET_PRODUCT_BY_ID: 'Catalog.GET_PRODUCT_BY_ID', GET_PRODUCTS: 'Catalog.GET_PRODUCTS', REMOVE_PRODUCT_IMAGE: 'Catalog.REMOVE_PRODUCT_IMAGE', SET_PRODUCT_VISIBILITY: 'Catalog.SET_PRODUCT_VISIBILITY', UPDAGE_CART_ENABLED: 'Catalog.UPDAGE_CART_ENABLED', } export const Community = { ADD_SUB_GROUPS: 'Community.ADD_SUB_GROUPS', } export const Chat = { ARCHIVE: 'Chat.ARCHIVE', CAN_MARK_PLAYED: 'Chat.CAN_MARK_PLAYED', CAN_MUTE: 'Chat.CAN_MUTE', CAN_REPLY: 'Chat.CAN_REPLY', CLEAR: 'Chat.CLEAR', CLOSE_CHAT: 'Chat.CLOSE_CHAT', DELETE: 'Chat.DELETE', DELETE_MESSAGE: 'Chat.DELETE_MESSAGE', DOWNLOAD_MEDIA: 'Chat.DOWNLOAD_MEDIA', // ++ ADDED FIND: 'Chat.FIND', FORWARD_MESSAGE: 'Chat.FORWARD_MESSAGE', GET: 'Chat.GET', GET_ACTIVE_CHAT: 'Chat.GET_ACTIVE_CHAT', GET_LAST_SEEN: 'Chat.GET_LAST_SEEN', GET_MESSAGE_ACK: 'Chat.GET_MESSAGE_ACK', GET_MESSAGES: 'Chat.GET_MESSAGES', GET_NOTES: 'Chat.GET_NOTES', GET_PLATFORM_MESSAGE: 'Chat.GET_PLATFORM_MESSAGE', MARK_IS_COMPOSING: 'Chat.MARK_IS_COMPOSING', MARK_IS_PAUSED: 'Chat.MARK_IS_PAUSED', MARK_IS_READ: 'Chat.MARK_IS_READ', MARK_IS_RECORDING: 'Chat.MARK_IS_RECORDING', MARK_IS_UNREAD: 'Chat.MARK_IS_UNREAD', MARK_PLAYED: 'Chat.MARK_PLAYED', MUTE: 'Chat.MUTE', OPEN_CHAT_AT: 'Chat.OPEN_CHAT_AT', OPEN_CHAT_BOTTOM: 'Chat.OPEN_CHAT_BOTTOM', OPEN_CHAT_FROM_UNREAD: 'Chat.OPEN_CHAT_FROM_UNREAD', PIN_MSG: 'Chat.PIN_MSG', LIST: 'Chat.LIST', SET_CHAT_LIST: 'Chat.SET_CHAT_LIST', SET_INPUT_TEXT: 'Chat.SET_INPUT_TEXT', SET_NOTES: 'Chat.SET_NOTES', } export const Contact = { GET: 'Contact.GET', GET_BUSINESS_PROFILE: 'Contact.GET_BUSINESS_PROFILE', GET_COMMON_GROUPS: 'Contact.GET_COMMON_GROUPS', GET_PROFILE_PICTURE_URL: 'Contact.GET_PROFILE_PICTURE_URL', GET_STATUS: 'Contact.GET_STATUS', LIST: 'Contact.LIST', LIST_CONTACT_BY_COUNTRY: 'Contact.LIST_CONTACT_BY_COUNTRY', IS_EXIST: 'Contact.IS_EXIST', REMOVE: 'Contact.REMOVE', } export const Conn = { GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER: 'Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER', GET_AUTH_CODE: 'Conn.GET_AUTH_CODE', GET_PROFILE: 'Conn.GET_PROFILE', GET_MY_USER_ID: 'Conn.GET_MY_USER_ID', } export const Group = { ADD_PARTICIPANTS: 'Group.ADD_PARTICIPANTS', APPROVE: 'Group.APPROVE', LIST: 'Group.LIST', CAN_ADD: 'Group.CAN_ADD', CAN_DEMOTE: 'Group.CAN_DEMOTE', CAN_PROMOTE: 'Group.CAN_PROMOTE', CAN_REMOVE: 'Group.CAN_REMOVE', CREATE: 'Group.CREATE', DEMOTE_PARTICIPANTS: 'Group.DEMOTE_PARTICIPANTS', GET_GROUP_INFO_FROM_INVITE_CODE: 'Group.GET_GROUP_INFO_FROM_INVITE_CODE', GET_GROUP_SIZE_LIMIT: 'Group.GET_GROUP_SIZE_LIMIT', GET_INVITE_LINK: 'Group.GET_INVITE_LINK', GET_MEMBERSHIP_REQUESTS: 'Group.GET_MEMBERSHIP_REQUESTS', GET_PARTICIPANTS: 'Group.GET_PARTICIPANTS', IAM_ADMIN: 'Group.IAM_ADMIN', IAM_MEMBER: 'Group.IAM_MEMBER', IAM_RESTRICTED_MEMBER: 'Group.IAM_RESTRICTED_MEMBER', IAM_SUPER_ADMIN: 'Group.IAM_SUPER_ADMIN', JOIN: 'Group.JOIN', LEAVE: 'Group.LEAVE', PROMOTE_PARTICIPANTS: 'Group.PROMOTE_PARTICIPANTS', REJECT: 'Group.REJECT', REMOVE_ICON: 'Group.REMOVE_ICON', REMOVE_PARTICIPANTS: 'Group.REMOVE_PARTICIPANTS', REVOKE_INVITE_CODE: 'Group.REVOKE_INVITE_CODE', SET_DESCRIPTION: 'Group.SET_DESCRIPTION', SET_ICON: 'Group.SET_ICON', SET_PROPERTY: 'Group.SET_PROPERTY', SET_SUBJECT: 'Group.SET_SUBJECT', } export const Newsletter = { CREATE: 'Newsletter.CREATE', DESTROY: 'Newsletter.DESTROY', EDIT: 'Newsletter.EDIT', GET_SUBSCRIBERS: 'Newsletter.GET_SUBSCRIBERS', MUTE: 'Newsletter.MUTE', } export const Send = { TEXT: 'Send.TEXT', IMAGE: 'Send.IMAGE', LOCATION: 'Send.LOCATION', DOCUMENT: 'Send.DOCUMENT', FILE: 'Send.FILE', POLL: 'Send.POLL', VCARD: 'Send.VCARD', } export const Status = { GET: 'Status.GET', GET_MY_STATUS: 'Status.GET_MY_STATUS', REMOVE: 'Status.REMOVE', SEND_IMAGE_STATUS: 'Status.SEND_IMAGE_STATUS', SEND_READ_STATUS: 'Status.SEND_READ_STATUS', SEND_TEXT_STATUS: 'Status.SEND_TEXT_STATUS', SEND_VIDEO_STATUS: 'Status.SEND_VIDEO_STATUS', UPDATE_PARTICIPANTS: 'Status.UPDATE_PARTICIPANTS', } export const Profile = { EDIT_BUSINESS_PROFILE: 'Profile.EDIT_BUSINESS_PROFILE', GET_MY_PROFILE_NAME: 'Profile.GET_MY_PROFILE_NAME', GET_MY_PROFILE_PICTURE: 'Profile.GET_MY_PROFILE_PICTURE', GET_MY_STATUS: 'Profile.GET_MY_STATUS', IS_BUSINESS: 'Profile.IS_BUSINESS', REMOVE_MY_PROFILE_PICTURE: 'Profile.REMOVE_MY_PROFILE_PICTURE', SET_MY_PROFILE_NAME: 'Profile.SET_MY_PROFILE_NAME', SET_MY_PROFILE_PICTURE: 'Profile.SET_MY_PROFILE_PICTURE', SET_MY_STATUS: 'Profile.SET_MY_STATUS', } export const AI = { REWRITE_MESSAGE: 'AI.REWRITE_MESSAGE', } export const Window = { READY: 'Window.READY', ACTIVE_CHAT: 'Window.ACTIVE_CHAT', GO_TO_PAGE: 'Window.GO_TO_PAGE', CLOSE_PAGE: 'Window.CLOSE_PAGE', SHOW_MODAL_MAIN: 'Window.SHOW_MODAL_MAIN', SHOW_MODAL_UPGRADE: 'Window.SHOW_MODAL_UPGRADE', SHOW_MODAL_ACTIVATION: 'Window.SHOW_MODAL_ACTIVATION', SHOW_MODAL_PROFILE: 'Window.SHOW_MODAL_PROFILE', SHOW_MODAL_FAQ: 'Window.SHOW_MODAL_FAQ', SEND_BROADCAST: 'Window.SEND_BROADCAST', }
```

# src/constants/index.ts

```ts
// src/constants/index.ts export * as Action from './action' export * as Setting from './setting' export const PRIMARY_ICON = 'tabler:tags' export const Status = { SUCCESS: 'SUCCESS', IDLE: 'IDLE', PENDING: 'PENDING', FAILED: 'FAILED', RUNNING: 'RUNNING', SCHEDULER: 'SCHEDULER', CANCELLED: 'CANCELLED', PAUSED: 'PAUSED', DRAFT: 'DRAFT', POSTED: 'POSTED', } export const Page = { HOME: 'Page.HOME', DIRECT_CHAT: 'Page.DIRECT_CHAT', PRIVACY: 'Page.PRIVACY', EXPORT: 'Page.EXPORT', FAQ: 'Page.FAQ', UPGRADE: 'Page.UPGRADE', ACTIVATE: 'Page.ACTIVATE', PROFILE: 'Page.PROFILE', } export const Account = { BUSINESS: 'BUSINESS', PERSONAL: 'PERSONAL', } export const Message = { TEXT: 'TEXT', MEDIA: 'MEDIA', IMAGE: 'IMAGE', VIDEO: 'VIDEO', AUDIO: 'AUDIO', FILE: 'FILE', LOCATION: 'LOCATION', VCARD: 'VCARD', BUTTON: 'BUTTON', LIST: 'LIST', POLL: 'POLL', } export const Media = { BROADCAST: 'BROADCAST', BROADCAST_TEMPLATE: 'BROADCAST_TEMPLATE', STATUS_CONTENT: 'STATUS_CONTENT', QUICK_REPLY: 'QUICK_REPLY', } export const ContactType = { ALL: 'CONTACT_TYPE_ALL', SAVED_CONTACTS: 'CONTACT_TYPE_SAVED_CONTACTS', UNSAVED_CONTACTS: 'CONTACT_TYPE_UNSAVED_CONTACTS', } export const AccountType = { ALL: 'ACCOUNT_TYPE_ALL', PERSONAL: 'ACCOUNT_TYPE_PERSONAL', BUSINESS: 'ACCOUNT_TYPE_BUSINESS', } export const MessageType = { ALL: 'MESSAGE_TYPE_ALL', HAVE_UNREAD_MESSAGES: 'MESSAGE_TYPE_HAVE_UNREAD_MESSAGES', NO_UNREAD_MESSAGES: 'MESSAGE_TYPE_NO_UNREAD_MESSAGES', } export const SaveAs = { CSV: 'SAVE_AS_CSV', EXCEL: 'SAVE_AS_EXCEL', PDF: 'SAVE_AS_PDF', JSON: 'SAVE_AS_JSON', MARKDOWN: 'SAVE_AS_MARKDOWN', HTML: 'SAVE_AS_HTML', VCARD: 'SAVE_AS_VCARD', } export const StatusType = { TEXT: 'TEXT_STATUS', IMAGE: 'IMAGE_STATUS', VIDEO: 'VIDEO_STATUS', }
```

# src/constants/setting.ts

```ts
export const LICENSE_KEY = 'SETTING_LICENSE_KEY' export const LICENSE_INSTANCE_ID = 'SETTING_LICENSE_INSTANCE_ID' export const LICENSE_DATA_CACHE = 'SETTING_LICENSE_DATA_CACHE' export const IS_FIRST_TIME = 'SETTING_IS_FIRST_TIME' export const NEED_TO_OPEN = 'SETTING_NEED_TO_OPEN' export const HAS_ACKNOWLEDGED_BROADCAST_WARNING = 'SETTING.HAS_ACKNOWLEDGED_BROADCAST_WARNING' export const BLUR_PROFILE_PICTURES = 'SETTING.BLUR_PROFILE_PICTURES' export const BLUR_MESSAGES = 'SETTING.BLUR_MESSAGES' export const BLUR_USER_GROUP_NAMES = 'SETTING.BLUR_USER_GROUP_NAMES' export const BLUR_RECENT_MESSAGES = 'SETTING.BLUR_RECENT_MESSAGES' export const EXPORT_COLUMNS = 'SETTING_EXPORT_COLUMNS'
```

# src/contents/header.tsx

```tsx
import { Action } from '@/constants' import useWa from '@/hooks/useWa' import db, { type Label } from '@/libs/db' import theme from '@/libs/theme' import style from '@/utils/style' import { postMessage } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Box, Center, Checkbox, Group, MantineProvider, Menu, ScrollArea, Text, TextInput, Tooltip, } from '@mantine/core' import { useLiveQuery } from 'dexie-react-hooks' import $ from 'jquery' import type { PlasmoCSConfig, PlasmoGetInlineAnchor, PlasmoGetShadowHostId, } from 'plasmo' import React, { useMemo, useState } from 'react' import { When } from 'react-if' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-header` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } export const getInlineAnchor: PlasmoGetInlineAnchor = async () => ({ element: $('div[class="x78zum5 xdt5ytf x5yr21d"]')[0], insertPosition: 'afterbegin', }) const Header = () => { const wa = useWa() const [activeLabelId, setActiveLabelId] = useState<number | null>(null) const allLabels = useLiveQuery(() => db.labels.toArray()) const [labelSearch, setLabelSearch] = useState('') // State for menu search const { pinnedLabels, unpinnedLabels } = useMemo(() => { const pinned = allLabels?.filter((label) => label.isPinned === 1 && label.show) || [] const unpinned = allLabels?.filter((label) => !label.isPinned && label.show) || [] return { pinnedLabels: pinned, unpinnedLabels: unpinned } }, [allLabels]) // Memoized search results for the management menu const filteredMenuLabels = useMemo(() => { if (!allLabels) return [] if (!labelSearch) return allLabels return allLabels.filter((label) => label.label.toLowerCase().includes(labelSearch.toLowerCase()), ) }, [allLabels, labelSearch]) const handleFilterChat = async (label: Label) => { if (label.id === activeLabelId) { await wa.chat.setChatList('all') setActiveLabelId(null) return } await wa.chat.setChatList('custom', label.numbers) setActiveLabelId(label.id) } const handleClearFilter = async () => { await wa.chat.setChatList('all') setActiveLabelId(null) } const handleToggleVisibility = async (label: Label) => { if (label.id) { await db.labels.update(label.id, { show: label.show ? 0 : 1 }) } } const handleTogglePin = async (label: Label) => { if (label.id) { await db.labels.update(label.id, { isPinned: label.isPinned ? 0 : 1 }) } } const handleManageLabels = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } const renderLabel = (label: Label) => { const isActive = activeLabelId === label.id return ( // MODIFIED: Added Tooltip to show label description on hover. <Tooltip key={label.id} label={label.description} position="bottom" withArrow disabled={!label.description} multiline w={220} > <Badge size="lg" color={label.color || 'gray'} radius={'sm'} variant={isActive ? 'filled' : 'light'} onClick={() => handleFilterChat(label)} mr={'sm'} style={{ cursor: 'pointer' }} > {label.label} ({label.numbers?.length || 0}) </Badge> </Tooltip> ) } return ( <MantineProvider theme={theme} cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-header') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <Group style={{ backgroundColor: 'var(--mantine-color-body)', borderBottom: '1px solid var(--mantine-color-gray-3)', }} w={'100%'} px="lg" py={10} justify="space-between" gap="xs" wrap="nowrap" > <ScrollArea w={1100}> {/* MODIFIED: Added informative empty state when no labels exist. */} {allLabels && allLabels.length > 0 ? ( <Box style={{ textWrap: 'nowrap' }}> {pinnedLabels.map(renderLabel)} {unpinnedLabels.map(renderLabel)} </Box> ) : ( <Center h={36}> <Text c="dimmed" size="sm"> No filters yet. Click the{' '} <Icon icon="tabler:adjustments-alt" style={{ display: 'inline-block', verticalAlign: 'middle' }} />{' '} icon to create your first label! </Text> </Center> )} </ScrollArea> <Group mr={60} justify="flex-end" wrap="nowrap"> <When condition={activeLabelId !== null}> <Tooltip label="Clear Filter" position="bottom"> <ActionIcon variant="subtle" color="red" size="lg" onClick={handleClearFilter} > <Icon fontSize={22} icon={'tabler:x'} /> </ActionIcon> </Tooltip> </When> <Menu shadow="md" width={280} position="bottom-end" closeOnItemClick={false} > <Menu.Target> <Tooltip label="Manage Filters & Labels" position="bottom"> <ActionIcon variant="subtle" size="lg"> <Icon fontSize={22} icon={'tabler:adjustments-alt'} /> </ActionIcon> </Tooltip> </Menu.Target> <Menu.Dropdown> {/* MODIFIED: Added search input inside the management menu. */} <TextInput placeholder="Search labels..." value={labelSearch} onChange={(event) => setLabelSearch(event.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={14} />} m="xs" onClick={(e) => e.stopPropagation()} /> <Menu.Divider /> <ScrollArea h={200}> {filteredMenuLabels.length > 0 ? ( filteredMenuLabels.map((label) => ( <Menu.Item key={label.id}> <Group justify="space-between" wrap="nowrap"> <Checkbox checked={!!label.show} onChange={() => handleToggleVisibility(label)} label={ <Text size="sm" truncate> {label.label} </Text> } color={label.color} /> <Tooltip label={label.isPinned ? 'Unpin' : 'Pin'} position="left" > <ActionIcon variant="subtle" color={label.isPinned ? 'yellow' : 'gray'} onClick={() => handleTogglePin(label)} > <Icon icon={ label.isPinned ? 'tabler:star-filled' : 'tabler:star' } fontSize={16} /> </ActionIcon> </Tooltip> </Group> </Menu.Item> )) ) : ( <Text c="dimmed" ta="center" size="sm" p="xs"> No labels found. </Text> )} </ScrollArea> <Menu.Divider /> <Menu.Item leftSection={<Icon icon="tabler:settings" fontSize={16} />} onClick={handleManageLabels} closeMenuOnClick={true} > Manage labels </Menu.Item> </Menu.Dropdown> </Menu> </Group> </Group> </MantineProvider> ) } export default Header
```

# src/contents/inject-script.ts

```ts
import { Action } from '@/constants' import wa from '@/libs/wa' import { initInjectScriptRelays } from '@/relays' import { postMessage } from '@/utils/util' import type { PlasmoCSConfig } from 'plasmo' export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], world: 'MAIN', } initInjectScriptRelays() wa.on.ready(() => { setTimeout(() => { onReady() }, 2000) }) const onReady = () => { setTimeout(() => { window.postMessage({ action: Action.Window.READY, body: {}, }) WPP.on('chat.active_chat', (chat) => { const body = { name: chat.contact?.__x_pushname || chat.contact?.__x_verifiedName || chat.name || chat.formattedTitle, number: chat.id.user, formattedNumber: chat.id._serialized, isUser: chat.id._serialized.includes('@c.us'), isGroup: chat.id._serialized.includes('@g.us'), isBusiness: chat.contact?.__x_isBusiness, } postMessage(Action.Window.ACTIVE_CHAT, body) }) }, 1000) }
```

# src/contents/main.tsx

```tsx
import AppMenu from '@/components/AppMenu' import ToastProvider from '@/components/Toast/ToastProvider' import theme from '@/libs/theme' import style from '@/utils/style' import { MantineProvider } from '@mantine/core' import type { PlasmoCSConfig, PlasmoGetShadowHostId } from 'plasmo' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-main` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Main = () => { return ( <> <MantineProvider theme={theme} //@ts-ignore cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-main') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <AppMenu /> <ToastProvider /> </MantineProvider> </> ) } export default Main
```

# src/features/label/components/ContactsUploader.tsx

```tsx
// src/features/label/components/ContactsUploader.tsx import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Button, Group, List, Stack, Text, ThemeIcon } from '@mantine/core' import { Dropzone, MIME_TYPES } from '@mantine/dropzone' import React, { useState } from 'react' import * as XLSX from 'xlsx' interface Props { onConfirm: (numbers: string[]) => void onClose: () => void } /** * A component to handle uploading and parsing contact numbers from CSV/Excel files. */ const ContactsUploader: React.FC<Props> = ({ onConfirm, onClose }) => { const [parsedData, setParsedData] = useState<any[]>([]) const [fileName, setFileName] = useState<string | null>(null) const handleDrop = (files: File[]) => { if (files.length === 0) return const file = files[0] const reader = new FileReader() reader.onload = (event) => { try { const data = new Uint8Array(event.target.result as ArrayBuffer) const workbook = XLSX.read(data, { type: 'array' }) const sheetName = workbook.SheetNames[0] const worksheet = workbook.Sheets[sheetName] const json = XLSX.utils.sheet_to_json(worksheet) if (json.length === 0) { toast.error('The uploaded file is empty or in the wrong format.') return } setParsedData(json) setFileName(file.name) } catch (error) { console.error('Failed to parse file:', error) toast.error( 'Failed to parse the file. Please ensure it is a valid CSV or Excel file.', ) handleReject() } } reader.readAsArrayBuffer(file) } const handleReject = (rejections?: any[]) => { setParsedData([]) setFileName(null) if (rejections && rejections.length > 0) { toast.error('File rejected. Please upload a valid CSV or Excel file.') } } const handleConfirm = () => { if (parsedData.length === 0) { toast.error('No data to import.') return } const firstRow = parsedData[0] const key = Object.keys(firstRow).find( (k) => k.toLowerCase() === 'number' || k.toLowerCase() === 'phone', ) const numbers = parsedData .map((row) => { const value = key ? row[key] : row[Object.keys(row)[0]] return String(value).replace(/\D/g, '') // Remove all non-digit characters }) .filter((number) => number.length > 5) // Basic validation for phone number length if (numbers.length === 0) { toast.error( "Could not find valid numbers. Ensure a column is named 'number' or contains phone numbers.", ) return } onConfirm(numbers) handleReject() // Clear state after confirming } if (parsedData.length > 0) { return ( <Stack> <Text> File{' '} <Text span fw={700}> {fileName} </Text>{' '} is ready. We found{' '} <Text span fw={700}> {parsedData.length} </Text>{' '} rows. </Text> <Text c="dimmed" size="sm"> We will add the imported numbers to the label. Duplicate numbers will be ignored. </Text> <Group justify="end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleConfirm}>Confirm Import</Button> </Group> </Stack> ) } return ( <Stack> <Dropzone onDrop={handleDrop} onReject={handleReject} maxSize={5 * 1024 ** 2} // 5MB accept={[MIME_TYPES.csv, MIME_TYPES.xls, MIME_TYPES.xlsx]} multiple={false} > <Group justify="center" gap="xl" mih={220} style={{ pointerEvents: 'none' }} > <Dropzone.Idle> <Icon icon={'tabler:file-text'} fontSize={50} /> </Dropzone.Idle> <div> <Text size="xl" inline> Drag file here or click to select </Text> <Text size="sm" c="dimmed" inline mt={7}> Attach a single CSV or Excel file. </Text> </div> </Group> </Dropzone> <List size="sm" c="dimmed" mt="md" spacing="xs" withPadding> <List.Item> The file must have a header row (e.g., "Name", "Number"). </List.Item> <List.Item> We recommend a column named{' '} <Text span fw={500}> number </Text>{' '} or{' '} <Text span fw={500}> phone </Text> . Otherwise, we will use the first column. </List.Item> </List> </Stack> ) } export default ContactsUploader
```

# src/features/label/components/EditableCell.tsx

```tsx
// src/features/label/components/EditableCell.tsx import { Loader, TextInput, Tooltip } from '@mantine/core' import React, { useEffect, useRef, useState } from 'react' interface Props { value: string onSave: (newValue: string) => Promise<void> children: React.ReactNode } /** * A reusable component that displays a value and provides an inline editing * experience on double-click. */ const EditableCell: React.FC<Props> = ({ value, onSave, children }) => { const [isEditing, setIsEditing] = useState(false) const [currentValue, setCurrentValue] = useState(value) const [isLoading, setIsLoading] = useState(false) const inputRef = useRef<HTMLInputElement>(null) useEffect(() => { if (isEditing && inputRef.current) { inputRef.current.focus() inputRef.current.select() } }, [isEditing]) const handleDoubleClick = () => { setCurrentValue(value) setIsEditing(true) } const handleSave = async () => { // Avoid saving if the value hasn't changed if (currentValue.trim() === value.trim()) { setIsEditing(false) return } setIsLoading(true) try { await onSave(currentValue) } catch (error) { // The parent component will show an error toast. Revert value on failure. setCurrentValue(value) } finally { setIsLoading(false) setIsEditing(false) } } const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => { if (event.key === 'Enter') { handleSave() } else if (event.key === 'Escape') { setIsEditing(false) setCurrentValue(value) } } if (isEditing) { return ( <TextInput ref={inputRef} value={currentValue} onChange={(e) => setCurrentValue(e.currentTarget.value)} onBlur={handleSave} onKeyDown={handleKeyDown} disabled={isLoading} rightSection={isLoading ? <Loader size="xs" /> : null} onClick={(e) => e.stopPropagation()} // Prevent row click events /> ) } return ( <Tooltip label="Double-click to edit" openDelay={500} withArrow> <div onDoubleClick={handleDoubleClick} style={{ cursor: 'pointer', width: '100%', minHeight: '22px' }} > {children} </div> </Tooltip> ) } export default React.memo(EditableCell)
```

# src/features/label/components/LabelActions.tsx

```tsx
// src/features/label/components/LabelActions.tsx import type { Label } from '@/libs/db' import { Icon } from '@iconify/react' import { ActionIcon, Group, Menu, Tooltip } from '@mantine/core' import React from 'react' interface Props { label: Label onEdit: (label: Label) => void onDelete: (label: Label) => void onManageContacts: (label: Label) => void onExport: (label: Label, format: 'csv' | 'excel') => void } /** * A memoized component that renders the action icons for a label row. * This includes editing, deleting, managing, and exporting contacts. */ const LabelActions: React.FC<Props> = ({ label, onEdit, onDelete, onManageContacts, onExport, }) => { return ( <Group gap="xs" justify="center"> <Tooltip label="Manage Contacts"> <ActionIcon variant="light" onClick={() => onManageContacts(label)}> <Icon icon="tabler:users-group" /> </ActionIcon> </Tooltip> <Menu shadow="md" width={150} position="bottom-end"> <Menu.Target> <Tooltip label="Export Contacts"> <ActionIcon variant="light" color="blue"> <Icon icon="tabler:file-export" /> </ActionIcon> </Tooltip> </Menu.Target> <Menu.Dropdown> <Menu.Label>Export as</Menu.Label> <Menu.Item leftSection={<Icon icon="tabler:file-type-csv" />} onClick={() => onExport(label, 'csv')} > {' '} CSV{' '} </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:file-type-xls" />} onClick={() => onExport(label, 'excel')} > {' '} Excel{' '} </Menu.Item> </Menu.Dropdown> </Menu> <Tooltip label="Edit Label"> <ActionIcon variant="light" color="blue" onClick={() => onEdit(label)}> <Icon icon="tabler:pencil" /> </ActionIcon> </Tooltip> <Tooltip label="Delete Label"> <ActionIcon variant="light" color="red" onClick={() => onDelete(label)}> <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ) } export default React.memo(LabelActions)
```

# src/features/label/components/LabelBulkActions.tsx

```tsx
// src/features/label/components/LabelBulkActions.tsx import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Menu, Text, Tooltip } from '@mantine/core' import React from 'react' interface Props { selectedCount: number onDelete: () => void onPin: () => void onUnpin: () => void onClear: () => void onExport: (format: 'csv' | 'excel') => void // Added export handler } const LabelBulkActions: React.FC<Props> = ({ selectedCount, onDelete, onPin, onUnpin, onClear, onExport, // Destructure new prop }) => { return ( <Group justify="space-between" p="sm" style={{ border: '1px solid var(--mantine-color-gray-3)', borderRadius: 'var(--mantine-radius-md)', backgroundColor: 'var(--mantine-color-gray-0)', }} > <Group> <Text fw={500} size="sm"> {selectedCount} selected </Text> <Button size="xs" variant="light" color="yellow" leftSection={<Icon icon="tabler:star" fontSize={16} />} onClick={onPin} > Pin </Button> <Button size="xs" variant="light" color="gray" leftSection={<Icon icon="tabler:star-off" fontSize={16} />} onClick={onUnpin} > Unpin </Button> {/* START: MODIFIED - Added bulk export button with a format selection menu */} <Menu shadow="md" width={150}> <Menu.Target> <Button size="xs" variant="light" color="blue" leftSection={<Icon icon="tabler:file-export" fontSize={16} />} > Export Selected </Button> </Menu.Target> <Menu.Dropdown> <Menu.Label>Export as</Menu.Label> <Menu.Item leftSection={<Icon icon="tabler:file-type-csv" />} onClick={() => onExport('csv')} > CSV </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:file-type-xls" />} onClick={() => onExport('excel')} > Excel </Menu.Item> </Menu.Dropdown> </Menu> {/* END: MODIFIED */} <Button size="xs" variant="light" color="red" leftSection={<Icon icon="tabler:trash" fontSize={16} />} onClick={onDelete} > Delete </Button> </Group> <Tooltip label="Clear selection"> <ActionIcon variant="light" color="gray" onClick={onClear}> <Icon icon="tabler:x" /> </ActionIcon> </Tooltip> </Group> ) } export default React.memo(LabelBulkActions)
```

# src/features/label/components/LabelContactsVisualization.tsx

```tsx
// src/features/label/components/LabelContactsVisualization.tsx import useWa from '@/hooks/useWa' import { Avatar, Group, Text, Tooltip } from '@mantine/core' import React, { useEffect, useState } from 'react' interface Props { contactIds: string[] } const MAX_AVATARS = 4 const LabelContactsVisualization: React.FC<Props> = ({ contactIds }) => { const wa = useWa() const [avatars, setAvatars] = useState<string[]>([]) const totalContacts = contactIds.length useEffect(() => { if (!wa.isReady || totalContacts === 0) { setAvatars([]) return } const fetchAvatars = async () => { const idsToFetch = contactIds.slice(0, MAX_AVATARS) try { const urls = await Promise.all( idsToFetch.map((id) => wa.contact.getProfilePictureUrl(id)), ) setAvatars(urls.filter(Boolean)) } catch (error) { console.error('Failed to fetch contact avatars:', error) setAvatars([]) } } fetchAvatars() }, [contactIds, wa.isReady, wa.contact]) if (totalContacts === 0) { return <Text size="sm">0</Text> } return ( <Group gap="xs" wrap="nowrap"> <Tooltip label={`${totalContacts} contact${totalContacts > 1 ? 's' : ''}`} > <Avatar.Group spacing="sm"> {avatars.map((url, index) => ( <Avatar key={index} src={url} radius="xl" size="sm" /> ))} {totalContacts > MAX_AVATARS && ( <Avatar radius="xl" size="sm"> +{totalContacts - MAX_AVATARS} </Avatar> )} </Avatar.Group> </Tooltip> <Text size="sm">{totalContacts}</Text> </Group> ) } export default React.memo(LabelContactsVisualization)
```

# src/features/label/components/LabelFilters.tsx

```tsx
// src/features/label/components/LabelFilters.tsx import type { Filter } from '@/hooks/useDataQuery' import { useDataQuery } from '@/hooks/useDataQuery' import db, { type Label } from '@/libs/db' import { Icon } from '@iconify/react' import { Button, ColorSwatch, Group, Input, NumberInput, Popover, Select, SimpleGrid, Stack, Text, } from '@mantine/core' import { useLiveQuery } from 'dexie-react-hooks' import _ from 'lodash' import React, { useMemo, useState } from 'react' interface Props { dataQuery: ReturnType<typeof useDataQuery<Label>> } const contactFilterOptions: any = [ { value: 'any', label: 'Any' }, { value: 'none', label: 'No Contacts' }, { value: 'has', label: 'Has Contacts' }, { value: 'more_than', label: 'More Than...' }, ] const LabelFilters: React.FC<Props> = ({ dataQuery }) => { const allLabels = useLiveQuery(() => db.labels.toArray()) const [popoverOpened, setPopoverOpened] = useState(false) const [contactFilterType, setContactFilterType] = useState('any') const [contactCount, setContactCount] = useState<string | number>(0) // Memoize unique groups and colors to prevent re-calculation on every render const { uniqueGroups, uniqueColors } = useMemo(() => { const groups = _.uniq( allLabels?.map((l) => l.group).filter(Boolean), ) as string[] const colors = _.uniq( allLabels?.map((l) => l.color).filter(Boolean), ) as string[] return { uniqueGroups: groups.map((g) => ({ value: g, label: g })), uniqueColors: colors, } }, [allLabels]) const activeFiltersCount = dataQuery.filters.length const handleFilterChange = ( field: string, operator: Filter['operator'], value: any, ) => { if (value === null || value === '' || value === 'any') { dataQuery.removeFilter(field) } else { dataQuery.updateFilter({ field, operator, value }) } } const handleContactFilterChange = (type: string | null) => { setContactFilterType(type || 'any') switch (type) { case 'none': handleFilterChange('numbers', 'isEmpty', true) break case 'has': handleFilterChange('numbers', 'isNotEmpty', true) break case 'more_than': handleFilterChange( 'numbers', 'countGreaterThan', Number(contactCount) || 0, ) break default: dataQuery.removeFilter('numbers') break } } const handleContactCountChange = (value: string | number) => { setContactCount(value) if (contactFilterType === 'more_than') { handleFilterChange('numbers', 'countGreaterThan', Number(value) || 0) } } const handleClearFilters = () => { dataQuery.clearFilters() setContactFilterType('any') setContactCount(0) setPopoverOpened(false) } return ( <Popover width={300} trapFocus position="bottom-end" withArrow shadow="md" opened={popoverOpened} onChange={setPopoverOpened} > <Popover.Target> <Button variant="default" leftSection={<Icon icon="tabler:filter" fontSize={16} />} rightSection={ activeFiltersCount > 0 ? ( <Text size="xs" c="blue" fw={700}> {activeFiltersCount} </Text> ) : null } onClick={() => setPopoverOpened((o) => !o)} > Filters </Button> </Popover.Target> <Popover.Dropdown> <Stack> <Select label="Filter by Group" placeholder="Select a group" data={uniqueGroups} onChange={(value) => handleFilterChange('group', 'equals', value)} value={ dataQuery.filters.find((f) => f.field === 'group')?.value || null } clearable /> <div> <Input.Label>Filter by Color</Input.Label> <SimpleGrid cols={5} mt={4} spacing="xs"> {uniqueColors.map((color) => ( <ColorSwatch key={color} color={color} onClick={() => handleFilterChange('color', 'equals', color)} style={{ cursor: 'pointer', outline: dataQuery.filters.find((f) => f.field === 'color') ?.value === color ? `2px solid var(--mantine-primary-color-filled)` : 'none', }} /> ))} </SimpleGrid> </div> <Select label="Filter by Contacts" data={contactFilterOptions} value={contactFilterType} onChange={handleContactFilterChange} /> {contactFilterType === 'more_than' && ( <NumberInput placeholder="Enter number" value={contactCount} onChange={handleContactCountChange} min={0} /> )} <Group justify="space-between" mt="md"> <Button variant="transparent" size="sm" onClick={handleClearFilters} disabled={activeFiltersCount === 0} > Clear All </Button> <Button size="sm" onClick={() => setPopoverOpened(false)}> Done </Button> </Group> </Stack> </Popover.Dropdown> </Popover> ) } export default LabelFilters
```

# src/features/label/components/LabelPageHeader.tsx

```tsx
// src/features/label/components/LabelPageHeader.tsx import { useDataQuery } from '@/hooks/useDataQuery' import type { Label } from '@/libs/db' import { Icon } from '@iconify/react' import { Button, Group, TextInput } from '@mantine/core' import React from 'react' import LabelFilters from './LabelFilters' interface Props { dataQuery: ReturnType<typeof useDataQuery<Label>> onAdd: () => void onBackup: () => void onRestore: () => void } /** * A memoized component for the header section of the label management page. * It contains search, filtering, and primary actions to prevent re-renders. */ const LabelPageHeader: React.FC<Props> = ({ dataQuery, onAdd, onBackup, onRestore, }) => { return ( <Group justify="space-between"> {/* Left side: Search and Filters */} <Group> <TextInput placeholder="Search by label name..." value={dataQuery.search} size="sm" onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} style={{ flex: 1, minWidth: 250 }} /> <LabelFilters dataQuery={dataQuery} /> </Group> {/* Right side: Action Buttons */} <Group> <Button variant="default" leftSection={<Icon icon="tabler:file-import" fontSize={18} />} onClick={onRestore} > Restore </Button> <Button variant="default" leftSection={<Icon icon="tabler:file-export" fontSize={18} />} onClick={onBackup} > Backup </Button> <Button leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={onAdd} > Add Label </Button> </Group> </Group> ) } export default React.memo(LabelPageHeader)
```

# src/features/label/components/ModalCreateUpdateLabel.tsx

```tsx
// src/features/label/components/ModalCreateUpdateLabel.tsx import Modal from '@/components/Modal/Modal' import type { Label } from '@/libs/db' import db from '@/libs/db' import toast from '@/utils/toast' import { Button, Center, ColorInput, Group, Stack, Switch, Text, Textarea, // MODIFIED: Imported Textarea TextInput, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect } from 'react' interface Props { opened: boolean data?: Label | null onClose: () => void onSuccess?: () => void } // START: MODIFIED - Added a predefined color palette const PREDEFINED_COLORS = [ '#25262b', '#868e96', '#fa5252', '#e64980', '#be4bdb', '#7950f2', '#4c6ef5', '#228be6', '#15aabf', '#12b886', '#40c057', '#82c91e', '#fab005', '#fd7e14', ] // END: MODIFIED const ModalCreateUpdateLabel: React.FC<Props> = ({ opened, data, onClose, onSuccess, }: Props) => { const form = useForm({ initialValues: { name: '', group: '', color: '#228be6', isPinned: false, description: '', // MODIFIED: Added description }, validate: { name: (value) => { if (_.isEmpty(value)) { return 'Required' } if (value.length > 20) { return 'Max 20 characters' } return null }, }, }) useEffect(() => { if (data && opened) { form.setValues({ name: data.label || '', group: data.group || '', color: data.color || '#228be6', isPinned: data.isPinned === 1, description: data.description || '', // MODIFIED: Set description value }) } else { form.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, opened]) const handleCreate = async (values: typeof form.values) => { const payload = { label: values.name, value: values.name, group: values.group, color: values.color, isPinned: values.isPinned ? 1 : 0, description: values.description, // MODIFIED: Added description } try { await db.labels.add({ ...payload, show: 1, custom: 1, numbers: [] }) toast.success(`Label "${values.name}" created successfully.`) onSuccess?.() onClose() } catch (error) { console.error('Failed to create label:', error) toast.error('An error occurred while creating the label.') } } const handleUpdate = async (values: typeof form.values) => { if (!data?.id) return const payload = { label: values.name, value: values.name, group: values.group, color: values.color, isPinned: values.isPinned ? 1 : 0, description: values.description, // MODIFIED: Added description } try { await db.labels.update(data.id, payload) toast.success(`Label "${values.name}" updated successfully.`) onSuccess?.() onClose() } catch (error) { console.error('Failed to update label:', error) toast.error('An error occurred while updating the label.') } } // The main submit handler. const handleSubmit = async (values: typeof form.values) => { if (data && data.id) { await handleUpdate(values) } else { await handleCreate(values) } form.reset() } return ( <Modal opened={opened} onClose={onClose} w={500} withCloseButton style={{ zIndex: 9999 }} > <form onSubmit={form.onSubmit(handleSubmit)}> <Stack justify="space-between"> <Stack> <Center> <Title order={3}>{data ? 'Edit' : 'Create'} Label</Title> </Center> <TextInput label="Name" required data-autofocus {...form.getInputProps('name')} /> <TextInput label="Group (Optional)" placeholder="e.g., Leads, Customers" {...form.getInputProps('group')} /> {/* START: MODIFIED - Added color swatches */} <ColorInput label="Color" placeholder="Pick a color" swatches={PREDEFINED_COLORS} {...form.getInputProps('color')} /> {/* END: MODIFIED */} {/* START: MODIFIED - Added description field */} <Textarea label="Description (Optional)" placeholder="Add notes or context for this label..." autosize minRows={2} {...form.getInputProps('description')} /> {/* END: MODIFIED */} <Switch mt="md" label={ <Text fw={500} size="sm"> Pin to Header </Text> } description="Pinned labels appear first for quick access." {...form.getInputProps('isPinned', { type: 'checkbox' })} /> </Stack> <Group align="end" justify="end" mt="md"> <Button type="submit">{data ? 'Save Changes' : 'Submit'}</Button> </Group> </Stack> </form> </Modal> ) } export default ModalCreateUpdateLabel
```

# src/features/label/components/ModalImportContacts.tsx

```tsx
// src/features/label/components/ModalImportContacts.tsx import Modal from '@/components/Modal/Modal' import db, { type Label } from '@/libs/db' import toast from '@/utils/toast' import { Center, Stack, Title } from '@mantine/core' import React from 'react' import ContactsUploader from './ContactsUploader' interface Props { opened: boolean onClose: () => void label: Label | null } /** * A modal for importing contacts from a file into a specific label. */ const ModalImportContacts: React.FC<Props> = ({ opened, onClose, label }) => { if (!label) return null const handleConfirmUpload = async (importedNumbers: string[]) => { try { const existingNumbers = label.numbers || [] const combinedNumbers = [ ...new Set([...existingNumbers, ...importedNumbers]), ] const newCount = combinedNumbers.length - existingNumbers.length await db.labels.update(label.id, { numbers: combinedNumbers }) toast.success(`${newCount} new contact(s) imported to "${label.label}".`) } catch (error) { console.error('Failed to import contacts:', error) toast.error('An error occurred during the import process.') } finally { onClose() } } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500} style={{ zIndex: 9999 }} > <Stack> <Center> <Title order={4}>Import Contacts to "{label.label}"</Title> </Center> <ContactsUploader onConfirm={handleConfirmUpload} onClose={onClose} /> </Stack> </Modal> ) } export default ModalImportContacts
```

# src/features/label/components/ModalImportLabels.tsx

```tsx
// src/features/label/components/ModalImportLabels.tsx import Modal from '@/components/Modal/Modal' import type { Label } from '@/libs/db' import db from '@/libs/db' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Button, Center, Group, List, Stack, Text, Title } from '@mantine/core' import { Dropzone } from '@mantine/dropzone' // No MIME_TYPES import needed for JSON import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void onSuccess: () => void } type ImportedLabel = Omit<Label, 'id'> /** * A modal for importing labels from a JSON backup file. * It handles file validation, parsing, and the database upsert logic. */ const ModalImportLabels: React.FC<Props> = ({ opened, onClose, onSuccess }) => { const [parsedLabels, setParsedLabels] = useState<ImportedLabel[]>([]) const [fileName, setFileName] = useState<string | null>(null) const [loading, setLoading] = useState(false) const handleDrop = (files: File[]) => { if (files.length === 0) return const file = files[0] const reader = new FileReader() reader.onload = (event) => { try { const data = JSON.parse(event.target?.result as string) if (!Array.isArray(data)) { throw new Error('Invalid file format: expecting an array of labels.') } setParsedLabels(data) setFileName(file.name) } catch (error) { console.error('Failed to parse file:', error) toast.error( 'Failed to parse file. Please ensure it is a valid JSON backup.', ) handleReject() } } reader.readAsText(file) } const handleReject = () => { setParsedLabels([]) setFileName(null) } const handleClose = () => { if (loading) return handleReject() onClose() } const handleConfirmImport = async () => { if (parsedLabels.length === 0) { toast.error('No labels to import.') return } setLoading(true) try { const existingLabels = await db.labels.toArray() const existingLabelsMap = new Map(existingLabels.map((l) => [l.label, l])) const labelsToUpsert: Label[] = [] let newCount = 0 let updatedCount = 0 for (const importedLabel of parsedLabels) { const existingLabel = existingLabelsMap.get(importedLabel.label) if (existingLabel) { // Merge and update existing label const combinedNumbers = [ ...new Set([ ...(existingLabel.numbers || []), ...(importedLabel.numbers || []), ]), ] labelsToUpsert.push({ ...existingLabel, ...importedLabel, numbers: combinedNumbers, }) updatedCount++ } else { // Add as new label labelsToUpsert.push({ ...importedLabel, show: 1, custom: 1, } as Label) newCount++ } } await db.labels.bulkPut(labelsToUpsert) toast.success( `${newCount} new label(s) created and ${updatedCount} label(s) updated.`, ) onSuccess() } catch (error) { console.error('Failed to import labels:', error) toast.error('An error occurred during the import process.') } finally { setLoading(false) handleClose() } } return ( <Modal opened={opened} onClose={handleClose} withCloseButton w={550} style={{ zIndex: 9999 }} > <Stack> <Center> <Title order={4}>Import & Restore Labels</Title> </Center> {parsedLabels.length > 0 ? ( <ConfirmState fileName={fileName!} labelCount={parsedLabels.length} onCancel={handleClose} onConfirm={handleConfirmImport} loading={loading} /> ) : ( <InitialState onDrop={handleDrop} onReject={handleReject} /> )} </Stack> </Modal> ) } // Internal component for the initial dropzone view const InitialState = ({ onDrop, onReject }) => ( <Stack> <Dropzone onDrop={onDrop} onReject={onReject} maxSize={5 * 1024 ** 2} // 5MB // MODIFIED: Use the correct MIME type string for JSON accept={['application/json']} multiple={false} > <Group justify="center" gap="xl" mih={220} style={{ pointerEvents: 'none' }} > <Dropzone.Idle> <Icon icon={'tabler:upload'} fontSize={50} /> </Dropzone.Idle> <div> <Text size="xl" inline> Drag your backup file here or click to select </Text> <Text size="sm" c="dimmed" inline mt={7}> Attach a single JSON file exported from this extension. </Text> </div> </Group> </Dropzone> <List size="sm" c="dimmed" mt="md" spacing="xs" withPadding> <List.Item> Importing will merge contacts from the backup file into existing labels with the same name. </List.Item> <List.Item> Labels from the backup that do not exist will be created. </List.Item> </List> </Stack> ) // Internal component for the confirmation view after a file is parsed const ConfirmState = ({ fileName, labelCount, onCancel, onConfirm, loading, }) => ( <Stack> <Text> File{' '} <Text span fw={700}> {fileName} </Text>{' '} is ready. It contains{' '} <Text span fw={700}> {labelCount} </Text>{' '} labels. </Text> <Text c="dimmed" size="sm"> Existing labels with matching names will be updated, and their contact lists will be merged. </Text> <Group justify="end" mt="md"> <Button variant="default" onClick={onCancel} disabled={loading}> Cancel </Button> <Button loading={loading} onClick={onConfirm}> Confirm Import </Button> </Group> </Stack> ) export default ModalImportLabels
```

# src/features/label/components/ModalManageContacts.tsx

```tsx
// src/features/label/components/ModalManageContacts.tsx import Modal from '@/components/Modal/Modal' import useWa from '@/hooks/useWa' import db, { type Label } from '@/libs/db' import toast from '@/utils/toast' import { getContactName } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Card, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' import React, { useEffect, useMemo, useState } from 'react' interface Props { opened: boolean label: Label | null onClose: () => void } interface ContactItem { id: string name: string } /** * A modal for managing which contacts are associated with a specific label. * It features a searchable list of all contacts. */ const ModalManageContacts: React.FC<Props> = ({ opened, label, onClose }) => { const wa = useWa() const [loading, setLoading] = useState(true) const [allContacts, setAllContacts] = useState<ContactItem[]>([]) const [searchQuery, setSearchQuery] = useState('') const [selectedContactIds, setSelectedContactIds] = useState<Set<string>>( new Set(), ) // Effect to fetch contacts and set initial state when the modal opens useEffect(() => { if (opened && label) { const fetchContacts = async () => { setLoading(true) try { const contactsFromWa = await wa.contact.list({ onlyMyContacts: true }) const formattedContacts = contactsFromWa .map((c: any) => ({ id: c.id, name: getContactName(c), })) .sort((a, b) => a.name.localeCompare(b.name)) setAllContacts(formattedContacts) setSelectedContactIds(new Set(label.numbers || [])) } catch (error) { console.error('Failed to fetch contacts:', error) toast.error('Could not load your contacts.') } finally { setLoading(false) } } fetchContacts() } else { setAllContacts([]) setSelectedContactIds(new Set()) setSearchQuery('') } }, [opened, label, wa.contact]) // Toggles the selection of a single contact const handleToggleContact = (contactId: string) => { setSelectedContactIds((prev) => { const newSet = new Set(prev) if (newSet.has(contactId)) { newSet.delete(contactId) } else { newSet.add(contactId) } return newSet }) } // Memoized search results for performance const filteredContacts = useMemo(() => { if (!searchQuery) return allContacts return allContacts.filter((contact) => contact.name.toLowerCase().includes(searchQuery.toLowerCase()), ) }, [allContacts, searchQuery]) // Persists the changes to the database const handleSave = async () => { if (!label?.id) return try { await db.labels.update(label.id, { numbers: Array.from(selectedContactIds), }) toast.success(`Contacts for "${label.label}" updated successfully.`) onClose() } catch (error) { console.error('Failed to update contacts for label:', error) toast.error('An error occurred while saving.') } } return ( <Modal opened={opened} onClose={onClose} w={600} withCloseButton style={{ zIndex: 9999 }} > <Stack> <Title order={3} ta="center"> Manage Contacts for "{label?.label}" </Title> <Text c="dimmed" size="sm" ta="center"> Select the contacts to associate with this label. </Text> <TextInput placeholder="Search contacts..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} onChange={(e) => setSearchQuery(e.currentTarget.value)} /> <Card withBorder p={0} style={{ height: 300 }}> {loading ? ( <Group justify="center" align="center" style={{ height: '100%' }}> <Loader /> </Group> ) : ( <ScrollArea style={{ height: 300 }}> <Stack gap="xs" p="sm"> {filteredContacts.length > 0 ? ( filteredContacts.map((contact) => ( <Checkbox key={contact.id} label={contact.name} checked={selectedContactIds.has(contact.id)} onChange={() => handleToggleContact(contact.id)} /> )) ) : ( <Text c="dimmed" ta="center" pt="xl"> No contacts found. </Text> )} </Stack> </ScrollArea> )} </Card> <Group justify="space-between" align="center"> <Text size="sm" fw={500}> {selectedContactIds.size} contact(s) selected </Text> <Group> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleSave} disabled={loading}> Save Changes </Button> </Group> </Group> </Stack> </Modal> ) } export default ModalManageContacts
```

# src/features/label/PageLabel.tsx

```tsx
// src/features/label/PageLabel.tsx import LayoutPage from '@/components/Layout/LayoutPage' import { SaveAs } from '@/constants' import useDataQuery from '@/hooks/useDataQuery' import useFile from '@/hooks/useFile' import useWa from '@/hooks/useWa' import type { Label } from '@/libs/db' import db from '@/libs/db' import toast from '@/utils/toast' import { getContactName } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Stack, Switch, Text, Tooltip } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable, type DataTableColumn } from 'mantine-datatable' import React, { useCallback, useMemo, useState } from 'react' import EditableCell from './components/EditableCell' import LabelActions from './components/LabelActions' import LabelBulkActions from './components/LabelBulkActions' import LabelContactsVisualization from './components/LabelContactsVisualization' import LabelPageHeader from './components/LabelPageHeader' import ModalCreateUpdateLabel from './components/ModalCreateUpdateLabel' import ModalImportLabels from './components/ModalImportLabels' // ++ IMPORT NEW MODAL import ModalManageContacts from './components/ModalManageContacts' const PageLabel: React.FC = () => { const dataQuery = useDataQuery<Label>({ table: db.labels, searchField: 'label', initialSort: { field: 'label', direction: 'asc' }, initialPageSize: 10, }) const wa = useWa() const { saveAs } = useFile() const [showCreateUpdateModal, createUpdateModalHandlers] = useDisclosure(false) const [editingLabel, setEditingLabel] = useState<Label | null>(null) const [showManageContactsModal, manageContactsModalHandlers] = useDisclosure(false) const [selectedLabel, setSelectedLabel] = useState<Label | null>(null) const [showImportModal, importModalHandlers] = useDisclosure(false) // Memoize handlers to prevent re-rendering of the header component const handleCreate = useCallback(() => { setEditingLabel(null) createUpdateModalHandlers.open() }, [createUpdateModalHandlers]) const handleEdit = useCallback( (label: Label) => { setEditingLabel(label) createUpdateModalHandlers.open() }, [createUpdateModalHandlers], ) const handleManageContacts = useCallback( (label: Label) => { setSelectedLabel(label) manageContactsModalHandlers.open() }, [manageContactsModalHandlers], ) const handleExportAll = useCallback(async () => { try { toast.info('Preparing backup file...') const allLabels = await db.labels.toArray() if (allLabels.length === 0) { toast.info('There are no labels to back up.') return } const exportableLabels = allLabels.map(({ id, ...rest }) => rest) const fileName = `whats-status-labels-backup-${new Date().toISOString().slice(0, 10)}` await saveAs(SaveAs.JSON, exportableLabels, fileName, { skipSerialization: true, }) toast.success('All labels have been backed up successfully.') } catch (error) { console.error('Failed to export all labels:', error) toast.error('An error occurred while creating the backup.') } }, [saveAs]) const handleDelete = useCallback( async (label: Label) => { if ( confirm(`Are you sure you want to delete the label "${label.label}"?`) ) { try { if (label.id) { await db.labels.delete(label.id) toast.success(`Label "${label.label}" has been deleted.`) dataQuery.setSelectedRecords((prev) => prev.filter((r) => r.id !== label.id), ) } } catch (error) { console.error('Failed to delete label:', error) toast.error('An error occurred while deleting the label.') } } }, [dataQuery], ) const handleInlineUpdate = useCallback( async (label: Label, field: keyof Label, value: string | number) => { if (!label.id) return try { await db.labels.update(label.id, { [field]: value }) toast.success(`Label field updated successfully.`) } catch (error) { console.error(`Failed to update label field "${field}":`, error) toast.error('An error occurred while saving the changes.') throw error } }, [], ) const handleExport = useCallback( async (label: Label, format: 'csv' | 'excel') => { if (!wa.isReady) { toast.error('WhatsApp is not connected yet. Please wait.') return } if (!label.numbers || label.numbers.length === 0) { toast.info(`Label "${label.label}" has no contacts to export.`) return } toast.info('Preparing export... This may take a moment.') try { const contactDetails = await Promise.all( label.numbers.map(async (number: string) => { try { const contact = await wa.contact.get(number) return { name: getContactName(contact), number: number.replace('@c.us', ''), } } catch (e) { return { name: 'N/A', number: number.replace('@c.us', '') } } }), ) const fileName = `whats-status-export-${label.label.replace( /\s/g, '_', )}` const saveFormat = format === 'csv' ? SaveAs.CSV : SaveAs.EXCEL await saveAs(saveFormat, contactDetails, fileName, { skipSerialization: true, }) toast.success( `${contactDetails.length} contacts exported successfully.`, ) } catch (error) { console.error('Failed to export contacts:', error) toast.error('An error occurred while exporting contacts.') } }, [wa.isReady, wa.contact, saveAs], ) const handleExportSelected = useCallback( async (format: 'csv' | 'excel') => { const selectedLabels = dataQuery.selectedRecords if (selectedLabels.length === 0) { toast.info('No labels selected for export.') return } if (!wa.isReady) { toast.error('WhatsApp is not connected yet. Please wait.') return } toast.info('Preparing bulk export... This may take a moment.') try { let allContactsToExport: { name: string number: string label: string }[] = [] for (const label of selectedLabels) { if (label.numbers && label.numbers.length > 0) { const contactDetails = await Promise.all( label.numbers.map(async (number: string) => { try { const contact = await wa.contact.get(number) return { name: getContactName(contact), number: number.replace('@c.us', ''), label: label.label, // Add the source label for context } } catch (e) { return { name: 'N/A', number: number.replace('@c.us', ''), label: label.label, } } }), ) allContactsToExport = allContactsToExport.concat(contactDetails) } } if (allContactsToExport.length === 0) { toast.info('Selected labels have no contacts to export.') return } const fileName = `whats-status-bulk-export-${new Date().toISOString().slice(0, 10)}` const saveFormat = format === 'csv' ? SaveAs.CSV : SaveAs.EXCEL await saveAs(saveFormat, allContactsToExport, fileName, { skipSerialization: true, }) toast.success( `${allContactsToExport.length} contacts from ${selectedLabels.length} labels exported successfully.`, ) } catch (error) { console.error('Failed to export selected contacts:', error) toast.error('An error occurred during the bulk export.') } }, [dataQuery.selectedRecords, wa.isReady, wa.contact, saveAs], ) const handleDeleteSelected = useCallback(async () => { const selectedIds = dataQuery.selectedRecords .map((label) => label.id) .filter(Boolean) as number[] if (selectedIds.length === 0) return if ( confirm( `Are you sure you want to delete ${selectedIds.length} selected labels?`, ) ) { try { await db.labels.bulkDelete(selectedIds) toast.success(`${selectedIds.length} labels have been deleted.`) dataQuery.setSelectedRecords([]) } catch (error) { console.error('Failed to delete selected labels:', error) toast.error('An error occurred while deleting the labels.') } } }, [dataQuery]) const handlePinToggleSelected = useCallback( async (pin: boolean) => { const selectedLabels = dataQuery.selectedRecords if (selectedLabels.length === 0) return const updatedLabels = selectedLabels.map((label) => ({ ...label, isPinned: pin ? 1 : 0, })) try { await db.labels.bulkPut(updatedLabels) toast.success( `${selectedLabels.length} labels have been ${ pin ? 'pinned' : 'unpinned' }.`, ) dataQuery.setSelectedRecords([]) } catch (error) { console.error( `Failed to ${pin ? 'pin' : 'unpin'} selected labels:`, error, ) toast.error('An error occurred while updating the labels.') } }, [dataQuery], ) const columns = useMemo<DataTableColumn<Label>[]>( () => [ { accessor: 'label', title: 'Label', render: (label) => ( <EditableCell value={label.label} onSave={(newValue) => handleInlineUpdate(label, 'label', newValue)} > <Tooltip label={label.description} position="top-start" withArrow multiline w={220} disabled={!label.description} > <Badge color={label.color || 'gray'}>{label.label}</Badge> </Tooltip> </EditableCell> ), }, { accessor: 'group', title: 'Group', render: (label) => ( <EditableCell value={label.group || ''} onSave={(newValue) => handleInlineUpdate(label, 'group', newValue)} > <Text size="sm" truncate> {label.group || '-'} </Text> </EditableCell> ), }, { accessor: 'numbers', title: 'Contacts', render: (label) => ( <LabelContactsVisualization contactIds={label.numbers || []} /> ), }, { accessor: 'show', title: 'Visible', textAlign: 'center', render: (label) => ( <Tooltip label={ label.show ? 'Visible in header filters' : 'Hidden from header filters' } > <Switch checked={!!label.show} onChange={(event) => handleInlineUpdate( label, 'show', event.currentTarget.checked ? 1 : 0, ) } onClick={(e) => e.stopPropagation()} // Prevent row click event /> </Tooltip> ), }, { accessor: 'isPinned', title: 'Pinned', textAlign: 'center', render: (label) => label.isPinned ? ( <Tooltip label="Pinned"> <Icon icon="tabler:star-filled" color="var(--mantine-color-yellow-6)" /> </Tooltip> ) : null, }, { accessor: 'actions', title: 'Actions', textAlign: 'center', render: (label) => ( <LabelActions label={label} onEdit={handleEdit} onDelete={handleDelete} onManageContacts={handleManageContacts} onExport={handleExport} /> ), }, ], [ handleDelete, handleEdit, handleManageContacts, handleExport, handleInlineUpdate, ], ) return ( <> <LayoutPage> <Stack gap="md"> {/* ++ USE THE NEW HEADER COMPONENT ++ */} <LabelPageHeader dataQuery={dataQuery} onAdd={handleCreate} onBackup={handleExportAll} onRestore={importModalHandlers.open} /> {dataQuery.selectedRecords.length > 0 && ( <LabelBulkActions selectedCount={dataQuery.selectedRecords.length} onDelete={handleDeleteSelected} onPin={() => handlePinToggleSelected(true)} onUnpin={() => handlePinToggleSelected(false)} onClear={() => dataQuery.setSelectedRecords([])} onExport={handleExportSelected} /> )} <DataTable minHeight={420} records={dataQuery.data} columns={columns} striped highlightOnHover withTableBorder borderRadius="sm" fetching={!dataQuery.data} noRecordsText="No labels found. Create one to get started." selectedRecords={dataQuery.selectedRecords} onSelectedRecordsChange={dataQuery.setSelectedRecords} idAccessor="id" totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} recordsPerPageOptions={[10, 20, 50, 100]} onRecordsPerPageChange={dataQuery.setPageSize} /> </Stack> </LayoutPage> <ModalCreateUpdateLabel opened={showCreateUpdateModal} data={editingLabel} onClose={createUpdateModalHandlers.close} onSuccess={dataQuery.clearFilters} /> <ModalManageContacts opened={showManageContactsModal} label={selectedLabel} onClose={manageContactsModalHandlers.close} /> <ModalImportLabels opened={showImportModal} onClose={importModalHandlers.close} onSuccess={() => { dataQuery.clearFilters() // Refresh data after successful import }} /> </> ) } export default PageLabel
```

# src/hooks/useAi.ts

```ts
// src/hooks/useAi.ts import { AI } from '@/constants/action' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' const useAi = () => { const rewriteMessage = async ( prompt: string, message: string, system: | string | null = 'You are an expert copywriter. Your task is to rewrite the user message based on their instruction.', ): Promise<Response<string>> => { // Send the request to the background relay defined in `ai.relay.ts` return await sendToBackgroundViaRelay({ //@ts-ignore name: 'ai', body: { prompt, message, system }, }) } return { rewriteMessage, } } export default useAi
```

# src/hooks/useDataQuery.ts

```ts
// src/hooks/useDataQuery.ts import type { EntityTable } from 'dexie' import { useLiveQuery } from 'dexie-react-hooks' import { useMemo, useState } from 'react' type SortDirection = 'asc' | 'desc' interface Sort { field: string direction: SortDirection } type SortState = Sort | null // START: MODIFIED - Added new filter operators for contact count and array checks export type FilterOperator = | 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'between' | 'isEmpty' | 'isNotEmpty' | 'countGreaterThan' // END: MODIFIED export interface Filter { field: string operator: FilterOperator value: any secondValue?: any } interface useDataQueryOptions<T> { //@ts-ignore table: EntityTable<T, 'id'> initialPageSize?: number searchField?: string initialSort?: Sort initialFilters?: Filter[] } export const useDataQuery = <T>(options: useDataQueryOptions<T>) => { const { table, initialPageSize = 10, searchField = 'name', initialSort = { field: 'id', direction: 'desc' }, initialFilters = [], } = options const [page, setPage] = useState(1) const [pageSize, setPageSize] = useState(initialPageSize) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<T[]>([]) const [sort, setSort] = useState<SortState>(initialSort) const [filters, setFilters] = useState<Filter[]>(initialFilters) const applyFilter = (data: any[], filter: Filter) => { const { field, operator, value } = filter // START: MODIFIED - Added logic for new operators and improved filtering return data.filter((item: any) => { const itemValue = item[field] switch (operator) { case 'equals': return itemValue === value case 'contains': return String(itemValue) .toLowerCase() .includes(String(value).toLowerCase()) case 'startsWith': return String(itemValue) .toLowerCase() .startsWith(String(value).toLowerCase()) case 'endsWith': return String(itemValue) .toLowerCase() .endsWith(String(value).toLowerCase()) case 'greaterThan': return itemValue > value case 'lessThan': return itemValue < value case 'between': return ( itemValue >= value && itemValue <= (filter.secondValue ?? value) ) case 'isEmpty': return ( !itemValue || (Array.isArray(itemValue) && itemValue.length === 0) ) case 'isNotEmpty': return Array.isArray(itemValue) && itemValue.length > 0 case 'countGreaterThan': return Array.isArray(itemValue) && itemValue.length > value default: return true } }) // END: MODIFIED } const data = useLiveQuery(async () => { if (pageSize <= 0) return { data: [], totalItems: 0, hasMore: false } const startIndex = (page - 1) * pageSize let query = search ? table.where(searchField).startsWithIgnoreCase(search) : table.toCollection() let results = await query.toArray() // Apply all filters sequentially filters.forEach((filter) => { results = applyFilter(results, filter) }) if (sort) { results.sort((a: any, b: any) => { const aValue = a[sort.field] const bValue = b[sort.field] if (aValue === bValue) return 0 const comparison = aValue > bValue ? 1 : -1 return sort.direction === 'asc' ? comparison : -comparison }) } const paginatedResults = results.slice(startIndex, startIndex + pageSize) return { data: paginatedResults, totalItems: results.length, hasMore: startIndex + paginatedResults.length < results.length, } }, [page, pageSize, search, sort, filters]) const _delete = async (id: any) => { if (confirm('Are you sure?')) { await table.delete(id) } } const toggleSort = (field: string) => { setSort((currentSort) => { if (!currentSort || currentSort.field !== field) { return { field, direction: 'asc' } } if (currentSort.direction === 'asc') { return { field, direction: 'desc' } } if (currentSort.direction === 'desc') { return null } return currentSort }) } // START: MODIFIED - Improved filter management functions const addFilter = (filter: Filter) => { setFilters((prev) => [...prev, filter]) setPage(1) } const removeFilter = (field: string) => { setFilters((prev) => prev.filter((f) => f.field !== field)) setPage(1) } const updateFilter = (filter: Filter) => { setFilters((prev) => { const existing = prev.find((f) => f.field === filter.field) if (existing) { return prev.map((f) => (f.field === filter.field ? filter : f)) } return [...prev, filter] }) setPage(1) } // END: MODIFIED const clearFilters = () => { setFilters([]) setPage(1) } const derivedData = useMemo( () => ({ data: data?.data ?? [], totalRecords: data?.totalItems ?? 0, hasMore: data?.hasMore ?? false, }), [data], ) return { ...derivedData, selectedRecords, page, pageSize, search, sort, filters, setPage, setPageSize, setSelectedRecords, setSearch, toggleSort, addFilter, removeFilter, updateFilter, clearFilters, _delete, searchField, } } export default useDataQuery
```

# src/hooks/useFile.ts

```ts
// src/hooks/useFile.ts import { SaveAs, Setting } from '@/constants' import { storage } from '@/libs/storage' import FileSaver from 'file-saver' import _ from 'lodash' import * as XLSX from 'xlsx' import useLicense from './useLicense' const useFile = () => { const license = useLicense() const getSelectedColumns = async () => { return ( (await storage.get<Record<string, boolean>>(Setting.EXPORT_COLUMNS)) || { phoneNumber: true, publicName: true, savedName: true, isBlocked: true, isBusiness: true, isMyContact: true, } ) } const serializeData = async (data: any[]) => { const selectedColumns = await getSelectedColumns() let filteredData = data.map((item: any) => _.pickBy(item, (_, key) => selectedColumns[key] === true), ) if (license.isFree() && filteredData.length > 10) { filteredData = filteredData.map((item, index) => index >= 10 ? _.mapValues(item, () => '********') : item, ) } return filteredData } const defaultFilename = () => { return `export_${new Date().toISOString().slice(0, 10)}` } const saveAsCSV = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const csvString = XLSX.utils.sheet_to_csv(worksheet) const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' }) FileSaver.saveAs(blob, `${filename}.csv`) } const saveAsExcel = (data: any[], filename: string) => { if (!data || data.length === 0) return const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet 1') XLSX.writeFile(workbook, `${filename}.xlsx`) } const saveAsJson = (data: any[], filename: string) => { const json = JSON.stringify(data, null, 2) const blob = new Blob([json], { type: 'application/json' }) FileSaver.saveAs(blob, `${filename}.json`) } const saveAsVCard = (data: any[]) => { const vcardContent = data .map((contact) => { const name = contact.savedName || contact.publicName || 'Unknown' const phone = contact.phoneNumber ? `+${contact.phoneNumber}` : '' return `BEGIN:VCARD\nVERSION:3.0\nFN:${name}\nTEL;TYPE=CELL:${phone}\nEND:VCARD` }) .join('\n') const blob = new Blob([vcardContent], { type: 'text/vcard' }) FileSaver.saveAs(blob, `${defaultFilename()}.vcf`) } /** * Main function to save data in various formats. * @param fileType The format to save as (e.g., 'csv', 'xlsx'). * @param data The array of data objects to save. * @param filename (Optional) The base name for the file, without extension. * @param options (Optional) Additional options like skipping serialization. */ const saveAs = async ( fileType: string, data: any[], filename?: string, options?: { skipSerialization?: boolean }, ) => { const processedData = options?.skipSerialization ? data : await serializeData(data) const finalFilename = filename || defaultFilename() switch (fileType) { case SaveAs.CSV: saveAsCSV(processedData, finalFilename) break case SaveAs.EXCEL: saveAsExcel(processedData, finalFilename) break case SaveAs.JSON: saveAsJson(processedData, finalFilename) break case SaveAs.VCARD: saveAsVCard(processedData) // VCard has its own filename logic break // Other formats like Markdown and HTML can be added here. default: console.error(`Unsupported file type: ${fileType}`) break } } return { saveAs } } export default useFile
```

# src/hooks/useLicense.ts

```ts
// src/hooks/useLicense.ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import type { License } from '@/types' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { sendToBackground } from '@plasmohq/messaging' import { isPast } from 'date-fns' const useLicense = () => { const { license, setLicense } = useAppStore() const callLemonSqueezyApi = async (action: string, body: any) => { return await sendToBackground({ name: 'lemonsqueezy', body: { action, body, }, }) } const init = async () => { // First, check for a cached, valid license to avoid unnecessary API calls. const cachedLicense = await storage.get<License | null>( Setting.LICENSE_DATA_CACHE, ) if (cachedLicense?.license_key?.status === 'active') { setLicense(cachedLicense) return } // If no valid cache, proceed with the standard validation flow. const licenseKey = await storage.get<string | null>(Setting.LICENSE_KEY) if (!licenseKey) { setLicense(null) await storage.remove(Setting.LICENSE_DATA_CACHE) return } const response = await callLemonSqueezyApi('validateLicense', { licenseKey, }) if (response.error) { // Validation failed, clear all license-related storage. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is invalid or has been deactivated. You have been switched to the Free plan.', 'License Invalid', ) return } if (response.data.meta.store_id.toString() !== getStoreId()) { await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is for a different product. You have been switched to the Free plan.', 'License Error', ) return } // Validation successful, update app state and cache the license data if active. setLicense(response.data) if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } if ( response.data.license_key.expires_at && isPast(new Date(response.data.license_key.expires_at)) ) { toast.info( 'Your license has expired. You have been switched to the Free plan.', 'License Expired', ) await storage.remove(Setting.LICENSE_DATA_CACHE) } } const isFree = (): boolean => { if (!license) { return true } return license.license_key.status !== 'active' } const isPro = () => { if (!license) { return false } return license.license_key.status === 'active' } const isExpired = () => { // For lifetime licenses, 'expires_at' might be null. // The most reliable check is the status. If no expiration date exists, it's not expired. if (!license || !license.license_key.expires_at) { return false } return isPast(new Date(license.license_key.expires_at)) } const getLicense = () => { return license } const activate = async (licenseKey: string) => { const response = await callLemonSqueezyApi('activateLicense', { licenseKey, }) if (!response.error) { setLicense(response.data) await storage.set(Setting.LICENSE_KEY, licenseKey) await storage.set(Setting.LICENSE_INSTANCE_ID, response.data.instance.id) // Cache the license data immediately on successful activation. if (response.data.license_key.status === 'active') { await storage.set(Setting.LICENSE_DATA_CACHE, response.data) } } return response } const deactivate = async () => { const licenseKey = await storage.get(Setting.LICENSE_KEY) const instanceId = await storage.get(Setting.LICENSE_INSTANCE_ID) try { const response = await callLemonSqueezyApi('deactivateLicense', { licenseKey, instanceId, }) if (response.data.deactivated) { // Clear all license-related data from storage on deactivation. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.success('Your license has been deactivated from this device.') } else { toast.error('Failed to deactivate the license. Please contact support.') } } catch (e) { toast.error('An error occurred during deactivation.') } } const goToMyOrders = async () => { if (!license?.meta?.customer_id) { toast.error('Could not find customer information.') return } try { const response = await callLemonSqueezyApi('getCustomer', { customerId: license.meta.customer_id, }) if (response.error) { toast.error('Could not retrieve customer portal link.') return } window.open( response.data.data.attributes.urls.customer_portal, '_blank', 'noopener,noreferrer', ) } catch (e) { toast.error('An error occurred while fetching your subscription details.') } } return { init, isFree, isPro, isExpired, activate, getLicense, goToMyOrders, deactivate, } } export default useLicense
```

# src/hooks/useRuntimeMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = ( message: T, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void, ) => void | boolean /** * A React hook for handling Chrome runtime messages * @param listener The callback function to handle incoming messages * @returns void * * @example * useRuntimeMessage((message, sender, sendResponse) => { * if (message.type === 'getData') { * sendResponse({ data: 'example' }) * } * // Return true to keep the message channel open for async responses * return true * }) */ const useRuntimeMessage = <T = any>(listener: MessageListener<T>): void => { const memoizedHandler = useCallback<MessageListener<T>>( (message, sender, sendResponse) => { return listener(message, sender, sendResponse) }, [listener], ) useEffect(() => { chrome.runtime.onMessage.addListener(memoizedHandler) return () => { chrome.runtime.onMessage.removeListener(memoizedHandler) } }, [memoizedHandler]) } export default useRuntimeMessage
```

# src/hooks/useWa.ts

```ts
import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' const useWa = () => { const { isReady, activeChat } = useAppStore() return { isReady, activeChat, ...wa, } } export default useWa
```

# src/hooks/useWindowMessage.ts

```ts
import { useCallback, useEffect } from 'react' type MessageListener<T = any> = (event: MessageEvent<T>) => void const useWindowMessage = <T = any>(listener: MessageListener<T>): void => { const handleMessage = useCallback<MessageListener<T>>( (event) => { listener(event) }, [listener], ) useEffect(() => { window.addEventListener('message', handleMessage) return () => window.removeEventListener('message', handleMessage) }, [handleMessage]) } export default useWindowMessage
```

# src/libs/db.ts

```ts
// src/libs/db.ts import Dexie, { type EntityTable } from 'dexie' import packageJson from '../../package.json' export interface Media { id: number parentId: number type: string name: string file: File ext: string } export interface Broadcast { id: number name?: string | null type: string message: any isTyping: number isScheduler: number status: string delayMin?: number delayMax?: number pauseEnabled?: number pauseAfter?: number pauseDuration?: number pausedUntil?: Date | null } export interface BroadcastContact { id: number broadcastId: number number: string name?: string | null status: string error?: string | null scheduledAt?: Date | null sendAt?: Date | null } export interface BroadcastTemplate { id: number name: string type: string message: any } export interface BroadcastRecipient { id: number name: string recipients: { name: string; number: string; source: string }[] createdAt: Date } export interface Label { id: number label: string value: string show: number custom: number numbers?: any[] color?: string group?: string isPinned?: number description?: string // MODIFIED: Added description field } export interface DirectChatTemplate { id: number name: string message: string } export interface QuickReply { id: number name: string type: string message: any isPinned?: number createdAt?: Date } export interface UserStatus { id: number name?: string type: string message: any createdAt: Date status: string backgroundColor?: string font?: number isScheduled?: number scheduledAt?: Date | null postedAt?: Date | null } const db = new Dexie(packageJson.name) as Dexie & { media: EntityTable<Media, 'id'> broadcasts: EntityTable<Broadcast, 'id'> broadcastContacts: EntityTable<BroadcastContact, 'id'> broadcastTemplates: EntityTable<BroadcastTemplate, 'id'> broadcastRecipients: EntityTable<BroadcastRecipient, 'id'> labels: EntityTable<Label, 'id'> directChatTemplates: EntityTable<DirectChatTemplate, 'id'> quickReplies: EntityTable<QuickReply, 'id'> userStatuses: EntityTable<UserStatus, 'id'> } // NOTE: Dexie cannot index boolean values. Fields intended for use in `where()` clauses // have been changed from `boolean` to `number` (0 for false, 1 for true). db.version(1).stores({ media: '++id, parentId, type, name, file, ext', broadcasts: '++id, name, type, message, isTyping, isScheduler, status, delayMin, delayMax, pauseEnabled, pauseAfter, pauseDuration, pausedUntil', broadcastContacts: '++id, broadcastId, number, name, status, error, scheduledAt, sendAt, [broadcastId+status]', broadcastTemplates: '++id, name, type, message', broadcastRecipients: '++id, name, createdAt', labels: '++id, label, value, show, custom, color, group, isPinned, *numbers', // MODIFIED: `description` is not indexed as it's not for querying directChatTemplates: '++id, name', quickReplies: '++id, name, type, isPinned, createdAt', userStatuses: '++id, name, type, createdAt, status, backgroundColor, font, isScheduled, scheduledAt, postedAt', }) export default db
```

# src/libs/http.ts

```ts
import fetchAdapter from '@haverstack/axios-fetch-adapter' import axios from 'axios' const http = axios.create({ adapter: fetchAdapter, }) export default http
```

# src/libs/ls.ts

```ts
import * as lemon from '@lemonsqueezy/lemonsqueezy.js' lemon.lemonSqueezySetup({}) const lemonSqueezy = lemon export default lemonSqueezy
```

# src/libs/storage.ts

```ts
import { Storage } from '@plasmohq/storage' export const storage = new Storage({})
```

# src/libs/theme.ts

```ts
import { Button, createTheme, FileInput, Menu, Modal, MultiSelect, NumberInput, Popover, Radio, Select, Switch, TagsInput, Text, Textarea, TextInput, Tooltip, } from '@mantine/core' const theme = createTheme({ colors: { emerald: [ '#effbf3', '#ddf4e5', '#b6eac7', '#8cdfa7', '#6bd68c', '#56d07b', '#4acd72', '#3bb560', '#31a154', '#145229', ], }, primaryColor: 'teal', cursorType: 'pointer', components: { Button: Button.extend({ defaultProps: { size: 'sm', }, }), FileInput: FileInput.extend({ defaultProps: { size: 'md', }, }), Menu: Menu.extend({ defaultProps: { withinPortal: false } }), Modal: Modal.extend({ defaultProps: { size: 'xl', withCloseButton: false, withOverlay: false, withinPortal: false, }, }), NumberInput: NumberInput.extend({ defaultProps: { size: 'md' } }), MultiSelect: MultiSelect.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Popover: Popover.extend({ defaultProps: { withinPortal: false, }, }), Radio: Radio.extend({ defaultProps: { size: 'md', }, }), Select: Select.extend({ defaultProps: { size: 'md', comboboxProps: { withinPortal: false, }, }, }), Switch: Switch.extend({ defaultProps: { size: 'md', }, }), TagsInput: TagsInput.extend({ defaultProps: { size: 'md', }, }), Text: Text.extend({ defaultProps: { size: 'md', }, }), Textarea: Textarea.extend({ defaultProps: { size: 'md', }, }), TextInput: TextInput.extend({ defaultProps: { size: 'md', }, }), Tooltip: Tooltip.extend({ defaultProps: { position: 'left', withinPortal: false, withArrow: true, }, }), }, }) export default theme
```

# src/libs/wa/blocklist.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' export const all = async (): Promise<Wid[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.ALL, body: {}, }) } export const blockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.BLOCK_CONTACT, body: chatId, }) } export const isBlocked = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.IS_BLOCKED, body: chatId, }) } export const unblockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.UNBLOCK_CONTACT, body: chatId, }) }
```

# src/libs/wa/cart.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { SendMessageOptions } from '@wppconnect/wa-js/dist/chat' /** * Add product in cart * * @example * \`\`\`javascript * const cart = wa.cart.add('[number]@c.us', [ * { id: 'productId', qnt: 2 }, * ]); * \`\`\` */ export const add = async ( chatId: string, products: { id: string qnt: number }[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.ADD, body: { chatId, products }, }) } /** * Clear all items of cart * */ export const clear = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.CLEAR, body: wid, }) } /** * Get products in cart chat * * @example * \`\`\`javascript * const cart = wa.cart.get('[number]@c.us'); * \`\`\` */ export const get = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET, body: wid, }) } /** * Get thumb of a cart * * @example * \`\`\`javascript * const cart = wa.cart.getThumbFromCart('[number]@c.us'); * \`\`\` */ export const getThumbFromCart = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET_THUMB_FROM_CART, body: wid, }) } /** * Remove a product in cart * * @example * \`\`\`javascript * const cart = wa.cart.remove('[number]@c.us', '6987301181294productId'); * \`\`\` */ export const remove = async ( chatId: string, productId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.REMOVE, body: { chatId, productId }, }) } /** * Send a request order to business chat * * @example * \`\`\`javascript * const cart = wa.cart.submit('[number]@c.us'); * \`\`\` * * @example * \`\`\`javascript * // Send cart with a custom message * const cart = wa.cart.submit('[number]@c.us', 'Custom message here'); * \`\`\` */ export const submit = async ( wid: string, msg?: string, options?: SendMessageOptions, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.SUBMIT, body: { wid, msg, options }, }) } /** * Update product in cart * * @example * \`\`\`javascript * const cart = wa.cart.update('[number]@c.us', '6987301181294productId', { quantity: 12 }); * \`\`\` */ export const update = async ( chatId: string, productId: string, options: { quantity: number }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.UPDATE, body: { chatId, productId, options }, }) }
```

# src/libs/wa/catalog.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { createProductParams } from '@wppconnect/wa-js/dist/catalog/functions/createProduct' import type { editProductParams } from '@wppconnect/wa-js/dist/catalog/functions/editProduct' /** * Add image on product * This function include additional images on product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.addProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const addProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.ADD_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Add image on product * This function change main image of product * for change additional images use @addProductImage * * @example * \`\`\`javascript * await wa.catalog.changeProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const changeProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CHANGE_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Create new collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.createCollection('Collection Name', ['565656589898']); * \`\`\` */ export const createCollection = async ( collectionName: string, productsId: string[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_COLLECTION, body: { collectionName, productsId }, }) } /** * Create new product * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.addProduct( { name: 'Product name', image: 'base64 image string', description: 'product description', price: '89.90', isHidden: false, url: 'https://wppconnect.io', retailerId: 'AKA001', } ); * \`\`\` */ export const createProduct = async ( params: createProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_PRODUCT, body: params, }) } /** * Delete a collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.deleteCollection("377095767832354"); * \`\`\` * * @return Return sucess or error */ export const deleteCollection = async (collectionId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_COLLECTION, body: collectionId, }) } /** * @example * \`\`\`javascript * * // Delete various products * const myCatalog = await wa.catalog.delProducts(['6104203702939361', '6104289702939361']); * \`\`\` */ export const deleteProduct = async (productsIds: string[]): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_PRODUCT, body: productsIds, }) } /** * @example * \`\`\`javascript * const myCatalog = await wa.catalog.EditCollection('565656589898', { collectionName: 'New Name for collection', productsToAdd: ['5656523223'], productsToRemove: ['5656523232']}); * \`\`\` */ interface paramsEditCollection { name?: string productsToAdd?: string[] productsToRemove?: string[] } export const editCollection = async ( collectionId: string, params: paramsEditCollection, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_COLLECTION, body: { collectionId, params }, }) } /** * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = wa.catalog.editProduct('5498255476885590', {name: 'Plano 01', price: '89990', description: 'Insert description for your product', isHidden: true, url: 'http://www.wppconnect.io', retailerId: 'AKA001'}); * \`\`\` */ export const editProduct = async ( productId: string, params: editProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_PRODUCT, body: { productId, params }, }) } /** * Get collections of catalog * * @example * \`\`\`javascript * // Retrieve 20 collections of chat * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20'); * * // Retrieve 20 collections of chat and products arrays limit with 10 products * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20', '10'); * \`\`\` */ export const getCollections = async ( chatId: string, qnt?: number, productsCount?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_COLLECTIONS, body: { chatId, qnt, productsCount }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ export const getMyCatalog = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_MY_CATALOG, body: {}, }) } /** * Retrieves product by id * * @example * \`\`\`javascript * // Retrieve data of product * await wa.catalog.getProductById('5521985565656@c.us', '68685985868923'); * \`\`\` */ export const getProductById = async ( chatId: string, productId: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCT_BY_ID, body: { chatId, productId }, }) } /** * Retrieves product by contact id * * @example * Get products of catalogs * \`\`\`javascript * await wa.catalog.getProducts('5521985625689@c.us', 10); * \`\`\` */ export const getProducts = async (chatId: string, qnt: number): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCTS, body: { chatId, qnt }, }) } /** * Remove image on product * This function remove additional images of product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.removeProductImage('68685985868923', '0'); * \`\`\` */ export const removeProductImage = async ( productId: string, index: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.REMOVE_PRODUCT_IMAGE, body: { productId, index }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` */ export const setProductVisibility = async ( productId: any, isHidden: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.SET_PRODUCT_VISIBILITY, body: { productId, isHidden }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` * * @return Return sucess of product visibility set */ export const updateCartEnabled = async (enabled: boolean): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.UPDAGE_CART_ENABLED, body: enabled, }) }
```

# src/libs/wa/chat.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions, DeleteMessageReturn, ForwardMessagesOptions, GetMessagesOptions, RawMessage, } from '@wppconnect/wa-js/dist/chat' import type { ParticipantStatusACK } from '@wppconnect/wa-js/dist/chat/functions/getMessageACK' import type { Stringable } from '@wppconnect/wa-js/dist/types' import type { MsgKey, MsgModel, Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { ACK } from '@wppconnect/wa-js/dist/whatsapp/enums' /** * Archive a chat * * @example * // Archive a chat * wa.chat.archive('[number]@c.us'); * * // Unarchive a chat * wa.chat.archive('[number]@c.us', false); * \`\`\` */ export const archive = async ( chatId: string | Wid, archive = true, ): Promise<{ wid: Wid archive: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.ARCHIVE, body: { chatId, archive }, }) } /** * Get if message can played * * @example * \`\`\`javascript * wa.chat.canMarkPlayed('[message_id]'); * \`\`\` */ export const canMarkPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MARK_PLAYED, body: messageId, }) } /** * Check if is possible to mute this chat * * @example * \`\`\`javascript * const canMute = wa.chat.canMute('[number]@c.us'); * \`\`\` */ export const canMute = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MUTE, body: chatId, }) } /** * Get if message can reply * * @example * \`\`\`javascript * wa.chat.canReply('[message_id]'); * \`\`\` */ export const canReply = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_REPLY, body: messageId, }) } /** * Clear a chat message * */ export const clear = async ( chatId: string | Wid, keepStarred = true, ): Promise<{ wid: Wid status: number keepStarred: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLEAR, body: { chatId, keepStarred }, }) } /** * Close the chat tab * * @example * \`\`\`javascript * await wa.chat.closeChat(); * \`\`\` * */ export const closeChat = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLOSE_CHAT, body: {}, }) } /** * Delete a chat * */ export const _delete = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE, body: chatId, }) } /** * Delete a message * * @example * \`\`\`javascript * // Delete a message * wa.chat.deleteMessage('[number]@c.us', 'msgid'); * // Delete a list of messages * wa.chat.deleteMessage('[number]@c.us', ['msgid1', 'msgid2]); * // Delete a message and delete media * wa.chat.deleteMessage('[number]@c.us', 'msgid', true); * // Revoke a message * wa.chat.deleteMessage('[number]@c.us', 'msgid', true, true); * \`\`\` * */ export const deleteMessage = async ( chatId: string | Wid, ids: string | string[], deleteMediaInDevice = false, revoke = false, ): Promise<DeleteMessageReturn | DeleteMessageReturn[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE_MESSAGE, body: { chatId, ids, deleteMediaInDevice, revoke }, }) } /** * Downloads media from a message * * @example * \`\`\`javascript * await wa.chat.downloadMedia('messageId'); * \`\`\` */ export const downloadMedia = async ( messageId: string | MsgKey, ): Promise<Blob | null> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DOWNLOAD_MEDIA, body: messageId, }) } export const find = async (chatId: string | Wid): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FIND, body: chatId, }) } /** * Forward messages to a chat * * @example * \`\`\`javascript * // Forward messages * wa.chat.forwardMessage('[number]@c.us', 'true_[number]@c.us_ABCDEF'); * \`\`\` */ export const forwardMessage = async ( toChatId: string | Wid, msgId: string | MsgKey, options: ForwardMessagesOptions = {}, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FORWARD_MESSAGE, body: { toChatId, msgId, options }, }) } /** * Find a chat by id * */ export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET, body: chatId, }) } export const getActiveChat = async () => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_ACTIVE_CHAT, body: {}, }) } /** * Get timestamp of last seen * @example * \`\`\`javascript * wa.chat.getLastSeen('[number]@c.us'); * \`\`\` */ export const getLastSeen = async ( chatId: string | Wid, ): Promise<number | boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_LAST_SEEN, body: chatId, }) } /** * Get message ACK from a message * * @example * \`\`\`javascript * // Get message ACK * const ackInfo = await WPP.chat.getMessageACK('true_[number]@c.us_ABCDEF'); * * console.log(ackInfo.deliveryRemaining); // Delivery Remaining * console.log(ackInfo.readRemaining); // Read Remaining * console.log(ackInfo.playedRemaining); // PlayedRemaining, for audio(ptt) only * * console.log(ackInfo.participants[0].deliveredAt); // Delivered At, in timestamp format * console.log(ackInfo.participants[0].readAt); // Read At, in timestamp format * console.log(ackInfo.participants[0].playedAt); // Played At, in timestamp format, for audio(ptt) only * * //To get only how was received * const received = ackInfo.participants.filter(p => p.deliveredAt || p.readAt || p.playedAt); * * //To get only how was read * const read = ackInfo.participants.filter(p => p.readAt || p.playedAt); * * //To get only how was played * const played = ackInfo.participants.filter(p => p.playedAt); * \`\`\` */ export const getMessageACK = async ( msgId: string | MsgKey, ): Promise<{ ack: ACK fromMe: boolean deliveryRemaining: number readRemaining: number playedRemaining: number participants: ParticipantStatusACK[] }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGE_ACK, body: msgId, }) } /** * Fetch messages from a chat * * @example * \`\`\`javascript * // Some messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * }); * * // All messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * }); * * // Last 20 unread messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * onlyUnread: true, * }); * * // All unread messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * onlyUnread: true, * }); * * // 20 messages before specific message * wa.chat.getMessages('[number]@c.us', { * count: 20, * direction: 'before', * id: '<full message id>' * }); * * // Only media messages (url, document and links) * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'all', * }); * * // Only image messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'image', * }); * * // Only document messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'document', * }); * * // Only link (url) messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'url', * }); * \`\`\` */ export const getMessages = async ( chatId: string | Wid, options: GetMessagesOptions = {}, ): Promise<any[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGES, body: { chatId, options }, }) } /** * Get notes from a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.getNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const getNotes = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_NOTES, body: chatId, }) } /** * Get the platform message from message ID * * The platform can be: * * android * * iphone * * web * * unknown * * @example * \`\`\`javascript * // to get platform from a message * const platform = wa.chat.getPlatformFromMessage('[message_id]'); * \`\`\` */ export const getPlatformFromMessage = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<'android' | 'iphone' | 'web' | 'unknown'> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_PLATFORM_MESSAGE, body: messageId, }) } /** * Return a list of chats * * @example * \`\`\`javascript * // All chats * const chats = await wa.chat.list(); * * // Some chats * const chats = wa.chat.list({count: 20}); * * // 20 chats before specific chat * const chats = wa.chat.list({count: 20, direction: 'before', id: '[number]@c.us'}); * * // Only users chats * const chats = await wa.chat.list({onlyUsers: true}); * * // Only groups chats * const chats = await wa.chat.list({onlyGroups: true}); * * // Only communities chats * const chats = await wa.chat.list({onlyCommunities: true}); * * // Only Newsletter * const chats = await wa.chat.list({onlyNewsletter: true}); * * // Only with label Text * const chats = await wa.chat.list({withLabels: ['Test']}); * * // Only with label id * const chats = await wa.chat.list({withLabels: ['1']}); * * // Only with label with one of text or id * const chats = await wa.chat.list({withLabels: ['Alfa','5']}); * \`\`\` * */ export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.LIST, body: options, }) } /** * Mark a chat to composing state * and keep sending "is writting a message" * * @example * \`\`\`javascript * // Mark is composing * wa.chat.markIsComposing('[number]@c.us'); * * // Mark is composing for 5 seconds * wa.chat.markIsComposing('[number]@c.us', 5000); * \`\`\` */ export const markIsComposing = async ( chatId: string | Wid, duration?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_COMPOSING, body: { chatId, duration }, }) } /** * Mark a chat is paused state * * @example * \`\`\`javascript * // Mark as recording * wa.chat.markIsPaused('[number]@c.us'); * \`\`\` */ export const markIsPaused = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_PAUSED, body: chatId, }) } /** * Mark a chat as read and send SEEN event * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsRead('[number]@c.us'); * \`\`\` */ export const markIsRead = async ( chatId: string, ): Promise<{ wid: Wid unreadCount: number }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_READ, body: chatId, }) } /** * Mark a chat to recording state * and keep sending "is recording" * * @example * \`\`\`javascript * // Mark is recording * wa.chat.markIsRecording('[number]@c.us'); * * // Mark is recording for 5 seconds * wa.chat.markIsRecording('[number]@c.us', 5000); * \`\`\` */ export const markIsRecording = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_RECORDING, body: chatId, }) } /** * Mark a chat as unread * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsUnread('[number]@c.us'); * \`\`\` */ export const markIsUnread = async ( chatId: string | Wid, ): Promise<{ wid: Wid }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_UNREAD, body: chatId, }) } /** * Mark message as played * * @example * \`\`\`javascript * wa.chat.markPlayed('[message_id]'); * \`\`\` */ export const markPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_PLAYED, body: messageId, }) } /** * Mute a chat, you can use duration or expiration * For expiration, use unix timestamp (seconds only) * For duration, use seconds * * @example * \`\`\`javascript * // Mute for 60 seconds * wa.chat.mute('[number]@c.us', {duration: 60}); * * // Mute util 2021-01-01 * wa.chat.mute('[number]@c.us', {expiration: 1641006000}); * * // or using date * const expiration = new Date('2022-01-01 00:00:00'); * wa.chat.mute('[number]@c.us', {expiration: expiration}); * \`\`\` * */ export const mute = async ( chatId: string | Wid, time: { expiration: number | Date } | { duration: number }, ): Promise<{ wid: Wid expiration: number isMuted: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MUTE, body: { chatId, time }, }) } /** * Open the chat in the WhatsApp interface in a specific message * * @example * \`\`\`javascript * await wa.chat.openChatAt('[number]@c.us', <message_id>); * \`\`\` * */ export const openChatAt = async ( chatId: string | Wid, messageId: string, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_AT, body: { chatId, messageId }, }) } /** * Open the chat in the WhatsApp interface in bottom position * * @example * \`\`\`javascript * await wa.chat.openChatBottom('[number]@c.us'); * \`\`\` * */ export const openChatBottom = async ( chatId: string, ): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_BOTTOM, body: chatId, }) } /** * Open the chat in the WhatsApp interface from first unread message * * @example * \`\`\`javascript * await wa.chat.openChatFromUnread('[number]@c.us'); * \`\`\` * */ export const openChatFromUnread = async ( chatId: string | Wid, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_FROM_UNREAD, body: chatId, }) } /** * Pin a message in chat * * @example * \`\`\`javascript * // Pin a message in chat * wa.chat.pinMsg('true_[number]@c.us_ABCDEF'); * * // Pin a message in chat for 30 days * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', 2592000); * * // Unpin a message * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', false); * \`\`\` */ export const pinMsg = async ( msgId: string | MsgKey, pin = true, seconds = 604800, // default 7 days ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN_MSG, body: { msgId, pin, seconds }, }) } /** * Set custom Chat list in panel of whatsapp * * @example * \`\`\`javascript * // Your custom list * wa.chat.setChatList('custom', ['number@c.us', 'number2@c.us']); * * // List only with unread chats * wa.chat.setChatList('unread'); * * // List only with favorites chats * wa.chat.setChatList('favorites'); * * // List only with groups chats * wa.chat.setChatList('group'); * * // List only labels chat * wa.chat.setChatList('labels', '454545_labelId'); * \`\`\` */ export const setChatList = async (type: string, ids?: string | string[]) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_CHAT_LIST, body: { type, ids }, }) } export const setInputText = async (text: string, chatId?: string | Wid) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_INPUT_TEXT, body: { text, chatId }, }) } /** * Set notes for a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.setNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const setNotes = async ( chatId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_NOTES, body: { chatId, content }, }) }
```

# src/libs/wa/conn.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Alternative login method using code * Get the Link Device Code for Authentication using the phone number * * @example * \`\`\`javascript * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]'); * * // Disable push notification * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]', false); * \`\`\` */ export const genLinkDeviceCodeForPhoneNumber = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }) } /** * Return the current auth code * * @example * \`\`\`javascript * const authCode = await wa.conn.getAuthCode(); * console.log(authCode.fullCode); // Output: a long string to generate a QRCode * \`\`\` */ export const getAuthCode = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_AUTH_CODE, }) } export const getMyUserId = async (): Promise<Wid | undefined> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_MY_USER_ID, }) }
```

# src/libs/wa/contact.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ContactListOptions } from '@wppconnect/wa-js/dist/contact' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Get a contact by id * * @example * \`\`\`javascript * await wa.contact.get('[number]@c.us'); * \`\`\` * */ export const get = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET, body: contactId, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getBusinessProfile('[number]@c.us'); * \`\`\` * */ export const getBusinessProfile = async ( contactId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_BUSINESS_PROFILE, body: contactId, }) } /** * Get all commons groups for the contact * * @example * \`\`\`javascript * const groups_ids = await wa.contact.getCommonGroups('[number]@c.us'); * \`\`\` * */ export const getCommonGroups = async (wid: Wid | string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_COMMON_GROUPS, body: wid, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getProfilePictureUrl('[number]@c.us'); * \`\`\` * */ export const getProfilePictureUrl = async ( contactId: string | Wid, full = true, ): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_PROFILE_PICTURE_URL, body: { contactId, full }, }) } /** * Get the current text status * * @example * \`\`\`javascript * await wa.contact.getStatus('[number]@c.us'); * \`\`\` */ export const getStatus = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_STATUS, body: contactId, }) } export const list = async (options: ContactListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.LIST, body: options, }) } export const isExist = async (contactId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.IS_EXIST, body: contactId, }) }
```

# src/libs/wa/group.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions } from '@wppconnect/wa-js/dist/chat' import type { GroupProperty } from '@wppconnect/wa-js/dist/group' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Add one or more participants to a group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.addParticipants('[group@g.us]', [number@c.us]); * * // Get participant result: * console.log(result['123@c.us'].code); * console.log(result['123@c.us'].invite_code); * console.log(result['123@c.us'].invite_code_exp); * console.log(result['123@c.us'].message); * console.log(result['123@c.us'].wid); * * const memberResult = result['123@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['123@c.us'].invite_code; * console.log(link); * \`\`\` */ export const addParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.ADD_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Approve a membership request to group * * @example * \`\`\`javascript * await wa.group.approve(12345645@g.us, 5554999999999@c.us); * \`\`\` * */ export const approve = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.APPROVE, body: { groupId, membershipIds }, }) } /** * Check if your account is allowed to add new participants * * @example * \`\`\`javascript * const result = await wa.group.canAdd('group@g.us'); * console.log(result); * \`\`\` */ export const canAdd = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_ADD, body: groupId, }) } /** * Check if your account is allowed to demote participants * * @example * \`\`\`javascript * await wa.group.canDemote('group@g.us'); * console.log(result); * \`\`\` */ export const canDemote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_DEMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to promote participants * * @example * \`\`\`javascript * await WPP.group.canPromote('group@g.us'); * console.log(result); * \`\`\` * */ export const canPromote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_PROMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to remove participants * * @example * \`\`\`javascript * const result = await wa.group.canRemove('group@g.us'); * console.log(result); * \`\`\` */ export const canRemove = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_REMOVE, body: { groupId, participantsIds }, }) } /** * Create a new group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.create('Test Group', ['number@c.us']); * * console.log(result.gid.toString()); // Get the group ID * * // Get participant result: * console.log(result['number@c.us'].code); * console.log(result['number@c.us'].invite_code); * console.log(result['number@c.us'].invite_code_exp); * console.log(result['number@c.us'].message); * console.log(result['number@c.us'].wid); * * const memberResult = result['number@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['number@c.us'].invite_code; * console.log(link); * * // Create a Subgroup for a community * const result = await wa.group.create('Test Group', ['number@c.us'], 'communit@g.us'); * \`\`\` */ export const create = async ( groupName: string, participantsIds: (string | Wid) | (string | Wid)[], parentGroup: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CREATE, body: { groupName, participantsIds, parentGroup }, }) } /** * @example * \`\`\`javascript * // One member * await wa.group.demoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.demoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const demoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.DEMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Get group info from an inviteCode * * @example * \`\`\`javascript * await wa.group.getGroupInfoFromInviteCode('<inviteCode>'); * \`\`\` */ export const getGroupInfoFromInviteCode = async ( inviteCode: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, body: inviteCode, }) } /** * Get the max number of participants for a group * * @example * \`\`\`javascript * const limit = await wa.group.getGroupSizeLimit(); * console.log(limit); * \`\`\` */ export const getGroupSizeLimit = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_SIZE_LIMIT, body: {}, }) } export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LIST, }) } /** * @description Sends a request to the background script to get a group's invite link. * @param groupId The ID of the group (e.g., '1234567890@g.us'). * @returns A promise that resolves with the invite link string. */ export const getInviteLink = async (groupId: string): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_INVITE_LINK, body: { groupId }, }) } /** * Retrieve a lista of a membership approval requests * * @example * \`\`\`javascript * await wa.group.getMembershipRequests(12345645@g.us); * \`\`\` */ export const getMembershipRequests = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_MEMBERSHIP_REQUESTS, body: groupId, }) } /** * Get an array of participants of a group * * @example * \`\`\`javascript * wa.group.getParticipants('[group-id]@g.us'); * \`\`\` */ export const getParticipants = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_PARTICIPANTS, body: groupId, }) } export const iAmAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_ADMIN, body: groupId, }) } export const iAmMember = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_MEMBER, body: groupId, }) } export const iAmRestrictedMember = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_RESTRICTED_MEMBER, body: groupId, }) } export const iAmSuperAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_SUPER_ADMIN, body: groupId, }) } /** * Join in a group from an invite code. * * @example * \`\`\`javascript * await wa.group.join('abcde....'); * \`\`\` */ export const join = async (inviteCode: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.JOIN, body: inviteCode, }) } /** * Leave from a group. * * @example * \`\`\`javascript * await wa.group.leave('[number]@g.us'); * \`\`\` */ export const leave = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LEAVE, body: groupId, }) } /** * Promote group member to admin * * @example * \`\`\`javascript * // One member * await wa.group.promoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.promoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` * * @category Group */ export const promoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.PROMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Reject a membership request to group * * @example * \`\`\`javascript * await wa.group.reject(12345645@g.us, 5554999999999@c.us); * \`\`\` */ export const reject = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REJECT, body: { groupId, membershipIds }, }) } /** * Remove the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.removeIcon('[group@g.us]'); * \`\`\` */ export const removeIcon = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_ICON, body: groupId, }) } /** * Remove participants of a group * * @example * \`\`\`javascript * // One member * await wa.group.removeParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.removeParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const removeParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Revoke the current invite code and generate new one. * * @example * \`\`\`javascript * const code = WPP.group.revokeInviteCode('[group-id]@g.us'); * const link = 'https://chat.whatsapp.com/' + code; * \`\`\` */ export const revokeInviteCode = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REVOKE_INVITE_CODE, body: groupId, }) } /** * Define the group description * * @example * \`\`\`javascript * await wa.group.setDescription('[group-id]@g.us', 'new group description'); * \`\`\` */ export const setDescription = async ( groupId: string | Wid, description: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_DESCRIPTION, body: { groupId, description }, }) } /** * Set the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.setIcon('[group@g.us]', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const setIcon = async ( groupId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_ICON, body: { groupId, content }, }) } /** * Set the group property * * @example * \`\`\`javascript * // Only admins can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', true); * * // All can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', false); * * // Disatble temporary messages * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 0); * * // Enable temporary messages for 24 hours * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 86400); * * // Enable temporary messages for 7 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 604800); * * // Enable temporary messages for 90 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 7776000); * * // Only admins can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', true); * * // All can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', false); * \`\`\` */ export const setProperty = async ( groupId: string | Wid, property: GroupProperty, value: 0 | 1 | 86400 | 604800 | 7776000 | boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_PROPERTY, body: { groupId, property, value }, }) } /** * Define the group subject * * @example * \`\`\`javascript * await wa.group.setSubject('[group-id]@g.us', 'new group subject'); * \`\`\` */ export const setSubject = async ( groupId: string | Wid, subject: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_SUBJECT, body: { groupId, subject }, }) }
```

# src/libs/wa/index.ts

```ts
import * as chat from './chat' import * as conn from './conn' import * as contact from './contact' import * as group from './group' import * as on from './on' import * as send from './send' import * as status from './status' export default { on, conn, send, contact, chat, group, status, }
```

# src/libs/wa/newsletter.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' /** * Create a newsletter * * @example * \`\`\`javascript * // To edit name * wa.newsletter.create('Name for your newsletter', { * description: 'Description for that', * picture: '<base64_string', * }); * \`\`\` */ export const create = async ( name: string, opts: { description?: string; picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.CREATE, body: { name, opts }, }) } /** * Delete a newsletter * * @example * \`\`\`javascript * const code = wa.newsletter.destroy('[newsletter-id]@newsletter'); * \`\`\` */ export const destroy = async (id: string): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.DESTROY, body: id, }) } /** * Edit the newsletter data * * @example * \`\`\`javascript * // To edit name * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * name: 'New Name' * }); * * // To edit description * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * description: 'New description' * }); * * // To change picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: '<base64_image>' * }); * * // To remove picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: null * }); * \`\`\` */ export const edit = async ( newsletterId: string, opts: { name?: string description?: string picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.EDIT, body: { newsletterId, opts }, }) } /** * Get subscribers of a newsletters * * @example * \`\`\`javascript * const code = wa.newsletter.getSubscribers('[newsletter-id]@newsletter'); * \`\`\` */ export const getSubscribers = async (id: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.GET_SUBSCRIBERS, body: id, }) } /** * Mute and unmute a newsletter * * @example * // Mute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', true); * \`\`\` * * // Unmute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', false); * \`\`\` */ export const mute = async ( newsletterId: string, value?: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.MUTE, body: { newsletterId, value }, }) }
```

# src/libs/wa/on.ts

```ts
export const ready = (callback = () => {}) => { const targetSelector = '#side' // WhatsApp left-panel root const node = document.querySelector(targetSelector) if (node) { require('@wppconnect/wa-js/dist/wppconnect-wa') callback() return } // Wait for the node to appear only once const observer = new MutationObserver(() => { const el = document.querySelector(targetSelector) if (el) { console.log('âœ…âœ…âœ…âœ…âœ…') observer.disconnect() // stop watching require('@wppconnect/wa-js/dist/wppconnect-wa') callback() } }) observer.observe(document.body, { childList: true, subtree: true, }) }
```

# src/libs/wa/profile.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { BusinessProfileModel } from '@wppconnect/wa-js/dist/whatsapp' /** * Update your business profile * * @example * \`\`\`javascript * await wa.profile.editBusinessProfile({description: 'New description for profile'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({categories: { id: "133436743388217", localized_display_name: "Artes e entretenimento", not_a_biz: false, }}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({email: 'test@test.com.br'}); * \`\`\` * * Change website of profile (max 2 sites) * \`\`\`javascript * await wa.profile.editBusinessProfile({website: [ "https://www.wppconnect.io", "https://www.teste2.com.br", ]}); * \`\`\` * * Change businessHours for Specific Hours * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { * { tue: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, wed: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, thu: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, fri: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sat: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sun: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, } }, timezone: "America/Sao_Paulo" }); * * Change businessHours for Always Opened * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "open_24h", }, tue: { mode: "open_24h", }, wed: { mode: "open_24h", }, thu: { mode: "open_24h", }, fri: { mode: "open_24h", }, sat: { mode: "open_24h", }, sun: { mode: "open_24h", }, } timezone: "America/Sao_Paulo" }); * * Change businessHours for Appointment Only * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "appointment_only", }, tue: { mode: "appointment_only", }, wed: { mode: "appointment_only", }, thu: { mode: "appointment_only", }, fri: { mode: "appointment_only", }, sat: { mode: "appointment_only", }, sun: { mode: "appointment_only", }, } timezone: "America/Sao_Paulo" }); * * */ export const editBusinessProfile = async ( params: BusinessProfileModel, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.EDIT_BUSINESS_PROFILE, body: params, }) } /** * Get your current profile name * * @example * \`\`\`javascript * const myProfileName = wa.profile.getMyProfileName(); * \`\`\` */ export const getMyProfileName = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_NAME, body: {}, }) } /** * Get your current profile picture * * @example * \`\`\`javascript * await wa.profile.getMyProfilePicture(); * \`\`\` */ export const getMyProfilePicture = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_PICTURE, body: {}, }) } /** * Get your current text status * * @example * \`\`\`javascript * await wa.profile.getMyStatus(); * \`\`\` */ export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_STATUS, body: {}, }) } /** * Return the current logged user is Bussiness or not * * @example * \`\`\`javascript * wa.profile.isBusiness(); * \`\`\` */ export const isBusiness = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.IS_BUSINESS, body: {}, }) } /** * Remove your profile picture * * @example * \`\`\`javascript * await wa.profile.removeMyProfilePicture(); * \`\`\` */ export const removeMyProfilePicture = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.REMOVE_MY_PROFILE_PICTURE, body: {}, }) } /** * Update your current profile name * * @example * \`\`\`javascript * await wa.profile.setMyProfileName('My new name'); * \`\`\` */ export const setMyProfileName = async (name: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_NAME, body: {}, }) } /** * Update your profile picture * * @example * \`\`\`javascript * await wa.profile.setMyProfilePicture('data:image/jpeg;base64,.....'); * \`\`\` */ export const setMyProfilePicture = async (content: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_PICTURE, body: content, }) } /** * Update your current text status * * @example * \`\`\`javascript * await wa.profile.setMyStatus('Example text'); * \`\`\` */ export const setMyStatus = async (statusText: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_STATUS, body: statusText, }) }
```

# src/libs/wa/send.ts

```ts
import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { AudioMessageOptions, AutoDetectMessageOptions, DocumentMessageOptions, ImageMessageOptions, LocationMessageOptions, PoolMessageOptions, SendMessageOptions, StickerMessageOptions, TextMessageOptions, VCardContact, VideoMessageOptions, } from '@wppconnect/wa-js/dist/chat' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { SendMsgResult } from '@wppconnect/wa-js/dist/whatsapp/enums' export const text = async ( chatId: any, content: any, options: TextMessageOptions = {}, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.TEXT, body: { chatId, content, options, }, }) } export const file = async ( chatId: string | Wid, content: string | Blob | File, options: | AutoDetectMessageOptions | AudioMessageOptions | DocumentMessageOptions | ImageMessageOptions | VideoMessageOptions | StickerMessageOptions | TextMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.FILE, body: { chatId, content, options, }, }) } export const location = async ( chatId: string | Wid, options: LocationMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.LOCATION, body: { chatId, options, }, }) } export const poll = async ( chatId: any, name: string, choices: string[], options?: PoolMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.POLL, body: { chatId, name, choices, options, }, }) } export const vcard = async ( chatId: string | Wid, contacts: string | Wid | VCardContact | (string | Wid | VCardContact)[], options?: SendMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.VCARD, body: { chatId, contacts, options, }, }) }
```

# src/libs/wa/status.ts

```ts
import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ImageStatusOptions, TextStatusOptions, VideoStatusOptions, } from '@wppconnect/wa-js/dist/status' import type { MsgKey, Wid } from '@wppconnect/wa-js/dist/whatsapp' export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET, body: chatId, }) } export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET_MY_STATUS, body: {}, }) } export const remove = async (msgId: string | MsgKey): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.REMOVE, body: msgId, }) } /** * Send a image message to status stories * * @example * \`\`\`javascript * wa.status.sendImageStatus('data:image/jpeg;base64,<a long base64 file...>'); * \`\`\` */ export const sendImageStatus = async ( content: any, options: ImageStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_IMAGE_STATUS, body: { content, options }, }) } /** * Mark status as read/seen * * @example * \`\`\`javascript * wa.status.sendReadStatus('[phone_number]@c.us', 'false_status@broadcast_3A169E0FD4BC6E92212F_5521526232927@c.us'); * \`\`\` */ export const sendReadStatus = async ( chatId: string | Wid, statusId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_READ_STATUS, body: { chatId, statusId }, }) } /** * Send a text message to status stories * * @example * \`\`\`javascript * wa.status.sendTextStatus(`Bootstrap primary color: #0275d8`, { backgroundColor: '#0275d8', font: 2}); * \`\`\` */ export const sendTextStatus = async ( content: any, options: TextStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_TEXT_STATUS, body: { content, options }, }) } /** * Send a video message to status stories * * @example * \`\`\`javascript * wa.status.sendVideoStatus('data:video/mp4;base64,<a long base64 file...>'); * \`\`\` */ export const sendVideoStatus = async ( content: any, options: VideoStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_VIDEO_STATUS, body: { content, options }, }) } /** * Define a custom list of participants to send the status message * * @example * \`\`\`javascript * // Use a custom list * await wa.status.updateParticipants(['123@c.us', '456@c.us']); * // Use the contacts by default * await wa.status.updateParticipants(null); * \`\`\` */ export const updateParticipants = async ( ids?: (string | Wid)[] | null, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.UPDATE_PARTICIPANTS, body: ids, }) }
```

# src/relays/blocklist.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const blockContact = () => { relay( { name: Action.Blocklist.BLOCK_CONTACT, }, async ({ body }) => { return await WPP.blocklist.blockContact(body) }, ) } const isBlocked = () => { relay( { name: Action.Blocklist.IS_BLOCKED, }, async ({ body }) => { return WPP.blocklist.isBlocked(body) }, ) } const unblockContact = () => { relay( { name: Action.Blocklist.UNBLOCK_CONTACT, }, async ({ body }) => { return WPP.blocklist.unblockContact(body) }, ) } const initBlocklistRelays = () => { all() blockContact() isBlocked() unblockContact() } export default initBlocklistRelays
```

# src/relays/cart.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const add = () => { relay( { name: Action.Cart.ADD, }, async ({ body }) => { const { chatId, products } = body return await WPP.cart.add(chatId, products) }, ) } const clear = () => { relay( { name: Action.Cart.CLEAR, }, async ({ body }) => { return await WPP.cart.clear(body) }, ) } const get = () => { relay( { name: Action.Cart.GET, }, async ({ body }) => { return WPP.cart.get(body) }, ) } const getThumbFromCart = () => { relay( { name: Action.Cart.GET_THUMB_FROM_CART, }, async ({ body }) => { return await WPP.cart.getThumbFromCart(body) }, ) } const remove = () => { relay( { name: Action.Cart.REMOVE, }, async ({ body }) => { const { chatId, productId } = body return WPP.cart.remove(chatId, productId) }, ) } const submit = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { wid, msg, options } = body return WPP.cart.submit(wid, msg, options) }, ) } const update = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { chatId, productId, options } = body return WPP.cart.update(chatId, productId, options) }, ) } const initCartRelays = () => { add() clear() get() getThumbFromCart() remove() submit() update() } export default initCartRelays
```

# src/relays/catalog.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const addProductImage = () => { relay( { name: Action.Catalog.ADD_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.addProductImage(productId, content) }, ) } const changeProductImage = () => { relay( { name: Action.Catalog.CHANGE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.changeProductImage(productId, content) }, ) } const createCollection = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { const { collectionName, productsId } = body return await WPP.catalog.createCollection(collectionName, productsId) }, ) } const createProduct = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.createProduct(body) }, ) } const deleteCollection = () => { relay( { name: Action.Catalog.DELETE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.deleteCollection(body) }, ) } const deleteProduct = () => { relay( { name: Action.Catalog.DELETE_PRODUCT, }, async ({ body }) => { return await WPP.catalog.delProducts(body) }, ) } const editCollection = () => { relay( { name: Action.Catalog.EDIT_COLLECTION, }, async ({ body }) => { const { collectionId, params } = body return await WPP.catalog.editCollection(collectionId, params) }, ) } const editProduct = () => { relay( { name: Action.Catalog.EDIT_PRODUCT, }, async ({ body }) => { const { productId, params } = body return await WPP.catalog.editProduct(productId, params) }, ) } const getCollections = () => { relay( { name: Action.Catalog.GET_COLLECTIONS, }, async ({ body }) => { const { chatId, qnt, productsCount } = body return await WPP.catalog.getCollections(chatId, qnt, productsCount) }, ) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ const getMyCatalog = () => { relay( { name: Action.Catalog.GET_MY_CATALOG, }, async ({ body }) => { return await WPP.catalog.getMyCatalog() }, ) } const getProductById = () => { relay( { name: Action.Catalog.GET_PRODUCT_BY_ID, }, async ({ body }) => { const { chatId, productId } = body return await WPP.catalog.getProductById(chatId, productId) }, ) } const getProducts = () => { relay( { name: Action.Catalog.GET_PRODUCTS, }, async ({ body }) => { const { chatId, qnt } = body return await WPP.catalog.getProducts(chatId, qnt) }, ) } const removeProductImage = () => { relay( { name: Action.Catalog.REMOVE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, index } = body return await WPP.catalog.removeProductImage(productId, index) }, ) } const setProductVisibility = () => { relay( { name: Action.Catalog.SET_PRODUCT_VISIBILITY, }, async ({ body }) => { const { productId, isHidden } = body return await WPP.catalog.setProductVisibility(productId, isHidden) }, ) } const updateCartEnabled = () => { relay( { name: Action.Catalog.UPDAGE_CART_ENABLED, }, async ({ body }) => { return await WPP.catalog.updateCartEnabled(body) }, ) } const initCatalogRelays = () => { addProductImage() changeProductImage() createCollection() createProduct() deleteCollection() deleteProduct() editCollection() editProduct() getCollections() getMyCatalog() getProductById() getProducts() removeProductImage() setProductVisibility() updateCartEnabled() } export default initCatalogRelays
```

# src/relays/chat.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const archive = () => { relay( { name: Action.Chat.ARCHIVE, }, async ({ body }) => { return await WPP.chat.archive(body) }, ) } const canMarkPlayed = () => { relay( { name: Action.Chat.CAN_MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.canMarkPlayed(body) }, ) } const canMute = () => { relay( { name: Action.Chat.CAN_MUTE, }, async ({ body }) => { return WPP.chat.canMute(body) }, ) } const canReply = () => { relay( { name: Action.Chat.CAN_REPLY, }, async ({ body }) => { return await WPP.chat.canReply(body) }, ) } const clear = () => { relay( { name: Action.Chat.CLEAR, }, async ({ body }) => { return await WPP.chat.clear(body) }, ) } const closeChat = () => { relay( { name: Action.Chat.CLOSE_CHAT, }, async ({ body }) => { return await WPP.chat.closeChat() }, ) } const _delete = () => { relay( { name: Action.Chat.DELETE, }, async ({ body }) => { return await WPP.chat.delete(body) }, ) } const deleteMessage = () => { relay( { name: Action.Chat.DELETE_MESSAGE, }, async ({ body }) => { const { chatId, ids, deleteMediaInDevice, revoke } = body return await WPP.chat.deleteMessage( chatId, ids, deleteMediaInDevice, revoke, ) }, ) } const list = () => { relay( { name: Action.Chat.LIST, }, async ({ body }) => { console.log('body', body) return (await WPP.chat.list(body)).map(serialize.chat) }, ) } const find = () => { relay( { name: Action.Chat.FIND, }, async (req) => { try { const chatId = req.body const chat = await WPP.chat.find(chatId) return response.success(serialize.chat(chat)) } catch (error) { return response.error(error.message) } }, ) } const forwardMessage = () => { relay( { name: Action.Chat.FORWARD_MESSAGE, }, async ({ body }) => { const { toChatId, msgId, options } = body return await WPP.chat.forwardMessage(toChatId, msgId, options) }, ) } const get = () => { relay( { name: Action.Chat.GET, }, async ({ body }) => { try { const chat = WPP.chat.get(body) return serialize.chat(chat) } catch (error) {} }, ) } const getActiveChat = () => { relay( { name: Action.Chat.GET_ACTIVE_CHAT, }, async (req) => { try { const chat = WPP.chat.getActiveChat() if (!chat) { return null } return serialize.chat(chat) } catch (error) { return null } }, ) } const getLastSeen = () => { relay( { name: Action.Chat.GET_LAST_SEEN, }, async ({ body }) => { return await WPP.chat.getLastSeen(body) }, ) } const getMessageACK = () => { relay( { name: Action.Chat.GET_MESSAGE_ACK, }, async ({ body }) => { return await WPP.chat.getMessageACK(body) }, ) } const getMessages = () => { relay( { name: Action.Chat.GET_MESSAGES, }, async ({ body }) => { const { chatId, options } = body const messages = await WPP.chat.getMessages(chatId, options) return messages.map(serialize.message) }, ) } const getNotes = () => { relay( { name: Action.Chat.GET_NOTES, }, async ({ body }) => { return await WPP.chat.getNotes(body) }, ) } const getPlatformFromMessage = () => { relay( { name: Action.Chat.GET_PLATFORM_MESSAGE, }, async ({ body }) => { return WPP.chat.getPlatformFromMessage(body) }, ) } const markIsComposing = () => { relay( { name: Action.Chat.MARK_IS_COMPOSING, }, async ({ body }) => { const { chatId, duration } = body return WPP.chat.markIsComposing(chatId, duration) }, ) } const markIsPaused = () => { relay( { name: Action.Chat.MARK_IS_PAUSED, }, async ({ body }) => { return await WPP.chat.markIsPaused(body) }, ) } const markIsRead = () => { relay( { name: Action.Chat.MARK_IS_READ, }, async ({ body }) => { return await WPP.chat.markIsRead(body) }, ) } const markIsRecording = () => { relay( { name: Action.Chat.MARK_IS_RECORDING, }, async ({ body }) => { return await WPP.chat.markIsRecording(body) }, ) } const markIsUnread = () => { relay( { name: Action.Chat.MARK_IS_UNREAD, }, async ({ body }) => { return await WPP.chat.markIsUnread(body) }, ) } const markPlayed = () => { relay( { name: Action.Chat.MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.markPlayed(body) }, ) } const mute = () => { relay( { name: Action.Chat.MUTE, }, async ({ body }) => { const { chatId, time } = body return await WPP.chat.mute(chatId, time) }, ) } const openChatAt = () => { relay( { name: Action.Chat.OPEN_CHAT_AT, }, async ({ body }) => { const { chatId, messageId } = body return await WPP.chat.openChatAt(chatId, messageId) }, ) } const openChatFromUnread = () => { relay( { name: Action.Chat.OPEN_CHAT_FROM_UNREAD, }, async ({ body }) => { return await WPP.chat.openChatFromUnread(body) }, ) } const pinMsg = () => { relay( { name: Action.Chat.PIN_MSG, }, async ({ body }) => { const { msgId, pin, seconds } = body return await WPP.chat.pinMsg(msgId, pin, seconds) }, ) } const openChatBottom = () => { relay( { name: Action.Chat.OPEN_CHAT_BOTTOM, }, async (req) => { try { const chatId = req.body return await WPP.chat.openChatBottom(chatId) } catch (error) { return false } }, ) } const setChatList = () => { relay( { name: Action.Chat.SET_CHAT_LIST, }, async (req) => { try { const { type, ids } = req.body await WPP.chat.setChatList(type, ids) } catch (error) { console.error(`setChatList: ${error}`) } }, ) } const setInputText = () => { relay( { name: Action.Chat.SET_INPUT_TEXT, }, async ({ body }) => { const { text, chatId } = body return await WPP.chat.setInputText(text, chatId) }, ) } const setNotes = () => { relay( { name: Action.Chat.SET_NOTES, }, async ({ body }) => { const { chatId, content } = body return await WPP.chat.setNotes(chatId, content) }, ) } const downloadMedia = () => { relay( { name: Action.Chat.DOWNLOAD_MEDIA, }, async ({ body: messageId }) => { try { const media = await Promise.race([ WPP.chat.downloadMedia(messageId), new Promise((_, reject) => setTimeout(() => reject(new Error('Error download media')), 3000), ), ]) return media } catch (error) { return null } }, ) } const initChatRelay = () => { archive() canMarkPlayed() canMute() canReply() clear() closeChat() _delete() deleteMessage() downloadMedia() find() forwardMessage() get() getActiveChat() getLastSeen() getMessageACK() getMessages() getNotes() getPlatformFromMessage() markIsComposing() markIsPaused() markIsRead() markIsRecording() markIsUnread() markPlayed() mute() list() openChatBottom() openChatAt() openChatFromUnread() pinMsg() setChatList() setInputText() setNotes() } export default initChatRelay
```

# src/relays/community.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const initCommunityRelays = () => { all() } export default initCommunityRelays
```

# src/relays/conn.relay.ts

```ts
import { Account, Action } from '@/constants' import country from '@/utils/country' import { delay } from '@/utils/util' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const genLinkDeviceCodeForPhoneNumber = () => { relay( { name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }, async ({ body }) => { const { phone, sendPushNotification } = body return await WPP.conn.genLinkDeviceCodeForPhoneNumber( phone, sendPushNotification, ) }, ) } const getAuthCode = () => { relay( { name: Action.Conn.GET_AUTH_CODE, }, async ({ body }) => { return await WPP.conn.getAuthCode() }, ) } const getMyUserId = () => { relay( { name: Action.Conn.GET_MY_USER_ID, }, async (req) => { return WPP.conn.getMyUserId() }, ) } const getProfile = () => { relay( { name: Action.Conn.GET_PROFILE, }, async (req) => { await delay(1000) const { user: number } = WPP.conn.getMyUserId() const contact = await WPP.contact.get(`${number}@c.us`) const countryCode = await WPP.whatsapp.functions.getCountryShortcodeByPhone(contact.id.user) const selectedCountry = country.getCountryByCode(countryCode) return { name: contact.pushname || contact.formattedName || contact.name || contact.verifiedName, number, type: contact.isBusiness ? Account.BUSINESS : Account.PERSONAL, country: selectedCountry.label, } }, ) } const initConnRelays = () => { genLinkDeviceCodeForPhoneNumber() getAuthCode() getMyUserId() getProfile() } export default initConnRelays
```

# src/relays/contact.relay.ts

```ts
import { Action } from '@/constants' import filterBy from '@/utils/filterBy' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Contact.GET, }, async ({ body }) => { const contact = await WPP.contact.get(body) return serialize.contact(contact) }, ) } const getBusinessProfile = () => { relay( { name: Action.Contact.GET_BUSINESS_PROFILE, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getCommonGroups = () => { relay( { name: Action.Contact.GET_COMMON_GROUPS, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getProfilePictureUrl = () => { relay( { name: Action.Contact.GET_PROFILE_PICTURE_URL, }, async ({ body }) => { const { contactId, full } = body return await WPP.contact.getProfilePictureUrl(contactId, full) }, ) } const getStatus = () => { relay( { name: Action.Contact.GET_STATUS, }, async ({ body }) => { return await WPP.contact.getStatus(body) }, ) } const list = () => { relay( { name: Action.Contact.LIST, }, async (req) => { const options = req.body const contacts = ((await WPP.contact.list(options)) ?? []) .filter(filterBy.dontIncludeLid) .map(serialize.contact) return contacts }, ) } const isExist = () => { relay( { name: Action.Contact.IS_EXIST, }, async (req) => { try { const contactId = req.body const result = await WPP.contact.queryExists(contactId) return !!result } catch (error) { return false } }, ) } const initContactRelay = () => { get() getBusinessProfile() getCommonGroups() getProfilePictureUrl() getStatus() isExist() list() } export default initContactRelay
```

# src/relays/group.relay.ts

```ts
import { Action } from '@/constants' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const addParticipants = () => { relay( { name: Action.Group.ADD_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.addParticipants(groupId, participantsIds) }, ) } const approve = () => { relay( { name: Action.Group.APPROVE, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.approve(groupId, membershipIds) }, ) } const canAdd = () => { relay( { name: Action.Group.CAN_ADD, }, async ({ body }) => { return await WPP.group.canAdd(body) }, ) } const canDemote = () => { relay( { name: Action.Group.CAN_DEMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canDemote(groupId, participantsIds) }, ) } const canPromote = () => { relay( { name: Action.Group.CAN_PROMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canPromote(groupId, participantsIds) }, ) } const canRemove = () => { relay( { name: Action.Group.CAN_REMOVE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canRemove(groupId, participantsIds) }, ) } const create = () => { relay( { name: Action.Group.CREATE, }, async ({ body }) => { const { groupName, participantsIds, parentGroup } = body return await WPP.group.create(groupName, participantsIds, parentGroup) }, ) } const demoteParticipants = () => { relay( { name: Action.Group.DEMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.demoteParticipants(groupId, participantsIds) }, ) } const getGroupInfoFromInviteCode = () => { relay( { name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, }, async ({ body }) => { return await WPP.group.getGroupInfoFromInviteCode(body) }, ) } const getGroupSizeLimit = () => { relay( { name: Action.Group.GET_GROUP_SIZE_LIMIT, }, async ({ body }) => { return await WPP.group.getGroupSizeLimit() }, ) } const list = () => { relay( { name: Action.Group.LIST, }, async ({ body }) => { const list = await WPP.chat.list(body) if (!list) { return [] } return list.map(serialize.chat) }, ) } const getInviteLink = () => { relay( { name: Action.Group.GET_INVITE_LINK, }, async (req) => { try { const { groupId } = req.body const link = await WPP.group.getInviteCode(groupId) return `https://chat.whatsapp.com/${link}` } catch (error) { console.error(`getInviteLink relay error: ${error}`) return null } }, ) } const getMembershipRequests = () => { relay( { name: Action.Group.GET_MEMBERSHIP_REQUESTS, }, async ({ body }) => { return await WPP.group.getMembershipRequests(body) }, ) } const getParticipants = () => { relay( { name: Action.Group.GET_PARTICIPANTS, }, async ({ body }) => { try { const participants = await WPP.group.getParticipants(body) return participants.map(serialize.participant) } catch (error) { return [] } }, ) } const iAmAdmin = () => { relay( { name: Action.Group.IAM_ADMIN, }, async ({ body }) => { return await WPP.group.iAmAdmin(body) }, ) } const iAmMember = () => { relay( { name: Action.Group.IAM_MEMBER, }, async ({ body }) => { return await WPP.group.iAmMember(body) }, ) } const iAmRestrictedMember = () => { relay( { name: Action.Group.IAM_RESTRICTED_MEMBER, }, async ({ body }) => { return await WPP.group.iAmRestrictedMember(body) }, ) } const iAmSuperAdmin = () => { relay( { name: Action.Group.IAM_SUPER_ADMIN, }, async ({ body }) => { return await WPP.group.iAmSuperAdmin(body) }, ) } const join = () => { relay( { name: Action.Group.JOIN, }, async ({ body }) => { return await WPP.group.join(body) }, ) } const leave = () => { relay( { name: Action.Group.LEAVE, }, async ({ body }) => { return await WPP.group.leave(body) }, ) } const promoteParticipants = () => { relay( { name: Action.Group.PROMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.promoteParticipants(groupId, participantsIds) }, ) } const reject = () => { relay( { name: Action.Group.REJECT, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.reject(groupId, membershipIds) }, ) } const removeIcon = () => { relay( { name: Action.Group.REMOVE_ICON, }, async ({ body }) => { return await WPP.group.removeIcon(body) }, ) } const removeParticipants = () => { relay( { name: Action.Group.REMOVE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.removeParticipants(groupId, participantsIds) }, ) } const revokeInviteCode = () => { relay( { name: Action.Group.REVOKE_INVITE_CODE, }, async ({ body }) => { return await WPP.group.revokeInviteCode(body) }, ) } const setDescription = () => { relay( { name: Action.Group.SET_DESCRIPTION, }, async ({ body }) => { const { groupId, description } = body return await WPP.group.setDescription(groupId, description) }, ) } const setIcon = () => { relay( { name: Action.Group.SET_ICON, }, async ({ body }) => { const { groupId, content } = body return await WPP.group.setIcon(groupId, content) }, ) } const setProperty = () => { relay( { name: Action.Group.SET_PROPERTY, }, async ({ body }) => { const { groupId, property, value } = body return await WPP.group.setProperty(groupId, property, value) }, ) } const setSubject = () => { relay( { name: Action.Group.SET_SUBJECT, }, async ({ body }) => { const { groupId, subject } = body return await WPP.group.setSubject(groupId, subject) }, ) } const initGroupRelay = () => { addParticipants() approve() canAdd() canDemote() canPromote() canRemove() create() demoteParticipants() getInviteLink() getGroupInfoFromInviteCode() getGroupSizeLimit() getMembershipRequests() getParticipants() list() iAmAdmin() iAmMember() iAmRestrictedMember() iAmSuperAdmin() join() leave() promoteParticipants() reject() removeIcon() removeParticipants() revokeInviteCode() setDescription() setIcon() setProperty() setSubject() } export default initGroupRelay
```

# src/relays/index.ts

```ts
import initBlocklistRelays from './blocklist.relay' import initCartRelays from './cart.relay' import initChatRelay from './chat.relay' import initConnRelays from './conn.relay' import initContactRelay from './contact.relay' import initGroupRelay from './group.relay' import initSendRelay from './send.relay' import initStatusRelay from './status.relay' export const initInjectScriptRelays = () => { initBlocklistRelays() initCartRelays() initChatRelay() initConnRelays() initContactRelay() initGroupRelay() initSendRelay() initStatusRelay() }
```

# src/relays/newsletter.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const create = () => { relay( { name: Action.Newsletter.CREATE, }, async ({ body }) => { const { name, opts } = body return await WPP.newsletter.create(name, opts) }, ) } const destroy = () => { relay( { name: Action.Newsletter.DESTROY, }, async ({ body }) => { return await WPP.newsletter.destroy(body) }, ) } const edit = () => { relay( { name: Action.Newsletter.EDIT, }, async ({ body }) => { const { newsletterId, opts } = body return await WPP.newsletter.edit(newsletterId, opts) }, ) } const getSubscribers = () => { relay( { name: Action.Newsletter.GET_SUBSCRIBERS, }, async ({ body }) => { return await WPP.newsletter.getSubscribers(body) }, ) } const mute = () => { relay( { name: Action.Newsletter.MUTE, }, async ({ body }) => { const { newsletterId, value } = body return await WPP.newsletter.mute(newsletterId, value) }, ) } const initNewsletterRelay = () => { create() destroy() edit() getSubscribers() mute() } export default initNewsletterRelay
```

# src/relays/profile.relay.ts

```ts
import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Profile.EDIT_BUSINESS_PROFILE, }, async ({ body }) => { return WPP.status.get(body) }, ) } const initProfileRelays = () => { get() } export default initProfileRelays
```

# src/relays/send.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const sendText = () => { relay( { name: Action.Send.TEXT, }, async (req) => { try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendTextMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendFile = () => { relay( { name: Action.Send.FILE, }, async (req) => { console.log('req', req) try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendFileMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendLocation = () => { relay( { name: Action.Send.LOCATION, }, async (req) => { try { const { chatId, options } = req.body const { sendMsgResult } = await WPP.chat.sendLocationMessage( chatId, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendPoll = () => { relay( { name: Action.Send.POLL, }, async (req) => { try { const { chatId, name, choices, options } = req.body const { sendMsgResult } = await WPP.chat.sendCreatePollMessage( chatId, name, choices, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendVCard = () => { relay( { name: Action.Send.VCARD, }, async (req) => { try { const { chatId, contacts, options } = req.body const { sendMsgResult } = await WPP.chat.sendVCardContactMessage( chatId, contacts, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const initSendRelay = () => { sendText() sendFile() sendLocation() sendPoll() sendVCard() } export default initSendRelay
```

# src/relays/status.relay.ts

```ts
import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Status.GET, }, async ({ body }) => { return WPP.status.get(body) }, ) } const getMyStatus = () => { relay( { name: Action.Status.GET_MY_STATUS, }, async ({ body }) => { return await WPP.status.getMyStatus() }, ) } const remove = () => { relay( { name: Action.Status.REMOVE, }, async ({ body }) => { return await WPP.status.remove(body) }, ) } const sendImageStatus = () => { relay( { name: Action.Status.SEND_IMAGE_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendImageStatus(content, options) }, ) } const sendReadStatus = () => { relay( { name: Action.Status.SEND_READ_STATUS, }, async ({ body }) => { const { chatId, statusId } = body return await WPP.status.sendReadStatus(chatId, statusId) }, ) } const sendTextStatus = () => { relay( { name: Action.Status.SEND_TEXT_STATUS, }, async ({ body }) => { try { const { content, options } = body await WPP.status.sendTextStatus(content, options) return response.success() } catch (error) { return response.error(error.message) } }, ) } const sendVideoStatus = () => { relay( { name: Action.Status.SEND_VIDEO_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendVideoStatus(content, options) }, ) } const updateParticipants = () => { relay( { name: Action.Status.UPDATE_PARTICIPANTS, }, async ({ body }) => { return await WPP.status.updateParticipants(body) }, ) } const initStatusRelay = () => { get() getMyStatus() remove() sendImageStatus() sendReadStatus() sendTextStatus() sendVideoStatus() updateParticipants() } export default initStatusRelay
```

# src/stores/app.ts

```ts
import type { License } from '@/types' import { create } from 'zustand' interface AppState { isReady: boolean setIsReady: (isReady: boolean) => void profile: any setProfile: (profile: any) => void license?: License | null setLicense: (license: any) => void groups: any[] setGroups: (groups: []) => void isLoading: boolean setIsLoading: (state: boolean) => void activeChat: any setActiveChat: (chat: any) => void } export const useAppStore = create<AppState>((set) => ({ isReady: false, setIsReady: (isReady: boolean) => set({ isReady }), license: null, setLicense: (license: any) => set({ license: license }), groups: [], setGroups: (groups: []) => set({ groups }), profile: {}, setProfile: (profile: any) => set({ profile }), isLoading: false, setIsLoading: (state: any) => set({ isLoading: state }), activeChat: {}, setActiveChat: (chat: any) => set({ activeChat: chat }), }))
```

# src/stores/toast.ts

```ts
import { create } from 'zustand' export interface Toast { id: number type: 'success' | 'error' | 'info' | 'warning' title: string message: string duration?: number } interface ToastState { toasts: Toast[] addToast: (toast: Omit<Toast, 'id'>) => void removeToast: (id: number) => void } export const useToastStore = create<ToastState>((set) => ({ toasts: [], addToast: (toast) => set((state) => ({ toasts: [...state.toasts, { ...toast, id: Date.now() }], })), removeToast: (id) => set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id), })), }))
```

# src/styles/globals.css

```css
div.plasmo-csui-container { margin: 0; color-scheme: var(--mantine-color-scheme); font-family: var(--mantine-font-family); font-size: var(--mantine-font-size-md); line-height: var(--mantine-line-height); background-color: var(--mantine-color-body); color: var(--mantine-color-text); -webkit-font-smoothing: var(--mantine-webkit-font-smoothing); -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing); right: 0px; left: auto !important; } .root { position: fixed; top: '30%'; left: '50%'; transform: 'translate(-50%, -50%)'; z-index: 1001; background-color: red; } #plasmo-inline { background: transparent; }
```

# src/tabs/landing-page.tsx

```tsx
import { PRIMARY_ICON } from '@/constants' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { Accordion, Anchor, Avatar, Badge, Box, Button, Card, Center, Container, Divider, Grid, Group, List, MantineProvider, Paper, Stack, Table, Text, ThemeIcon, Title, Tooltip, Transition, } from '@mantine/core' import '@mantine/core/styles.css' import { useWindowScroll } from '@mantine/hooks' import React, { useEffect, useState } from 'react' // --- Start: New Config for Status Scheduler --- // Define a structured feature type for the comparison table export interface PlanFeature { feature: string free: string | boolean pro: string | boolean } // Centralized list of features for easy management and comparison const comparisonFeatures: PlanFeature[] = [ { feature: 'Text Status Updates', free: true, pro: true }, { feature: 'Image & Video Status Updates', free: false, pro: true }, { feature: 'Schedule Statuses for Later', free: false, pro: true }, { feature: 'Status Management Dashboard', free: 'Limited (3 Drafts)', pro: 'Unlimited', }, { feature: 'Automated Posting', free: false, pro: true }, { feature: 'Save Statuses as Drafts', free: true, pro: true }, { feature: 'Customer Support', free: 'Standard Support', pro: 'Priority Support', }, ] // Define plan objects for the pricing cards. const plans = [ { name: 'Free', isFree: true, description: 'For basic, manual status updates.', price: '$0', placeholderPrice: null, link: '#', features: [ 'Post text-only statuses', 'Save up to 3 drafts', 'Manual posting only', 'Standard support', ], }, { name: 'Pro Lifetime', isFree: false, description: 'Pay once, automate your WhatsApp presence forever.', placeholderPrice: '$89', price: '$39', link: 'https://extdotninja.lemonsqueezy.com/buy/07900b2b-ed92-4714-b111-51f07d221c0c?logo=0', // Placeholder for new product ID features: [ 'Schedule Unlimited Statuses', 'Post Images & Videos', 'Fully Automated Posting', 'Full Management Dashboard', 'Priority Customer Support', 'All Future Updates Included', ], }, ] // --- End: New Config --- const CheckIcon = () => ( <Icon icon="tabler:check" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-teal-6)" /> ) const CrossIcon = () => ( <Icon icon="tabler:x" fontSize={20} strokeWidth={2.5} color="var(--mantine-color-red-6)" /> ) // --- Countdown Timer Logic --- interface TimeLeft { days: number hours: number minutes: number seconds: number } const calculateTimeLeft = (offerEndDate: Date): TimeLeft | null => { const difference = +offerEndDate - +new Date() if (difference <= 0) { return null } return { days: Math.floor(difference / (1000 * 60 * 60 * 24)), hours: Math.floor((difference / (1000 * 60 * 60)) % 24), minutes: Math.floor((difference / 1000 / 60) % 60), seconds: Math.floor((difference / 1000) % 60), } } const TimeSegment: React.FC<{ value: number; label: string }> = ({ value, label, }) => ( <Stack align="center" gap={0}> <Text fz={32} fw={700} c="yellow.6"> {' '} {String(value).padStart(2, '0')}{' '} </Text> <Text size="xs" c="dimmed"> {' '} {label}{' '} </Text> </Stack> ) const CountdownTimer: React.FC<{ offerEndDate: Date; isMini?: boolean }> = ({ offerEndDate, isMini = false, }) => { const [timeLeft, setTimeLeft] = useState<TimeLeft | null>( calculateTimeLeft(offerEndDate), ) useEffect(() => { const timer = setInterval(() => { setTimeLeft(calculateTimeLeft(offerEndDate)) }, 1000) return () => clearInterval(timer) }, [offerEndDate]) if (!timeLeft) { return ( <Text c="red.7" fw={700} size="lg"> {' '} Offer has ended!{' '} </Text> ) } if (isMini) { return ( <Text c="white" size="sm" fw={500}> {' '} Offer Ends In: {String(timeLeft.days).padStart(2, '0')}: {String(timeLeft.hours).padStart(2, '0')}: {String(timeLeft.minutes).padStart(2, '0')}: {String(timeLeft.seconds).padStart(2, '0')} </Text> ) } return ( <Group justify="center" gap="lg"> <TimeSegment value={timeLeft.days} label="DAYS" /> <TimeSegment value={timeLeft.hours} label="HOURS" /> <TimeSegment value={timeLeft.minutes} label="MINUTES" /> <TimeSegment value={timeLeft.seconds} label="SECONDS" /> </Group> ) } // --- End Countdown Timer Logic --- // --- Section Components --- const HeroSection = () => ( <Center p="xl" pt={80}> <Stack align="center" gap="xl" ta="center" maw={700}> <ThemeIcon size={80} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon={PRIMARY_ICON} fontSize={48} /> </ThemeIcon> <Title order={1} fz={{ base: 36, sm: 48 }}> {' '} Automate Your WhatsApp Status. Engage Your Audience 24/7.{' '} </Title> <Text c="dimmed" fz="lg"> {' '} Schedule text, image, and video statuses to post automatically. Keep your contacts engaged, promote your business, and save timeâ€”all from a simple dashboard.{' '} </Text> <Stack align="center"> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > {' '} Get Lifetime Access </Button> <Text size="xs" c="dimmed"> {' '} Includes 30-day money-back guarantee{' '} </Text> </Stack> </Stack> </Center> ) const FeaturesSection = () => { const featuresData = [ { icon: 'tabler:calendar-time', title: 'Schedule & Forget', description: "Plan your statuses for days, weeks, or months in advance. Our tool will post them for you at the perfect time, even when you're offline.", }, { icon: 'tabler:photo-video', title: 'Post Rich Media', description: 'Go beyond text. Capture attention by scheduling stunning images and engaging videos directly to your status.', }, { icon: 'tabler:dashboard', title: 'All-in-One Dashboard', description: "Manage all your statuses from one place. See what's scheduled, what's been posted, and what's in drafts. Stay organized and in control.", }, { icon: 'tabler:shield-check', title: 'Safe & Reliable', description: 'Our scheduler interacts with WhatsApp Web in a responsible way to ensure your updates are posted reliably, following best practices.', }, { icon: 'tabler:rocket', title: 'Boost Engagement', description: 'Maintain a consistent presence and keep your brand top-of-mind. Perfect for announcements, promotions, and daily updates.', }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>A Smarter Way to Manage Your Presence</Title> <Text c="dimmed"> {' '} Unlock powerful tools that make your communication more effective and efficient.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {featuresData.map((feature) => ( <Grid.Col span={{ base: 12, md: 4 }} key={feature.title}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon={feature.icon} fontSize={22} /> </ThemeIcon> <Text fw={700} fz="lg"> {' '} {feature.title}{' '} </Text> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} {feature.description}{' '} </Text> </Card> </Grid.Col> ))} </Grid> </Box> ) } const UserPersonaSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Built For Professionals</Title> <Text c="dimmed"> {' '} Whether you're in marketing, sales, or community management, we've got you covered.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:target-arrow" fontSize={22} /> </ThemeIcon> <Title order={3}>For Marketers & Businesses</Title> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} Schedule product launches, daily deals, and promotional content. Keep your audience engaged without being tied to your phone.{' '} </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> Automate marketing campaigns </List.Item> <List.Item> Announce limited-time offers </List.Item> <List.Item> Drive traffic with consistent updates </List.Item> </List> <Button component="a" href="#pricing" mt="auto" variant="light" color="teal" > {' '} Upgrade for Business Needs{' '} </Button> </Stack> </Card> </Grid.Col> <Grid.Col span={{ base: 12, md: 6 }}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack style={{ height: '100%' }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon="tabler:users-group" fontSize={22} /> </ThemeIcon> <Title order={3}>For Creators & Influencers</Title> </Group> <Text c="dimmed" size="sm" mt="md"> {' '} Plan your content calendar and schedule updates to connect with your followers. Share your work, behind-the-scenes content, and announcements automatically.{' '} </Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> Maintain daily engagement </List.Item> <List.Item> Promote new content or events </List.Item> <List.Item> Build a stronger community </List.Item> </List> <Button component="a" href="#pricing" mt="auto" variant="light" color="teal" > {' '} Get More Efficiency{' '} </Button> </Stack> </Card> </Grid.Col> </Grid> </Box> ) const CaseStudySection = () => { const caseStudies = [ { icon: 'tabler:building-store', title: 'E-Commerce Store', description: "A local clothing brand schedules daily 'Outfit of the Day' image statuses and weekend video promotions. This consistent engagement led to a 15% increase in direct inquiries via WhatsApp.", features: ['Image & Video Statuses', 'Content Planning'], }, { icon: 'tabler:home-cog', title: 'Real Estate Agent', description: "An agent schedules 'Just Listed' video tours and 'Open House' reminders. This keeps potential buyers informed and saves the agent hours each week.", features: ['Scheduled Updates', 'Time-Saving Automation'], }, { icon: 'tabler:play-football', title: 'Online Coach', description: 'A fitness coach schedules motivational text statuses and short workout video clips for their clients every morning, providing value and keeping their community active.', features: ['Daily Scheduling', 'Audience Engagement'], }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Solves Real-World Problems</Title> <Text c="dimmed"> {' '} See how professionals use our tool to make their communication smarter.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {caseStudies.map((study) => ( <Grid.Col span={{ base: 12, md: 4 }} key={study.title}> <Card withBorder radius="lg" p="xl" style={{ height: '100%', display: 'flex', flexDirection: 'column', }} > <Stack style={{ flexGrow: 1 }}> <Group> <ThemeIcon variant="light" size={40} radius="md"> <Icon icon={study.icon} fontSize={22} /> </ThemeIcon> <Title order={4}>{study.title}</Title> </Group> <Text c="dimmed" size="sm" mt="sm"> {' '} {study.description}{' '} </Text> </Stack> <Group gap="xs" mt="lg"> {study.features.map((feature) => ( <Badge key={feature} variant="light" color="teal"> {feature} </Badge> ))} </Group> </Card> </Grid.Col> ))} </Grid> </Box> ) } const PricingSection: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => ( <Box mt={80} id="pricing"> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Get a Lifetime License</Title> <Text c="dimmed">One single payment. All Pro features forever.</Text> </Stack> </Center> <Group justify="center" align="stretch" mt="xl" gap="lg"> {plans.map((plan, index) => ( <Paper key={index} withBorder w={{ base: '100%', sm: 380 }} radius={'lg'} p="xl" style={{ border: !plan.isFree ? '2px solid var(--mantine-color-teal-6)' : undefined, boxShadow: !plan.isFree ? 'var(--mantine-shadow-lg)' : 'var(--mantine-shadow-sm)', position: 'relative', }} > <Stack justify="space-between" style={{ height: '100%' }}> <Box ta="center"> <Title order={2}>{plan.name}</Title> <Text c="dimmed" mt={4} size="sm"> {' '} {plan.description}{' '} </Text> </Box> <Box my="lg" ta="center"> {!plan.isFree && ( <Stack mb="lg"> <Title order={4} c="orange.7"> {' '} LAUNCH OFFER: 56% OFF ENDS SOON!{' '} </Title> <CountdownTimer offerEndDate={offerEndDate} /> <Text size="xs" c="dimmed" mt="xs"> {' '} Don't miss out on saving $50. Price returns to normal after the timer ends.{' '} </Text> </Stack> )} <Box pos="relative"> <Group gap={8} align={'baseline'} justify="center"> {plan.placeholderPrice && ( <Title order={3} c={'dimmed'} style={{ textDecorationLine: 'line-through' }} > {' '} {plan.placeholderPrice}{' '} </Title> )} <Title order={1} fz={52}> {' '} {plan.price}{' '} </Title> </Group> </Box> </Box> <Divider label="Key Features" labelPosition="center" my="sm" /> <Stack gap="sm" mb="lg"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="sm" wrap="nowrap" align="flex-start"> <ThemeIcon variant="light" color={plan.isFree ? 'gray' : 'teal'} size="sm" radius="xl" > {plan.isFree ? ( <Icon icon="tabler:circle-check" fontSize={16} /> ) : ( <Icon icon="tabler:star" fontSize={16} /> )} </ThemeIcon> <Text size="sm">{feature}</Text> </Group> ))} </Stack> <Box mt="auto"> {plan.isFree ? ( <Button size="md" variant="default" fullWidth disabled> {' '} Your Current Plan{' '} </Button> ) : ( <Stack gap="xs"> <Button size="lg" component="a" href={plan.link} target="_blank" fullWidth leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Upgrade to Pro{' '} </Button> <Stack gap={4} align="center" mt="xs"> <Group justify="center" gap={6}> <Icon icon="tabler:lock" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> {' '} 100% Secure Payment via Lemon Squeezy{' '} </Text> </Group> <Group justify="center" gap={6}> <Icon icon="tabler:shield-check" fontSize={14} color="var(--mantine-color-gray-6)" /> <Text size="xs" c="dimmed"> {' '} 30-Day Money-Back Guarantee{' '} </Text> </Group> </Stack> </Stack> )} </Box> </Stack> </Paper> ))} </Group> </Box> ) const NoSubscriptionSection = () => ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>No Monthly Fees. Own It Forever.</Title> <Text c="dimmed"> {' '} Forget recurring subscription costs. With the Pro version, you pay once for lifetime access to all current features and future updates.{' '} </Text> <Card withBorder p="xl" radius="lg" mt="md" w="100%"> <Grid align="center"> <Grid.Col span={5} ta="center"> <Stack align="center"> <Icon icon="tabler:calendar-dollar" fontSize={48} color="var(--mantine-color-red-6)" /> <Text fw={500}>Endless Subscriptions</Text> <Icon icon="tabler:x" fontSize={32} color="var(--mantine-color-red-6)" /> </Stack> </Grid.Col> <Grid.Col span={2}> <Center> <Divider orientation="vertical" /> </Center> </Grid.Col> <Grid.Col span={5} ta="center"> <Stack align="center"> <Icon icon="tabler:pig-money" fontSize={48} color="var(--mantine-color-teal-6)" /> <Text fw={500}>One-Time Payment</Text> <Icon icon="tabler:check" fontSize={32} color="var(--mantine-color-teal-6)" /> </Stack> </Grid.Col> </Grid> </Card> </Stack> </Center> </Box> ) const FeatureComparisonTable = () => ( <Box mt={80}> <Center> <Title order={2} ta="center" mb="xl"> {' '} Features Comparison{' '} </Title> </Center> <Card withBorder radius="lg" p={0}> <Table striped highlightOnHover verticalSpacing="md" fz="sm"> <Table.Thead> <Table.Tr> <Table.Th w="40%">Feature</Table.Th> <Table.Th ta="center">Free</Table.Th> <Table.Th ta="center">Pro</Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {comparisonFeatures.map((item) => ( <Table.Tr key={item.feature} style={{ backgroundColor: item.free === false ? 'var(--mantine-color-teal-0)' : undefined, }} > <Table.Td> <Group gap="xs" justify="space-between"> <Text fw={500}>{item.feature}</Text> </Group> </Table.Td> <Table.Td ta="center"> {typeof item.free === 'boolean' ? ( item.free ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Text size="sm">{item.free}</Text> )} </Table.Td> <Table.Td ta="center"> {typeof item.pro === 'boolean' ? ( item.pro ? ( <CheckIcon /> ) : ( <CrossIcon /> ) ) : ( <Badge color="teal" variant="light"> {' '} {item.pro}{' '} </Badge> )} </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </Card> </Box> ) const SecuritySection = () => ( <Box mt={80}> <Card withBorder p="xl" radius="lg" bg="gray.0"> <Grid align="center"> <Grid.Col span={{ base: 12, md: 2 }} ta="center"> <ThemeIcon size={80} radius="xl" variant="light" color="teal"> <Icon icon="tabler:shield-lock" fontSize={48} /> </ThemeIcon> </Grid.Col> <Grid.Col span={{ base: 12, md: 10 }}> <Title order={2}>Your Privacy is Our Top Priority</Title> <Text c="dimmed" mt="md"> {' '} We designed this extension with a "privacy-first" approach. You have complete and total control over your data, always.{' '} </Text> <List mt="md" spacing="xs" size="sm" icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> } > <List.Item> {' '} <b>Local Processing:</b> All your status drafts and media are stored directly in your browser. They are never uploaded to our servers.{' '} </List.Item> <List.Item> {' '} <b>No Data Storage:</b> We never see, save, or have access to your status content or contacts.{' '} </List.Item> <List.Item> {' '} <b>You Are in Control:</b> All actions happen on your own computer, under your control.{' '} </List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const TestimonialsSection = () => { const testimonialsData = [ { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-8.png', name: 'Sarah L.', role: 'E-commerce Owner', quote: 'The status scheduler is a game-changer. I can plan a whole week of promotions in 30 minutes. Our <b>customer engagement has never been higher</b>. The ability to schedule images of our new products is fantastic.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-2.png', name: 'Mike P.', role: 'Fitness Coach', quote: 'I use it to post daily workout tips for my clients. The ability to <b>schedule video statuses is amazing</b>. It saves me so much time every single day and keeps my community motivated.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-4.png', name: 'Alisha C.', role: 'Digital Marketer', quote: 'We manage several business accounts, and this tool allows us to maintain a consistent brand presence across all of them. The <b>dashboard is intuitive, and the scheduling is flawless</b>.', }, { avatar: 'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-5.png', name: 'David G.', role: 'Freelance Photographer', quote: "As a photographer, I can schedule my portfolio images to post throughout the week. It's a fantastic way to <b>showcase my work without constantly being on my phone</b>. Worth every penny for the lifetime license.", }, ] return ( <Box mt={80}> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Trusted by Professionals</Title> <Text c="dimmed"> {' '} See what our happy customers are saying about the Pro version.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> {testimonialsData.map((testimonial) => ( <Grid.Col span={{ base: 12, md: 6 }} key={testimonial.name}> <Card withBorder radius="lg" p="xl" style={{ height: '100%' }}> <Stack> <Text c="dimmed" dangerouslySetInnerHTML={{ __html: testimonial.quote }} /> <Group mt="md"> <Avatar src={testimonial.avatar} alt={testimonial.name} radius="xl" /> <div> <Text fw={500}>{testimonial.name}</Text> <Text size="xs" c="dimmed"> {' '} {testimonial.role}{' '} </Text> </div> </Group> </Stack> </Card> </Grid.Col> ))} </Grid> </Box> ) } const GuaranteeSection = () => ( <Paper bg="teal.0" radius="lg" p="xl" mt={80} style={{ border: '2px dashed var(--mantine-color-teal-4)' }} > <Group justify="center" align="center"> <ThemeIcon variant="light" color="teal" size={60} radius="xl"> <Icon icon="tabler:shield-check" fontSize={32} /> </ThemeIcon> <Stack gap={0} ta={{ base: 'center', sm: 'left' }}> <Title order={3}>Our 100% 'Peace of Mind' Full Guarantee</Title> <Text c="dimmed" maw={500}> {' '} We're confident you'll love the Pro features. If you're not 100% satisfied, contact us within 30 days of your purchase for a full, no-questions-asked refund.{' '} </Text> </Stack> </Group> </Paper> ) const FaqSection = () => { const faqData = [ { icon: 'tabler:rocket', question: 'Why do I need to upgrade to Pro?', answer: 'Pro unlocks the core automation features. You can <b>schedule posts</b> for the future and use rich media like <b>images and videos</b>. It transforms the tool from a simple status maker into a powerful marketing and engagement assistant.', }, { icon: 'tabler:key', question: 'Is this a one-time payment or a subscription?', answer: 'It is a <b>one-time payment</b>. You pay once and get lifetime access to all current and future Pro features. No monthly fees, no subscriptions, ever.', }, { icon: 'tabler:shield-check', question: 'Is this safe to use for my WhatsApp account?', answer: 'Yes. The scheduler uses the official WhatsApp Web interface to post statuses, just as you would manually. It operates with delays between actions to ensure natural-looking activity, keeping your account in good standing.', }, { icon: 'tabler:help', question: 'How does the scheduler actually work?', answer: 'You create your status (text, image, or video), set a future date and time, and save it. Our extension, running in your browser on WhatsApp Web, will automatically post it for you at the scheduled time, even if you are away from your computer.', }, ] return ( <Box mt={80} id="faq"> <Center> <Title order={2} ta="center" mb="xl"> {' '} Frequently Asked Questions{' '} </Title> </Center> <Accordion variant="separated" radius="lg"> {faqData.map((item, index) => ( <Accordion.Item key={index} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > <Text fw={500}>{item.question}</Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} /> </Accordion.Panel> </Accordion.Item> ))} </Accordion> </Box> ) } const ValueStackSection = () => ( <Box mt={80}> <Card withBorder radius="lg" p="xl"> <Center> <Stack align="center" ta="center" maw={600}> <Title order={2}>Here's Everything You Get</Title> <Text c="dimmed"> {' '} Your Pro Lifetime License is a complete package for professional WhatsApp engagement.{' '} </Text> </Stack> </Center> <Grid mt="xl" gutter="xl"> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Unlimited Status Scheduling</List.Item> <List.Item>Image & Video Status Posts</List.Item> <List.Item>Automated Posting Engine</List.Item> </List> </Grid.Col> <Grid.Col span={{ base: 12, sm: 6 }}> <List spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item>Full Status Management Dashboard</List.Item> <List.Item>Priority Customer Support</List.Item> <List.Item>30-Day Money-Back Guarantee</List.Item> </List> </Grid.Col> </Grid> </Card> </Box> ) const ContactUsSection = () => ( <Box mt={80}> <Card withBorder p="xl" shadow="sm" radius="lg"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail-filled" fontSize={24} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still Have Questions?</Title> <Text c="dimmed" size="sm"> {' '} Our team is ready to help. Contact us for any inquiries.{' '} </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > {' '} extdotninja@gmail.com{' '} </Anchor> </Stack> </Group> </Card> </Box> ) const Footer = () => ( <Box mt={80} py="xl"> <Divider /> <Stack align="center" ta="center" mt="xl" gap={4}> <Text size="sm"> {' '} Copyright Â© {new Date().getFullYear()}. All Rights Reserved.{' '} </Text> <Text size="xs" c="dimmed" maw={500}> {' '} This is an independent software and is not affiliated with, sponsored, or endorsed by WhatsApp LLC.{' '} </Text> </Stack> </Box> ) const StickyHeader: React.FC<{ offerEndDate: Date }> = ({ offerEndDate }) => { const [scroll] = useWindowScroll() return ( <Transition mounted={scroll.y > 200} transition="slide-down" duration={300} timingFunction="ease" > {(styles) => ( <Paper shadow="md" radius={0} p="xs" style={{ ...styles, position: 'fixed', top: 0, left: 0, right: 0, zIndex: 1000, backgroundColor: 'var(--mantine-color-dark-8)', }} > <Container size="md"> <Group justify="space-between"> <CountdownTimer offerEndDate={offerEndDate} isMini /> <Button size="sm" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={18} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > {' '} Get Lifetime Access for Just $39!{' '} </Button> </Group> </Container> </Paper> )} </Transition> ) } const getOfferEndDate = (): Date => { const storedEndDate = localStorage.getItem('offerEndDate') if (storedEndDate && new Date(storedEndDate) > new Date()) { return new Date(storedEndDate) } const newEndDate = new Date() newEndDate.setDate(newEndDate.getDate() + 3) localStorage.setItem('offerEndDate', newEndDate.toISOString()) return newEndDate } const LandingPage = () => { const [notification, setNotification] = useState<{ city: string country: string } | null>(null) const [offerEndDate] = useState(getOfferEndDate) useEffect(() => { const locations = [ { city: 'Torino', country: 'Italy' }, { city: 'Shaqra', country: 'Saudi Arabia' }, { city: 'Miami', country: 'United States' }, ] let timeoutId: NodeJS.Timeout const scheduleNextNotification = () => { clearTimeout(timeoutId) const randomDelay = Math.floor(Math.random() * (15000 - 8000 + 1)) + 8000 // 8-15 seconds timeoutId = setTimeout(() => { const randomLocation = locations[Math.floor(Math.random() * locations.length)] setNotification(randomLocation) timeoutId = setTimeout(() => { setNotification(null) scheduleNextNotification() }, 4000) // Show for 4 seconds }, randomDelay) } timeoutId = setTimeout(scheduleNextNotification, 5000) // First one after 5 seconds return () => clearTimeout(timeoutId) }, []) return ( <MantineProvider theme={theme}> <StickyHeader offerEndDate={offerEndDate} /> <Container size="md" py="xl"> <Stack gap={80}> <HeroSection /> <FeaturesSection /> <UserPersonaSection /> <CaseStudySection /> <PricingSection offerEndDate={offerEndDate} /> <NoSubscriptionSection /> <FeatureComparisonTable /> <SecuritySection /> <TestimonialsSection /> <GuaranteeSection /> <FaqSection /> <ValueStackSection /> <ContactUsSection /> <Center mt={40}> <Stack align="center" gap="lg"> <Title order={2}>Ready to Supercharge Your Engagement?</Title> <Text c="dimmed" size="lg"> {' '} Get all Pro features for a one-time payment.{' '} </Text> <Stack align="center"> <Button size="lg" component="a" href={plans.find((p) => !p.isFree)?.link} target="_blank" leftSection={<Icon icon="tabler:crown" fontSize={20} />} variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="md" > {' '} Get Lifetime Access Now for Just $39{' '} </Button> <Text size="xs" c="dimmed"> {' '} 30-day no-questions-asked money-back guarantee.{' '} </Text> </Stack> </Stack> </Center> <Footer /> </Stack> </Container> <Transition mounted={!!notification} transition="slide-right" duration={500} timingFunction="ease" > {(styles) => ( <Paper shadow="lg" p="sm" radius="md" withBorder style={{ ...styles, position: 'fixed', bottom: 20, left: 20, zIndex: 2000, }} > <Group> <ThemeIcon color="teal" size={36} radius="xl"> <Icon icon="tabler:shield-check" fontSize={22} /> </ThemeIcon> <Stack gap={0}> <Text fw={500} size="sm"> {' '} Just upgraded to Pro!{' '} </Text> <Text size="xs" c="dimmed"> {' '} {`Someone from ${notification?.city}, ${notification?.country}`}{' '} </Text> </Stack> </Group> </Paper> )} </Transition> </MantineProvider> ) } export default LandingPage
```

# src/tabs/resource-page.tsx

```tsx
// src/tabs/resource-page.tsx // This page provides promotional materials for the Chrome Web Store listing. import PromoIcon from '@/components/Promo/PromoIcon' import ScreenshotWrapper from '@/components/Promo/ScreenshotWrapper' import { PRIMARY_ICON } from '@/constants' import theme from '@/libs/theme' import { Icon } from '@iconify/react' import { Badge, Button, Card, Center, Code, Container, CopyButton, Fieldset, Grid, Group, List, MantineProvider, Paper, Stack, Switch, Table, Tabs, Text, Textarea, ThemeIcon, Title, } from '@mantine/core' import '@mantine/core/styles.css' import { DateTimePicker } from '@mantine/dates' import '@mantine/dates/styles.css' import FileSaver from 'file-saver' import html2canvas from 'html2canvas' import React, { useRef } from 'react' // A gradient background that matches the landing page's theme. const PROMO_GRADIENT_BACKGROUND = 'linear-gradient(135deg, var(--mantine-color-teal-8), var(--mantine-color-lime-8))' // The primary icon representing the Status Scheduler feature. const STATUS_SCHEDULER_ICON = 'tabler:calendar-stats' // --- START: New Mockups for Status Scheduler Feature --- // Mockup of the main dashboard showing a list of scheduled and posted statuses. const MockupStatusDashboard = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={4}>Status Management Dashboard</Title> <Text c="dimmed" size="sm"> {' '} Track all your statusesâ€”drafts, scheduled, and postedâ€”in one place.{' '} </Text> <Table striped highlightOnHover withTableBorder mt="sm"> <Table.Thead> <Table.Tr> <Table.Th>Status Name</Table.Th> <Table.Th>Type</Table.Th> <Table.Th>Status</Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> <Table.Tr> <Table.Td>Weekend Promotion</Table.Td> <Table.Td> <Badge variant="light" leftSection={<Icon icon="tabler:photo" />}> Image </Badge> </Table.Td> <Table.Td> <Badge color="blue">Scheduled</Badge> </Table.Td> </Table.Tr> <Table.Tr> <Table.Td>Morning Update</Table.Td> <Table.Td> <Badge variant="light" leftSection={<Icon icon="tabler:file-text" />} > Text </Badge> </Table.Td> <Table.Td> <Badge color="green">Posted</Badge> </Table.Td> </Table.Tr> <Table.Tr> <Table.Td>New Product Announcement</Table.Td> <Table.Td> <Badge variant="light" leftSection={<Icon icon="tabler:video" />}> Video </Badge> </Table.Td> <Table.Td> <Badge color="gray">Draft</Badge> </Table.Td> </Table.Tr> </Table.Tbody> </Table> </Stack> </Card> ) // Mockup showing the Pro scheduling feature. const MockupCreateStatusPro = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={4}>Create & Schedule Status</Title> <Text c="dimmed" size="sm"> {' '} Craft your content, set the time, and let us do the posting.{' '} </Text> <Fieldset legend="Status Type: Image"> <Center p="lg" style={{ border: '2px dashed var(--mantine-color-gray-3)', borderRadius: 'var(--mantine-radius-md)', }} > <Stack align="center"> <Icon icon="tabler:photo-up" fontSize={48} color="var(--mantine-color-gray-5)" /> <Text c="dimmed">promo_banner.jpg</Text> </Stack> </Center> <Textarea label="Caption" placeholder="50% off this weekend!" disabled mt="md" /> </Fieldset> <Fieldset legend={ <Group gap="xs"> <Text>Automated Scheduling</Text> </Group> } > <Switch checked label="Schedule for later" disabled /> <DateTimePicker label="Post Date & Time" value={new Date()} disabled mt="sm" /> </Fieldset> </Stack> </Card> ) // Mockup for the Privacy/Security feature slide. const FeatureMockupPrivacy = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack align="center"> <ThemeIcon size={60} radius="xl" variant="light" color="teal"> <Icon icon="tabler:shield-lock" fontSize={32} /> </ThemeIcon> <Title order={4} mt="md"> {' '} 100% Private & Secure{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Your status drafts and media files are stored locally in your browser and are never seen, stored, or uploaded by us.{' '} </Text> <List mt="lg" spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item> {' '} <b>Local Processing:</b> Uses official WhatsApp Web functions in your browser.{' '} </List.Item> <List.Item> {' '} <b>No Data Storage:</b> Your content is never saved by us.{' '} </List.Item> <List.Item> {' '} <b>You Are in Control:</b> All actions happen on your own computer.{' '} </List.Item> </List> </Stack> </Card> ) // --- START: Two New Mockups --- // Mockup showcasing the ability to upload and schedule images or videos. const MockupRichMediaPosting = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack> <Title order={4}>Rich Media Posting</Title> <Text c="dimmed" size="sm"> {' '} Upload and schedule engaging images or videos for your status. Capture your audience's attention.{' '} </Text> <Center p="lg" style={{ border: '2px dashed var(--mantine-color-teal-3)', borderRadius: 'var(--mantine-radius-md)', backgroundColor: 'var(--mantine-color-teal-0)', }} > <Stack align="center" gap="xs"> <Icon icon="tabler:photo-video" fontSize={60} color="var(--mantine-color-teal-6)" /> <Text fw={500} c="teal.8"> {' '} Upload Your Image or Video{' '} </Text> <Button variant="outline" color="teal" size="xs"> {' '} Select File{' '} </Button> </Stack> </Center> <List mt="md" spacing="sm" size="sm" center icon={ <ThemeIcon color="teal" size={24} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item> Supported image formats: JPG, PNG, GIF </List.Item> <List.Item> Supported video formats: MP4, MOV </List.Item> <List.Item> Secure & encrypted media uploads (local) </List.Item> </List> </Stack> </Card> ) // Mockup emphasizing time-saving and automation. const MockupTimeSavingAutomation = () => ( <Card withBorder radius="md" p="xl" w={620}> <Stack align="center"> <ThemeIcon size={60} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon="tabler:clock-hour-4" fontSize={32} /> </ThemeIcon> <Title order={4} mt="md"> {' '} Save Time with Status Automation{' '} </Title> <Text c="dimmed" size="sm" ta="center"> {' '} Spend less time on manual tasks and more time growing your business. Automated posting keeps you engaged, even when you're away from your desk.{' '} </Text> <Grid mt="lg" gutter="md"> <Grid.Col span={6}> <Card withBorder shadow="xs" p="md"> <Stack align="center" gap="xs"> <Icon icon="tabler:alarm-minus" fontSize={36} color="var(--mantine-color-red-6)" /> <Text fw={500} size="sm" ta="center"> {' '} Without Scheduler{' '} </Text> <Text size="xs" c="dimmed" ta="center"> {' '} Manual posting, time-consuming, inconsistent presence.{' '} </Text> </Stack> </Card> </Grid.Col> <Grid.Col span={6}> <Card withBorder shadow="xs" p="md"> <Stack align="center" gap="xs"> <Icon icon="tabler:alarm-plus" fontSize={36} color="var(--mantine-color-teal-6)" /> <Text fw={500} size="sm" ta="center"> {' '} With Scheduler{' '} </Text> <Text size="xs" c="dimmed" ta="center"> {' '} Set & forget, 24/7 engagement, save hours of work.{' '} </Text> </Stack> </Card> </Grid.Col> </Grid> </Stack> </Card> ) // --- END: Two New Mockups --- // --- Page Components --- const MarqueeTileFeatureShowcase = () => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center" gutter={40}> <Grid.Col span={5}> <Stack> <ThemeIcon size={90} radius="xl" variant="gradient" gradient={{ from: 'teal', to: 'lime' }} > <Icon icon={STATUS_SCHEDULER_ICON} fontSize={70} /> </ThemeIcon> <Title fz={48} lh={1.2} c="white"> {' '} Automate Your WhatsApp Status Like a Pro{' '} </Title> <Title order={2} c="white" fw={500} mt="md"> {' '} Keep your audience engaged, save time, and boost your reach. The essential tool for marketers and business owners.{' '} </Title> </Stack> </Grid.Col> <Grid.Col span={4}> <Stack gap="lg"> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={44} > <Icon icon="tabler:calendar-time" fontSize={30} /> </ThemeIcon> <Title order={2} fw={700}> {' '} Schedule Posts{' '} </Title> </Group> <Text size="xl" c="gray.7" fw={500} mt="xs"> {' '} Plan status content for days or weeks in advance.{' '} </Text> </Card> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={44} > <Icon icon="tabler:photo-video" fontSize={30} /> </ThemeIcon> <Title fw={700} order={2}> {' '} Use Rich Media{' '} </Title> </Group> <Text size="xl" c="gray.7" fw={500} mt="xs"> {' '} Engage your audience with scheduled images & videos.{' '} </Text> </Card> <Card withBorder shadow="lg" p="lg"> <Group> <ThemeIcon variant="gradient" gradient={{ from: 'teal', to: 'lime' }} radius="xl" size={40} > <Icon icon="tabler:dashboard" fontSize={30} /> </ThemeIcon> <Title order={2} fw={700}> {' '} Content Dashboard{' '} </Title> </Group> <Text size="xl" c="gray.7" fw={500} mt="xs"> {' '} Manage all your statuses from one central place.{' '} </Text> </Card> </Stack> </Grid.Col> </Grid> </Stack> </Paper> ) interface MarqueeTileFeatureDetailProps { icon: string title: string description: string featureComponent: React.ReactNode } const MarqueeTileFeatureDetail: React.FC<MarqueeTileFeatureDetailProps> = ({ icon, title, description, featureComponent, }) => ( <Paper w={1280} h={800} withBorder radius="lg" p={60} style={{ background: PROMO_GRADIENT_BACKGROUND, }} > <Stack h="100%" justify="center"> <Grid align="center" gutter={50}> <Grid.Col span={4}> <Stack> <ThemeIcon size={60} radius="lg"> <Icon icon={icon} fontSize={40} /> </ThemeIcon> <Title order={1} fz={44} lh={1.2} c="white"> {' '} {title}{' '} </Title> <Text size="xl" fw={500} c="gray.1" mt="md"> {' '} {description}{' '} </Text> </Stack> </Grid.Col> <Grid.Col span={6}> <Center h="100%">{featureComponent}</Center> </Grid.Col> </Grid> </Stack> </Paper> ) const ScreenshotGallery: React.FC = () => { const screenshotData = [ { title: 'Marquee Promo Tile: Feature Showcase (1280x800)', filename: 'marquee_promo_tile_features.png', component: <MarqueeTileFeatureShowcase />, }, { title: 'Feature Screenshot: Organized Dashboard (1280x800)', filename: 'feature_dashboard.png', component: ( <MarqueeTileFeatureDetail icon="tabler:layout-dashboard" title="Your Content, Organized" description="Manage all your scheduled, posted, and draft statuses from a single, powerful dashboard. Stay on top of your content calendar with ease." featureComponent={<MockupStatusDashboard />} /> ), }, { title: 'Feature Screenshot: Plan Content in Advance (1280x800)', filename: 'feature_scheduling_pro.png', component: ( <MarqueeTileFeatureDetail icon="tabler:calendar-plus" title="Plan Content in Advance" description="Craft your text, image, or video status, pick a future date and time, and let us handle the rest. Perfect for campaigns, announcements, and daily updates." featureComponent={<MockupCreateStatusPro />} /> ), }, { title: 'Feature Screenshot: Rich Media Posting (1280x800)', filename: 'feature_rich_media.png', component: ( <MarqueeTileFeatureDetail icon="tabler:photo-video" title="Post Rich Media" description="Upload and schedule engaging images or captivating videos for your status. Capture your audience's attention with stunning visual content." featureComponent={<MockupRichMediaPosting />} /> ), }, { title: 'Feature Screenshot: Effortless Time Saving (1280x800)', filename: 'feature_time_saving.png', component: ( <MarqueeTileFeatureDetail icon="tabler:clock-hour-4" title="Save Time with Automation" description="Focus on what matters most. Automate your status updates to maintain a consistent presence, freeing up your time for core business tasks." featureComponent={<MockupTimeSavingAutomation />} /> ), }, { title: 'Feature Screenshot: Privacy First (1280x800)', filename: 'feature_privacy_secure.png', component: ( <MarqueeTileFeatureDetail icon="tabler:shield-lock" title="Your Privacy is Our Priority" description="This extension operates 100% locally on your computer. Your status drafts and files are never uploaded to any server, ensuring complete privacy." featureComponent={<FeatureMockupPrivacy />} /> ), }, ] return ( <Stack> <Text c="dimmed" mb="md"> {' '} Generate and download high-resolution promotional assets for the Chrome Web Store.{' '} </Text> <Stack gap="xl"> {screenshotData.map((item) => ( <ScreenshotWrapper key={item.title} title={item.title} filename={item.filename} > {item.component} </ScreenshotWrapper> ))} </Stack> </Stack> ) } const ResourcePage = () => { const iconRef = useRef<HTMLDivElement>(null) const icons = [ { component: <PromoIcon size={128} icon={PRIMARY_ICON} />, ref: iconRef, name: 'promotional_icon.png', }, ] const storeListingText = { titles: [ 'Status Scheduler for WhatsApp', 'Automate & Schedule WA Statuses', 'WhatsApp Status Planner & Poster', ], shortDescriptions: [ 'Schedule text, image, and video statuses to post automatically. Save time, increase engagement, and plan your content in advance.', 'The essential tool for marketers. Plan your WhatsApp statuses ahead of time. Supports images, videos, and fully automated posting.', 'Automate your WhatsApp presence. Create statuses, schedule them, and let the extension post them for you at the perfect time.', ], longDescription: `ðŸš€ Elevate Your Audience Engagement with Automatic Status Scheduling! Tired of manually posting WhatsApp statuses every day? Status Scheduler for WhatsApp is the ultimate tool to automate your presence, save you precious time, and keep your audience consistently engaged. âœ¨ Key Features - ðŸ—“ï¸ Schedule & Forget: Plan your status content for days, weeks, or even months in advance. Set the perfect time, and we'll post it for you. - ðŸ“¸ Rich Media: Go beyond text! Schedule stunning images and captivating videos to grab your contacts' attention. - ðŸ“‹ Full Content Dashboard: Manage all your statusesâ€”drafts, scheduled, and already postedâ€”from one clean, intuitive interface. - ðŸ›¡ï¸ Safe & Reliable: Built with safety first, our tool interacts responsibly with WhatsApp Web to ensure reliable posting without compromising your account. - â° Save Time: Focus on your business. Spend less time on manual tasks and more time on what matters. ðŸ¤” Who Is This For? - ðŸ’¼ Digital Marketers: Plan and automate promotional campaigns, product launches, and daily deals. - ðŸ“ˆ Business Owners: Maintain a consistent brand presence and keep your customers informed of the latest news. - ðŸŽ¨ Content Creators & Influencers: Share your work, behind-the-scenes content, and announcements automatically. - ðŸ‘¥ Community Managers: Send scheduled updates, reminders, and news to your community. ðŸš€ Get started in seconds and take control of your WhatsApp content strategy! WhatsApp is a trademark of WhatsApp Inc., registered in the U.S. and other countries. This extension has no relationship to WhatsApp or WhatsApp Inc.`, } const justificationTexts = { singlePurpose: `The core purpose of this extension is to allow users to create, manage, and automatically schedule WhatsApp statuses. All features, such as text/image/video status creation, the management dashboard, and scheduling controls, are directly related to this single purpose of automating and planning status content.`, storage: `The 'storage' permission is used to store essential user settings and license information locally on the user's device. This includes: - The user's license key to unlock Pro features. - An instance ID for license activation management. - User-created data such as status drafts and references to related media files, which are stored locally in IndexedDB for persistence. This data is stored only on the user's computer and is crucial for providing a persistent and personalized experience without requiring a remote server or user accounts.`, scripting: `Content scripts are essential for the extension's functionality. They are used exclusively on web.whatsapp.com to: 1. Inject the user interface (the main modal for managing statuses) onto the page. 2. Communicate with the WhatsApp Web JavaScript context to securely post the scheduled statuses on the user's behalf. This process is handled locally and is necessary to fulfill the extension's core purpose.`, hostWhatsapp: `The permission for "https://web.whatsapp.com/*" is required to allow the extension's content scripts to run on WhatsApp Web. The extension needs to access the DOM and interact with the page to inject its UI and perform the status posting on the user's behalf. The extension's functionality is entirely dependent on its ability to operate on this specific domain.`, hostLemonSqueezy: `The permission for "https://api.lemonsqueezy.com/*" is used to securely communicate with the Lemon Squeezy API for license validation and management. When a user activates a Pro license, the extension sends a request to this domain to verify, activate, or deactivate the license key. This is a standard and secure method for handling software licensing and does not transmit any personal data or status content.`, } const keywords = [ 'whatsapp status scheduler', 'whatsapp status planner', 'schedule whatsapp status', 'whatsapp marketing automation', 'auto post whatsapp status', 'whatsapp status automation', 'image status scheduler', 'video status scheduler', 'whatsapp content planner', 'status auto poster', ] const keywordsString = keywords.join(', ') const handleDownloadIcon = async ( ref: React.RefObject<HTMLDivElement>, filename: string, ) => { if (!ref.current) return const canvas = await html2canvas(ref.current, { backgroundColor: null, // Transparent background }) canvas.toBlob((blob) => { if (blob) FileSaver.saveAs(blob, filename) }) } return ( <MantineProvider theme={theme}> <Container size="lg" py="xl"> <Stack gap="xl"> <Title order={1} ta="center"> {' '} Chrome Web Store - Promotional Resources{' '} </Title> <Text c="dimmed" ta="center"> {' '} Use these assets and text to create your store listing page.{' '} </Text> <Tabs defaultValue="screenshots"> <Tabs.List grow> <Tabs.Tab value="text" leftSection={<Icon icon="tabler:file-text" />} > {' '} Store Listing Text{' '} </Tabs.Tab> <Tabs.Tab value="icons" leftSection={<Icon icon="tabler:photo" />} > {' '} Promotional Icons{' '} </Tabs.Tab> <Tabs.Tab value="screenshots" leftSection={<Icon icon="tabler:camera" />} > {' '} Screenshots & Tiles{' '} </Tabs.Tab> <Tabs.Tab value="keywords" leftSection={<Icon icon="tabler:tags" />} > {' '} Keywords (SEO){' '} </Tabs.Tab> <Tabs.Tab value="privacy" leftSection={<Icon icon="tabler:shield-lock" />} > {' '} Privacy Justifications{' '} </Tabs.Tab> </Tabs.List> <Tabs.Panel value="text" pt="lg"> <Stack gap="xl"> <Stack> <Title order={3}>Titles</Title> {storeListingText.titles.map((title, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={title.length > 30 ? 'red' : 'dimmed'} > {' '} {title.length} / 30 chars{' '} </Text> </Group> <Group mt="sm" justify="space-between"> <Code>{title}</Code> <CopyButton value={title}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Stack> <Title order={3}>Short Descriptions</Title> {storeListingText.shortDescriptions.map((desc, index) => ( <Card withBorder radius="md" key={index}> <Group justify="space-between"> <Text fw={500}>Option {index + 1}</Text> <Text size="sm" c={desc.length > 132 ? 'red' : 'dimmed'} > {' '} {desc.length} / 132 chars{' '} </Text> </Group> <Textarea mt="sm" readOnly value={desc} autosize maxRows={4} /> <Group justify="flex-end" mt="sm"> <CopyButton value={desc}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> ))} </Stack> <Card withBorder radius="md"> <Title order={3}>Detailed Description</Title> <Textarea mt="sm" readOnly value={storeListingText.longDescription} autosize minRows={15} /> <Group justify="flex-end" mt="sm"> <CopyButton value={storeListingText.longDescription}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> </Card> </Stack> </Tabs.Panel> <Tabs.Panel value="icons" pt="lg"> <Center> <Card withBorder radius="md" p="xl" w={300}> <Stack align="center" justify="space-between"> <div ref={iconRef}>{icons[0].component}</div> <Stack align="center" gap="md" mt="md"> <Text fw={500}>Promotional Icon (128x128 px)</Text> <Button variant="light" onClick={() => handleDownloadIcon(icons[0].ref, icons[0].name) } > {' '} Download{' '} </Button> </Stack> </Stack> </Card> </Center> </Tabs.Panel> <Tabs.Panel value="screenshots" pt="lg"> <ScreenshotGallery /> </Tabs.Panel> <Tabs.Panel value="keywords" pt="lg"> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={3}>Keywords for Store Listing</Title> <CopyButton value={keywordsString}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} leftSection={<Icon icon="tabler:copy" />} > {' '} {copied ? 'Copied All' : 'Copy All'}{' '} </Button> )} </CopyButton> </Group> <Text c="dimmed" size="sm" mt="xs"> {' '} Use these keywords in your store listing's metadata to improve search visibility.{' '} </Text> <Paper withBorder p="md" mt="md" radius="sm"> <Group gap="xs"> {keywords.map((keyword) => ( <Badge key={keyword} variant="light" color="gray" size="lg" > {' '} {keyword}{' '} </Badge> ))} </Group> </Paper> </Card> </Tabs.Panel> <Tabs.Panel value="privacy" pt="lg"> <Stack gap="xl"> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Single Purpose Justification</Title> <CopyButton value={justificationTexts.singlePurpose}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.singlePurpose} autosize minRows={4} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Storage Permission Justification</Title> <CopyButton value={justificationTexts.storage}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.storage} autosize minRows={5} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}>Content Scripting Justification</Title> <CopyButton value={justificationTexts.scripting}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.scripting} autosize minRows={5} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}> {' '} Host Permission: https://web.whatsapp.com/*{' '} </Title> <CopyButton value={justificationTexts.hostWhatsapp}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.hostWhatsapp} autosize minRows={4} /> </Card> <Card withBorder radius="md"> <Group justify="space-between"> <Title order={4}> {' '} Host Permission: https://api.lemonsqueezy.com/*{' '} </Title> <CopyButton value={justificationTexts.hostLemonSqueezy}> {({ copied, copy }) => ( <Button size="xs" color={copied ? 'teal' : 'gray'} onClick={copy} > {' '} {copied ? 'Copied' : 'Copy'}{' '} </Button> )} </CopyButton> </Group> <Textarea mt="sm" readOnly value={justificationTexts.hostLemonSqueezy} autosize minRows={4} /> </Card> </Stack> </Tabs.Panel> </Tabs> </Stack> </Container> </MantineProvider> ) } export default ResourcePage
```

# src/types/globals.d.ts

```ts
import type * as wajs from '@wppconnect/wa-js' declare global { interface Window { WPP: typeof wajs } const WPP: typeof wajs }
```

# src/types/index.d.ts

```ts
import type { Status } from '@/constants' export interface Response<T> { status: keyof typeof Status | string data?: T | null error?: string | null } interface LicenseInstance { createt_at: Date id: string name: string } interface LicenseKey { activation_limit: number activation_usage: number create_at: Date expires_at: Date id: number status: string test_mode: boolean } interface LicenseMeta { customer_email: string customer_id: number customer_name: string order_id: number order_item_id: number product_id: number store_id: number variant_id: number variant_name: string } export interface License { activated?: boolean | null valid?: boolean | null instance?: LicenseInstance | null license_key: LicenseKey meta: LicenseMeta }
```

# src/utils/country.ts

```ts
const countries = { AD: { label: 'ðŸ‡¦ðŸ‡© Andorra', phone: '376' }, AE: { label: 'ðŸ‡¦ðŸ‡ª United Arab Emirates', phone: '971' }, AF: { label: 'ðŸ‡¦ðŸ‡« Afghanistan', phone: '93' }, AG: { label: 'ðŸ‡¦ðŸ‡¬ Antigua and Barbuda', phone: '1-268' }, AI: { label: 'ðŸ‡¦ðŸ‡® Anguilla', phone: '1-264' }, AL: { label: 'ðŸ‡¦ðŸ‡± Albania', phone: '355' }, AM: { label: 'ðŸ‡¦ðŸ‡² Armenia', phone: '374' }, AO: { label: 'ðŸ‡¦ðŸ‡´ Angola', phone: '244' }, AQ: { label: 'ðŸ‡¦ðŸ‡¶ Antarctica', phone: '672' }, AR: { label: 'ðŸ‡¦ðŸ‡· Argentina', phone: '54' }, AS: { label: 'ðŸ‡¦ðŸ‡¸ American Samoa', phone: '1-684' }, AT: { label: 'ðŸ‡¦ðŸ‡¹ Austria', phone: '43' }, AU: { label: 'ðŸ‡¦ðŸ‡º Australia', phone: '61' }, AW: { label: 'ðŸ‡¦ðŸ‡¼ Aruba', phone: '297' }, AX: { label: 'ðŸ‡¦ðŸ‡½ Alland Islands', phone: '358' }, AZ: { label: 'ðŸ‡¦ðŸ‡¿ Azerbaijan', phone: '994' }, BA: { label: 'ðŸ‡§ðŸ‡¦ Bosnia and Herzegovina', phone: '387' }, BB: { label: 'ðŸ‡§ðŸ‡§ Barbados', phone: '1-246' }, BD: { label: 'ðŸ‡§ðŸ‡© Bangladesh', phone: '880' }, BE: { label: 'ðŸ‡§ðŸ‡ª Belgium', phone: '32' }, BF: { label: 'ðŸ‡§ðŸ‡« Burkina Faso', phone: '226' }, BG: { label: 'ðŸ‡§ðŸ‡¬ Bulgaria', phone: '359' }, BH: { label: 'ðŸ‡§ðŸ‡­ Bahrain', phone: '973' }, BI: { label: 'ðŸ‡§ðŸ‡® Burundi', phone: '257' }, BJ: { label: 'ðŸ‡§ðŸ‡¯ Benin', phone: '229' }, BL: { label: 'ðŸ‡§ðŸ‡± Saint Barthelemy', phone: '590' }, BM: { label: 'ðŸ‡§ðŸ‡² Bermuda', phone: '1-441' }, BN: { label: 'ðŸ‡§ðŸ‡³ Brunei Darussalam', phone: '673' }, BO: { label: 'ðŸ‡§ðŸ‡´ Bolivia', phone: '591' }, BR: { label: 'ðŸ‡§ðŸ‡· Brazil', phone: '55' }, BS: { label: 'ðŸ‡§ðŸ‡¸ Bahamas', phone: '1-242' }, BT: { label: 'ðŸ‡§ðŸ‡¹ Bhutan', phone: '975' }, BV: { label: 'ðŸ‡§ðŸ‡» Bouvet Island', phone: '47' }, BW: { label: 'ðŸ‡§ðŸ‡¼ Botswana', phone: '267' }, BY: { label: 'ðŸ‡§ðŸ‡¾ Belarus', phone: '375' }, BZ: { label: 'ðŸ‡§ðŸ‡¿ Belize', phone: '501' }, CA: { label: 'ðŸ‡¨ðŸ‡¦ Canada', phone: '1' }, CC: { label: 'ðŸ‡¨ðŸ‡¨ Cocos (Keeling) Islands', phone: '61' }, CD: { label: 'ðŸ‡¨ðŸ‡© Congo, Democratic Republic of the', phone: '243' }, CF: { label: 'ðŸ‡¨ðŸ‡« Central African Republic', phone: '236' }, CG: { label: 'ðŸ‡¨ðŸ‡¬ Congo, Republic of the', phone: '242' }, CH: { label: 'ðŸ‡¨ðŸ‡­ Switzerland', phone: '41' }, CI: { label: "ðŸ‡¨ðŸ‡® Cote d'Ivoire", phone: '225' }, CK: { label: 'ðŸ‡¨ðŸ‡° Cook Islands', phone: '682' }, CL: { label: 'ðŸ‡¨ðŸ‡± Chile', phone: '56' }, CM: { label: 'ðŸ‡¨ðŸ‡² Cameroon', phone: '237' }, CN: { label: 'ðŸ‡¨ðŸ‡³ China', phone: '86' }, CO: { label: 'ðŸ‡¨ðŸ‡´ Colombia', phone: '57' }, CR: { label: 'ðŸ‡¨ðŸ‡· Costa Rica', phone: '506' }, CU: { label: 'ðŸ‡¨ðŸ‡º Cuba', phone: '53' }, CV: { label: 'ðŸ‡¨ðŸ‡» Cape Verde', phone: '238' }, CW: { label: 'ðŸ‡¨ðŸ‡¼ Curacao', phone: '599' }, CX: { label: 'ðŸ‡¨ðŸ‡½ Christmas Island', phone: '61' }, CY: { label: 'ðŸ‡¨ðŸ‡¾ Cyprus', phone: '357' }, CZ: { label: 'ðŸ‡¨ðŸ‡¿ Czech Republic', phone: '420' }, DE: { label: 'ðŸ‡©ðŸ‡ª Germany', phone: '49' }, DJ: { label: 'ðŸ‡©ðŸ‡¯ Djibouti', phone: '253' }, DK: { label: 'ðŸ‡©ðŸ‡° Denmark', phone: '45' }, DM: { label: 'ðŸ‡©ðŸ‡² Dominica', phone: '1-767' }, DO: { label: 'ðŸ‡©ðŸ‡´ Dominican Republic', phone: '1-809' }, DZ: { label: 'ðŸ‡©ðŸ‡¿ Algeria', phone: '213' }, EC: { label: 'ðŸ‡ªðŸ‡¨ Ecuador', phone: '593' }, EE: { label: 'ðŸ‡ªðŸ‡ª Estonia', phone: '372' }, EG: { label: 'ðŸ‡ªðŸ‡¬ Egypt', phone: '20' }, EH: { label: 'ðŸ‡ªðŸ‡­ Western Sahara', phone: '212' }, ER: { label: 'ðŸ‡ªðŸ‡· Eritrea', phone: '291' }, ES: { label: 'ðŸ‡ªðŸ‡¸ Spain', phone: '34' }, ET: { label: 'ðŸ‡ªðŸ‡¹ Ethiopia', phone: '251' }, FI: { label: 'ðŸ‡«ðŸ‡® Finland', phone: '358' }, FJ: { label: 'ðŸ‡«ðŸ‡¯ Fiji', phone: '679' }, FK: { label: 'ðŸ‡«ðŸ‡° Falkland Islands (Malvinas)', phone: '500' }, FM: { label: 'ðŸ‡«ðŸ‡² Micronesia, Federated States of', phone: '691' }, FO: { label: 'ðŸ‡«ðŸ‡´ Faroe Islands', phone: '298' }, FR: { label: 'ðŸ‡«ðŸ‡· France', phone: '33' }, GA: { label: 'ðŸ‡¬ðŸ‡¦ Gabon', phone: '241' }, GB: { label: 'ðŸ‡¬ðŸ‡§ United Kingdom', phone: '44' }, GD: { label: 'ðŸ‡¬ðŸ‡© Grenada', phone: '1-473' }, GE: { label: 'ðŸ‡¬ðŸ‡ª Georgia', phone: '995' }, GF: { label: 'ðŸ‡¬ðŸ‡« French Guiana', phone: '594' }, GG: { label: 'ðŸ‡¬ðŸ‡¬ Guernsey', phone: '44' }, GH: { label: 'ðŸ‡¬ðŸ‡­ Ghana', phone: '233' }, GI: { label: 'ðŸ‡¬ðŸ‡® Gibraltar', phone: '350' }, GL: { label: 'ðŸ‡¬ðŸ‡± Greenland', phone: '299' }, GM: { label: 'ðŸ‡¬ðŸ‡² Gambia', phone: '220' }, GN: { label: 'ðŸ‡¬ðŸ‡³ Guinea', phone: '224' }, GP: { label: 'ðŸ‡¬ðŸ‡µ Guadeloupe', phone: '590' }, GQ: { label: 'ðŸ‡¬ðŸ‡¶ Equatorial Guinea', phone: '240' }, GR: { label: 'ðŸ‡¬ðŸ‡· Greece', phone: '30' }, GS: { label: 'ðŸ‡¬ðŸ‡¸ South Georgia and the South Sandwich Islands', phone: '500', }, GT: { label: 'ðŸ‡¬ðŸ‡¹ Guatemala', phone: '502' }, GU: { label: 'ðŸ‡¬ðŸ‡º Guam', phone: '1-671' }, GW: { label: 'ðŸ‡¬ðŸ‡¼ Guinea-Bissau', phone: '245' }, GY: { label: 'ðŸ‡¬ðŸ‡¾ Guyana', phone: '592' }, HK: { label: 'ðŸ‡­ðŸ‡° Hong Kong', phone: '852' }, HM: { label: 'ðŸ‡­ðŸ‡² Heard Island and McDonald Islands', phone: '672' }, HN: { label: 'ðŸ‡­ðŸ‡³ Honduras', phone: '504' }, HR: { label: 'ðŸ‡­ðŸ‡· Croatia', phone: '385' }, HT: { label: 'ðŸ‡­ðŸ‡¹ Haiti', phone: '509' }, HU: { label: 'ðŸ‡­ðŸ‡º Hungary', phone: '36' }, ID: { label: 'ðŸ‡®ðŸ‡© Indonesia', phone: '62' }, IE: { label: 'ðŸ‡®ðŸ‡ª Ireland', phone: '353' }, IL: { label: 'ðŸ‡®ðŸ‡± Israel', phone: '972' }, IM: { label: 'ðŸ‡®ðŸ‡² Isle of Man', phone: '44' }, IN: { label: 'ðŸ‡®ðŸ‡³ India', phone: '91' }, IO: { label: 'ðŸ‡®ðŸ‡´ British Indian Ocean Territory', phone: '246' }, IQ: { label: 'ðŸ‡®ðŸ‡¶ Iraq', phone: '964' }, IR: { label: 'ðŸ‡®ðŸ‡· Iran, Islamic Republic of', phone: '98' }, IS: { label: 'ðŸ‡®ðŸ‡¸ Iceland', phone: '354' }, IT: { label: 'ðŸ‡®ðŸ‡¹ Italy', phone: '39' }, JE: { label: 'ðŸ‡¯ðŸ‡ª Jersey', phone: '44' }, JM: { label: 'ðŸ‡¯ðŸ‡² Jamaica', phone: '1-876' }, JO: { label: 'ðŸ‡¯ðŸ‡´ Jordan', phone: '962' }, JP: { label: 'ðŸ‡¯ðŸ‡µ Japan', phone: '81' }, KE: { label: 'ðŸ‡°ðŸ‡ª Kenya', phone: '254' }, KG: { label: 'ðŸ‡°ðŸ‡¬ Kyrgyzstan', phone: '996' }, KH: { label: 'ðŸ‡°ðŸ‡­ Cambodia', phone: '855' }, KI: { label: 'ðŸ‡°ðŸ‡® Kiribati', phone: '686' }, KM: { label: 'ðŸ‡°ðŸ‡² Comoros', phone: '269' }, KN: { label: 'ðŸ‡°ðŸ‡³ Saint Kitts and Nevis', phone: '1-869' }, KP: { label: "ðŸ‡°ðŸ‡µ Korea, Democratic People's Republic of", phone: '850' }, KR: { label: 'ðŸ‡°ðŸ‡· Korea, Republic of', phone: '82' }, KW: { label: 'ðŸ‡°ðŸ‡¼ Kuwait', phone: '965' }, KY: { label: 'ðŸ‡°ðŸ‡¾ Cayman Islands', phone: '1-345' }, KZ: { label: 'ðŸ‡°ðŸ‡¿ Kazakhstan', phone: '7' }, LA: { label: "ðŸ‡±ðŸ‡¦ Lao People's Democratic Republic", phone: '856' }, LB: { label: 'ðŸ‡±ðŸ‡§ Lebanon', phone: '961' }, LC: { label: 'ðŸ‡±ðŸ‡¨ Saint Lucia', phone: '1-758' }, LI: { label: 'ðŸ‡±ðŸ‡® Liechtenstein', phone: '423' }, LK: { label: 'ðŸ‡±ðŸ‡° Sri Lanka', phone: '94' }, LR: { label: 'ðŸ‡±ðŸ‡· Liberia', phone: '231' }, LS: { label: 'ðŸ‡±ðŸ‡¸ Lesotho', phone: '266' }, LT: { label: 'ðŸ‡±ðŸ‡¹ Lithuania', phone: '370' }, LU: { label: 'ðŸ‡±ðŸ‡º Luxembourg', phone: '352' }, LV: { label: 'ðŸ‡±ðŸ‡» Latvia', phone: '371' }, LY: { label: 'ðŸ‡±ðŸ‡¾ Libya', phone: '218' }, MA: { label: 'ðŸ‡²ðŸ‡¦ Morocco', phone: '212' }, MC: { label: 'ðŸ‡²ðŸ‡¨ Monaco', phone: '377' }, MD: { label: 'ðŸ‡²ðŸ‡© Moldova, Republic of', phone: '373' }, ME: { label: 'ðŸ‡²ðŸ‡ª Montenegro', phone: '382' }, MF: { label: 'ðŸ‡²ðŸ‡« Saint Martin (French part)', phone: '590' }, MG: { label: 'ðŸ‡²ðŸ‡¬ Madagascar', phone: '261' }, MH: { label: 'ðŸ‡²ðŸ‡­ Marshall Islands', phone: '692' }, MK: { label: 'ðŸ‡²ðŸ‡° Macedonia, the Former Yugoslav Republic of', phone: '389' }, ML: { label: 'ðŸ‡²ðŸ‡± Mali', phone: '223' }, MM: { label: 'ðŸ‡²ðŸ‡² Myanmar', phone: '95' }, MN: { label: 'ðŸ‡²ðŸ‡³ Mongolia', phone: '976' }, MO: { label: 'ðŸ‡²ðŸ‡´ Macao', phone: '853' }, MP: { label: 'ðŸ‡²ðŸ‡µ Northern Mariana Islands', phone: '1-670' }, MQ: { label: 'ðŸ‡²ðŸ‡¶ Martinique', phone: '596' }, MR: { label: 'ðŸ‡²ðŸ‡· Mauritania', phone: '222' }, MS: { label: 'ðŸ‡²ðŸ‡¸ Montserrat', phone: '1-664' }, MT: { label: 'ðŸ‡²ðŸ‡¹ Malta', phone: '356' }, MU: { label: 'ðŸ‡²ðŸ‡º Mauritius', phone: '230' }, MV: { label: 'ðŸ‡²ðŸ‡» Maldives', phone: '960' }, MW: { label: 'ðŸ‡²ðŸ‡¼ Malawi', phone: '265' }, MX: { label: 'ðŸ‡²ðŸ‡½ Mexico', phone: '52' }, MY: { label: 'ðŸ‡²ðŸ‡¾ Malaysia', phone: '60' }, MZ: { label: 'ðŸ‡²ðŸ‡¿ Mozambique', phone: '258' }, NA: { label: 'ðŸ‡³ðŸ‡¦ Namibia', phone: '264' }, NC: { label: 'ðŸ‡³ðŸ‡¨ New Caledonia', phone: '687' }, NE: { label: 'ðŸ‡³ðŸ‡ª Niger', phone: '227' }, NF: { label: 'ðŸ‡³ðŸ‡« Norfolk Island', phone: '672' }, NG: { label: 'ðŸ‡³ðŸ‡¬ Nigeria', phone: '234' }, NI: { label: 'ðŸ‡³ðŸ‡® Nicaragua', phone: '505' }, NL: { label: 'ðŸ‡³ðŸ‡± Netherlands', phone: '31' }, NO: { label: 'ðŸ‡³ðŸ‡´ Norway', phone: '47' }, NP: { label: 'ðŸ‡³ðŸ‡µ Nepal', phone: '977' }, NR: { label: 'ðŸ‡³ðŸ‡· Nauru', phone: '674' }, NU: { label: 'ðŸ‡³ðŸ‡º Niue', phone: '683' }, NZ: { label: 'ðŸ‡³ðŸ‡¿ New Zealand', phone: '64' }, OM: { label: 'ðŸ‡´ðŸ‡² Oman', phone: '968' }, PA: { label: 'ðŸ‡µðŸ‡¦ Panama', phone: '507' }, PE: { label: 'ðŸ‡µðŸ‡ª Peru', phone: '51' }, PF: { label: 'ðŸ‡µðŸ‡« French Polynesia', phone: '689' }, PG: { label: 'ðŸ‡µðŸ‡¬ Papua New Guinea', phone: '675' }, PH: { label: 'ðŸ‡µðŸ‡­ Philippines', phone: '63' }, PK: { label: 'ðŸ‡µðŸ‡° Pakistan', phone: '92' }, PL: { label: 'ðŸ‡µðŸ‡± Poland', phone: '48' }, PM: { label: 'ðŸ‡µðŸ‡² Saint Pierre and Miquelon', phone: '508' }, PN: { label: 'ðŸ‡µðŸ‡³ Pitcairn', phone: '870' }, PR: { label: 'ðŸ‡µðŸ‡· Puerto Rico', phone: '1' }, PS: { label: 'ðŸ‡µðŸ‡¸ Palestine, State of', phone: '970' }, PT: { label: 'ðŸ‡µðŸ‡¹ Portugal', phone: '351' }, PW: { label: 'ðŸ‡µðŸ‡¼ Palau', phone: '680' }, PY: { label: 'ðŸ‡µðŸ‡¾ Paraguay', phone: '595' }, QA: { label: 'ðŸ‡¶ðŸ‡¦ Qatar', phone: '974' }, RE: { label: 'ðŸ‡·ðŸ‡ª Reunion', phone: '262' }, RO: { label: 'ðŸ‡·ðŸ‡´ Romania', phone: '40' }, RS: { label: 'ðŸ‡·ðŸ‡¸ Serbia', phone: '381' }, RU: { label: 'ðŸ‡·ðŸ‡º Russian Federation', phone: '7' }, RW: { label: 'ðŸ‡·ðŸ‡¼ Rwanda', phone: '250' }, SA: { label: 'ðŸ‡¸ðŸ‡¦ Saudi Arabia', phone: '966' }, SB: { label: 'ðŸ‡¸ðŸ‡§ Solomon Islands', phone: '677' }, SC: { label: 'ðŸ‡¸ðŸ‡¨ Seychelles', phone: '248' }, SD: { label: 'ðŸ‡¸ðŸ‡© Sudan', phone: '249' }, SE: { label: 'ðŸ‡¸ðŸ‡ª Sweden', phone: '46' }, SG: { label: 'ðŸ‡¸ðŸ‡¬ Singapore', phone: '65' }, SH: { label: 'ðŸ‡¸ðŸ‡­ Saint Helena', phone: '290' }, SI: { label: 'ðŸ‡¸ðŸ‡® Slovenia', phone: '386' }, SJ: { label: 'ðŸ‡¸ðŸ‡¯ Svalbard and Jan Mayen', phone: '47' }, SK: { label: 'ðŸ‡¸ðŸ‡° Slovakia', phone: '421' }, SL: { label: 'ðŸ‡¸ðŸ‡± Sierra Leone', phone: '232' }, SM: { label: 'ðŸ‡¸ðŸ‡² San Marino', phone: '378' }, SN: { label: 'ðŸ‡¸ðŸ‡³ Senegal', phone: '221' }, SO: { label: 'ðŸ‡¸ðŸ‡´ Somalia', phone: '252' }, SR: { label: 'ðŸ‡¸ðŸ‡· Suriname', phone: '597' }, SS: { label: 'ðŸ‡¸ðŸ‡¸ South Sudan', phone: '211' }, ST: { label: 'ðŸ‡¸ðŸ‡¹ Sao Tome and Principe', phone: '239' }, SV: { label: 'ðŸ‡¸ðŸ‡» El Salvador', phone: '503' }, SX: { label: 'ðŸ‡¸ðŸ‡½ Sint Maarten (Dutch part)', phone: '1-721' }, SY: { label: 'ðŸ‡¸ðŸ‡¾ Syrian Arab Republic', phone: '963' }, SZ: { label: 'ðŸ‡¸ðŸ‡¿ Swaziland', phone: '268' }, TC: { label: 'ðŸ‡¹ðŸ‡¨ Turks and Caicos Islands', phone: '1-649' }, TD: { label: 'ðŸ‡¹ðŸ‡© Chad', phone: '235' }, TF: { label: 'ðŸ‡¹ðŸ‡« French Southern Territories', phone: '262' }, TG: { label: 'ðŸ‡¹ðŸ‡¬ Togo', phone: '228' }, TH: { label: 'ðŸ‡¹ðŸ‡­ Thailand', phone: '66' }, TJ: { label: 'ðŸ‡¹ðŸ‡¯ Tajikistan', phone: '992' }, TK: { label: 'ðŸ‡¹ðŸ‡° Tokelau', phone: '690' }, TL: { label: 'ðŸ‡¹ðŸ‡± Timor-Leste', phone: '670' }, TM: { label: 'ðŸ‡¹ðŸ‡² Turkmenistan', phone: '993' }, TN: { label: 'ðŸ‡¹ðŸ‡³ Tunisia', phone: '216' }, TO: { label: 'ðŸ‡¹ðŸ‡´ Tonga', phone: '676' }, TR: { label: 'ðŸ‡¹ðŸ‡· Turkey', phone: '90' }, TT: { label: 'ðŸ‡¹ðŸ‡¹ Trinidad and Tobago', phone: '1-868' }, TV: { label: 'ðŸ‡¹ðŸ‡» Tuvalu', phone: '688' }, TW: { label: 'ðŸ‡¹ðŸ‡¼ Taiwan, Province of China', phone: '886' }, TZ: { label: 'ðŸ‡¹ðŸ‡¿ United Republic of Tanzania', phone: '255' }, UA: { label: 'ðŸ‡ºðŸ‡¦ Ukraine', phone: '380' }, UG: { label: 'ðŸ‡ºðŸ‡¬ Uganda', phone: '256' }, US: { label: 'ðŸ‡ºðŸ‡¸ United States', phone: '1' }, UY: { label: 'ðŸ‡ºðŸ‡¾ Uruguay', phone: '598' }, UZ: { label: 'ðŸ‡ºðŸ‡¿ Uzbekistan', phone: '998' }, VA: { label: 'ðŸ‡»ðŸ‡¦ Holy See (Vatican City State)', phone: '379' }, VC: { label: 'ðŸ‡»ðŸ‡¨ Saint Vincent and the Grenadines', phone: '1-784' }, VE: { label: 'ðŸ‡»ðŸ‡ª Venezuela', phone: '58' }, VG: { label: 'ðŸ‡»ðŸ‡¬ British Virgin Islands', phone: '1-284' }, VI: { label: 'ðŸ‡»ðŸ‡® US Virgin Islands', phone: '1-340' }, VN: { label: 'ðŸ‡»ðŸ‡³ Vietnam', phone: '84' }, VU: { label: 'ðŸ‡»ðŸ‡º Vanuatu', phone: '678' }, WF: { label: 'ðŸ‡¼ðŸ‡« Wallis and Futuna', phone: '681' }, WS: { label: 'ðŸ‡¼ðŸ‡¸ Samoa', phone: '685' }, XK: { label: 'ðŸ‡½ðŸ‡° Kosovo', phone: '383' }, YE: { label: 'ðŸ‡¾ðŸ‡ª Yemen', phone: '967' }, YT: { label: 'ðŸ‡¾ðŸ‡¹ Mayotte', phone: '262' }, ZA: { label: 'ðŸ‡¿ðŸ‡¦ South Africa', phone: '27' }, ZM: { label: 'ðŸ‡¿ðŸ‡² Zambia', phone: '260' }, ZW: { label: 'ðŸ‡¿ðŸ‡¼ Zimbabwe', phone: '263' }, } const getCountryByCode = (code: string) => { return countries[code] ?? { label: '-', phone: '-' } } export default { getCountryByCode, countries, }
```

# src/utils/env.ts

```ts
const isProduction = () => { return process.env.NODE_ENV === 'production' } const isDevelopment = () => { return process.env.NODE_ENV === 'development' } export const isStaging = () => { return process.env.PLASMO_PUBLIC_STAGING === 'true' } export default { isProduction, isDevelopment, isStaging, }
```

# src/utils/ext.ts

```ts
import type { Tabs } from 'webextension-polyfill' import browser from 'webextension-polyfill' export async function getCurrentTab(): Promise<Tabs.Tab> { const queryOptions = { active: true, currentWindow: true } const [tab] = await browser.tabs.query(queryOptions) return tab } export async function getTabs(): Promise<Tabs.Tab[]> { return new Promise(async (resolve, reject) => { try { const tabs = await browser.tabs.query({ currentWindow: true }) const filteredTabs = tabs.filter( (tab) => !tab.url?.startsWith('chrome://'), ) return resolve(filteredTabs) } catch (error) { reject(error) } }) } export async function getTabByUrl(url: string): Promise<Tabs.Tab | null> { const queryOptions = { url: url } const tabs = await browser.tabs.query(queryOptions) return tabs.length > 0 ? tabs[0] : null } export const openWa = async () => { await browser.tabs.create({ url: 'https://web.whatsapp.com' }) } export const isWaTabActive = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return result?.active } export const isWaTabAvailable = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return !!result }
```

# src/utils/filterBy.ts

```ts
import { AccountType, ContactType, MessageType } from '@/constants' import type { ContactModel } from '@wppconnect/wa-js/dist/whatsapp' const dontIncludeLid = (contact: ContactModel) => contact.id.server !== 'lid' const dontIncludeMe = (contact: any, number: any) => contact.phoneNumber !== number const accountType = (contact: any, type: string) => { switch (type) { case AccountType.ALL: return true case AccountType.PERSONAL: return contact.isBusiness === false case AccountType.BUSINESS: return contact.isBusiness === true default: return true } } const contactType = (contact: any, type: string): boolean => { switch (type) { case ContactType.ALL: return true case ContactType.SAVED_CONTACTS: return contact.isMyContact === true case ContactType.UNSAVED_CONTACTS: return contact.isMyContact === false default: return true } } const includeAdmin = (data: any, isIncludeAdmin: boolean) => { if (isIncludeAdmin) { if (data.isAdmin) { return true } } else { if (data.isAdmin) return false } return true } const onlyMyContact = (data: any, onlyMyContact: boolean) => { if (onlyMyContact) { return data.isMyContact === true } else { return data.isMyContact !== true } } const messageType = (contact: any, type: string): boolean => { switch (type) { case MessageType.ALL: return true case MessageType.HAVE_UNREAD_MESSAGES: return contact.hasUnread === true case MessageType.NO_UNREAD_MESSAGES: return contact.hasUnread === false default: return true } } const country = (contact: any, country: string) => { const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) return countryCode === country } export default { dontIncludeLid, dontIncludeMe, accountType, includeAdmin, onlyMyContact, contactType, messageType, country, }
```

# src/utils/page.ts

```ts
import { Action } from '@/constants' import { postMessage } from './util' const goTo = (page: string) => { postMessage(Action.Window.GO_TO_PAGE, page) } export default { goTo, }
```

# src/utils/response.ts

```ts
import { Status } from '@/constants' import type { Response } from '@/types' const success = <T = any>(data?: T | null): Response<T | undefined | null> => { return { status: Status.SUCCESS, data: data, } } const error = (error: string | undefined | null): Response<null> => { return { status: Status.FAILED, error: error, } } export const response = { success, error, }
```

# src/utils/serialize.ts

```ts
import type { ChatModel, ContactModel, GroupMetadataModel, MediaDataModel, MsgModel, ParticipantModel, } from '@wppconnect/wa-js/dist/whatsapp' import _ from 'lodash' import country from './country' const button = (buttons: any[]) => { return buttons .map(({ type, label, value }) => { switch (type) { case 'text': return { text: value } case 'url': return { text: label, url: value } case 'phoneNumber': return { text: label, phoneNumber: value } default: break } }) .filter((button) => !!button) } const list = (rows: any[]) => { return rows.filter((row) => row.title !== '') } const contact = (contact: ContactModel) => { if (!contact) return {} const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) const hasUnread = WPP.chat.get(contact.id._serialized)?.hasUnread ?? false const selectedCountry = country.getCountryByCode(countryCode) return { id: contact.id._serialized, avatar: contact.getProfilePicThumb().__x_eurl, country: selectedCountry.label, name: contact.name, pushname: contact.pushname, shortname: contact.shortName, notifyName: contact.notifyName, formattedName: contact.formattedName, formattedPhone: contact.formattedPhone, formattedShortName: contact.formattedShortName, formattedShortNameWithNonBreakingSpaces: contact.formattedShortNameWithNonBreakingSpaces, formattedUser: contact.formattedUser, isBusiness: contact.isBusiness, isContactBlocked: contact.isContactBlocked, //@ts-ignore isFavorite: contact.isFavorite, isGroup: contact.isGroup, isMe: contact.isMe, isMyContact: contact.isMyContact, isUser: contact.isUser, isWaContact: contact.isWAContact, labels: contact.labels, hasUnread, } } const mediaData = (data?: MediaDataModel) => { if (!data) return {} return { mimeType: data?.mimetype, size: data?.size, base64: data?.preview?.base64, height: data?.fullHeight, width: data?.fullWidth, } } const message = (msgModel: MsgModel) => { return { id: msgModel.id._serialized, ack: msgModel.ack, body: msgModel.body, from: msgModel.from, isViewOnce: msgModel.isViewOnce, timestamp: msgModel.t * 1000, to: msgModel.to, type: msgModel.type, mimetype: msgModel.mimetype, size: msgModel.size, filename: msgModel.filename, caption: msgModel.caption, duration: msgModel.duration, height: msgModel.height, width: msgModel.width, quotedMessage: msgModel.quotedMsg, contact: contact(msgModel.senderObj), } } const groupMetadata = (data: GroupMetadataModel) => { return { id: data?.id?._serialized, description: data?.desc, size: data?.size, subject: data?.subject, creation: data?.creation * 1000, participants: data?.participants?.getModelsArray().map(participant), } } const chat = (chat: ChatModel) => { return { id: chat.id._serialized, name: chat.name, messages: chat.msgs.getModelsArray().map(message), contact: contact(chat.contact), groupMetadata: groupMetadata(chat.groupMetadata), } } const participant = (participant: ParticipantModel) => { return { id: participant.id, isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, contact: contact(participant.contact), } } export default { button, list, contact, chat, participant, message, }
```

# src/utils/style.ts

```ts
import appMenuStyle from 'data-text:@/components/AppMenu.module.css' import layoutStyle from 'data-text:@/components/Layout/LayoutPage.module.css' import toastStyle from 'data-text:@/components/Toast/Toast.module.css' import globalsStyle from 'data-text:@/styles/globals.css' import coreStyle from 'data-text:@mantine/core/styles.css' import dateStyle from 'data-text:@mantine/dates/styles.css' import dropzoneStyle from 'data-text:@mantine/dropzone/styles.css' import tableStyle from 'data-text:mantine-datatable/styles.layer.css' const styles = [ coreStyle, dateStyle, dropzoneStyle, tableStyle, toastStyle, globalsStyle, layoutStyle, appMenuStyle, ] const generate = () => { return styles.join('') } export default { generate }
```

# src/utils/throwError.ts

```ts
const broadcastNotFound = () => { throw new Error('Broadcast not found') } const mediaNotFound = () => { throw new Error('Media not found') } const contactNotExist = () => { throw new Error('Contact not exist') } export default { broadcastNotFound, mediaNotFound, contactNotExist, }
```

# src/utils/toast.ts

```ts
import { useToastStore } from '@/stores/toast' const showSuccess = (message: string, title: string = 'Success') => { useToastStore.getState().addToast({ type: 'success', title, message }) } const showError = (message: string, title: string = 'Error') => { useToastStore.getState().addToast({ type: 'error', title, message }) } const showInfo = (message: string, title: string = 'Information') => { useToastStore.getState().addToast({ type: 'info', title, message }) } const showWarning = (message: string, title: string = 'Warning') => { useToastStore.getState().addToast({ type: 'warning', title, message }) } export default { success: showSuccess, error: showError, info: showInfo, // ADDED: Export the new 'warning' function. warning: showWarning, }
```

# src/utils/util.ts

```ts
// src/utils/util.ts import { Action, Message } from '@/constants' import type { UseFormReturnType } from '@mantine/form' import { sendToBackground } from '@plasmohq/messaging' import _ from 'lodash' export async function delay(timeoutMs = 1000) { await new Promise((resolve) => setTimeout(resolve, timeoutMs)) } export const generateRandomDelay = (min: number, max: number) => { // Calculate the range of multiples of 1000 const minThousand = Math.ceil(min / 1000) const maxThousand = Math.floor(max / 1000) // Generate a random integer in that range and multiply by 1000 const randomThousand = Math.floor(Math.random() * (maxThousand - minThousand + 1)) + minThousand return randomThousand * 1000 } export const truncate = (data: string, length: number = 30) => { return _.chain(data) .thru((str) => (str.length > length ? `${str.slice(0, length)}...` : str)) .value() } export const postMessage = (action: string, body: any = null) => { window.postMessage({ action, body }) } export const showModalUpgrade = ( featureName = 'Pro Feature', featureBenefit = 'Upgrade to Pro to unlock this feature and many more!', ) => { postMessage(Action.Window.SHOW_MODAL_UPGRADE, { featureName, featureBenefit }) } export const showModalMain = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } export const showModalActivation = () => { postMessage(Action.Window.SHOW_MODAL_ACTIVATION) } export const showModalProfile = () => { postMessage(Action.Window.SHOW_MODAL_PROFILE) } export const showModalFaq = () => { postMessage(Action.Window.SHOW_MODAL_FAQ) } export const goToLandingPage = async () => { await sendToBackground({ name: 'landing-page', body: {}, }) } export const getStoreId = () => { return process.env.PLASMO_PUBLIC_STORE_ID } export const isTypeMessageMedia = (type: string) => { return [Message.MEDIA, Message.IMAGE, Message.VIDEO, Message.FILE].includes( type, ) } export const formHasErrors = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ): boolean => { let hasError = false if (form1.validate().hasErrors) { hasError = true } if (form2.validate().hasErrors) { hasError = true } return hasError } export const resetForms = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ) => { form1.reset() form2.reset() } /** * @description Generates a thumbnail from a video file. * @param {File} file The video file. * @returns {Promise<string>} A promise that resolves with a base64 data URL of the thumbnail. */ export const generateVideoThumbnail = (file: File): Promise<string> => { return new Promise((resolve, reject) => { try { const video = document.createElement('video') const canvas = document.createElement('canvas') const context = canvas.getContext('2d') video.muted = true video.playsInline = true video.onloadeddata = () => { canvas.width = video.videoWidth canvas.height = video.videoHeight video.currentTime = 1 // Seek to 1 second to get a good frame video.onseeked = () => { if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height) const thumbnailUrl = canvas.toDataURL('image/png') URL.revokeObjectURL(video.src) // Clean up memory resolve(thumbnailUrl) } else { reject(new Error('Could not get canvas context.')) } } } video.onerror = () => { URL.revokeObjectURL(video.src) reject(new Error('Failed to load video file for thumbnail.')) } video.src = URL.createObjectURL(file) } catch (error) { reject(error) } }) } export const getContactName = (contact: any) => { return ( contact.name || contact.pushname || contact.notifyName || contact.formattedName || '-' ) }
```

# tsconfig.json

```json
{ "extends": "plasmo/templates/tsconfig.base", "exclude": ["node_modules"], "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"], "compilerOptions": { "paths": { "@/*": ["src/*"] }, "baseUrl": "." } }
```

